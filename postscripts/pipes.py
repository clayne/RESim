#!/usr/bin/env python 
import procTrace
import os
import sys
import glob
'''
given a path to a procTrace.txt and syscall_trace.txt (generated by @cgc.traceProcess(),
identify and report on sockets shared between processes as well as externally visible
sockets.
'''
def getTokValue(line, field):
        retval = None
        parts = line.split()
        for i in range(len(parts)-1):
             #print('does %s start with %s' % (parts[i], field))
             if parts[i].startswith(field+':'):
                 fparts = parts[i].strip().split(':', 1)
                 if len(fparts) > 1 and len(fparts[1])>0:
                     retval = fparts[1].strip(',')
                 else:
                     try:
                         retval = parts[i+1]
                     except:
                         print('no next field after %s in %s' % (field, line))
                 retval = retval.strip()
                 break
        return retval

def getPipeParts(tok):
    if '(' in tok:
        name, rest = tok.split('(')
        fdmode = rest[:-1]
        mode = fdmode[0:1]
        fd = fdmode[2:-1]
        return name, mode, fd
    else:
        return None, None, None
    
class Pipes():
                     
    def __init__(self, path):
        proc_trace_file = os.path.join(path, 'procTrace.txt')
        self.proc_trace = procTrace.ProcTrace(proc_trace_file) 

        self.pipes = {}

        with open(proc_trace_file) as fh:
            for line in fh:
                if line.strip().startswith('pipes:'):
                    pstring = line.split('pipes:')[1]
                    #print('pstring %s' % pstring)
                    parts = pstring.split()
                    for part in parts:
                        name, mode, fd = getPipeParts(part)
                        #print('name %s mode %s  fd %s' % (name, mode, fd))
                        if name not in self.pipes:
                            self.pipes[name] = {}
                        if mode not in self.pipes[name]:
                            self.pipes[name][mode]=[]
                        if fd not in self.pipes[name][mode]:
                            self.pipes[name][mode].append(fd)

    def showPipes(self):
        for name in self.pipes:
            if name is None:
                continue
            pid = name.split('-')[1]
            pname = self.proc_trace.getPname(pid)
            outline = '%s %s' % (pname, name)
            for mode in self.pipes[name]:
                outline = outline+' %s%s' % (mode, str(self.pipes[name][mode]))
            print(outline) 
if __name__ == '__main__':
    proc = sys.argv[1]
    pipes = Pipes(proc)
    pipes.showPipes()
