diff -ruN linux-3.10/arch/arm/boot/dts/qsp.dts linux-3.10_patched/arch/arm/boot/dts/qsp.dts
--- linux-3.10/arch/arm/boot/dts/qsp.dts	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.10_patched/arch/arm/boot/dts/qsp.dts	2025-06-14 05:48:04.945173245 +0000
@@ -0,0 +1,1881 @@
+/*
+ * Copyright 2011, Wind River
+ * 2006 (c) G. Liakhovetski <g.liakhovetski@gmx.de>
+ * Copyright 2008 Freescale Semiconductor, Inc.
+ *
+ * This file is licensed under
+ * the terms of the GNU General Public License version 2.  This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+
+/* The dts file for an QSP virtual board can (and should) be generated
+ * by simics itself from the actual configuration. This is a simple version
+ * with just one of each device hardcoded into it and 512Mb memory.
+ */
+
+/dts-v1/;
+
+
+/ {
+	model = "Simics QSP";
+	compatible = "simics,qsp-arm";
+	#address-cells = <1>;
+	#size-cells = <1>;
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu@0 {
+			compatible = "arm,cortex-a9";
+			reg = <0>;
+		};
+	};
+
+
+	memory {
+		name = "memory";
+		device_type = "memory";
+		reg = <0x00000000 0x2000000>;
+	};
+	chosen {
+		bootargs = "root=0x6300 console=ttyAM0 ";
+	};
+
+	flash@0x00000000 {
+		#address-cells = <2>;
+		#size-cells = <1>;
+		compatible = "simple-bus";
+		ranges = <0 0 0x00000000 0x10000000>;
+		qsp_flash@0,0 {
+					compatible = "qsp-flash";
+					bank-width = <2>;
+					reg = <0 0x00000000 0x10000000>;
+					#address-cells = <1>;
+					#size-cells = <1>;
+					partition@0 {
+						label = "entire_flash";
+						reg = <0x00000000 0x10000000>;
+					};
+
+
+				   };
+	 };
+
+	soc@0xe0000000 {
+		#address-cells = <2>;
+		#size-cells = <1>;
+		device_type = "soc";
+		compatible = "simple-bus";
+		ranges = <		0 0 0xe0000000 0x1000 //pic0
+		1 0 0xe0001000 0x1000 //sysregs0
+		2 0 0xe0002000 0x1000 //rtc0
+		3 0 0xe0010000 0x1000 //uart0
+		4 0 0xe0011000 0x1000 //uart1
+		5 0 0xe0012000 0x1000 //uart2
+		6 0 0xe0013000 0x1000 //uart3
+		7 0 0xe0014000 0x1000 //uart4
+		8 0 0xe0015000 0x1000 //uart5
+		9 0 0xe0016000 0x1000 //uart6
+		10 0 0xe0017000 0x1000 //uart7
+		11 0 0xe0018000 0x1000 //uart8
+		12 0 0xe0019000 0x1000 //uart9
+		13 0 0xe001a000 0x1000 //uart10
+		14 0 0xe001b000 0x1000 //uart11
+		15 0 0xe001c000 0x1000 //uart12
+		16 0 0xe001d000 0x1000 //uart13
+		17 0 0xe001e000 0x1000 //uart14
+		18 0 0xe001f000 0x1000 //uart15
+		19 0 0xe0020000 0x1000 //timer0
+		20 0 0xe0030000 0x1000 //led0
+		21 0 0xe0031000 0x1000 //led1
+		22 0 0xe0032000 0x1000 //led2
+		23 0 0xe0033000 0x1000 //led3
+		24 0 0xe0034000 0x1000 //led4
+		25 0 0xe0035000 0x1000 //led5
+		26 0 0xe0036000 0x1000 //led6
+		27 0 0xe0037000 0x1000 //led7
+		28 0 0xe0038000 0x1000 //led8
+		29 0 0xe0039000 0x1000 //led9
+		30 0 0xe003a000 0x1000 //led10
+		31 0 0xe003b000 0x1000 //led11
+		32 0 0xe003c000 0x1000 //led12
+		33 0 0xe003d000 0x1000 //led13
+		34 0 0xe003e000 0x1000 //led14
+		35 0 0xe003f000 0x1000 //led15
+		36 0 0xe0040000 0x1000 //mac0
+		37 0 0xe0041000 0x1000 //mac1
+		38 0 0xe0042000 0x1000 //mac2
+		39 0 0xe0043000 0x1000 //mac3
+		40 0 0xe0044000 0x1000 //mac4
+		41 0 0xe0045000 0x1000 //mac5
+		42 0 0xe0046000 0x1000 //mac6
+		43 0 0xe0047000 0x1000 //mac7
+		44 0 0xe0048000 0x1000 //mac8
+		45 0 0xe0049000 0x1000 //mac9
+		46 0 0xe004a000 0x1000 //mac10
+		47 0 0xe004b000 0x1000 //mac11
+		48 0 0xe004c000 0x1000 //mac12
+		49 0 0xe004d000 0x1000 //mac13
+		50 0 0xe004e000 0x1000 //mac14
+		51 0 0xe004f000 0x1000 //mac15
+		52 0 0xe0050000 0x1000 //disk_ctrl0
+		53 0 0xe0051000 0x1000 //disk_ctrl1
+		54 0 0xe0052000 0x1000 //disk_ctrl2
+		55 0 0xe0053000 0x1000 //disk_ctrl3
+		56 0 0xe0054000 0x1000 //disk_ctrl4
+		57 0 0xe0055000 0x1000 //disk_ctrl5
+		58 0 0xe0056000 0x1000 //disk_ctrl6
+		59 0 0xe0057000 0x1000 //disk_ctrl7
+		60 0 0xe0058000 0x1000 //disk_ctrl8
+		61 0 0xe0059000 0x1000 //disk_ctrl9
+		62 0 0xe005a000 0x1000 //disk_ctrl10
+		63 0 0xe005b000 0x1000 //disk_ctrl11
+		64 0 0xe005c000 0x1000 //disk_ctrl12
+		65 0 0xe005d000 0x1000 //disk_ctrl13
+		66 0 0xe005e000 0x1000 //disk_ctrl14
+		67 0 0xe005f000 0x1000 //disk_ctrl15
+>;
+		bus-frequency = <0>;
+
+		PIC: interrupt-controller@0,0 {
+			#interrupt-cells = <2>;
+			cell-index = <0>;
+			device_type = "interrupt-controller";
+			compatible = "qsp-pic";
+			interrupt-controller;
+			reg = <0 0x0 0x1000>;
+		};
+
+		SYSREGS: sysregs {
+			device_type = "sysregs";
+			compatible = "qsp,sysregs";
+			reg = <1 0x0 0x1000>;
+		};
+
+		RTC: rtc {
+			device_type = "rtc";
+			compatible = "qsp-rtc";
+			reg = <2 0x0 0x1000>;
+		};
+
+		UART0: qspserial0 {
+			device_type = "serial";
+			compatible = "qsp-serial";
+			reg = <3 0x0 0x1000>;
+			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
+			interrupt-parent = <&PIC>;
+ 			interrupts = <16 0x1>;
+		};
+
+		UART1: qspserial1 {
+			device_type = "serial";
+			compatible = "qsp-serial";
+			reg = <4 0x0 0x1000>;
+			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
+			interrupt-parent = <&PIC>;
+ 			interrupts = <17 0x1>;
+		};
+
+		UART2: qspserial2 {
+			device_type = "serial";
+			compatible = "qsp-serial";
+			reg = <5 0x0 0x1000>;
+			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
+			interrupt-parent = <&PIC>;
+ 			interrupts = <18 0x1>;
+		};
+
+		UART3: qspserial3 {
+			device_type = "serial";
+			compatible = "qsp-serial";
+			reg = <6 0x0 0x1000>;
+			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
+			interrupt-parent = <&PIC>;
+ 			interrupts = <19 0x1>;
+		};
+
+		UART4: qspserial4 {
+			device_type = "serial";
+			compatible = "qsp-serial";
+			reg = <7 0x0 0x1000>;
+			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
+			interrupt-parent = <&PIC>;
+ 			interrupts = <20 0x1>;
+		};
+
+		UART5: qspserial5 {
+			device_type = "serial";
+			compatible = "qsp-serial";
+			reg = <8 0x0 0x1000>;
+			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
+			interrupt-parent = <&PIC>;
+ 			interrupts = <21 0x1>;
+		};
+
+		UART6: qspserial6 {
+			device_type = "serial";
+			compatible = "qsp-serial";
+			reg = <9 0x0 0x1000>;
+			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
+			interrupt-parent = <&PIC>;
+ 			interrupts = <22 0x1>;
+		};
+
+		UART7: qspserial7 {
+			device_type = "serial";
+			compatible = "qsp-serial";
+			reg = <10 0x0 0x1000>;
+			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
+			interrupt-parent = <&PIC>;
+ 			interrupts = <23 0x1>;
+		};
+
+		UART8: qspserial8 {
+			device_type = "serial";
+			compatible = "qsp-serial";
+			reg = <11 0x0 0x1000>;
+			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
+			interrupt-parent = <&PIC>;
+ 			interrupts = <24 0x1>;
+		};
+
+		UART9: qspserial9 {
+			device_type = "serial";
+			compatible = "qsp-serial";
+			reg = <12 0x0 0x1000>;
+			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
+			interrupt-parent = <&PIC>;
+ 			interrupts = <25 0x1>;
+		};
+
+		UART10: qspserial10 {
+			device_type = "serial";
+			compatible = "qsp-serial";
+			reg = <13 0x0 0x1000>;
+			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
+			interrupt-parent = <&PIC>;
+ 			interrupts = <26 0x1>;
+		};
+
+		UART11: qspserial11 {
+			device_type = "serial";
+			compatible = "qsp-serial";
+			reg = <14 0x0 0x1000>;
+			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
+			interrupt-parent = <&PIC>;
+ 			interrupts = <27 0x1>;
+		};
+
+		UART12: qspserial12 {
+			device_type = "serial";
+			compatible = "qsp-serial";
+			reg = <15 0x0 0x1000>;
+			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
+			interrupt-parent = <&PIC>;
+ 			interrupts = <28 0x1>;
+		};
+
+		UART13: qspserial13 {
+			device_type = "serial";
+			compatible = "qsp-serial";
+			reg = <16 0x0 0x1000>;
+			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
+			interrupt-parent = <&PIC>;
+ 			interrupts = <29 0x1>;
+		};
+
+		UART14: qspserial14 {
+			device_type = "serial";
+			compatible = "qsp-serial";
+			reg = <17 0x0 0x1000>;
+			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
+			interrupt-parent = <&PIC>;
+ 			interrupts = <30 0x1>;
+		};
+
+		UART15: qspserial15 {
+			device_type = "serial";
+			compatible = "qsp-serial";
+			reg = <18 0x0 0x1000>;
+			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
+			interrupt-parent = <&PIC>;
+ 			interrupts = <31 0x1>;
+		};
+
+		TIMER0: qsptimer0 {
+			compatible = "qsp,timer";
+			reg = <19 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <32 0x1>;
+		};
+
+		led0 {
+		 	 label = "led0";
+                         compatible = "leds-qsp";
+                         reg = <20 0x0 0x1000>;
+
+		 	 linux,default-trigger = "default-on";
+
+			led0 {
+				label = "power";
+				index = <0>;
+				linux,default-trigger = "default-on";
+			};
+			led01 {
+				label = "heartbeat";
+				index = <1>;
+				linux,default-trigger = "heartbeat";
+			};
+			led02 {
+				label = "timer";
+				index = <2>;
+				//linux,default-trigger = "timer";
+			};
+			led03 {
+				label = "cpu0";
+				index = <3>;
+				//linux,default-trigger = "cpu0";
+			};
+			led04 {
+				label = "cpu1";
+				index = <4>;
+				//linux,default-trigger = "cpu1";
+			};
+			led05 {
+				label = "cpu2";
+				index = <5>;
+				//linux,default-trigger = "cpu2";
+			};
+			led06 {
+				label = "cpu3";
+				index = <6>;
+				//linux,default-trigger = "cpu3";
+			};
+			led07 {
+				label = "led07";
+				index = <7>;
+			};
+			led08 {
+				label = "led08";
+				index = <8>;
+			};
+			led09 {
+				label = "led09";
+				index = <9>;
+			};
+			led10 {
+				label = "led10";
+				index = <10>;
+			};
+			led11 {
+				label = "led11";
+				index = <11>;
+			};
+			led12 {
+				label = "led12";
+				index = <12>;
+			};
+			led13 {
+				label = "led13";
+				index = <13>;
+			};
+			led14 {
+				label = "led14";
+				index = <14>;
+			};
+			led15 {
+				label = "led15";
+				index = <15>;
+			};
+
+		};
+
+		led1 {
+		 	 label = "led1";
+                         compatible = "leds-qsp";
+                         reg = <21 0x0 0x1000>;
+
+		 	 linux,default-trigger = "default-on";
+
+			led0 {
+				label = "power";
+				index = <0>;
+				linux,default-trigger = "default-on";
+			};
+			led01 {
+				label = "heartbeat";
+				index = <1>;
+				linux,default-trigger = "heartbeat";
+			};
+			led02 {
+				label = "timer";
+				index = <2>;
+				//linux,default-trigger = "timer";
+			};
+			led03 {
+				label = "cpu0";
+				index = <3>;
+				//linux,default-trigger = "cpu0";
+			};
+			led04 {
+				label = "cpu1";
+				index = <4>;
+				//linux,default-trigger = "cpu1";
+			};
+			led05 {
+				label = "cpu2";
+				index = <5>;
+				//linux,default-trigger = "cpu2";
+			};
+			led06 {
+				label = "cpu3";
+				index = <6>;
+				//linux,default-trigger = "cpu3";
+			};
+			led07 {
+				label = "led07";
+				index = <7>;
+			};
+			led08 {
+				label = "led08";
+				index = <8>;
+			};
+			led09 {
+				label = "led09";
+				index = <9>;
+			};
+			led10 {
+				label = "led10";
+				index = <10>;
+			};
+			led11 {
+				label = "led11";
+				index = <11>;
+			};
+			led12 {
+				label = "led12";
+				index = <12>;
+			};
+			led13 {
+				label = "led13";
+				index = <13>;
+			};
+			led14 {
+				label = "led14";
+				index = <14>;
+			};
+			led15 {
+				label = "led15";
+				index = <15>;
+			};
+
+		};
+
+		led2 {
+		 	 label = "led2";
+                         compatible = "leds-qsp";
+                         reg = <22 0x0 0x1000>;
+
+		 	 linux,default-trigger = "default-on";
+
+			led0 {
+				label = "power";
+				index = <0>;
+				linux,default-trigger = "default-on";
+			};
+			led01 {
+				label = "heartbeat";
+				index = <1>;
+				linux,default-trigger = "heartbeat";
+			};
+			led02 {
+				label = "timer";
+				index = <2>;
+				//linux,default-trigger = "timer";
+			};
+			led03 {
+				label = "cpu0";
+				index = <3>;
+				//linux,default-trigger = "cpu0";
+			};
+			led04 {
+				label = "cpu1";
+				index = <4>;
+				//linux,default-trigger = "cpu1";
+			};
+			led05 {
+				label = "cpu2";
+				index = <5>;
+				//linux,default-trigger = "cpu2";
+			};
+			led06 {
+				label = "cpu3";
+				index = <6>;
+				//linux,default-trigger = "cpu3";
+			};
+			led07 {
+				label = "led07";
+				index = <7>;
+			};
+			led08 {
+				label = "led08";
+				index = <8>;
+			};
+			led09 {
+				label = "led09";
+				index = <9>;
+			};
+			led10 {
+				label = "led10";
+				index = <10>;
+			};
+			led11 {
+				label = "led11";
+				index = <11>;
+			};
+			led12 {
+				label = "led12";
+				index = <12>;
+			};
+			led13 {
+				label = "led13";
+				index = <13>;
+			};
+			led14 {
+				label = "led14";
+				index = <14>;
+			};
+			led15 {
+				label = "led15";
+				index = <15>;
+			};
+
+		};
+
+		led3 {
+		 	 label = "led3";
+                         compatible = "leds-qsp";
+                         reg = <23 0x0 0x1000>;
+
+		 	 linux,default-trigger = "default-on";
+
+			led0 {
+				label = "power";
+				index = <0>;
+				linux,default-trigger = "default-on";
+			};
+			led01 {
+				label = "heartbeat";
+				index = <1>;
+				linux,default-trigger = "heartbeat";
+			};
+			led02 {
+				label = "timer";
+				index = <2>;
+				//linux,default-trigger = "timer";
+			};
+			led03 {
+				label = "cpu0";
+				index = <3>;
+				//linux,default-trigger = "cpu0";
+			};
+			led04 {
+				label = "cpu1";
+				index = <4>;
+				//linux,default-trigger = "cpu1";
+			};
+			led05 {
+				label = "cpu2";
+				index = <5>;
+				//linux,default-trigger = "cpu2";
+			};
+			led06 {
+				label = "cpu3";
+				index = <6>;
+				//linux,default-trigger = "cpu3";
+			};
+			led07 {
+				label = "led07";
+				index = <7>;
+			};
+			led08 {
+				label = "led08";
+				index = <8>;
+			};
+			led09 {
+				label = "led09";
+				index = <9>;
+			};
+			led10 {
+				label = "led10";
+				index = <10>;
+			};
+			led11 {
+				label = "led11";
+				index = <11>;
+			};
+			led12 {
+				label = "led12";
+				index = <12>;
+			};
+			led13 {
+				label = "led13";
+				index = <13>;
+			};
+			led14 {
+				label = "led14";
+				index = <14>;
+			};
+			led15 {
+				label = "led15";
+				index = <15>;
+			};
+
+		};
+
+		led4 {
+		 	 label = "led4";
+                         compatible = "leds-qsp";
+                         reg = <24 0x0 0x1000>;
+
+		 	 linux,default-trigger = "default-on";
+
+			led0 {
+				label = "power";
+				index = <0>;
+				linux,default-trigger = "default-on";
+			};
+			led01 {
+				label = "heartbeat";
+				index = <1>;
+				linux,default-trigger = "heartbeat";
+			};
+			led02 {
+				label = "timer";
+				index = <2>;
+				//linux,default-trigger = "timer";
+			};
+			led03 {
+				label = "cpu0";
+				index = <3>;
+				//linux,default-trigger = "cpu0";
+			};
+			led04 {
+				label = "cpu1";
+				index = <4>;
+				//linux,default-trigger = "cpu1";
+			};
+			led05 {
+				label = "cpu2";
+				index = <5>;
+				//linux,default-trigger = "cpu2";
+			};
+			led06 {
+				label = "cpu3";
+				index = <6>;
+				//linux,default-trigger = "cpu3";
+			};
+			led07 {
+				label = "led07";
+				index = <7>;
+			};
+			led08 {
+				label = "led08";
+				index = <8>;
+			};
+			led09 {
+				label = "led09";
+				index = <9>;
+			};
+			led10 {
+				label = "led10";
+				index = <10>;
+			};
+			led11 {
+				label = "led11";
+				index = <11>;
+			};
+			led12 {
+				label = "led12";
+				index = <12>;
+			};
+			led13 {
+				label = "led13";
+				index = <13>;
+			};
+			led14 {
+				label = "led14";
+				index = <14>;
+			};
+			led15 {
+				label = "led15";
+				index = <15>;
+			};
+
+		};
+
+		led5 {
+		 	 label = "led5";
+                         compatible = "leds-qsp";
+                         reg = <25 0x0 0x1000>;
+
+		 	 linux,default-trigger = "default-on";
+
+			led0 {
+				label = "power";
+				index = <0>;
+				linux,default-trigger = "default-on";
+			};
+			led01 {
+				label = "heartbeat";
+				index = <1>;
+				linux,default-trigger = "heartbeat";
+			};
+			led02 {
+				label = "timer";
+				index = <2>;
+				//linux,default-trigger = "timer";
+			};
+			led03 {
+				label = "cpu0";
+				index = <3>;
+				//linux,default-trigger = "cpu0";
+			};
+			led04 {
+				label = "cpu1";
+				index = <4>;
+				//linux,default-trigger = "cpu1";
+			};
+			led05 {
+				label = "cpu2";
+				index = <5>;
+				//linux,default-trigger = "cpu2";
+			};
+			led06 {
+				label = "cpu3";
+				index = <6>;
+				//linux,default-trigger = "cpu3";
+			};
+			led07 {
+				label = "led07";
+				index = <7>;
+			};
+			led08 {
+				label = "led08";
+				index = <8>;
+			};
+			led09 {
+				label = "led09";
+				index = <9>;
+			};
+			led10 {
+				label = "led10";
+				index = <10>;
+			};
+			led11 {
+				label = "led11";
+				index = <11>;
+			};
+			led12 {
+				label = "led12";
+				index = <12>;
+			};
+			led13 {
+				label = "led13";
+				index = <13>;
+			};
+			led14 {
+				label = "led14";
+				index = <14>;
+			};
+			led15 {
+				label = "led15";
+				index = <15>;
+			};
+
+		};
+
+		led6 {
+		 	 label = "led6";
+                         compatible = "leds-qsp";
+                         reg = <26 0x0 0x1000>;
+
+		 	 linux,default-trigger = "default-on";
+
+			led0 {
+				label = "power";
+				index = <0>;
+				linux,default-trigger = "default-on";
+			};
+			led01 {
+				label = "heartbeat";
+				index = <1>;
+				linux,default-trigger = "heartbeat";
+			};
+			led02 {
+				label = "timer";
+				index = <2>;
+				//linux,default-trigger = "timer";
+			};
+			led03 {
+				label = "cpu0";
+				index = <3>;
+				//linux,default-trigger = "cpu0";
+			};
+			led04 {
+				label = "cpu1";
+				index = <4>;
+				//linux,default-trigger = "cpu1";
+			};
+			led05 {
+				label = "cpu2";
+				index = <5>;
+				//linux,default-trigger = "cpu2";
+			};
+			led06 {
+				label = "cpu3";
+				index = <6>;
+				//linux,default-trigger = "cpu3";
+			};
+			led07 {
+				label = "led07";
+				index = <7>;
+			};
+			led08 {
+				label = "led08";
+				index = <8>;
+			};
+			led09 {
+				label = "led09";
+				index = <9>;
+			};
+			led10 {
+				label = "led10";
+				index = <10>;
+			};
+			led11 {
+				label = "led11";
+				index = <11>;
+			};
+			led12 {
+				label = "led12";
+				index = <12>;
+			};
+			led13 {
+				label = "led13";
+				index = <13>;
+			};
+			led14 {
+				label = "led14";
+				index = <14>;
+			};
+			led15 {
+				label = "led15";
+				index = <15>;
+			};
+
+		};
+
+		led7 {
+		 	 label = "led7";
+                         compatible = "leds-qsp";
+                         reg = <27 0x0 0x1000>;
+
+		 	 linux,default-trigger = "default-on";
+
+			led0 {
+				label = "power";
+				index = <0>;
+				linux,default-trigger = "default-on";
+			};
+			led01 {
+				label = "heartbeat";
+				index = <1>;
+				linux,default-trigger = "heartbeat";
+			};
+			led02 {
+				label = "timer";
+				index = <2>;
+				//linux,default-trigger = "timer";
+			};
+			led03 {
+				label = "cpu0";
+				index = <3>;
+				//linux,default-trigger = "cpu0";
+			};
+			led04 {
+				label = "cpu1";
+				index = <4>;
+				//linux,default-trigger = "cpu1";
+			};
+			led05 {
+				label = "cpu2";
+				index = <5>;
+				//linux,default-trigger = "cpu2";
+			};
+			led06 {
+				label = "cpu3";
+				index = <6>;
+				//linux,default-trigger = "cpu3";
+			};
+			led07 {
+				label = "led07";
+				index = <7>;
+			};
+			led08 {
+				label = "led08";
+				index = <8>;
+			};
+			led09 {
+				label = "led09";
+				index = <9>;
+			};
+			led10 {
+				label = "led10";
+				index = <10>;
+			};
+			led11 {
+				label = "led11";
+				index = <11>;
+			};
+			led12 {
+				label = "led12";
+				index = <12>;
+			};
+			led13 {
+				label = "led13";
+				index = <13>;
+			};
+			led14 {
+				label = "led14";
+				index = <14>;
+			};
+			led15 {
+				label = "led15";
+				index = <15>;
+			};
+
+		};
+
+		led8 {
+		 	 label = "led8";
+                         compatible = "leds-qsp";
+                         reg = <28 0x0 0x1000>;
+
+		 	 linux,default-trigger = "default-on";
+
+			led0 {
+				label = "power";
+				index = <0>;
+				linux,default-trigger = "default-on";
+			};
+			led01 {
+				label = "heartbeat";
+				index = <1>;
+				linux,default-trigger = "heartbeat";
+			};
+			led02 {
+				label = "timer";
+				index = <2>;
+				//linux,default-trigger = "timer";
+			};
+			led03 {
+				label = "cpu0";
+				index = <3>;
+				//linux,default-trigger = "cpu0";
+			};
+			led04 {
+				label = "cpu1";
+				index = <4>;
+				//linux,default-trigger = "cpu1";
+			};
+			led05 {
+				label = "cpu2";
+				index = <5>;
+				//linux,default-trigger = "cpu2";
+			};
+			led06 {
+				label = "cpu3";
+				index = <6>;
+				//linux,default-trigger = "cpu3";
+			};
+			led07 {
+				label = "led07";
+				index = <7>;
+			};
+			led08 {
+				label = "led08";
+				index = <8>;
+			};
+			led09 {
+				label = "led09";
+				index = <9>;
+			};
+			led10 {
+				label = "led10";
+				index = <10>;
+			};
+			led11 {
+				label = "led11";
+				index = <11>;
+			};
+			led12 {
+				label = "led12";
+				index = <12>;
+			};
+			led13 {
+				label = "led13";
+				index = <13>;
+			};
+			led14 {
+				label = "led14";
+				index = <14>;
+			};
+			led15 {
+				label = "led15";
+				index = <15>;
+			};
+
+		};
+
+		led9 {
+		 	 label = "led9";
+                         compatible = "leds-qsp";
+                         reg = <29 0x0 0x1000>;
+
+		 	 linux,default-trigger = "default-on";
+
+			led0 {
+				label = "power";
+				index = <0>;
+				linux,default-trigger = "default-on";
+			};
+			led01 {
+				label = "heartbeat";
+				index = <1>;
+				linux,default-trigger = "heartbeat";
+			};
+			led02 {
+				label = "timer";
+				index = <2>;
+				//linux,default-trigger = "timer";
+			};
+			led03 {
+				label = "cpu0";
+				index = <3>;
+				//linux,default-trigger = "cpu0";
+			};
+			led04 {
+				label = "cpu1";
+				index = <4>;
+				//linux,default-trigger = "cpu1";
+			};
+			led05 {
+				label = "cpu2";
+				index = <5>;
+				//linux,default-trigger = "cpu2";
+			};
+			led06 {
+				label = "cpu3";
+				index = <6>;
+				//linux,default-trigger = "cpu3";
+			};
+			led07 {
+				label = "led07";
+				index = <7>;
+			};
+			led08 {
+				label = "led08";
+				index = <8>;
+			};
+			led09 {
+				label = "led09";
+				index = <9>;
+			};
+			led10 {
+				label = "led10";
+				index = <10>;
+			};
+			led11 {
+				label = "led11";
+				index = <11>;
+			};
+			led12 {
+				label = "led12";
+				index = <12>;
+			};
+			led13 {
+				label = "led13";
+				index = <13>;
+			};
+			led14 {
+				label = "led14";
+				index = <14>;
+			};
+			led15 {
+				label = "led15";
+				index = <15>;
+			};
+
+		};
+
+		led10 {
+		 	 label = "led10";
+                         compatible = "leds-qsp";
+                         reg = <30 0x0 0x1000>;
+
+		 	 linux,default-trigger = "default-on";
+
+			led0 {
+				label = "power";
+				index = <0>;
+				linux,default-trigger = "default-on";
+			};
+			led01 {
+				label = "heartbeat";
+				index = <1>;
+				linux,default-trigger = "heartbeat";
+			};
+			led02 {
+				label = "timer";
+				index = <2>;
+				//linux,default-trigger = "timer";
+			};
+			led03 {
+				label = "cpu0";
+				index = <3>;
+				//linux,default-trigger = "cpu0";
+			};
+			led04 {
+				label = "cpu1";
+				index = <4>;
+				//linux,default-trigger = "cpu1";
+			};
+			led05 {
+				label = "cpu2";
+				index = <5>;
+				//linux,default-trigger = "cpu2";
+			};
+			led06 {
+				label = "cpu3";
+				index = <6>;
+				//linux,default-trigger = "cpu3";
+			};
+			led07 {
+				label = "led07";
+				index = <7>;
+			};
+			led08 {
+				label = "led08";
+				index = <8>;
+			};
+			led09 {
+				label = "led09";
+				index = <9>;
+			};
+			led10 {
+				label = "led10";
+				index = <10>;
+			};
+			led11 {
+				label = "led11";
+				index = <11>;
+			};
+			led12 {
+				label = "led12";
+				index = <12>;
+			};
+			led13 {
+				label = "led13";
+				index = <13>;
+			};
+			led14 {
+				label = "led14";
+				index = <14>;
+			};
+			led15 {
+				label = "led15";
+				index = <15>;
+			};
+
+		};
+
+		led11 {
+		 	 label = "led11";
+                         compatible = "leds-qsp";
+                         reg = <31 0x0 0x1000>;
+
+		 	 linux,default-trigger = "default-on";
+
+			led0 {
+				label = "power";
+				index = <0>;
+				linux,default-trigger = "default-on";
+			};
+			led01 {
+				label = "heartbeat";
+				index = <1>;
+				linux,default-trigger = "heartbeat";
+			};
+			led02 {
+				label = "timer";
+				index = <2>;
+				//linux,default-trigger = "timer";
+			};
+			led03 {
+				label = "cpu0";
+				index = <3>;
+				//linux,default-trigger = "cpu0";
+			};
+			led04 {
+				label = "cpu1";
+				index = <4>;
+				//linux,default-trigger = "cpu1";
+			};
+			led05 {
+				label = "cpu2";
+				index = <5>;
+				//linux,default-trigger = "cpu2";
+			};
+			led06 {
+				label = "cpu3";
+				index = <6>;
+				//linux,default-trigger = "cpu3";
+			};
+			led07 {
+				label = "led07";
+				index = <7>;
+			};
+			led08 {
+				label = "led08";
+				index = <8>;
+			};
+			led09 {
+				label = "led09";
+				index = <9>;
+			};
+			led10 {
+				label = "led10";
+				index = <10>;
+			};
+			led11 {
+				label = "led11";
+				index = <11>;
+			};
+			led12 {
+				label = "led12";
+				index = <12>;
+			};
+			led13 {
+				label = "led13";
+				index = <13>;
+			};
+			led14 {
+				label = "led14";
+				index = <14>;
+			};
+			led15 {
+				label = "led15";
+				index = <15>;
+			};
+
+		};
+
+		led12 {
+		 	 label = "led12";
+                         compatible = "leds-qsp";
+                         reg = <32 0x0 0x1000>;
+
+		 	 linux,default-trigger = "default-on";
+
+			led0 {
+				label = "power";
+				index = <0>;
+				linux,default-trigger = "default-on";
+			};
+			led01 {
+				label = "heartbeat";
+				index = <1>;
+				linux,default-trigger = "heartbeat";
+			};
+			led02 {
+				label = "timer";
+				index = <2>;
+				//linux,default-trigger = "timer";
+			};
+			led03 {
+				label = "cpu0";
+				index = <3>;
+				//linux,default-trigger = "cpu0";
+			};
+			led04 {
+				label = "cpu1";
+				index = <4>;
+				//linux,default-trigger = "cpu1";
+			};
+			led05 {
+				label = "cpu2";
+				index = <5>;
+				//linux,default-trigger = "cpu2";
+			};
+			led06 {
+				label = "cpu3";
+				index = <6>;
+				//linux,default-trigger = "cpu3";
+			};
+			led07 {
+				label = "led07";
+				index = <7>;
+			};
+			led08 {
+				label = "led08";
+				index = <8>;
+			};
+			led09 {
+				label = "led09";
+				index = <9>;
+			};
+			led10 {
+				label = "led10";
+				index = <10>;
+			};
+			led11 {
+				label = "led11";
+				index = <11>;
+			};
+			led12 {
+				label = "led12";
+				index = <12>;
+			};
+			led13 {
+				label = "led13";
+				index = <13>;
+			};
+			led14 {
+				label = "led14";
+				index = <14>;
+			};
+			led15 {
+				label = "led15";
+				index = <15>;
+			};
+
+		};
+
+		led13 {
+		 	 label = "led13";
+                         compatible = "leds-qsp";
+                         reg = <33 0x0 0x1000>;
+
+		 	 linux,default-trigger = "default-on";
+
+			led0 {
+				label = "power";
+				index = <0>;
+				linux,default-trigger = "default-on";
+			};
+			led01 {
+				label = "heartbeat";
+				index = <1>;
+				linux,default-trigger = "heartbeat";
+			};
+			led02 {
+				label = "timer";
+				index = <2>;
+				//linux,default-trigger = "timer";
+			};
+			led03 {
+				label = "cpu0";
+				index = <3>;
+				//linux,default-trigger = "cpu0";
+			};
+			led04 {
+				label = "cpu1";
+				index = <4>;
+				//linux,default-trigger = "cpu1";
+			};
+			led05 {
+				label = "cpu2";
+				index = <5>;
+				//linux,default-trigger = "cpu2";
+			};
+			led06 {
+				label = "cpu3";
+				index = <6>;
+				//linux,default-trigger = "cpu3";
+			};
+			led07 {
+				label = "led07";
+				index = <7>;
+			};
+			led08 {
+				label = "led08";
+				index = <8>;
+			};
+			led09 {
+				label = "led09";
+				index = <9>;
+			};
+			led10 {
+				label = "led10";
+				index = <10>;
+			};
+			led11 {
+				label = "led11";
+				index = <11>;
+			};
+			led12 {
+				label = "led12";
+				index = <12>;
+			};
+			led13 {
+				label = "led13";
+				index = <13>;
+			};
+			led14 {
+				label = "led14";
+				index = <14>;
+			};
+			led15 {
+				label = "led15";
+				index = <15>;
+			};
+
+		};
+
+		led14 {
+		 	 label = "led14";
+                         compatible = "leds-qsp";
+                         reg = <34 0x0 0x1000>;
+
+		 	 linux,default-trigger = "default-on";
+
+			led0 {
+				label = "power";
+				index = <0>;
+				linux,default-trigger = "default-on";
+			};
+			led01 {
+				label = "heartbeat";
+				index = <1>;
+				linux,default-trigger = "heartbeat";
+			};
+			led02 {
+				label = "timer";
+				index = <2>;
+				//linux,default-trigger = "timer";
+			};
+			led03 {
+				label = "cpu0";
+				index = <3>;
+				//linux,default-trigger = "cpu0";
+			};
+			led04 {
+				label = "cpu1";
+				index = <4>;
+				//linux,default-trigger = "cpu1";
+			};
+			led05 {
+				label = "cpu2";
+				index = <5>;
+				//linux,default-trigger = "cpu2";
+			};
+			led06 {
+				label = "cpu3";
+				index = <6>;
+				//linux,default-trigger = "cpu3";
+			};
+			led07 {
+				label = "led07";
+				index = <7>;
+			};
+			led08 {
+				label = "led08";
+				index = <8>;
+			};
+			led09 {
+				label = "led09";
+				index = <9>;
+			};
+			led10 {
+				label = "led10";
+				index = <10>;
+			};
+			led11 {
+				label = "led11";
+				index = <11>;
+			};
+			led12 {
+				label = "led12";
+				index = <12>;
+			};
+			led13 {
+				label = "led13";
+				index = <13>;
+			};
+			led14 {
+				label = "led14";
+				index = <14>;
+			};
+			led15 {
+				label = "led15";
+				index = <15>;
+			};
+
+		};
+
+		led15 {
+		 	 label = "led15";
+                         compatible = "leds-qsp";
+                         reg = <35 0x0 0x1000>;
+
+		 	 linux,default-trigger = "default-on";
+
+			led0 {
+				label = "power";
+				index = <0>;
+				linux,default-trigger = "default-on";
+			};
+			led01 {
+				label = "heartbeat";
+				index = <1>;
+				linux,default-trigger = "heartbeat";
+			};
+			led02 {
+				label = "timer";
+				index = <2>;
+				//linux,default-trigger = "timer";
+			};
+			led03 {
+				label = "cpu0";
+				index = <3>;
+				//linux,default-trigger = "cpu0";
+			};
+			led04 {
+				label = "cpu1";
+				index = <4>;
+				//linux,default-trigger = "cpu1";
+			};
+			led05 {
+				label = "cpu2";
+				index = <5>;
+				//linux,default-trigger = "cpu2";
+			};
+			led06 {
+				label = "cpu3";
+				index = <6>;
+				//linux,default-trigger = "cpu3";
+			};
+			led07 {
+				label = "led07";
+				index = <7>;
+			};
+			led08 {
+				label = "led08";
+				index = <8>;
+			};
+			led09 {
+				label = "led09";
+				index = <9>;
+			};
+			led10 {
+				label = "led10";
+				index = <10>;
+			};
+			led11 {
+				label = "led11";
+				index = <11>;
+			};
+			led12 {
+				label = "led12";
+				index = <12>;
+			};
+			led13 {
+				label = "led13";
+				index = <13>;
+			};
+			led14 {
+				label = "led14";
+				index = <14>;
+			};
+			led15 {
+				label = "led15";
+				index = <15>;
+			};
+		};
+
+		ETH0: eth0 {
+			device_type = "eth";
+			compatible = "qsp-mac";
+			reg = <36 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <64 0x1>;
+
+		};
+
+		ETH1: eth1 {
+			device_type = "eth";
+			compatible = "qsp-mac";
+			reg = <37 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <65 0x1>;
+
+		};
+
+		ETH2: eth2 {
+			device_type = "eth";
+			compatible = "qsp-mac";
+			reg = <38 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <66 0x1>;
+
+		};
+
+		ETH3: eth3 {
+			device_type = "eth";
+			compatible = "qsp-mac";
+			reg = <39 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <67 0x1>;
+
+		};
+
+		ETH4: eth4 {
+			device_type = "eth";
+			compatible = "qsp-mac";
+			reg = <40 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <68 0x1>;
+
+		};
+
+		ETH5: eth5 {
+			device_type = "eth";
+			compatible = "qsp-mac";
+			reg = <41 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <69 0x1>;
+
+		};
+
+		ETH6: eth6 {
+			device_type = "eth";
+			compatible = "qsp-mac";
+			reg = <42 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <70 0x1>;
+
+		};
+
+		ETH7: eth7 {
+			device_type = "eth";
+			compatible = "qsp-mac";
+			reg = <43 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <71 0x1>;
+
+		};
+
+		ETH8: eth8 {
+			device_type = "eth";
+			compatible = "qsp-mac";
+			reg = <44 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <72 0x1>;
+
+		};
+
+		ETH9: eth9 {
+			device_type = "eth";
+			compatible = "qsp-mac";
+			reg = <45 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <73 0x1>;
+
+		};
+
+		ETH10: eth10 {
+			device_type = "eth";
+			compatible = "qsp-mac";
+			reg = <46 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <74 0x1>;
+
+		};
+
+		ETH11: eth11 {
+			device_type = "eth";
+			compatible = "qsp-mac";
+			reg = <47 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <75 0x1>;
+
+		};
+
+		ETH12: eth12 {
+			device_type = "eth";
+			compatible = "qsp-mac";
+			reg = <48 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <76 0x1>;
+
+		};
+
+		ETH13: eth13 {
+			device_type = "eth";
+			compatible = "qsp-mac";
+			reg = <49 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <77 0x1>;
+
+		};
+
+		ETH14: eth14 {
+			device_type = "eth";
+			compatible = "qsp-mac";
+			reg = <50 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <78 0x1>;
+
+		};
+
+		ETH15: eth15 {
+			device_type = "eth";
+			compatible = "qsp-mac";
+			reg = <51 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <79 0x1>;
+
+		};
+
+		DISKCTL0: diskctrl0 {
+			device_type = "disk-controller";
+			compatible = "qsp,disk-controller";
+			reg = <52 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <80 0x1>;
+		};
+
+		DISKCTL1: diskctrl1 {
+			device_type = "disk-controller";
+			compatible = "qsp,disk-controller";
+			reg = <53 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <81 0x1>;
+		};
+
+		DISKCTL2: diskctrl2 {
+			device_type = "disk-controller";
+			compatible = "qsp,disk-controller";
+			reg = <54 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <82 0x1>;
+		};
+
+		DISKCTL3: diskctrl3 {
+			device_type = "disk-controller";
+			compatible = "qsp,disk-controller";
+			reg = <55 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <83 0x1>;
+		};
+
+		DISKCTL4: diskctrl4 {
+			device_type = "disk-controller";
+			compatible = "qsp,disk-controller";
+			reg = <56 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <84 0x1>;
+		};
+
+		DISKCTL5: diskctrl5 {
+			device_type = "disk-controller";
+			compatible = "qsp,disk-controller";
+			reg = <57 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <85 0x1>;
+		};
+
+		DISKCTL6: diskctrl6 {
+			device_type = "disk-controller";
+			compatible = "qsp,disk-controller";
+			reg = <58 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <86 0x1>;
+		};
+
+		DISKCTL7: diskctrl7 {
+			device_type = "disk-controller";
+			compatible = "qsp,disk-controller";
+			reg = <59 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <87 0x1>;
+		};
+
+		DISKCTL8: diskctrl8 {
+			device_type = "disk-controller";
+			compatible = "qsp,disk-controller";
+			reg = <60 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <88 0x1>;
+		};
+
+		DISKCTL9: diskctrl9 {
+			device_type = "disk-controller";
+			compatible = "qsp,disk-controller";
+			reg = <61 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <89 0x1>;
+		};
+
+		DISKCTL10: diskctrl10 {
+			device_type = "disk-controller";
+			compatible = "qsp,disk-controller";
+			reg = <62 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <90 0x1>;
+		};
+
+		DISKCTL11: diskctrl11 {
+			device_type = "disk-controller";
+			compatible = "qsp,disk-controller";
+			reg = <63 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <91 0x1>;
+		};
+
+		DISKCTL12: diskctrl12 {
+			device_type = "disk-controller";
+			compatible = "qsp,disk-controller";
+			reg = <64 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <92 0x1>;
+		};
+
+		DISKCTL13: diskctrl13 {
+			device_type = "disk-controller";
+			compatible = "qsp,disk-controller";
+			reg = <65 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <93 0x1>;
+		};
+
+		DISKCTL14: diskctrl14 {
+			device_type = "disk-controller";
+			compatible = "qsp,disk-controller";
+			reg = <66 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <94 0x1>;
+		};
+
+		DISKCTL15: diskctrl15 {
+			device_type = "disk-controller";
+			compatible = "qsp,disk-controller";
+			reg = <67 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <95 0x1>;
+		};
+	};
+};
\ No newline at end of file
diff -ruN linux-3.10/arch/arm/configs/qsp_defconfig linux-3.10_patched/arch/arm/configs/qsp_defconfig
--- linux-3.10/arch/arm/configs/qsp_defconfig	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.10_patched/arch/arm/configs/qsp_defconfig	2025-06-14 05:48:04.945173245 +0000
@@ -0,0 +1,1377 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/arm 3.4.0 Kernel Configuration
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+# CONFIG_ARCH_USES_GETTIMEOFFSET is not set
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+CONFIG_KTIME_SCALAR=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_ARCH_HAS_CPU_IDLE_WAIT=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_ARM_PATCH_PHYS_VIRT=y
+CONFIG_GENERIC_BUG=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_HAVE_IRQ_WORK=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE=""
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_XZ=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_XZ is not set
+# CONFIG_KERNEL_LZO is not set
+CONFIG_DEFAULT_HOSTNAME="(none)"
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_FHANDLE is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+CONFIG_HAVE_GENERIC_HARDIRQS=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_IRQ_DOMAIN=y
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_RCU=y
+# CONFIG_PREEMPT_RCU is not set
+CONFIG_RCU_FANOUT=32
+# CONFIG_RCU_FANOUT_EXACT is not set
+# CONFIG_RCU_FAST_NO_HZ is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_CGROUPS is not set
+# CONFIG_CHECKPOINT_RESTORE is not set
+# CONFIG_NAMESPACES is not set
+# CONFIG_SCHED_AUTOGROUP is not set
+# CONFIG_SYSFS_DEPRECATED is not set
+# CONFIG_RELAY is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_XZ is not set
+# CONFIG_RD_LZO is not set
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_EXPERT=y
+CONFIG_UID16=y
+# CONFIG_SYSCTL_SYSCALL is not set
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+# CONFIG_EMBEDDED is not set
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_PERF_USE_VMALLOC=y
+
+#
+# Kernel Performance Events And Counters
+#
+# CONFIG_PERF_EVENTS is not set
+# CONFIG_PERF_COUNTERS is not set
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLUB_DEBUG=y
+CONFIG_COMPAT_BRK=y
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+# CONFIG_JUMP_LABEL is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_USE_GENERIC_SMP_HELPERS=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+CONFIG_QSP=y
+
+#
+# GCOV-based kernel profiling
+#
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+# CONFIG_MODULE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_BSGLIB is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+# CONFIG_SYSV68_PARTITION is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+# CONFIG_INLINE_SPIN_TRYLOCK is not set
+# CONFIG_INLINE_SPIN_TRYLOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK is not set
+# CONFIG_INLINE_SPIN_LOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_SPIN_UNLOCK_BH is not set
+CONFIG_INLINE_SPIN_UNLOCK_IRQ=y
+# CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_READ_TRYLOCK is not set
+# CONFIG_INLINE_READ_LOCK is not set
+# CONFIG_INLINE_READ_LOCK_BH is not set
+# CONFIG_INLINE_READ_LOCK_IRQ is not set
+# CONFIG_INLINE_READ_LOCK_IRQSAVE is not set
+CONFIG_INLINE_READ_UNLOCK=y
+# CONFIG_INLINE_READ_UNLOCK_BH is not set
+CONFIG_INLINE_READ_UNLOCK_IRQ=y
+# CONFIG_INLINE_READ_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_WRITE_TRYLOCK is not set
+# CONFIG_INLINE_WRITE_LOCK is not set
+# CONFIG_INLINE_WRITE_LOCK_BH is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQSAVE is not set
+CONFIG_INLINE_WRITE_UNLOCK=y
+# CONFIG_INLINE_WRITE_UNLOCK_BH is not set
+CONFIG_INLINE_WRITE_UNLOCK_IRQ=y
+# CONFIG_INLINE_WRITE_UNLOCK_IRQRESTORE is not set
+CONFIG_MUTEX_SPIN_ON_OWNER=y
+# CONFIG_FREEZER is not set
+
+#
+# System Type
+#
+CONFIG_MMU=y
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_VEXPRESS is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_BCMRING is not set
+# CONFIG_ARCH_HIGHBANK is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CNS3XXX is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_PRIMA2 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_MXS is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_DOVE is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_LPC32XX is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_TEGRA is not set
+# CONFIG_ARCH_PICOXCELL is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_SHMOBILE is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C24XX is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_S5P64X0 is not set
+# CONFIG_ARCH_S5PC100 is not set
+# CONFIG_ARCH_S5PV210 is not set
+# CONFIG_ARCH_EXYNOS is not set
+# CONFIG_ARCH_SHARK is not set
+CONFIG_ARCH_QSP=y
+# CONFIG_ARCH_U300 is not set
+# CONFIG_ARCH_U8500 is not set
+# CONFIG_ARCH_NOMADIK is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_PLAT_SPEAR is not set
+# CONFIG_ARCH_VT8500 is not set
+# CONFIG_ARCH_ZYNQ is not set
+CONFIG_MACH_QSP=y
+CONFIG_ARM_QSP=y
+
+#
+# System MMU
+#
+
+#
+# Processor Type
+#
+CONFIG_CPU_V7=y
+CONFIG_CPU_32v6K=y
+CONFIG_CPU_32v7=y
+CONFIG_CPU_ABRT_EV7=y
+CONFIG_CPU_PABRT_V7=y
+CONFIG_CPU_CACHE_V7=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V7=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_LPAE is not set
+# CONFIG_ARCH_PHYS_ADDR_T_64BIT is not set
+CONFIG_ARM_THUMB=y
+# CONFIG_ARM_THUMBEE is not set
+CONFIG_SWP_EMULATE=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+# CONFIG_CACHE_L2X0 is not set
+CONFIG_ARM_L1_CACHE_SHIFT_6=y
+CONFIG_ARM_L1_CACHE_SHIFT=6
+CONFIG_ARM_DMA_MEM_BUFFERABLE=y
+CONFIG_ARM_NR_BANKS=8
+CONFIG_CPU_HAS_PMU=y
+CONFIG_MULTI_IRQ_HANDLER=y
+# CONFIG_ARM_ERRATA_430973 is not set
+# CONFIG_ARM_ERRATA_458693 is not set
+# CONFIG_ARM_ERRATA_460075 is not set
+# CONFIG_ARM_ERRATA_742230 is not set
+# CONFIG_ARM_ERRATA_742231 is not set
+CONFIG_ARM_ERRATA_720789=y
+# CONFIG_ARM_ERRATA_743622 is not set
+# CONFIG_ARM_ERRATA_751472 is not set
+# CONFIG_ARM_ERRATA_754322 is not set
+# CONFIG_ARM_ERRATA_754327 is not set
+# CONFIG_ARM_ERRATA_764369 is not set
+
+#
+# Bus support
+#
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+# CONFIG_HIGH_RES_TIMERS is not set
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_HAVE_SMP=y
+CONFIG_SMP=y
+CONFIG_SMP_ON_UP=y
+# CONFIG_ARM_CPU_TOPOLOGY is not set
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_NR_CPUS=128
+# CONFIG_HOTPLUG_CPU is not set
+# CONFIG_LOCAL_TIMERS is not set
+CONFIG_ARCH_NR_GPIO=0
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
+# CONFIG_PREEMPT is not set
+CONFIG_HZ=100
+# CONFIG_THUMB2_KERNEL is not set
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+CONFIG_HAVE_ARCH_PFN_VALID=y
+CONFIG_HIGHMEM=y
+# CONFIG_HIGHPTE is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_COMPACTION is not set
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_BOUNCE=y
+CONFIG_VIRT_TO_BUS=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+# CONFIG_CLEANCACHE is not set
+CONFIG_FORCE_MAX_ZONEORDER=11
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+# CONFIG_SECCOMP is not set
+# CONFIG_CC_STACKPROTECTOR is not set
+# CONFIG_DEPRECATED_PARAM_STRUCT is not set
+
+#
+# Boot options
+#
+CONFIG_USE_OF=y
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_ZBOOT_ROM_BSS=0
+# CONFIG_ARM_APPENDED_DTB is not set
+CONFIG_CMDLINE="console=ttyS0,115200"
+CONFIG_CMDLINE_FROM_BOOTLOADER=y
+# CONFIG_CMDLINE_EXTEND is not set
+# CONFIG_CMDLINE_FORCE is not set
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_CRASH_DUMP is not set
+# CONFIG_AUTO_ZRELADDR is not set
+
+#
+# CPU Power Management
+#
+# CONFIG_CPU_IDLE is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+# CONFIG_FPE_NWFPE is not set
+# CONFIG_FPE_FASTFPE is not set
+CONFIG_VFP=y
+CONFIG_VFPv3=y
+CONFIG_NEON=y
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_ARCH_BINFMT_ELF_RANDOMIZE_PIE=y
+CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS=y
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+CONFIG_BINFMT_MISC=y
+
+#
+# Power management options
+#
+CONFIG_PM_RUNTIME=y
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+# CONFIG_APM_EMULATION is not set
+# CONFIG_ARM_CPU_SUSPEND is not set
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+# CONFIG_UNIX_DIAG is not set
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=y
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE_DEMUX is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+CONFIG_SYN_COOKIES=y
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+# CONFIG_INET_LRO is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_INET_UDP_DIAG is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+# CONFIG_BATMAN_ADV is not set
+# CONFIG_OPENVSWITCH is not set
+CONFIG_RPS=y
+CONFIG_RFS_ACCEL=y
+CONFIG_XPS=y
+CONFIG_BQL=y
+CONFIG_HAVE_BPF_JIT=y
+# CONFIG_BPF_JIT is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+CONFIG_WIRELESS=y
+# CONFIG_CFG80211 is not set
+# CONFIG_LIB80211 is not set
+
+#
+# CFG80211 needs to be enabled for MAC80211
+#
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+# CONFIG_NFC is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_GENERIC_CPU_DEVICES is not set
+# CONFIG_DMA_SHARED_BUFFER is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_TESTS is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+CONFIG_MTD_OF_PARTS=y
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+# CONFIG_MTD_BLKDEVS is not set
+# CONFIG_MTD_BLOCK is not set
+# CONFIG_MTD_BLOCK_RO is not set
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_SM_FTL is not set
+# CONFIG_MTD_OOPS is not set
+# CONFIG_MTD_SWAP is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+CONFIG_MTD_QSP_FLASH=y
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+CONFIG_MTD_PHYSMAP=y
+# CONFIG_MTD_PHYSMAP_COMPAT is not set
+CONFIG_MTD_PHYSMAP_OF=y
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOCG3 is not set
+# CONFIG_MTD_NAND is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# LPDDR flash memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+CONFIG_MTD_UBI=m
+CONFIG_MTD_UBI_WL_THRESHOLD=4096
+CONFIG_MTD_UBI_BEB_RESERVE=1
+# CONFIG_MTD_UBI_GLUEBI is not set
+# CONFIG_MTD_UBI_DEBUG is not set
+CONFIG_DTC=y
+CONFIG_OF=y
+
+#
+# Device Tree and Open Firmware support
+#
+CONFIG_PROC_DEVICETREE=y
+# CONFIG_OF_SELFTEST is not set
+CONFIG_OF_FLATTREE=y
+CONFIG_OF_EARLY_FLATTREE=y
+CONFIG_OF_ADDRESS=y
+CONFIG_OF_IRQ=y
+CONFIG_OF_DEVICE=y
+CONFIG_OF_NET=y
+CONFIG_OF_MDIO=y
+CONFIG_OF_MTD=y
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_LOOP_MIN_COUNT=8
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+
+#
+# DRBD disabled because PROC_FS, INET or CONNECTOR not selected
+#
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=131072
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_BLK_DEV_RBD is not set
+CONFIG_BLK_DEV_QSP=y
+
+#
+# Misc devices
+#
+# CONFIG_SENSORS_LIS3LV02D is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_93CX6 is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+
+#
+# Altera FPGA firmware download module
+#
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_ISCSI_BOOT_SYSFS is not set
+# CONFIG_LIBFC is not set
+# CONFIG_LIBFCOE is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+# CONFIG_TARGET_CORE is not set
+CONFIG_NETDEVICES=y
+CONFIG_NET_CORE=y
+# CONFIG_BONDING is not set
+# CONFIG_DUMMY is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_MII is not set
+# CONFIG_NET_TEAM is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+
+#
+# CAIF transport drivers
+#
+CONFIG_ETHERNET=y
+# CONFIG_NET_VENDOR_BROADCOM is not set
+# CONFIG_NET_CALXEDA_XGMAC is not set
+# CONFIG_NET_VENDOR_CHELSIO is not set
+# CONFIG_NET_VENDOR_CIRRUS is not set
+# CONFIG_DM9000 is not set
+# CONFIG_DNET is not set
+# CONFIG_NET_VENDOR_FARADAY is not set
+# CONFIG_NET_VENDOR_INTEL is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
+# CONFIG_ETHOC is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+# CONFIG_NET_VENDOR_SMSC is not set
+# CONFIG_NET_VENDOR_STMICRO is not set
+CONFIG_NET_QSP=y
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_AMD_PHY is not set
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+# CONFIG_SMSC_PHY is not set
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_REALTEK_PHY is not set
+# CONFIG_NATIONAL_PHY is not set
+# CONFIG_STE10XP is not set
+# CONFIG_LSI_ET1011C_PHY is not set
+# CONFIG_MICREL_PHY is not set
+# CONFIG_FIXED_PHY is not set
+# CONFIG_MDIO_BITBANG is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_WLAN is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+# CONFIG_WAN is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+# CONFIG_INPUT_SPARSEKMAP is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_N_GSM is not set
+# CONFIG_TRACE_SINK is not set
+CONFIG_DEVKMEM=y
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_TIMBERDALE is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_XILINX_PS_UART is not set
+CONFIG_SERIAL_QSP_UART=y
+CONFIG_SERIAL_QSP_MAXPORTS=16
+CONFIG_SERIAL_QSP_CONSOLE=y
+# CONFIG_TTY_PRINTK is not set
+# CONFIG_HVC_DCC is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_RAMOOPS is not set
+# CONFIG_I2C is not set
+# CONFIG_SPI is not set
+# CONFIG_HSI is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+
+#
+# Enable Device Drivers -> PPS to see the PTP clock options.
+#
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+
+#
+# Broadcom specific AMBA
+#
+# CONFIG_BCMA is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+# CONFIG_DRM is not set
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+# CONFIG_FB is not set
+# CONFIG_EXYNOS_VIDEO is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+# CONFIG_SOUND is not set
+# CONFIG_HID_SUPPORT is not set
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+# CONFIG_USB_ARCH_HAS_XHCI is not set
+# CONFIG_USB_SUPPORT is not set
+# CONFIG_MMC is not set
+# CONFIG_MEMSTICK is not set
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+
+#
+# LED drivers
+#
+# CONFIG_LEDS_OT200 is not set
+CONFIG_LEDS_QSP=y
+CONFIG_LEDS_TRIGGERS=y
+
+#
+# LED Triggers
+#
+CONFIG_LEDS_TRIGGER_TIMER=y
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+# CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
+# CONFIG_LEDS_TRIGGER_DEFAULT_ON is not set
+
+#
+# iptables trigger is under Netfilter config (LED target)
+#
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# SPI RTC drivers
+#
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+CONFIG_RTC_DRV_QSP=y
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+
+#
+# Virtio drivers
+#
+# CONFIG_VIRTIO_BALLOON is not set
+# CONFIG_VIRTIO_MMIO is not set
+
+#
+# Microsoft Hyper-V guest support
+#
+# CONFIG_STAGING is not set
+
+#
+# Hardware Spinlock drivers
+#
+CONFIG_CLK_QSP=y
+CONFIG_IOMMU_SUPPORT=y
+
+#
+# Remoteproc drivers (EXPERIMENTAL)
+#
+
+#
+# Rpmsg drivers (EXPERIMENTAL)
+#
+# CONFIG_VIRT_DRIVERS is not set
+# CONFIG_PM_DEVFREQ is not set
+CONFIG_PIC_SUPPORT=y
+CONFIG_QSP_PIC=y
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_DEFAULTS_TO_ORDERED=y
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+# CONFIG_EXT4_FS is not set
+CONFIG_JBD=y
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_FANOTIFY is not set
+# CONFIG_QUOTA is not set
+# CONFIG_QUOTACTL is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_TMPFS_XATTR is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=m
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+# CONFIG_JFFS2_LZO is not set
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_UBIFS_FS=m
+# CONFIG_UBIFS_FS_XATTR is not set
+# CONFIG_UBIFS_FS_ADVANCED_COMPR is not set
+CONFIG_UBIFS_FS_LZO=y
+CONFIG_UBIFS_FS_ZLIB=y
+# CONFIG_UBIFS_FS_DEBUG is not set
+# CONFIG_LOGFS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX6FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_PSTORE is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_SIMICSFS=y
+CONFIG_SIMICSFS_ADDRESS="0xe0200000"
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+# CONFIG_NFS_V3 is not set
+# CONFIG_NFS_V4 is not set
+CONFIG_ROOT_NFS=y
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_SUNRPC_DEBUG is not set
+# CONFIG_CEPH_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+# CONFIG_NLS is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_DEFAULT_MESSAGE_LOGLEVEL=4
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+# CONFIG_LOCKUP_DETECTOR is not set
+# CONFIG_HARDLOCKUP_DETECTOR is not set
+# CONFIG_DETECT_HUNG_TASK is not set
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_SLUB_DEBUG_ON is not set
+# CONFIG_SLUB_STATS is not set
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_SPARSE_RCU_POINTER is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_KOBJECT is not set
+# CONFIG_DEBUG_HIGHMEM is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_INFO_REDUCED is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+CONFIG_RCU_CPU_STALL_TIMEOUT=60
+# CONFIG_RCU_CPU_STALL_INFO is not set
+# CONFIG_RCU_TRACE is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# CONFIG_DEBUG_PER_CPU_MAPS is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_TRACING_SUPPORT=y
+CONFIG_FTRACE=y
+# CONFIG_FUNCTION_TRACER is not set
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_ENABLE_DEFAULT_TRACERS is not set
+CONFIG_BRANCH_PROFILE_NONE=y
+# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
+# CONFIG_PROFILE_ALL_BRANCHES is not set
+# CONFIG_STACK_TRACER is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_STRICT_DEVMEM is not set
+CONFIG_ARM_UNWIND=y
+# CONFIG_DEBUG_USER is not set
+# CONFIG_DEBUG_LL is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+# CONFIG_CRYPTO_FIPS is not set
+CONFIG_CRYPTO_ALGAPI=m
+CONFIG_CRYPTO_ALGAPI2=m
+CONFIG_CRYPTO_RNG=m
+CONFIG_CRYPTO_RNG2=m
+# CONFIG_CRYPTO_MANAGER is not set
+# CONFIG_CRYPTO_MANAGER2 is not set
+# CONFIG_CRYPTO_USER is not set
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_PCRYPT is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+# CONFIG_CRYPTO_CBC is not set
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_MD4 is not set
+# CONFIG_CRYPTO_MD5 is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=m
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=m
+# CONFIG_CRYPTO_ZLIB is not set
+CONFIG_CRYPTO_LZO=m
+
+#
+# Random Number Generation
+#
+CONFIG_CRYPTO_ANSI_CPRNG=m
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+CONFIG_CRYPTO_HW=y
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_GENERIC_IO=y
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC16=m
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC32_SELFTEST is not set
+CONFIG_CRC32_SLICEBY8=y
+# CONFIG_CRC32_SLICEBY4 is not set
+# CONFIG_CRC32_SARWATE is not set
+# CONFIG_CRC32_BIT is not set
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+# CONFIG_CRC8 is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=m
+CONFIG_LZO_COMPRESS=m
+CONFIG_LZO_DECOMPRESS=m
+# CONFIG_XZ_DEC is not set
+# CONFIG_XZ_DEC_BCJ is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_CPU_RMAP=y
+CONFIG_DQL=y
+CONFIG_NLATTR=y
+# CONFIG_AVERAGE is not set
+# CONFIG_CORDIC is not set
diff -ruN linux-3.10/arch/arm/Kconfig linux-3.10_patched/arch/arm/Kconfig
--- linux-3.10/arch/arm/Kconfig	2013-06-30 22:13:29.000000000 +0000
+++ linux-3.10_patched/arch/arm/Kconfig	2025-06-14 05:48:04.945173245 +0000
@@ -812,6 +812,15 @@
 	help
 	  Support for the StrongARM based Digital DNARD machine, also known
 	  as "Shark" (<http://www.shark-linux.de/shark.html>).
+config ARCH_QSP
+       bool "Simics QSP Platform"
+       select CPU_V7
+       select GENERIC_CLOCKEVENTS
+       select USE_OF
+       select MULTI_IRQ_HANDLER
+       help
+         Support for Simics QSP Platform
+
 
 config ARCH_U300
 	bool "ST-Ericsson U300 Series"
Binary files linux-3.10/arch/arm/mach-qsp/built-in.o and linux-3.10_patched/arch/arm/mach-qsp/built-in.o differ
diff -ruN linux-3.10/arch/arm/mach-qsp/.built-in.o.cmd linux-3.10_patched/arch/arm/mach-qsp/.built-in.o.cmd
--- linux-3.10/arch/arm/mach-qsp/.built-in.o.cmd	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.10_patched/arch/arm/mach-qsp/.built-in.o.cmd	2025-06-14 05:48:04.945173245 +0000
@@ -0,0 +1 @@
+cmd_arch/arm/mach-qsp/built-in.o :=  /home/mike/qsp_buildroot/buildroot/output/host/usr/bin/ccache /home/mike/qsp_buildroot/buildroot/output/host/usr/bin/arm-none-linux-gnueabi-ld -EL   -r -o arch/arm/mach-qsp/built-in.o arch/arm/mach-qsp/setup.o arch/arm/mach-qsp/platsmp.o 
diff -ruN linux-3.10/arch/arm/mach-qsp/include/mach/entry-macro.S linux-3.10_patched/arch/arm/mach-qsp/include/mach/entry-macro.S
--- linux-3.10/arch/arm/mach-qsp/include/mach/entry-macro.S	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.10_patched/arch/arm/mach-qsp/include/mach/entry-macro.S	2025-06-14 05:48:04.945173245 +0000
@@ -0,0 +1,16 @@
+
+#ifndef HAVE_GET_IRQNR_PREAMBLE
+	.macro	get_irqnr_preamble, base, tmp
+	.endm
+#endif
+	.macro  get_irqnr_and_base, irqnr, irqstat, base, tmp
+	.endm
+
+	.macro test_for_ipi, irqnr, irqstat, base, tmp
+	.endm
+
+	.macro	disable_fiq
+	.endm
+
+	.macro	arch_ret_to_user, tmp1, tmp2
+	.endm
diff -ruN linux-3.10/arch/arm/mach-qsp/include/mach/io.h linux-3.10_patched/arch/arm/mach-qsp/include/mach/io.h
--- linux-3.10/arch/arm/mach-qsp/include/mach/io.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.10_patched/arch/arm/mach-qsp/include/mach/io.h	2025-06-14 05:48:04.945173245 +0000
@@ -0,0 +1,26 @@
+/*
+ *  arch/arm/mach-vexpress/include/mach/io.h
+ *
+ *  Copyright (C) 2003 ARM Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARM_ARCH_IO_H
+#define __ASM_ARM_ARCH_IO_H
+
+#define __io(a)		__typesafe_io(a)
+#define __mem_pci(a)	(a)
+
+#endif
diff -ruN linux-3.10/arch/arm/mach-qsp/include/mach/irqs.h linux-3.10_patched/arch/arm/mach-qsp/include/mach/irqs.h
--- linux-3.10/arch/arm/mach-qsp/include/mach/irqs.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.10_patched/arch/arm/mach-qsp/include/mach/irqs.h	2025-06-14 05:48:04.945173245 +0000
@@ -0,0 +1,4 @@
+#ifndef __ARM_QSP_IRQ_H
+#define __ARM_QSP_IRQ_H
+#define NR_IRQS	1024
+#endif
diff -ruN linux-3.10/arch/arm/mach-qsp/include/mach/system.h linux-3.10_patched/arch/arm/mach-qsp/include/mach/system.h
--- linux-3.10/arch/arm/mach-qsp/include/mach/system.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.10_patched/arch/arm/mach-qsp/include/mach/system.h	2025-06-14 05:48:04.945173245 +0000
@@ -0,0 +1,37 @@
+/*
+ *  arch/arm/mach-vexpress/include/mach/system.h
+ *
+ *  Copyright (C) 2003 ARM Limited
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_SYSTEM_H
+#define __ASM_ARCH_SYSTEM_H
+
+static inline void arch_idle(void)
+{
+	/*
+	 * This should do all the clock switching
+	 * and wait for interrupt tricks
+	 */
+	cpu_do_idle();
+}
+
+static inline void arch_reset(char mode, const char *cmd)
+{
+}
+
+#endif
diff -ruN linux-3.10/arch/arm/mach-qsp/include/mach/timex.h linux-3.10_patched/arch/arm/mach-qsp/include/mach/timex.h
--- linux-3.10/arch/arm/mach-qsp/include/mach/timex.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.10_patched/arch/arm/mach-qsp/include/mach/timex.h	2025-06-14 05:48:04.945173245 +0000
@@ -0,0 +1,22 @@
+/*
+ *  arch/arm/mach-qsp/include/mach/timex.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/* Bogus value since we're using clocksource */
+#define CLOCK_TICK_RATE		(1000000)
+
+
diff -ruN linux-3.10/arch/arm/mach-qsp/include/mach/uncompress.h linux-3.10_patched/arch/arm/mach-qsp/include/mach/uncompress.h
--- linux-3.10/arch/arm/mach-qsp/include/mach/uncompress.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.10_patched/arch/arm/mach-qsp/include/mach/uncompress.h	2025-06-14 05:48:04.945173245 +0000
@@ -0,0 +1,53 @@
+/*
+ *  arch/arm/mach-qsp/include/mach/uncompress.h
+ *
+ *  Copyright (C) 2012 Wind River
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* Status register bits
+ */
+#define TX_READY (1<<0)
+#define RX_READY (1<<1)
+
+/* Control register bits
+ */
+#define TX_INT (1<<0)
+#define RX_INT (1<<1)
+
+/* Register defines
+ */
+#define ID_REG      0x00
+#define STATUS_REG  0x04
+#define CONTROL_REG 0x08
+#define TXDATA_REG  0x0c
+#define RXDATA_REG  0x10
+
+#define QSP_SERIAL_BASE 0xe0010000
+
+/*
+ * This does not append a newline
+ */
+static inline void putc(int c)
+{
+	*(volatile unsigned long *)(QSP_SERIAL_BASE + TXDATA_REG) = c;
+}
+
+/*
+ * nothing to do
+ */
+#define arch_decomp_setup()
+#define arch_decomp_wdog()
+#define flush()
diff -ruN linux-3.10/arch/arm/mach-qsp/include/mach/vmalloc.h linux-3.10_patched/arch/arm/mach-qsp/include/mach/vmalloc.h
--- linux-3.10/arch/arm/mach-qsp/include/mach/vmalloc.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.10_patched/arch/arm/mach-qsp/include/mach/vmalloc.h	2025-06-14 05:48:04.945173245 +0000
@@ -0,0 +1,21 @@
+/*
+ *  arch/arm/mach-vexpress/include/mach/vmalloc.h
+ *
+ *  Copyright (C) 2003 ARM Limited
+ *  Copyright (C) 2000 Russell King.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#define VMALLOC_END		0xf8000000UL
diff -ruN linux-3.10/arch/arm/mach-qsp/Kconfig linux-3.10_patched/arch/arm/mach-qsp/Kconfig
--- linux-3.10/arch/arm/mach-qsp/Kconfig	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.10_patched/arch/arm/mach-qsp/Kconfig	2025-06-14 05:48:04.945173245 +0000
@@ -0,0 +1,17 @@
+config MACH_QSP
+	bool "Support Simics QSP platforms from device tree"
+	select ARM_QSP
+	select USE_OF
+	select HAVE_SMP
+	help
+	  Include support for Simics QSP based platforms
+	  using the device tree for discovery.
+
+config ARM_QSP
+	bool "Simics QSP for ARM"
+	default n
+	select QSP
+	select QSP_PIC
+	select CLK_QSP
+	help
+	  This option enables support for the QSP simics platform for arm.
diff -ruN linux-3.10/arch/arm/mach-qsp/Makefile linux-3.10_patched/arch/arm/mach-qsp/Makefile
--- linux-3.10/arch/arm/mach-qsp/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.10_patched/arch/arm/mach-qsp/Makefile	2025-06-14 05:48:04.945173245 +0000
@@ -0,0 +1,2 @@
+obj-y:=setup.o
+obj-$(CONFIG_SMP)			+= platsmp.o
diff -ruN linux-3.10/arch/arm/mach-qsp/Makefile.boot linux-3.10_patched/arch/arm/mach-qsp/Makefile.boot
--- linux-3.10/arch/arm/mach-qsp/Makefile.boot	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.10_patched/arch/arm/mach-qsp/Makefile.boot	2025-06-14 05:48:04.945173245 +0000
@@ -0,0 +1,3 @@
+zreladdr-$(CONFIG_ARM_QSP)	+= 0x10008000
+params_phys-$(CONFIG_ARM_QSP)	:= 0x10000100
+initrd_phys-$(CONFIG_ARM_QSP)	:= 0x10800000
diff -ruN linux-3.10/arch/arm/mach-qsp/platsmp.c linux-3.10_patched/arch/arm/mach-qsp/platsmp.c
--- linux-3.10/arch/arm/mach-qsp/platsmp.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.10_patched/arch/arm/mach-qsp/platsmp.c	2025-06-14 05:48:04.945173245 +0000
@@ -0,0 +1,161 @@
+/*
+ *  linux/arch/arm/mach-qsp/platsmp.c
+ *
+ *  Copyright (C) 2012 Wind River
+ *  All Rights Reserved
+ *  Author: Ivar Holmqvist <ivar.holmqvist@windriver.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/smp.h>
+#include <linux/io.h>
+#include <linux/of_fdt.h>
+#include <linux/of_address.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <linux/jiffies.h>
+
+#include <linux/qsp/qsp_pic.h>
+
+/* TODO: The pen_release and boot_lock stuff are stolen from vexpress and
+ *       is really overkill on QSP and should be removed.
+ */
+
+#define ID_REG	       0x00
+#define ENABLE_REG     0x04
+#define DISABLE_REG    0x08
+#define BOOT_PC_REG    0x0c
+#define CPU_STATUS_REG 0x14
+#define PROBE_REG      0x18
+
+static void __iomem *sysregs_base;
+
+/*
+ * control for which core is the next to come out of the secondary
+ * boot "holding pen"
+ */
+volatile int __cpuinitdata pen_release = -1;
+
+/*
+ * Write pen_release in a way that is guaranteed to be visible to all
+ * observers, irrespective of whether they're taking part in coherency
+ * or not.  This is necessary for the hotplug code to work reliably.
+ */
+static void __cpuinit write_pen_release(int val)
+{
+	pen_release = val;
+}
+
+static DEFINE_SPINLOCK(boot_lock);
+
+
+/* FIXME: probe max cores from sysregs... */
+#define QSP_MAX_CORES 128
+
+static void generate_ipi(const struct cpumask *mask, unsigned int irq)
+{
+	int cpu;
+	BUG_ON(irq > (IPI_NUM_TYPES - 1));
+	for_each_cpu(cpu, mask) {
+		/* FIXME: should we do cpu_logical_map(cpu) here
+		 */
+		qsp_pic_message_pass(cpu, irq);
+	}
+}
+
+/*
+ * Initialise the CPU possible map early - this describes the CPUs
+ * which may be present or become present in the system.
+ */
+void __init smp_init_cpus(void)
+{
+	int hw_cpu;
+	struct device_node *np;
+
+	np = of_find_node_by_type(NULL, "sysregs");
+	BUG_ON(np == NULL);
+
+	sysregs_base = of_iomap(np, 0);
+	BUG_ON(sysregs_base == 0);
+
+	for (hw_cpu = 0; hw_cpu < QSP_MAX_CORES; ++hw_cpu) {
+		writel(hw_cpu, sysregs_base + PROBE_REG);
+		if (readl(sysregs_base + CPU_STATUS_REG) == 1)
+			set_cpu_possible(hw_cpu, true);
+	}
+
+	set_smp_cross_call(generate_ipi);
+
+}
+
+void __init platform_smp_prepare_cpus(unsigned int max_cpus)
+{
+	smp_qsp_pic_probe();
+}
+
+extern void secondary_startup(void);
+
+int __cpuinit boot_secondary(unsigned int cpu, struct task_struct *idle)
+{
+	int i;
+	/*
+	 * Set synchronisation state between this boot processor
+	 * and the secondary one
+	 */
+	spin_lock(&boot_lock);
+
+	/*
+	 * This is really belt and braces; we hold unintended secondary
+	 * CPUs in the holding pen until we're ready for them.  However,
+	 * since we haven't sent them a soft interrupt, they shouldn't
+	 * be there.
+	 */
+	write_pen_release(cpu);
+
+	/*
+	 * Send the secondary CPU a soft interrupt, thereby causing
+	 * the boot monitor to read the system wide flags register,
+	 * and branch to the address found there.
+	 */
+	writel(__pa(secondary_startup), sysregs_base + BOOT_PC_REG);
+	writel(cpu, sysregs_base + ENABLE_REG);
+	if (readl(sysregs_base + CPU_STATUS_REG) != 1)
+		return -ENOSYS;
+
+	for (i = 0; i < 10000; i++) {
+		if (pen_release == -1)
+			break;
+		udelay(100);
+	}
+
+	/*
+	 * now the secondary core is starting up let it run its
+	 * calibrations, then wait for it to finish
+	 */
+	spin_unlock(&boot_lock);
+	return pen_release != -1 ? -ENOSYS : 0;
+}
+
+
+void __cpuinit platform_secondary_init(unsigned int cpu)
+
+{
+	/*
+	 * let the primary processor know we're out of the
+	 * pen, then head off into the C entry point
+	 */
+	BUG_ON(pen_release != cpu);
+	write_pen_release(-1);
+
+	/*
+	 * Synchronise with the boot thread.
+	 */
+	spin_lock(&boot_lock);
+	spin_unlock(&boot_lock);
+}
+
Binary files linux-3.10/arch/arm/mach-qsp/platsmp.o and linux-3.10_patched/arch/arm/mach-qsp/platsmp.o differ
diff -ruN linux-3.10/arch/arm/mach-qsp/.platsmp.o.cmd linux-3.10_patched/arch/arm/mach-qsp/.platsmp.o.cmd
--- linux-3.10/arch/arm/mach-qsp/.platsmp.o.cmd	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.10_patched/arch/arm/mach-qsp/.platsmp.o.cmd	2025-06-14 05:48:04.945173245 +0000
@@ -0,0 +1,275 @@
+cmd_arch/arm/mach-qsp/platsmp.o := /home/mike/qsp_buildroot/buildroot/output/host/usr/bin/ccache /home/mike/qsp_buildroot/buildroot/output/host/usr/bin/arm-none-linux-gnueabi-gcc -Wp,-MD,arch/arm/mach-qsp/.platsmp.o.d -nostdinc -isystem /home/mike/qsp_buildroot/buildroot/output/host/opt/ext-toolchain/bin/../lib/gcc/arm-none-linux-gnueabi/4.8.1/include -I/home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include -Iarch/arm/include/generated -Iinclude  -include /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/include/linux/kconfig.h -D__KERNEL__ -mlittle-endian -Iarch/arm/mach-qsp/include -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -Wno-format-security -fno-delete-null-pointer-checks -O2 -marm -fno-dwarf2-cfi-asm -mabi=aapcs-linux -mno-thumb-interwork -funwind-tables -D__LINUX_ARM_ARCH__=7 -march=armv7-a -msoft-float -Uarm -Wframe-larger-than=1024 -fno-stack-protector -Wno-unused-but-set-variable -fomit-frame-pointer -g -Wdeclaration-after-statement -Wno-pointer-sign -fno-strict-overflow -fconserve-stack -DCC_HAVE_ASM_GOTO    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(platsmp)"  -D"KBUILD_MODNAME=KBUILD_STR(platsmp)" -c -o arch/arm/mach-qsp/platsmp.o arch/arm/mach-qsp/platsmp.c
+
+source_arch/arm/mach-qsp/platsmp.o := arch/arm/mach-qsp/platsmp.c
+
+deps_arch/arm/mach-qsp/platsmp.o := \
+  include/linux/init.h \
+    $(wildcard include/config/modules.h) \
+    $(wildcard include/config/hotplug.h) \
+  include/linux/compiler.h \
+    $(wildcard include/config/sparse/rcu/pointer.h) \
+    $(wildcard include/config/trace/branch/profiling.h) \
+    $(wildcard include/config/profile/all/branches.h) \
+    $(wildcard include/config/enable/must/check.h) \
+    $(wildcard include/config/enable/warn/deprecated.h) \
+  include/linux/compiler-gcc.h \
+    $(wildcard include/config/arch/supports/optimized/inlining.h) \
+    $(wildcard include/config/optimize/inlining.h) \
+  include/linux/compiler-gcc4.h \
+  include/linux/types.h \
+    $(wildcard include/config/uid16.h) \
+    $(wildcard include/config/lbdaf.h) \
+    $(wildcard include/config/arch/dma/addr/t/64bit.h) \
+    $(wildcard include/config/phys/addr/t/64bit.h) \
+    $(wildcard include/config/64bit.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/types.h \
+  include/asm-generic/int-ll64.h \
+  arch/arm/include/generated/asm/bitsperlong.h \
+  include/asm-generic/bitsperlong.h \
+  include/linux/posix_types.h \
+  include/linux/stddef.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/posix_types.h \
+  include/asm-generic/posix_types.h \
+  include/linux/errno.h \
+  arch/arm/include/generated/asm/errno.h \
+  include/asm-generic/errno.h \
+  include/asm-generic/errno-base.h \
+  include/linux/smp.h \
+    $(wildcard include/config/smp.h) \
+    $(wildcard include/config/use/generic/smp/helpers.h) \
+    $(wildcard include/config/debug/preempt.h) \
+  include/linux/list.h \
+    $(wildcard include/config/debug/list.h) \
+  include/linux/poison.h \
+    $(wildcard include/config/illegal/pointer/value.h) \
+  include/linux/const.h \
+  include/linux/cpumask.h \
+    $(wildcard include/config/cpumask/offstack.h) \
+    $(wildcard include/config/hotplug/cpu.h) \
+    $(wildcard include/config/debug/per/cpu/maps.h) \
+    $(wildcard include/config/disable/obsolete/cpumask/functions.h) \
+  include/linux/kernel.h \
+    $(wildcard include/config/preempt/voluntary.h) \
+    $(wildcard include/config/debug/atomic/sleep.h) \
+    $(wildcard include/config/prove/locking.h) \
+    $(wildcard include/config/ring/buffer.h) \
+    $(wildcard include/config/tracing.h) \
+    $(wildcard include/config/numa.h) \
+    $(wildcard include/config/compaction.h) \
+    $(wildcard include/config/ftrace/mcount/record.h) \
+  include/linux/sysinfo.h \
+  /home/mike/qsp_buildroot/buildroot/output/host/opt/ext-toolchain/lib/gcc/arm-none-linux-gnueabi/4.8.1/include/stdarg.h \
+  include/linux/linkage.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/linkage.h \
+  include/linux/bitops.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/bitops.h \
+  include/linux/irqflags.h \
+    $(wildcard include/config/trace/irqflags.h) \
+    $(wildcard include/config/irqsoff/tracer.h) \
+    $(wildcard include/config/preempt/tracer.h) \
+    $(wildcard include/config/trace/irqflags/support.h) \
+  include/linux/typecheck.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/irqflags.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/ptrace.h \
+    $(wildcard include/config/cpu/endian/be8.h) \
+    $(wildcard include/config/arm/thumb.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/hwcap.h \
+  include/asm-generic/bitops/non-atomic.h \
+  include/asm-generic/bitops/fls64.h \
+  include/asm-generic/bitops/sched.h \
+  include/asm-generic/bitops/hweight.h \
+  include/asm-generic/bitops/arch_hweight.h \
+  include/asm-generic/bitops/const_hweight.h \
+  include/asm-generic/bitops/lock.h \
+  include/asm-generic/bitops/le.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/byteorder.h \
+  include/linux/byteorder/little_endian.h \
+  include/linux/swab.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/swab.h \
+  include/linux/byteorder/generic.h \
+  include/asm-generic/bitops/ext2-atomic-setbit.h \
+  include/linux/log2.h \
+    $(wildcard include/config/arch/has/ilog2/u32.h) \
+    $(wildcard include/config/arch/has/ilog2/u64.h) \
+  include/linux/printk.h \
+    $(wildcard include/config/printk.h) \
+    $(wildcard include/config/dynamic/debug.h) \
+  include/linux/dynamic_debug.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/div64.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/compiler.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/bug.h \
+    $(wildcard include/config/bug.h) \
+    $(wildcard include/config/thumb2/kernel.h) \
+    $(wildcard include/config/debug/bugverbose.h) \
+    $(wildcard include/config/arm/lpae.h) \
+  include/asm-generic/bug.h \
+    $(wildcard include/config/generic/bug.h) \
+    $(wildcard include/config/generic/bug/relative/pointers.h) \
+  include/linux/threads.h \
+    $(wildcard include/config/nr/cpus.h) \
+    $(wildcard include/config/base/small.h) \
+  include/linux/bitmap.h \
+  include/linux/string.h \
+    $(wildcard include/config/binary/printf.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/string.h \
+  include/linux/bug.h \
+  include/linux/preempt.h \
+    $(wildcard include/config/preempt.h) \
+    $(wildcard include/config/preempt/count.h) \
+    $(wildcard include/config/preempt/notifiers.h) \
+  include/linux/thread_info.h \
+    $(wildcard include/config/compat.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/thread_info.h \
+    $(wildcard include/config/arm/thumbee.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/fpstate.h \
+    $(wildcard include/config/vfpv3.h) \
+    $(wildcard include/config/iwmmxt.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/domain.h \
+    $(wildcard include/config/io/36.h) \
+    $(wildcard include/config/cpu/use/domains.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/barrier.h \
+    $(wildcard include/config/cpu/32v6k.h) \
+    $(wildcard include/config/cpu/xsc3.h) \
+    $(wildcard include/config/cpu/fa526.h) \
+    $(wildcard include/config/arch/has/barriers.h) \
+    $(wildcard include/config/arm/dma/mem/bufferable.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/outercache.h \
+    $(wildcard include/config/outer/cache/sync.h) \
+    $(wildcard include/config/outer/cache.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/smp.h \
+  include/linux/io.h \
+    $(wildcard include/config/mmu.h) \
+    $(wildcard include/config/has/ioport.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/io.h \
+    $(wildcard include/config/need/mach/io/h.h) \
+    $(wildcard include/config/pcmcia/soc/common.h) \
+    $(wildcard include/config/pci.h) \
+    $(wildcard include/config/isa.h) \
+    $(wildcard include/config/pccard.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/memory.h \
+    $(wildcard include/config/need/mach/memory/h.h) \
+    $(wildcard include/config/page/offset.h) \
+    $(wildcard include/config/highmem.h) \
+    $(wildcard include/config/dram/size.h) \
+    $(wildcard include/config/dram/base.h) \
+    $(wildcard include/config/have/tcm.h) \
+    $(wildcard include/config/arm/patch/phys/virt.h) \
+    $(wildcard include/config/phys/offset.h) \
+  arch/arm/include/generated/asm/sizes.h \
+  include/asm-generic/sizes.h \
+  include/asm-generic/memory_model.h \
+    $(wildcard include/config/flatmem.h) \
+    $(wildcard include/config/discontigmem.h) \
+    $(wildcard include/config/sparsemem/vmemmap.h) \
+    $(wildcard include/config/sparsemem.h) \
+  include/asm-generic/pci_iomap.h \
+    $(wildcard include/config/no/generic/pci/ioport/map.h) \
+    $(wildcard include/config/generic/pci/iomap.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/page.h \
+    $(wildcard include/config/cpu/copy/v3.h) \
+    $(wildcard include/config/cpu/copy/v4wt.h) \
+    $(wildcard include/config/cpu/copy/v4wb.h) \
+    $(wildcard include/config/cpu/copy/feroceon.h) \
+    $(wildcard include/config/cpu/copy/fa.h) \
+    $(wildcard include/config/cpu/sa1100.h) \
+    $(wildcard include/config/cpu/xscale.h) \
+    $(wildcard include/config/cpu/copy/v6.h) \
+    $(wildcard include/config/have/arch/pfn/valid.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/glue.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/pgtable-2level-types.h \
+  include/asm-generic/getorder.h \
+  include/linux/of_fdt.h \
+    $(wildcard include/config/of/flattree.h) \
+    $(wildcard include/config/blk/dev/initrd.h) \
+  include/linux/of_address.h \
+    $(wildcard include/config/of/address.h) \
+  include/linux/ioport.h \
+  include/linux/of.h \
+    $(wildcard include/config/sparc.h) \
+    $(wildcard include/config/of/dynamic.h) \
+    $(wildcard include/config/of.h) \
+  include/linux/kref.h \
+  include/linux/atomic.h \
+    $(wildcard include/config/arch/has/atomic/or.h) \
+    $(wildcard include/config/generic/atomic64.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/atomic.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/cmpxchg.h \
+    $(wildcard include/config/cpu/sa110.h) \
+    $(wildcard include/config/cpu/v6.h) \
+  include/asm-generic/cmpxchg-local.h \
+  include/asm-generic/atomic-long.h \
+  include/linux/mod_devicetable.h \
+  include/linux/spinlock.h \
+    $(wildcard include/config/debug/spinlock.h) \
+    $(wildcard include/config/generic/lockbreak.h) \
+    $(wildcard include/config/debug/lock/alloc.h) \
+  include/linux/stringify.h \
+  include/linux/bottom_half.h \
+  include/linux/spinlock_types.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/spinlock_types.h \
+  include/linux/lockdep.h \
+    $(wildcard include/config/lockdep.h) \
+    $(wildcard include/config/lock/stat.h) \
+    $(wildcard include/config/prove/rcu.h) \
+  include/linux/rwlock_types.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/spinlock.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/processor.h \
+    $(wildcard include/config/have/hw/breakpoint.h) \
+    $(wildcard include/config/arm/errata/754327.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/hw_breakpoint.h \
+  include/linux/rwlock.h \
+  include/linux/spinlock_api_smp.h \
+    $(wildcard include/config/inline/spin/lock.h) \
+    $(wildcard include/config/inline/spin/lock/bh.h) \
+    $(wildcard include/config/inline/spin/lock/irq.h) \
+    $(wildcard include/config/inline/spin/lock/irqsave.h) \
+    $(wildcard include/config/inline/spin/trylock.h) \
+    $(wildcard include/config/inline/spin/trylock/bh.h) \
+    $(wildcard include/config/uninline/spin/unlock.h) \
+    $(wildcard include/config/inline/spin/unlock/bh.h) \
+    $(wildcard include/config/inline/spin/unlock/irq.h) \
+    $(wildcard include/config/inline/spin/unlock/irqrestore.h) \
+  include/linux/rwlock_api_smp.h \
+    $(wildcard include/config/inline/read/lock.h) \
+    $(wildcard include/config/inline/write/lock.h) \
+    $(wildcard include/config/inline/read/lock/bh.h) \
+    $(wildcard include/config/inline/write/lock/bh.h) \
+    $(wildcard include/config/inline/read/lock/irq.h) \
+    $(wildcard include/config/inline/write/lock/irq.h) \
+    $(wildcard include/config/inline/read/lock/irqsave.h) \
+    $(wildcard include/config/inline/write/lock/irqsave.h) \
+    $(wildcard include/config/inline/read/trylock.h) \
+    $(wildcard include/config/inline/write/trylock.h) \
+    $(wildcard include/config/inline/read/unlock.h) \
+    $(wildcard include/config/inline/write/unlock.h) \
+    $(wildcard include/config/inline/read/unlock/bh.h) \
+    $(wildcard include/config/inline/write/unlock/bh.h) \
+    $(wildcard include/config/inline/read/unlock/irq.h) \
+    $(wildcard include/config/inline/write/unlock/irq.h) \
+    $(wildcard include/config/inline/read/unlock/irqrestore.h) \
+    $(wildcard include/config/inline/write/unlock/irqrestore.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/prom.h \
+  include/linux/delay.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/delay.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/param.h \
+    $(wildcard include/config/hz.h) \
+  include/linux/jiffies.h \
+  include/linux/math64.h \
+  include/linux/time.h \
+    $(wildcard include/config/arch/uses/gettimeoffset.h) \
+  include/linux/cache.h \
+    $(wildcard include/config/arch/has/cache/line/size.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/cache.h \
+    $(wildcard include/config/arm/l1/cache/shift.h) \
+    $(wildcard include/config/aeabi.h) \
+  include/linux/seqlock.h \
+  include/linux/timex.h \
+  include/linux/param.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/timex.h \
+  arch/arm/mach-qsp/include/mach/timex.h \
+  include/linux/qsp/qsp_pic.h \
+    $(wildcard include/config/arm.h) \
+
+arch/arm/mach-qsp/platsmp.o: $(deps_arch/arm/mach-qsp/platsmp.o)
+
+$(deps_arch/arm/mach-qsp/platsmp.o):
diff -ruN linux-3.10/arch/arm/mach-qsp/setup.c linux-3.10_patched/arch/arm/mach-qsp/setup.c
--- linux-3.10/arch/arm/mach-qsp/setup.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.10_patched/arch/arm/mach-qsp/setup.c	2025-06-14 05:48:04.945173245 +0000
@@ -0,0 +1,113 @@
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/irqdomain.h>
+#include <linux/of.h>
+#include <linux/of_irq.h>
+#include <linux/of_address.h>
+#include <linux/of_platform.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/time.h>
+#include <asm/mach/map.h>
+#include <linux/qsp/qsp_pic.h>
+#include <linux/qsp/qsp_clk.h>
+#include <linux/delay.h>
+
+#define SOFT_RESET_REG 0x48
+/*
+ * Reset the system. It is called by machine_restart().
+ */
+void qsp_restart(char mode, const char *cmd)
+{
+        static void __iomem *sysregs_base;
+        struct device_node *np;
+        np = of_find_node_by_type(NULL, "sysregs");
+        BUG_ON(np == NULL);
+
+        sysregs_base = of_iomap(np, 0);
+        BUG_ON(sysregs_base == 0);
+
+        // write reset register
+        writel(1, sysregs_base + SOFT_RESET_REG);
+
+        mdelay(500);
+}
+
+static struct map_desc sysreg_io_desc[] __initdata = {
+	{
+		.virtual	= 0xf8000000,
+		.pfn		= __phys_to_pfn(0xe0000000),
+		.length		= SZ_128K,
+		.type		= MT_DEVICE,
+	},
+};
+
+void qsp_init_machine(void)
+{
+	of_platform_populate(NULL, of_default_bus_match_table, NULL, NULL);
+}
+
+static void __init qsp_map_io(void)
+{
+#ifdef CONFIG_SMP
+	/* platsmp.c - smp_init_cpus() needs to access sysreg early... */
+	iotable_init(sysreg_io_desc, ARRAY_SIZE(sysreg_io_desc));
+	pr_debug(KERN_INFO "qsp_map_io called\n");
+#endif
+}
+
+asmlinkage void qsp_pic_handle_irq(struct pt_regs *regs)
+{
+	int irq;
+	irq = qsp_pic_get_irq();
+	BUG_ON(irq == NO_IRQ);
+#if CONFIG_SMP
+	if (irq > IPI_BASE) {
+		qsp_ipi_eoi(irq);
+		handle_IPI(IPI_GET_MSG(irq), regs);
+		return;
+	}
+#endif
+	handle_IRQ(irq, regs);
+}
+
+static void qsp_timer_init(void)
+{
+
+	int irq;
+	struct device_node *np;
+	void __iomem *timer_base;
+
+	pr_info(KERN_INFO "qsp timer init\n");
+
+	np = of_find_compatible_node(NULL, NULL, "qsp,timer");
+	WARN_ON(np == NULL);
+
+	timer_base = of_iomap(np, 0);
+	WARN_ON(!timer_base);
+	pr_debug("Timer base %p\n", timer_base);
+
+	irq = irq_of_parse_and_map(np, 0);
+	WARN_ON(irq == 0);
+
+	qsp_timer_init_one(irq, timer_base);
+}
+
+static struct sys_timer qsp_timer = {
+	.init = qsp_timer_init,
+};
+
+static const char *qsp_dt_compat[] __initdata = {
+	"simics,qsp-arm",
+	NULL,
+};
+
+
+DT_MACHINE_START(QSP, "Simics QSP (Device Tree)")
+	.map_io		= qsp_map_io,
+	.init_irq	= qsp_pic_init,
+	.handle_irq	= qsp_pic_handle_irq,
+	.timer		= &qsp_timer,
+	.init_machine	= qsp_init_machine,
+	.dt_compat	= qsp_dt_compat,
+        .restart	= qsp_restart,
+MACHINE_END
Binary files linux-3.10/arch/arm/mach-qsp/setup.o and linux-3.10_patched/arch/arm/mach-qsp/setup.o differ
diff -ruN linux-3.10/arch/arm/mach-qsp/.setup.o.cmd linux-3.10_patched/arch/arm/mach-qsp/.setup.o.cmd
--- linux-3.10/arch/arm/mach-qsp/.setup.o.cmd	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.10_patched/arch/arm/mach-qsp/.setup.o.cmd	2025-06-14 05:48:04.945173245 +0000
@@ -0,0 +1,412 @@
+cmd_arch/arm/mach-qsp/setup.o := /home/mike/qsp_buildroot/buildroot/output/host/usr/bin/ccache /home/mike/qsp_buildroot/buildroot/output/host/usr/bin/arm-none-linux-gnueabi-gcc -Wp,-MD,arch/arm/mach-qsp/.setup.o.d -nostdinc -isystem /home/mike/qsp_buildroot/buildroot/output/host/opt/ext-toolchain/bin/../lib/gcc/arm-none-linux-gnueabi/4.8.1/include -I/home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include -Iarch/arm/include/generated -Iinclude  -include /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/include/linux/kconfig.h -D__KERNEL__ -mlittle-endian -Iarch/arm/mach-qsp/include -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -Wno-format-security -fno-delete-null-pointer-checks -O2 -marm -fno-dwarf2-cfi-asm -mabi=aapcs-linux -mno-thumb-interwork -funwind-tables -D__LINUX_ARM_ARCH__=7 -march=armv7-a -msoft-float -Uarm -Wframe-larger-than=1024 -fno-stack-protector -Wno-unused-but-set-variable -fomit-frame-pointer -g -Wdeclaration-after-statement -Wno-pointer-sign -fno-strict-overflow -fconserve-stack -DCC_HAVE_ASM_GOTO    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(setup)"  -D"KBUILD_MODNAME=KBUILD_STR(setup)" -c -o arch/arm/mach-qsp/setup.o arch/arm/mach-qsp/setup.c
+
+source_arch/arm/mach-qsp/setup.o := arch/arm/mach-qsp/setup.c
+
+deps_arch/arm/mach-qsp/setup.o := \
+    $(wildcard include/config/smp.h) \
+  include/linux/init.h \
+    $(wildcard include/config/modules.h) \
+    $(wildcard include/config/hotplug.h) \
+  include/linux/compiler.h \
+    $(wildcard include/config/sparse/rcu/pointer.h) \
+    $(wildcard include/config/trace/branch/profiling.h) \
+    $(wildcard include/config/profile/all/branches.h) \
+    $(wildcard include/config/enable/must/check.h) \
+    $(wildcard include/config/enable/warn/deprecated.h) \
+  include/linux/compiler-gcc.h \
+    $(wildcard include/config/arch/supports/optimized/inlining.h) \
+    $(wildcard include/config/optimize/inlining.h) \
+  include/linux/compiler-gcc4.h \
+  include/linux/types.h \
+    $(wildcard include/config/uid16.h) \
+    $(wildcard include/config/lbdaf.h) \
+    $(wildcard include/config/arch/dma/addr/t/64bit.h) \
+    $(wildcard include/config/phys/addr/t/64bit.h) \
+    $(wildcard include/config/64bit.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/types.h \
+  include/asm-generic/int-ll64.h \
+  arch/arm/include/generated/asm/bitsperlong.h \
+  include/asm-generic/bitsperlong.h \
+  include/linux/posix_types.h \
+  include/linux/stddef.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/posix_types.h \
+  include/asm-generic/posix_types.h \
+  include/linux/irq.h \
+    $(wildcard include/config/s390.h) \
+    $(wildcard include/config/irq/release/method.h) \
+    $(wildcard include/config/generic/hardirqs.h) \
+    $(wildcard include/config/generic/pending/irq.h) \
+  include/linux/smp.h \
+    $(wildcard include/config/use/generic/smp/helpers.h) \
+    $(wildcard include/config/debug/preempt.h) \
+  include/linux/errno.h \
+  arch/arm/include/generated/asm/errno.h \
+  include/asm-generic/errno.h \
+  include/asm-generic/errno-base.h \
+  include/linux/list.h \
+    $(wildcard include/config/debug/list.h) \
+  include/linux/poison.h \
+    $(wildcard include/config/illegal/pointer/value.h) \
+  include/linux/const.h \
+  include/linux/cpumask.h \
+    $(wildcard include/config/cpumask/offstack.h) \
+    $(wildcard include/config/hotplug/cpu.h) \
+    $(wildcard include/config/debug/per/cpu/maps.h) \
+    $(wildcard include/config/disable/obsolete/cpumask/functions.h) \
+  include/linux/kernel.h \
+    $(wildcard include/config/preempt/voluntary.h) \
+    $(wildcard include/config/debug/atomic/sleep.h) \
+    $(wildcard include/config/prove/locking.h) \
+    $(wildcard include/config/ring/buffer.h) \
+    $(wildcard include/config/tracing.h) \
+    $(wildcard include/config/numa.h) \
+    $(wildcard include/config/compaction.h) \
+    $(wildcard include/config/ftrace/mcount/record.h) \
+  include/linux/sysinfo.h \
+  /home/mike/qsp_buildroot/buildroot/output/host/opt/ext-toolchain/lib/gcc/arm-none-linux-gnueabi/4.8.1/include/stdarg.h \
+  include/linux/linkage.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/linkage.h \
+  include/linux/bitops.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/bitops.h \
+  include/linux/irqflags.h \
+    $(wildcard include/config/trace/irqflags.h) \
+    $(wildcard include/config/irqsoff/tracer.h) \
+    $(wildcard include/config/preempt/tracer.h) \
+    $(wildcard include/config/trace/irqflags/support.h) \
+  include/linux/typecheck.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/irqflags.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/ptrace.h \
+    $(wildcard include/config/cpu/endian/be8.h) \
+    $(wildcard include/config/arm/thumb.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/hwcap.h \
+  include/asm-generic/bitops/non-atomic.h \
+  include/asm-generic/bitops/fls64.h \
+  include/asm-generic/bitops/sched.h \
+  include/asm-generic/bitops/hweight.h \
+  include/asm-generic/bitops/arch_hweight.h \
+  include/asm-generic/bitops/const_hweight.h \
+  include/asm-generic/bitops/lock.h \
+  include/asm-generic/bitops/le.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/byteorder.h \
+  include/linux/byteorder/little_endian.h \
+  include/linux/swab.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/swab.h \
+  include/linux/byteorder/generic.h \
+  include/asm-generic/bitops/ext2-atomic-setbit.h \
+  include/linux/log2.h \
+    $(wildcard include/config/arch/has/ilog2/u32.h) \
+    $(wildcard include/config/arch/has/ilog2/u64.h) \
+  include/linux/printk.h \
+    $(wildcard include/config/printk.h) \
+    $(wildcard include/config/dynamic/debug.h) \
+  include/linux/dynamic_debug.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/div64.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/compiler.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/bug.h \
+    $(wildcard include/config/bug.h) \
+    $(wildcard include/config/thumb2/kernel.h) \
+    $(wildcard include/config/debug/bugverbose.h) \
+    $(wildcard include/config/arm/lpae.h) \
+  include/asm-generic/bug.h \
+    $(wildcard include/config/generic/bug.h) \
+    $(wildcard include/config/generic/bug/relative/pointers.h) \
+  include/linux/threads.h \
+    $(wildcard include/config/nr/cpus.h) \
+    $(wildcard include/config/base/small.h) \
+  include/linux/bitmap.h \
+  include/linux/string.h \
+    $(wildcard include/config/binary/printf.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/string.h \
+  include/linux/bug.h \
+  include/linux/preempt.h \
+    $(wildcard include/config/preempt.h) \
+    $(wildcard include/config/preempt/count.h) \
+    $(wildcard include/config/preempt/notifiers.h) \
+  include/linux/thread_info.h \
+    $(wildcard include/config/compat.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/thread_info.h \
+    $(wildcard include/config/arm/thumbee.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/fpstate.h \
+    $(wildcard include/config/vfpv3.h) \
+    $(wildcard include/config/iwmmxt.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/domain.h \
+    $(wildcard include/config/io/36.h) \
+    $(wildcard include/config/cpu/use/domains.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/barrier.h \
+    $(wildcard include/config/cpu/32v6k.h) \
+    $(wildcard include/config/cpu/xsc3.h) \
+    $(wildcard include/config/cpu/fa526.h) \
+    $(wildcard include/config/arch/has/barriers.h) \
+    $(wildcard include/config/arm/dma/mem/bufferable.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/outercache.h \
+    $(wildcard include/config/outer/cache/sync.h) \
+    $(wildcard include/config/outer/cache.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/smp.h \
+  include/linux/cache.h \
+    $(wildcard include/config/arch/has/cache/line/size.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/cache.h \
+    $(wildcard include/config/arm/l1/cache/shift.h) \
+    $(wildcard include/config/aeabi.h) \
+  include/linux/spinlock.h \
+    $(wildcard include/config/debug/spinlock.h) \
+    $(wildcard include/config/generic/lockbreak.h) \
+    $(wildcard include/config/debug/lock/alloc.h) \
+  include/linux/stringify.h \
+  include/linux/bottom_half.h \
+  include/linux/spinlock_types.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/spinlock_types.h \
+  include/linux/lockdep.h \
+    $(wildcard include/config/lockdep.h) \
+    $(wildcard include/config/lock/stat.h) \
+    $(wildcard include/config/prove/rcu.h) \
+  include/linux/rwlock_types.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/spinlock.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/processor.h \
+    $(wildcard include/config/have/hw/breakpoint.h) \
+    $(wildcard include/config/mmu.h) \
+    $(wildcard include/config/arm/errata/754327.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/hw_breakpoint.h \
+  include/linux/rwlock.h \
+  include/linux/spinlock_api_smp.h \
+    $(wildcard include/config/inline/spin/lock.h) \
+    $(wildcard include/config/inline/spin/lock/bh.h) \
+    $(wildcard include/config/inline/spin/lock/irq.h) \
+    $(wildcard include/config/inline/spin/lock/irqsave.h) \
+    $(wildcard include/config/inline/spin/trylock.h) \
+    $(wildcard include/config/inline/spin/trylock/bh.h) \
+    $(wildcard include/config/uninline/spin/unlock.h) \
+    $(wildcard include/config/inline/spin/unlock/bh.h) \
+    $(wildcard include/config/inline/spin/unlock/irq.h) \
+    $(wildcard include/config/inline/spin/unlock/irqrestore.h) \
+  include/linux/rwlock_api_smp.h \
+    $(wildcard include/config/inline/read/lock.h) \
+    $(wildcard include/config/inline/write/lock.h) \
+    $(wildcard include/config/inline/read/lock/bh.h) \
+    $(wildcard include/config/inline/write/lock/bh.h) \
+    $(wildcard include/config/inline/read/lock/irq.h) \
+    $(wildcard include/config/inline/write/lock/irq.h) \
+    $(wildcard include/config/inline/read/lock/irqsave.h) \
+    $(wildcard include/config/inline/write/lock/irqsave.h) \
+    $(wildcard include/config/inline/read/trylock.h) \
+    $(wildcard include/config/inline/write/trylock.h) \
+    $(wildcard include/config/inline/read/unlock.h) \
+    $(wildcard include/config/inline/write/unlock.h) \
+    $(wildcard include/config/inline/read/unlock/bh.h) \
+    $(wildcard include/config/inline/write/unlock/bh.h) \
+    $(wildcard include/config/inline/read/unlock/irq.h) \
+    $(wildcard include/config/inline/write/unlock/irq.h) \
+    $(wildcard include/config/inline/read/unlock/irqrestore.h) \
+    $(wildcard include/config/inline/write/unlock/irqrestore.h) \
+  include/linux/atomic.h \
+    $(wildcard include/config/arch/has/atomic/or.h) \
+    $(wildcard include/config/generic/atomic64.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/atomic.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/cmpxchg.h \
+    $(wildcard include/config/cpu/sa1100.h) \
+    $(wildcard include/config/cpu/sa110.h) \
+    $(wildcard include/config/cpu/v6.h) \
+  include/asm-generic/cmpxchg-local.h \
+  include/asm-generic/atomic-long.h \
+  include/linux/gfp.h \
+    $(wildcard include/config/kmemcheck.h) \
+    $(wildcard include/config/highmem.h) \
+    $(wildcard include/config/zone/dma.h) \
+    $(wildcard include/config/zone/dma32.h) \
+    $(wildcard include/config/pm/sleep.h) \
+  include/linux/mmzone.h \
+    $(wildcard include/config/force/max/zoneorder.h) \
+    $(wildcard include/config/memory/hotplug.h) \
+    $(wildcard include/config/sparsemem.h) \
+    $(wildcard include/config/have/memblock/node/map.h) \
+    $(wildcard include/config/discontigmem.h) \
+    $(wildcard include/config/flat/node/mem/map.h) \
+    $(wildcard include/config/cgroup/mem/res/ctlr.h) \
+    $(wildcard include/config/no/bootmem.h) \
+    $(wildcard include/config/have/memory/present.h) \
+    $(wildcard include/config/have/memoryless/nodes.h) \
+    $(wildcard include/config/need/node/memmap/size.h) \
+    $(wildcard include/config/have/memblock/node.h) \
+    $(wildcard include/config/need/multiple/nodes.h) \
+    $(wildcard include/config/have/arch/early/pfn/to/nid.h) \
+    $(wildcard include/config/flatmem.h) \
+    $(wildcard include/config/sparsemem/extreme.h) \
+    $(wildcard include/config/have/arch/pfn/valid.h) \
+    $(wildcard include/config/nodes/span/other/nodes.h) \
+    $(wildcard include/config/holes/in/zone.h) \
+    $(wildcard include/config/arch/has/holes/memorymodel.h) \
+  include/linux/wait.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/current.h \
+  include/linux/numa.h \
+    $(wildcard include/config/nodes/shift.h) \
+  include/linux/seqlock.h \
+  include/linux/nodemask.h \
+  include/linux/pageblock-flags.h \
+    $(wildcard include/config/hugetlb/page.h) \
+    $(wildcard include/config/hugetlb/page/size/variable.h) \
+  include/generated/bounds.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/page.h \
+    $(wildcard include/config/cpu/copy/v3.h) \
+    $(wildcard include/config/cpu/copy/v4wt.h) \
+    $(wildcard include/config/cpu/copy/v4wb.h) \
+    $(wildcard include/config/cpu/copy/feroceon.h) \
+    $(wildcard include/config/cpu/copy/fa.h) \
+    $(wildcard include/config/cpu/xscale.h) \
+    $(wildcard include/config/cpu/copy/v6.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/glue.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/pgtable-2level-types.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/memory.h \
+    $(wildcard include/config/need/mach/memory/h.h) \
+    $(wildcard include/config/page/offset.h) \
+    $(wildcard include/config/dram/size.h) \
+    $(wildcard include/config/dram/base.h) \
+    $(wildcard include/config/have/tcm.h) \
+    $(wildcard include/config/arm/patch/phys/virt.h) \
+    $(wildcard include/config/phys/offset.h) \
+  arch/arm/include/generated/asm/sizes.h \
+  include/asm-generic/sizes.h \
+  include/asm-generic/memory_model.h \
+    $(wildcard include/config/sparsemem/vmemmap.h) \
+  include/asm-generic/getorder.h \
+  include/linux/memory_hotplug.h \
+    $(wildcard include/config/memory/hotremove.h) \
+    $(wildcard include/config/have/arch/nodedata/extension.h) \
+  include/linux/notifier.h \
+  include/linux/mutex.h \
+    $(wildcard include/config/debug/mutexes.h) \
+    $(wildcard include/config/have/arch/mutex/cpu/relax.h) \
+  include/linux/rwsem.h \
+    $(wildcard include/config/rwsem/generic/spinlock.h) \
+  include/linux/rwsem-spinlock.h \
+  include/linux/srcu.h \
+  include/linux/rcupdate.h \
+    $(wildcard include/config/rcu/torture/test.h) \
+    $(wildcard include/config/tree/rcu.h) \
+    $(wildcard include/config/tree/preempt/rcu.h) \
+    $(wildcard include/config/rcu/trace.h) \
+    $(wildcard include/config/preempt/rcu.h) \
+    $(wildcard include/config/tiny/rcu.h) \
+    $(wildcard include/config/tiny/preempt/rcu.h) \
+    $(wildcard include/config/debug/objects/rcu/head.h) \
+    $(wildcard include/config/preempt/rt.h) \
+  include/linux/completion.h \
+  include/linux/debugobjects.h \
+    $(wildcard include/config/debug/objects.h) \
+    $(wildcard include/config/debug/objects/free.h) \
+  include/linux/rcutree.h \
+  include/linux/topology.h \
+    $(wildcard include/config/sched/smt.h) \
+    $(wildcard include/config/sched/mc.h) \
+    $(wildcard include/config/sched/book.h) \
+    $(wildcard include/config/use/percpu/numa/node/id.h) \
+  include/linux/percpu.h \
+    $(wildcard include/config/need/per/cpu/embed/first/chunk.h) \
+    $(wildcard include/config/need/per/cpu/page/first/chunk.h) \
+    $(wildcard include/config/have/setup/per/cpu/area.h) \
+  include/linux/pfn.h \
+  arch/arm/include/generated/asm/percpu.h \
+  include/asm-generic/percpu.h \
+  include/linux/percpu-defs.h \
+    $(wildcard include/config/debug/force/weak/per/cpu.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/topology.h \
+    $(wildcard include/config/arm/cpu/topology.h) \
+  include/asm-generic/topology.h \
+  include/linux/mmdebug.h \
+    $(wildcard include/config/debug/vm.h) \
+    $(wildcard include/config/debug/virtual.h) \
+  include/linux/irqreturn.h \
+  include/linux/irqnr.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/irq.h \
+    $(wildcard include/config/sparse/irq.h) \
+  arch/arm/mach-qsp/include/mach/irqs.h \
+  arch/arm/include/generated/asm/irq_regs.h \
+  include/asm-generic/irq_regs.h \
+  include/linux/irqdesc.h \
+    $(wildcard include/config/irq/preflow/fasteoi.h) \
+    $(wildcard include/config/proc/fs.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/hw_irq.h \
+  include/linux/irqdomain.h \
+    $(wildcard include/config/irq/domain.h) \
+    $(wildcard include/config/of/irq.h) \
+  include/linux/radix-tree.h \
+  include/linux/of.h \
+    $(wildcard include/config/sparc.h) \
+    $(wildcard include/config/of/dynamic.h) \
+    $(wildcard include/config/of.h) \
+  include/linux/kref.h \
+  include/linux/mod_devicetable.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/prom.h \
+  include/linux/of_irq.h \
+    $(wildcard include/config/ppc32.h) \
+    $(wildcard include/config/ppc/pmac.h) \
+  include/linux/ioport.h \
+  include/linux/of_address.h \
+    $(wildcard include/config/of/address.h) \
+    $(wildcard include/config/pci.h) \
+  include/linux/of_platform.h \
+    $(wildcard include/config/of/device.h) \
+  include/linux/device.h \
+    $(wildcard include/config/debug/devres.h) \
+    $(wildcard include/config/devtmpfs.h) \
+    $(wildcard include/config/sysfs/deprecated.h) \
+  include/linux/kobject.h \
+  include/linux/sysfs.h \
+    $(wildcard include/config/sysfs.h) \
+  include/linux/kobject_ns.h \
+  include/linux/klist.h \
+  include/linux/pm.h \
+    $(wildcard include/config/pm.h) \
+    $(wildcard include/config/pm/runtime.h) \
+    $(wildcard include/config/pm/clk.h) \
+    $(wildcard include/config/pm/generic/domains.h) \
+  include/linux/workqueue.h \
+    $(wildcard include/config/debug/objects/work.h) \
+    $(wildcard include/config/freezer.h) \
+  include/linux/timer.h \
+    $(wildcard include/config/timer/stats.h) \
+    $(wildcard include/config/debug/objects/timers.h) \
+  include/linux/ktime.h \
+    $(wildcard include/config/ktime/scalar.h) \
+  include/linux/time.h \
+    $(wildcard include/config/arch/uses/gettimeoffset.h) \
+  include/linux/math64.h \
+  include/linux/jiffies.h \
+  include/linux/timex.h \
+  include/linux/param.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/param.h \
+    $(wildcard include/config/hz.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/timex.h \
+  arch/arm/mach-qsp/include/mach/timex.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/device.h \
+    $(wildcard include/config/dmabounce.h) \
+    $(wildcard include/config/iommu/api.h) \
+    $(wildcard include/config/arch/omap.h) \
+  include/linux/pm_wakeup.h \
+  include/linux/of_device.h \
+  include/linux/platform_device.h \
+    $(wildcard include/config/suspend.h) \
+    $(wildcard include/config/hibernate/callbacks.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/mach/arch.h \
+    $(wildcard include/config/multi/irq/handler.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/mach/time.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/mach/map.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/io.h \
+    $(wildcard include/config/need/mach/io/h.h) \
+    $(wildcard include/config/pcmcia/soc/common.h) \
+    $(wildcard include/config/isa.h) \
+    $(wildcard include/config/pccard.h) \
+  include/asm-generic/pci_iomap.h \
+    $(wildcard include/config/no/generic/pci/ioport/map.h) \
+    $(wildcard include/config/generic/pci/iomap.h) \
+  include/linux/qsp/qsp_pic.h \
+    $(wildcard include/config/arm.h) \
+  include/linux/qsp/qsp_clk.h \
+  include/linux/clocksource.h \
+    $(wildcard include/config/arch/clocksource/data.h) \
+    $(wildcard include/config/clocksource/watchdog.h) \
+    $(wildcard include/config/generic/time/vsyscall.h) \
+  include/linux/delay.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/delay.h \
+
+arch/arm/mach-qsp/setup.o: $(deps_arch/arm/mach-qsp/setup.o)
+
+$(deps_arch/arm/mach-qsp/setup.o):
diff -ruN linux-3.10/arch/arm/Makefile linux-3.10_patched/arch/arm/Makefile
--- linux-3.10/arch/arm/Makefile	2013-06-30 22:13:29.000000000 +0000
+++ linux-3.10_patched/arch/arm/Makefile	2025-06-14 05:48:04.941173245 +0000
@@ -137,6 +137,7 @@
 
 # Machine directory name.  This list is sorted alphanumerically
 # by CONFIG_* macro name.
+machine-$(CONFIG_ARCH_QSP)		+= qsp
 machine-$(CONFIG_ARCH_AT91)		+= at91
 machine-$(CONFIG_ARCH_BCM)		+= bcm
 machine-$(CONFIG_ARCH_BCM2835)		+= bcm2835
diff -ruN linux-3.10/arch/arm/mm/proc-v7.S linux-3.10_patched/arch/arm/mm/proc-v7.S
--- linux-3.10/arch/arm/mm/proc-v7.S	2013-06-30 22:13:29.000000000 +0000
+++ linux-3.10_patched/arch/arm/mm/proc-v7.S	2025-06-14 05:48:04.945173245 +0000
@@ -337,6 +337,11 @@
 	mcr	p15, 0, r5, c10, c2, 0		@ write PRRR
 	mcr	p15, 0, r6, c10, c2, 1		@ write NMRR
 #endif
+#ifndef CONFIG_QSP
+       /* This breaks on simics.. don't have time to fix the model
+       * now, just disabling it.
+       */
+
 #ifndef CONFIG_ARM_THUMBEE
 	mrc	p15, 0, r0, c0, c1, 0		@ read ID_PFR0 for ThumbEE
 	and	r0, r0, #(0xf << 12)		@ ThumbEE enabled field
@@ -349,6 +354,7 @@
 	mcr	p14, 6, r0, c0, c0, 0		@ stop userspace TEEHBR access
 1:
 #endif
+#endif
 	adr	r5, v7_crval
 	ldmia	r5, {r5, r6}
 #ifdef CONFIG_CPU_ENDIAN_BE8
diff -ruN linux-3.10/arch/Kconfig linux-3.10_patched/arch/Kconfig
--- linux-3.10/arch/Kconfig	2013-06-30 22:13:29.000000000 +0000
+++ linux-3.10_patched/arch/Kconfig	2025-06-14 05:48:04.941173245 +0000
@@ -430,4 +430,7 @@
 config COMPAT_OLD_SIGACTION
 	bool
 
+config QSP
+	bool
+
 source "kernel/gcov/Kconfig"
diff -ruN linux-3.10/arch/powerpc/boot/dts/qsp.dts linux-3.10_patched/arch/powerpc/boot/dts/qsp.dts
--- linux-3.10/arch/powerpc/boot/dts/qsp.dts	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.10_patched/arch/powerpc/boot/dts/qsp.dts	2025-06-14 05:48:04.949173245 +0000
@@ -0,0 +1,3284 @@
+
+/*
+ * Copyright 2012, Wind River
+ *
+ * This file is licensed under
+ * the terms of the GNU General Public License version 2.  This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+
+/* This is a fully populated dts file for a QSP PPC board. The
+ * actual number of cpus and devices can controlled from simics
+ * and we expect to silently fail probing of non-existant devices.
+ */
+
+/dts-v1/;
+
+/ {
+	model = "QSP PPC Simple";
+	compatible = "simics,qsp-ppc";
+	#address-cells = <1>;
+	#size-cells = <1>;
+	chosen {
+		bootargs = "rw root=0x6300 console=ttyAM0";
+	};
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		PowerPC,e600@0 {
+			device_type = "cpu";
+			reg = <0x0>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@1 {
+			device_type = "cpu";
+			reg = <0x1>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@2 {
+			device_type = "cpu";
+			reg = <0x2>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@3 {
+			device_type = "cpu";
+			reg = <0x3>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@4 {
+			device_type = "cpu";
+			reg = <0x4>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@5 {
+			device_type = "cpu";
+			reg = <0x5>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@6 {
+			device_type = "cpu";
+			reg = <0x6>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@7 {
+			device_type = "cpu";
+			reg = <0x7>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@8 {
+			device_type = "cpu";
+			reg = <0x8>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@9 {
+			device_type = "cpu";
+			reg = <0x9>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@10 {
+			device_type = "cpu";
+			reg = <0xa>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@11 {
+			device_type = "cpu";
+			reg = <0xb>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@12 {
+			device_type = "cpu";
+			reg = <0xc>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@13 {
+			device_type = "cpu";
+			reg = <0xd>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@14 {
+			device_type = "cpu";
+			reg = <0xe>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@15 {
+			device_type = "cpu";
+			reg = <0xf>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@16 {
+			device_type = "cpu";
+			reg = <0x10>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@17 {
+			device_type = "cpu";
+			reg = <0x11>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@18 {
+			device_type = "cpu";
+			reg = <0x12>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@19 {
+			device_type = "cpu";
+			reg = <0x13>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@20 {
+			device_type = "cpu";
+			reg = <0x14>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@21 {
+			device_type = "cpu";
+			reg = <0x15>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@22 {
+			device_type = "cpu";
+			reg = <0x16>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@23 {
+			device_type = "cpu";
+			reg = <0x17>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@24 {
+			device_type = "cpu";
+			reg = <0x18>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@25 {
+			device_type = "cpu";
+			reg = <0x19>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@26 {
+			device_type = "cpu";
+			reg = <0x1a>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@27 {
+			device_type = "cpu";
+			reg = <0x1b>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@28 {
+			device_type = "cpu";
+			reg = <0x1c>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@29 {
+			device_type = "cpu";
+			reg = <0x1d>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@30 {
+			device_type = "cpu";
+			reg = <0x1e>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@31 {
+			device_type = "cpu";
+			reg = <0x1f>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@32 {
+			device_type = "cpu";
+			reg = <0x20>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@33 {
+			device_type = "cpu";
+			reg = <0x21>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@34 {
+			device_type = "cpu";
+			reg = <0x22>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@35 {
+			device_type = "cpu";
+			reg = <0x23>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@36 {
+			device_type = "cpu";
+			reg = <0x24>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@37 {
+			device_type = "cpu";
+			reg = <0x25>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@38 {
+			device_type = "cpu";
+			reg = <0x26>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@39 {
+			device_type = "cpu";
+			reg = <0x27>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@40 {
+			device_type = "cpu";
+			reg = <0x28>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@41 {
+			device_type = "cpu";
+			reg = <0x29>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@42 {
+			device_type = "cpu";
+			reg = <0x2a>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@43 {
+			device_type = "cpu";
+			reg = <0x2b>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@44 {
+			device_type = "cpu";
+			reg = <0x2c>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@45 {
+			device_type = "cpu";
+			reg = <0x2d>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@46 {
+			device_type = "cpu";
+			reg = <0x2e>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@47 {
+			device_type = "cpu";
+			reg = <0x2f>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@48 {
+			device_type = "cpu";
+			reg = <0x30>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@49 {
+			device_type = "cpu";
+			reg = <0x31>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@50 {
+			device_type = "cpu";
+			reg = <0x32>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@51 {
+			device_type = "cpu";
+			reg = <0x33>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@52 {
+			device_type = "cpu";
+			reg = <0x34>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@53 {
+			device_type = "cpu";
+			reg = <0x35>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@54 {
+			device_type = "cpu";
+			reg = <0x36>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@55 {
+			device_type = "cpu";
+			reg = <0x37>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@56 {
+			device_type = "cpu";
+			reg = <0x38>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@57 {
+			device_type = "cpu";
+			reg = <0x39>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@58 {
+			device_type = "cpu";
+			reg = <0x3a>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@59 {
+			device_type = "cpu";
+			reg = <0x3b>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@60 {
+			device_type = "cpu";
+			reg = <0x3c>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@61 {
+			device_type = "cpu";
+			reg = <0x3d>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@62 {
+			device_type = "cpu";
+			reg = <0x3e>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@63 {
+			device_type = "cpu";
+			reg = <0x3f>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@64 {
+			device_type = "cpu";
+			reg = <0x40>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@65 {
+			device_type = "cpu";
+			reg = <0x41>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@66 {
+			device_type = "cpu";
+			reg = <0x42>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@67 {
+			device_type = "cpu";
+			reg = <0x43>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@68 {
+			device_type = "cpu";
+			reg = <0x44>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@69 {
+			device_type = "cpu";
+			reg = <0x45>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@70 {
+			device_type = "cpu";
+			reg = <0x46>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@71 {
+			device_type = "cpu";
+			reg = <0x47>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@72 {
+			device_type = "cpu";
+			reg = <0x48>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@73 {
+			device_type = "cpu";
+			reg = <0x49>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@74 {
+			device_type = "cpu";
+			reg = <0x4a>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@75 {
+			device_type = "cpu";
+			reg = <0x4b>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@76 {
+			device_type = "cpu";
+			reg = <0x4c>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@77 {
+			device_type = "cpu";
+			reg = <0x4d>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@78 {
+			device_type = "cpu";
+			reg = <0x4e>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@79 {
+			device_type = "cpu";
+			reg = <0x4f>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@80 {
+			device_type = "cpu";
+			reg = <0x50>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@81 {
+			device_type = "cpu";
+			reg = <0x51>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@82 {
+			device_type = "cpu";
+			reg = <0x52>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@83 {
+			device_type = "cpu";
+			reg = <0x53>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@84 {
+			device_type = "cpu";
+			reg = <0x54>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@85 {
+			device_type = "cpu";
+			reg = <0x55>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@86 {
+			device_type = "cpu";
+			reg = <0x56>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@87 {
+			device_type = "cpu";
+			reg = <0x57>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@88 {
+			device_type = "cpu";
+			reg = <0x58>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@89 {
+			device_type = "cpu";
+			reg = <0x59>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@90 {
+			device_type = "cpu";
+			reg = <0x5a>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@91 {
+			device_type = "cpu";
+			reg = <0x5b>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@92 {
+			device_type = "cpu";
+			reg = <0x5c>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@93 {
+			device_type = "cpu";
+			reg = <0x5d>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@94 {
+			device_type = "cpu";
+			reg = <0x5e>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@95 {
+			device_type = "cpu";
+			reg = <0x5f>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@96 {
+			device_type = "cpu";
+			reg = <0x60>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@97 {
+			device_type = "cpu";
+			reg = <0x61>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@98 {
+			device_type = "cpu";
+			reg = <0x62>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@99 {
+			device_type = "cpu";
+			reg = <0x63>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@100 {
+			device_type = "cpu";
+			reg = <0x64>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@101 {
+			device_type = "cpu";
+			reg = <0x65>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@102 {
+			device_type = "cpu";
+			reg = <0x66>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@103 {
+			device_type = "cpu";
+			reg = <0x67>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@104 {
+			device_type = "cpu";
+			reg = <0x68>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@105 {
+			device_type = "cpu";
+			reg = <0x69>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@106 {
+			device_type = "cpu";
+			reg = <0x6a>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@107 {
+			device_type = "cpu";
+			reg = <0x6b>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@108 {
+			device_type = "cpu";
+			reg = <0x6c>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@109 {
+			device_type = "cpu";
+			reg = <0x6d>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@110 {
+			device_type = "cpu";
+			reg = <0x6e>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@111 {
+			device_type = "cpu";
+			reg = <0x6f>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@112 {
+			device_type = "cpu";
+			reg = <0x70>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@113 {
+			device_type = "cpu";
+			reg = <0x71>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@114 {
+			device_type = "cpu";
+			reg = <0x72>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@115 {
+			device_type = "cpu";
+			reg = <0x73>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@116 {
+			device_type = "cpu";
+			reg = <0x74>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@117 {
+			device_type = "cpu";
+			reg = <0x75>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@118 {
+			device_type = "cpu";
+			reg = <0x76>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@119 {
+			device_type = "cpu";
+			reg = <0x77>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@120 {
+			device_type = "cpu";
+			reg = <0x78>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@121 {
+			device_type = "cpu";
+			reg = <0x79>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@122 {
+			device_type = "cpu";
+			reg = <0x7a>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@123 {
+			device_type = "cpu";
+			reg = <0x7b>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@124 {
+			device_type = "cpu";
+			reg = <0x7c>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@125 {
+			device_type = "cpu";
+			reg = <0x7d>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@126 {
+			device_type = "cpu";
+			reg = <0x7e>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+		PowerPC,e600@127 {
+			device_type = "cpu";
+			reg = <0x7f>;
+			clock-frequency =   <1000000000>;
+			timebase-frequency = <125000000>;
+			bus-frequency = <0>;
+			/* Following required by dtc but not used */
+			i-cache-size = <0x4000>;
+			d-cache-size = <0x4000>;
+		};
+
+	};
+
+	memory {
+		device_type = "memory";
+		reg = <0x0 0x20000000>;
+	};
+
+	flash@0xd0000000 {
+		#address-cells = <2>;
+		#size-cells = <1>;
+		compatible = "simple-bus";
+		ranges = <0 0 0xd0000000 0x10000000>;
+		qsp_flash@0,0 {
+					compatible = "qsp-flash";
+					bank-width = <2>;
+					reg = <0 0x00000000 0x10000000>;
+					#address-cells = <1>;
+					#size-cells = <1>;
+					partition@0 {
+						label = "entire_flash";
+						reg = <0x00000000 0x10000000>;
+					};
+
+
+				   };
+	 };
+
+	soc@0xe0000000 {
+		#address-cells = <2>;
+		#size-cells = <1>;
+		device_type = "soc";
+		compatible = "simple-bus";
+		ranges = <		0 0 0xe0000000 0x1000 //pic0
+		1 0 0xe0001000 0x1000 //sysregs0
+		2 0 0xe0002000 0x1000 //rtc0
+		3 0 0xe0010000 0x1000 //uart0
+		4 0 0xe0011000 0x1000 //uart1
+		5 0 0xe0012000 0x1000 //uart2
+		6 0 0xe0013000 0x1000 //uart3
+		7 0 0xe0014000 0x1000 //uart4
+		8 0 0xe0015000 0x1000 //uart5
+		9 0 0xe0016000 0x1000 //uart6
+		10 0 0xe0017000 0x1000 //uart7
+		11 0 0xe0018000 0x1000 //uart8
+		12 0 0xe0019000 0x1000 //uart9
+		13 0 0xe001a000 0x1000 //uart10
+		14 0 0xe001b000 0x1000 //uart11
+		15 0 0xe001c000 0x1000 //uart12
+		16 0 0xe001d000 0x1000 //uart13
+		17 0 0xe001e000 0x1000 //uart14
+		18 0 0xe001f000 0x1000 //uart15
+		19 0 0xe0020000 0x1000 //timer0
+		20 0 0xe0030000 0x1000 //led0
+		21 0 0xe0031000 0x1000 //led1
+		22 0 0xe0032000 0x1000 //led2
+		23 0 0xe0033000 0x1000 //led3
+		24 0 0xe0034000 0x1000 //led4
+		25 0 0xe0035000 0x1000 //led5
+		26 0 0xe0036000 0x1000 //led6
+		27 0 0xe0037000 0x1000 //led7
+		28 0 0xe0038000 0x1000 //led8
+		29 0 0xe0039000 0x1000 //led9
+		30 0 0xe003a000 0x1000 //led10
+		31 0 0xe003b000 0x1000 //led11
+		32 0 0xe003c000 0x1000 //led12
+		33 0 0xe003d000 0x1000 //led13
+		34 0 0xe003e000 0x1000 //led14
+		35 0 0xe003f000 0x1000 //led15
+		36 0 0xe0040000 0x1000 //mac0
+		37 0 0xe0041000 0x1000 //mac1
+		38 0 0xe0042000 0x1000 //mac2
+		39 0 0xe0043000 0x1000 //mac3
+		40 0 0xe0044000 0x1000 //mac4
+		41 0 0xe0045000 0x1000 //mac5
+		42 0 0xe0046000 0x1000 //mac6
+		43 0 0xe0047000 0x1000 //mac7
+		44 0 0xe0048000 0x1000 //mac8
+		45 0 0xe0049000 0x1000 //mac9
+		46 0 0xe004a000 0x1000 //mac10
+		47 0 0xe004b000 0x1000 //mac11
+		48 0 0xe004c000 0x1000 //mac12
+		49 0 0xe004d000 0x1000 //mac13
+		50 0 0xe004e000 0x1000 //mac14
+		51 0 0xe004f000 0x1000 //mac15
+		52 0 0xe0050000 0x1000 //disk_ctrl0
+		53 0 0xe0051000 0x1000 //disk_ctrl1
+		54 0 0xe0052000 0x1000 //disk_ctrl2
+		55 0 0xe0053000 0x1000 //disk_ctrl3
+		56 0 0xe0054000 0x1000 //disk_ctrl4
+		57 0 0xe0055000 0x1000 //disk_ctrl5
+		58 0 0xe0056000 0x1000 //disk_ctrl6
+		59 0 0xe0057000 0x1000 //disk_ctrl7
+		60 0 0xe0058000 0x1000 //disk_ctrl8
+		61 0 0xe0059000 0x1000 //disk_ctrl9
+		62 0 0xe005a000 0x1000 //disk_ctrl10
+		63 0 0xe005b000 0x1000 //disk_ctrl11
+		64 0 0xe005c000 0x1000 //disk_ctrl12
+		65 0 0xe005d000 0x1000 //disk_ctrl13
+		66 0 0xe005e000 0x1000 //disk_ctrl14
+		67 0 0xe005f000 0x1000 //disk_ctrl15
+>;
+		bus-frequency = <0>;
+
+		PIC: interrupt-controller@0,0 {
+			#interrupt-cells = <2>;
+			cell-index = <0>;
+			device_type = "interrupt-controller";
+			compatible = "qsp-pic";
+			interrupt-controller;
+			reg = <0 0x0 0x1000>;
+		};
+
+		SYSREGS: sysregs {
+
+			device_type = "sysregs";
+			compatible = "qsp,sysregs";
+			reg = <1 0x0 0x1000>;
+		};
+
+		RTC: rtc {
+			device_type = "rtc";
+			compatible = "qsp-rtc";
+			reg = <2 0x0 0x1000>;
+		};
+
+		UART0: qspserial0 {
+			device_type = "serial";
+			compatible = "qsp-serial";
+			reg = <3 0x0 0x1000>;
+			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
+			interrupt-parent = <&PIC>;
+ 			interrupts = <16 0x1>;
+		};
+
+		UART1: qspserial1 {
+			device_type = "serial";
+			compatible = "qsp-serial";
+			reg = <4 0x0 0x1000>;
+			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
+			interrupt-parent = <&PIC>;
+ 			interrupts = <17 0x1>;
+		};
+
+		UART2: qspserial2 {
+			device_type = "serial";
+			compatible = "qsp-serial";
+			reg = <5 0x0 0x1000>;
+			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
+			interrupt-parent = <&PIC>;
+ 			interrupts = <18 0x1>;
+		};
+
+		UART3: qspserial3 {
+			device_type = "serial";
+			compatible = "qsp-serial";
+			reg = <6 0x0 0x1000>;
+			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
+			interrupt-parent = <&PIC>;
+ 			interrupts = <19 0x1>;
+		};
+
+		UART4: qspserial4 {
+			device_type = "serial";
+			compatible = "qsp-serial";
+			reg = <7 0x0 0x1000>;
+			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
+			interrupt-parent = <&PIC>;
+ 			interrupts = <20 0x1>;
+		};
+
+		UART5: qspserial5 {
+			device_type = "serial";
+			compatible = "qsp-serial";
+			reg = <8 0x0 0x1000>;
+			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
+			interrupt-parent = <&PIC>;
+ 			interrupts = <21 0x1>;
+		};
+
+		UART6: qspserial6 {
+			device_type = "serial";
+			compatible = "qsp-serial";
+			reg = <9 0x0 0x1000>;
+			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
+			interrupt-parent = <&PIC>;
+ 			interrupts = <22 0x1>;
+		};
+
+		UART7: qspserial7 {
+			device_type = "serial";
+			compatible = "qsp-serial";
+			reg = <10 0x0 0x1000>;
+			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
+			interrupt-parent = <&PIC>;
+ 			interrupts = <23 0x1>;
+		};
+
+		UART8: qspserial8 {
+			device_type = "serial";
+			compatible = "qsp-serial";
+			reg = <11 0x0 0x1000>;
+			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
+			interrupt-parent = <&PIC>;
+ 			interrupts = <24 0x1>;
+		};
+
+		UART9: qspserial9 {
+			device_type = "serial";
+			compatible = "qsp-serial";
+			reg = <12 0x0 0x1000>;
+			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
+			interrupt-parent = <&PIC>;
+ 			interrupts = <25 0x1>;
+		};
+
+		UART10: qspserial10 {
+			device_type = "serial";
+			compatible = "qsp-serial";
+			reg = <13 0x0 0x1000>;
+			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
+			interrupt-parent = <&PIC>;
+ 			interrupts = <26 0x1>;
+		};
+
+		UART11: qspserial11 {
+			device_type = "serial";
+			compatible = "qsp-serial";
+			reg = <14 0x0 0x1000>;
+			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
+			interrupt-parent = <&PIC>;
+ 			interrupts = <27 0x1>;
+		};
+
+		UART12: qspserial12 {
+			device_type = "serial";
+			compatible = "qsp-serial";
+			reg = <15 0x0 0x1000>;
+			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
+			interrupt-parent = <&PIC>;
+ 			interrupts = <28 0x1>;
+		};
+
+		UART13: qspserial13 {
+			device_type = "serial";
+			compatible = "qsp-serial";
+			reg = <16 0x0 0x1000>;
+			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
+			interrupt-parent = <&PIC>;
+ 			interrupts = <29 0x1>;
+		};
+
+		UART14: qspserial14 {
+			device_type = "serial";
+			compatible = "qsp-serial";
+			reg = <17 0x0 0x1000>;
+			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
+			interrupt-parent = <&PIC>;
+ 			interrupts = <30 0x1>;
+		};
+
+		UART15: qspserial15 {
+			device_type = "serial";
+			compatible = "qsp-serial";
+			reg = <18 0x0 0x1000>;
+			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
+			interrupt-parent = <&PIC>;
+ 			interrupts = <31 0x1>;
+		};
+
+		TIMER0: qsptimer0 {
+			compatible = "qsp,timer";
+			reg = <19 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <32 0x1>;
+		};
+
+		led0 {
+		 	 label = "led0";
+                         compatible = "leds-qsp";
+                         reg = <20 0x0 0x1000>;
+
+		 	 linux,default-trigger = "default-on";
+
+			led0 {
+				label = "power";
+				index = <0>;
+				linux,default-trigger = "default-on";
+			};
+			led01 {
+				label = "heartbeat";
+				index = <1>;
+				linux,default-trigger = "heartbeat";
+			};
+			led02 {
+				label = "timer";
+				index = <2>;
+				//linux,default-trigger = "timer";
+			};
+			led03 {
+				label = "cpu0";
+				index = <3>;
+				//linux,default-trigger = "cpu0";
+			};
+			led04 {
+				label = "cpu1";
+				index = <4>;
+				//linux,default-trigger = "cpu1";
+			};
+			led05 {
+				label = "cpu2";
+				index = <5>;
+				//linux,default-trigger = "cpu2";
+			};
+			led06 {
+				label = "cpu3";
+				index = <6>;
+				//linux,default-trigger = "cpu3";
+			};
+			led07 {
+				label = "led07";
+				index = <7>;
+			};
+			led08 {
+				label = "led08";
+				index = <8>;
+			};
+			led09 {
+				label = "led09";
+				index = <9>;
+			};
+			led10 {
+				label = "led10";
+				index = <10>;
+			};
+			led11 {
+				label = "led11";
+				index = <11>;
+			};
+			led12 {
+				label = "led12";
+				index = <12>;
+			};
+			led13 {
+				label = "led13";
+				index = <13>;
+			};
+			led14 {
+				label = "led14";
+				index = <14>;
+			};
+			led15 {
+				label = "led15";
+				index = <15>;
+			};
+
+		};
+
+		led1 {
+		 	 label = "led1";
+                         compatible = "leds-qsp";
+                         reg = <21 0x0 0x1000>;
+
+		 	 linux,default-trigger = "default-on";
+
+			led0 {
+				label = "power";
+				index = <0>;
+				linux,default-trigger = "default-on";
+			};
+			led01 {
+				label = "heartbeat";
+				index = <1>;
+				linux,default-trigger = "heartbeat";
+			};
+			led02 {
+				label = "timer";
+				index = <2>;
+				//linux,default-trigger = "timer";
+			};
+			led03 {
+				label = "cpu0";
+				index = <3>;
+				//linux,default-trigger = "cpu0";
+			};
+			led04 {
+				label = "cpu1";
+				index = <4>;
+				//linux,default-trigger = "cpu1";
+			};
+			led05 {
+				label = "cpu2";
+				index = <5>;
+				//linux,default-trigger = "cpu2";
+			};
+			led06 {
+				label = "cpu3";
+				index = <6>;
+				//linux,default-trigger = "cpu3";
+			};
+			led07 {
+				label = "led07";
+				index = <7>;
+			};
+			led08 {
+				label = "led08";
+				index = <8>;
+			};
+			led09 {
+				label = "led09";
+				index = <9>;
+			};
+			led10 {
+				label = "led10";
+				index = <10>;
+			};
+			led11 {
+				label = "led11";
+				index = <11>;
+			};
+			led12 {
+				label = "led12";
+				index = <12>;
+			};
+			led13 {
+				label = "led13";
+				index = <13>;
+			};
+			led14 {
+				label = "led14";
+				index = <14>;
+			};
+			led15 {
+				label = "led15";
+				index = <15>;
+			};
+
+		};
+
+		led2 {
+		 	 label = "led2";
+                         compatible = "leds-qsp";
+                         reg = <22 0x0 0x1000>;
+
+		 	 linux,default-trigger = "default-on";
+
+			led0 {
+				label = "power";
+				index = <0>;
+				linux,default-trigger = "default-on";
+			};
+			led01 {
+				label = "heartbeat";
+				index = <1>;
+				linux,default-trigger = "heartbeat";
+			};
+			led02 {
+				label = "timer";
+				index = <2>;
+				//linux,default-trigger = "timer";
+			};
+			led03 {
+				label = "cpu0";
+				index = <3>;
+				//linux,default-trigger = "cpu0";
+			};
+			led04 {
+				label = "cpu1";
+				index = <4>;
+				//linux,default-trigger = "cpu1";
+			};
+			led05 {
+				label = "cpu2";
+				index = <5>;
+				//linux,default-trigger = "cpu2";
+			};
+			led06 {
+				label = "cpu3";
+				index = <6>;
+				//linux,default-trigger = "cpu3";
+			};
+			led07 {
+				label = "led07";
+				index = <7>;
+			};
+			led08 {
+				label = "led08";
+				index = <8>;
+			};
+			led09 {
+				label = "led09";
+				index = <9>;
+			};
+			led10 {
+				label = "led10";
+				index = <10>;
+			};
+			led11 {
+				label = "led11";
+				index = <11>;
+			};
+			led12 {
+				label = "led12";
+				index = <12>;
+			};
+			led13 {
+				label = "led13";
+				index = <13>;
+			};
+			led14 {
+				label = "led14";
+				index = <14>;
+			};
+			led15 {
+				label = "led15";
+				index = <15>;
+			};
+
+		};
+
+		led3 {
+		 	 label = "led3";
+                         compatible = "leds-qsp";
+                         reg = <23 0x0 0x1000>;
+
+		 	 linux,default-trigger = "default-on";
+
+			led0 {
+				label = "power";
+				index = <0>;
+				linux,default-trigger = "default-on";
+			};
+			led01 {
+				label = "heartbeat";
+				index = <1>;
+				linux,default-trigger = "heartbeat";
+			};
+			led02 {
+				label = "timer";
+				index = <2>;
+				//linux,default-trigger = "timer";
+			};
+			led03 {
+				label = "cpu0";
+				index = <3>;
+				//linux,default-trigger = "cpu0";
+			};
+			led04 {
+				label = "cpu1";
+				index = <4>;
+				//linux,default-trigger = "cpu1";
+			};
+			led05 {
+				label = "cpu2";
+				index = <5>;
+				//linux,default-trigger = "cpu2";
+			};
+			led06 {
+				label = "cpu3";
+				index = <6>;
+				//linux,default-trigger = "cpu3";
+			};
+			led07 {
+				label = "led07";
+				index = <7>;
+			};
+			led08 {
+				label = "led08";
+				index = <8>;
+			};
+			led09 {
+				label = "led09";
+				index = <9>;
+			};
+			led10 {
+				label = "led10";
+				index = <10>;
+			};
+			led11 {
+				label = "led11";
+				index = <11>;
+			};
+			led12 {
+				label = "led12";
+				index = <12>;
+			};
+			led13 {
+				label = "led13";
+				index = <13>;
+			};
+			led14 {
+				label = "led14";
+				index = <14>;
+			};
+			led15 {
+				label = "led15";
+				index = <15>;
+			};
+
+		};
+
+		led4 {
+		 	 label = "led4";
+                         compatible = "leds-qsp";
+                         reg = <24 0x0 0x1000>;
+
+		 	 linux,default-trigger = "default-on";
+
+			led0 {
+				label = "power";
+				index = <0>;
+				linux,default-trigger = "default-on";
+			};
+			led01 {
+				label = "heartbeat";
+				index = <1>;
+				linux,default-trigger = "heartbeat";
+			};
+			led02 {
+				label = "timer";
+				index = <2>;
+				//linux,default-trigger = "timer";
+			};
+			led03 {
+				label = "cpu0";
+				index = <3>;
+				//linux,default-trigger = "cpu0";
+			};
+			led04 {
+				label = "cpu1";
+				index = <4>;
+				//linux,default-trigger = "cpu1";
+			};
+			led05 {
+				label = "cpu2";
+				index = <5>;
+				//linux,default-trigger = "cpu2";
+			};
+			led06 {
+				label = "cpu3";
+				index = <6>;
+				//linux,default-trigger = "cpu3";
+			};
+			led07 {
+				label = "led07";
+				index = <7>;
+			};
+			led08 {
+				label = "led08";
+				index = <8>;
+			};
+			led09 {
+				label = "led09";
+				index = <9>;
+			};
+			led10 {
+				label = "led10";
+				index = <10>;
+			};
+			led11 {
+				label = "led11";
+				index = <11>;
+			};
+			led12 {
+				label = "led12";
+				index = <12>;
+			};
+			led13 {
+				label = "led13";
+				index = <13>;
+			};
+			led14 {
+				label = "led14";
+				index = <14>;
+			};
+			led15 {
+				label = "led15";
+				index = <15>;
+			};
+
+		};
+
+		led5 {
+		 	 label = "led5";
+                         compatible = "leds-qsp";
+                         reg = <25 0x0 0x1000>;
+
+		 	 linux,default-trigger = "default-on";
+
+			led0 {
+				label = "power";
+				index = <0>;
+				linux,default-trigger = "default-on";
+			};
+			led01 {
+				label = "heartbeat";
+				index = <1>;
+				linux,default-trigger = "heartbeat";
+			};
+			led02 {
+				label = "timer";
+				index = <2>;
+				//linux,default-trigger = "timer";
+			};
+			led03 {
+				label = "cpu0";
+				index = <3>;
+				//linux,default-trigger = "cpu0";
+			};
+			led04 {
+				label = "cpu1";
+				index = <4>;
+				//linux,default-trigger = "cpu1";
+			};
+			led05 {
+				label = "cpu2";
+				index = <5>;
+				//linux,default-trigger = "cpu2";
+			};
+			led06 {
+				label = "cpu3";
+				index = <6>;
+				//linux,default-trigger = "cpu3";
+			};
+			led07 {
+				label = "led07";
+				index = <7>;
+			};
+			led08 {
+				label = "led08";
+				index = <8>;
+			};
+			led09 {
+				label = "led09";
+				index = <9>;
+			};
+			led10 {
+				label = "led10";
+				index = <10>;
+			};
+			led11 {
+				label = "led11";
+				index = <11>;
+			};
+			led12 {
+				label = "led12";
+				index = <12>;
+			};
+			led13 {
+				label = "led13";
+				index = <13>;
+			};
+			led14 {
+				label = "led14";
+				index = <14>;
+			};
+			led15 {
+				label = "led15";
+				index = <15>;
+			};
+
+		};
+
+		led6 {
+		 	 label = "led6";
+                         compatible = "leds-qsp";
+                         reg = <26 0x0 0x1000>;
+
+		 	 linux,default-trigger = "default-on";
+
+			led0 {
+				label = "power";
+				index = <0>;
+				linux,default-trigger = "default-on";
+			};
+			led01 {
+				label = "heartbeat";
+				index = <1>;
+				linux,default-trigger = "heartbeat";
+			};
+			led02 {
+				label = "timer";
+				index = <2>;
+				//linux,default-trigger = "timer";
+			};
+			led03 {
+				label = "cpu0";
+				index = <3>;
+				//linux,default-trigger = "cpu0";
+			};
+			led04 {
+				label = "cpu1";
+				index = <4>;
+				//linux,default-trigger = "cpu1";
+			};
+			led05 {
+				label = "cpu2";
+				index = <5>;
+				//linux,default-trigger = "cpu2";
+			};
+			led06 {
+				label = "cpu3";
+				index = <6>;
+				//linux,default-trigger = "cpu3";
+			};
+			led07 {
+				label = "led07";
+				index = <7>;
+			};
+			led08 {
+				label = "led08";
+				index = <8>;
+			};
+			led09 {
+				label = "led09";
+				index = <9>;
+			};
+			led10 {
+				label = "led10";
+				index = <10>;
+			};
+			led11 {
+				label = "led11";
+				index = <11>;
+			};
+			led12 {
+				label = "led12";
+				index = <12>;
+			};
+			led13 {
+				label = "led13";
+				index = <13>;
+			};
+			led14 {
+				label = "led14";
+				index = <14>;
+			};
+			led15 {
+				label = "led15";
+				index = <15>;
+			};
+
+		};
+
+		led7 {
+		 	 label = "led7";
+                         compatible = "leds-qsp";
+                         reg = <27 0x0 0x1000>;
+
+		 	 linux,default-trigger = "default-on";
+
+			led0 {
+				label = "power";
+				index = <0>;
+				linux,default-trigger = "default-on";
+			};
+			led01 {
+				label = "heartbeat";
+				index = <1>;
+				linux,default-trigger = "heartbeat";
+			};
+			led02 {
+				label = "timer";
+				index = <2>;
+				//linux,default-trigger = "timer";
+			};
+			led03 {
+				label = "cpu0";
+				index = <3>;
+				//linux,default-trigger = "cpu0";
+			};
+			led04 {
+				label = "cpu1";
+				index = <4>;
+				//linux,default-trigger = "cpu1";
+			};
+			led05 {
+				label = "cpu2";
+				index = <5>;
+				//linux,default-trigger = "cpu2";
+			};
+			led06 {
+				label = "cpu3";
+				index = <6>;
+				//linux,default-trigger = "cpu3";
+			};
+			led07 {
+				label = "led07";
+				index = <7>;
+			};
+			led08 {
+				label = "led08";
+				index = <8>;
+			};
+			led09 {
+				label = "led09";
+				index = <9>;
+			};
+			led10 {
+				label = "led10";
+				index = <10>;
+			};
+			led11 {
+				label = "led11";
+				index = <11>;
+			};
+			led12 {
+				label = "led12";
+				index = <12>;
+			};
+			led13 {
+				label = "led13";
+				index = <13>;
+			};
+			led14 {
+				label = "led14";
+				index = <14>;
+			};
+			led15 {
+				label = "led15";
+				index = <15>;
+			};
+
+		};
+
+		led8 {
+		 	 label = "led8";
+                         compatible = "leds-qsp";
+                         reg = <28 0x0 0x1000>;
+
+		 	 linux,default-trigger = "default-on";
+
+			led0 {
+				label = "power";
+				index = <0>;
+				linux,default-trigger = "default-on";
+			};
+			led01 {
+				label = "heartbeat";
+				index = <1>;
+				linux,default-trigger = "heartbeat";
+			};
+			led02 {
+				label = "timer";
+				index = <2>;
+				//linux,default-trigger = "timer";
+			};
+			led03 {
+				label = "cpu0";
+				index = <3>;
+				//linux,default-trigger = "cpu0";
+			};
+			led04 {
+				label = "cpu1";
+				index = <4>;
+				//linux,default-trigger = "cpu1";
+			};
+			led05 {
+				label = "cpu2";
+				index = <5>;
+				//linux,default-trigger = "cpu2";
+			};
+			led06 {
+				label = "cpu3";
+				index = <6>;
+				//linux,default-trigger = "cpu3";
+			};
+			led07 {
+				label = "led07";
+				index = <7>;
+			};
+			led08 {
+				label = "led08";
+				index = <8>;
+			};
+			led09 {
+				label = "led09";
+				index = <9>;
+			};
+			led10 {
+				label = "led10";
+				index = <10>;
+			};
+			led11 {
+				label = "led11";
+				index = <11>;
+			};
+			led12 {
+				label = "led12";
+				index = <12>;
+			};
+			led13 {
+				label = "led13";
+				index = <13>;
+			};
+			led14 {
+				label = "led14";
+				index = <14>;
+			};
+			led15 {
+				label = "led15";
+				index = <15>;
+			};
+
+		};
+
+		led9 {
+		 	 label = "led9";
+                         compatible = "leds-qsp";
+                         reg = <29 0x0 0x1000>;
+
+		 	 linux,default-trigger = "default-on";
+
+			led0 {
+				label = "power";
+				index = <0>;
+				linux,default-trigger = "default-on";
+			};
+			led01 {
+				label = "heartbeat";
+				index = <1>;
+				linux,default-trigger = "heartbeat";
+			};
+			led02 {
+				label = "timer";
+				index = <2>;
+				//linux,default-trigger = "timer";
+			};
+			led03 {
+				label = "cpu0";
+				index = <3>;
+				//linux,default-trigger = "cpu0";
+			};
+			led04 {
+				label = "cpu1";
+				index = <4>;
+				//linux,default-trigger = "cpu1";
+			};
+			led05 {
+				label = "cpu2";
+				index = <5>;
+				//linux,default-trigger = "cpu2";
+			};
+			led06 {
+				label = "cpu3";
+				index = <6>;
+				//linux,default-trigger = "cpu3";
+			};
+			led07 {
+				label = "led07";
+				index = <7>;
+			};
+			led08 {
+				label = "led08";
+				index = <8>;
+			};
+			led09 {
+				label = "led09";
+				index = <9>;
+			};
+			led10 {
+				label = "led10";
+				index = <10>;
+			};
+			led11 {
+				label = "led11";
+				index = <11>;
+			};
+			led12 {
+				label = "led12";
+				index = <12>;
+			};
+			led13 {
+				label = "led13";
+				index = <13>;
+			};
+			led14 {
+				label = "led14";
+				index = <14>;
+			};
+			led15 {
+				label = "led15";
+				index = <15>;
+			};
+
+		};
+
+		led10 {
+		 	 label = "led10";
+                         compatible = "leds-qsp";
+                         reg = <30 0x0 0x1000>;
+
+		 	 linux,default-trigger = "default-on";
+
+			led0 {
+				label = "power";
+				index = <0>;
+				linux,default-trigger = "default-on";
+			};
+			led01 {
+				label = "heartbeat";
+				index = <1>;
+				linux,default-trigger = "heartbeat";
+			};
+			led02 {
+				label = "timer";
+				index = <2>;
+				//linux,default-trigger = "timer";
+			};
+			led03 {
+				label = "cpu0";
+				index = <3>;
+				//linux,default-trigger = "cpu0";
+			};
+			led04 {
+				label = "cpu1";
+				index = <4>;
+				//linux,default-trigger = "cpu1";
+			};
+			led05 {
+				label = "cpu2";
+				index = <5>;
+				//linux,default-trigger = "cpu2";
+			};
+			led06 {
+				label = "cpu3";
+				index = <6>;
+				//linux,default-trigger = "cpu3";
+			};
+			led07 {
+				label = "led07";
+				index = <7>;
+			};
+			led08 {
+				label = "led08";
+				index = <8>;
+			};
+			led09 {
+				label = "led09";
+				index = <9>;
+			};
+			led10 {
+				label = "led10";
+				index = <10>;
+			};
+			led11 {
+				label = "led11";
+				index = <11>;
+			};
+			led12 {
+				label = "led12";
+				index = <12>;
+			};
+			led13 {
+				label = "led13";
+				index = <13>;
+			};
+			led14 {
+				label = "led14";
+				index = <14>;
+			};
+			led15 {
+				label = "led15";
+				index = <15>;
+			};
+
+		};
+
+		led11 {
+		 	 label = "led11";
+                         compatible = "leds-qsp";
+                         reg = <31 0x0 0x1000>;
+
+		 	 linux,default-trigger = "default-on";
+
+			led0 {
+				label = "power";
+				index = <0>;
+				linux,default-trigger = "default-on";
+			};
+			led01 {
+				label = "heartbeat";
+				index = <1>;
+				linux,default-trigger = "heartbeat";
+			};
+			led02 {
+				label = "timer";
+				index = <2>;
+				//linux,default-trigger = "timer";
+			};
+			led03 {
+				label = "cpu0";
+				index = <3>;
+				//linux,default-trigger = "cpu0";
+			};
+			led04 {
+				label = "cpu1";
+				index = <4>;
+				//linux,default-trigger = "cpu1";
+			};
+			led05 {
+				label = "cpu2";
+				index = <5>;
+				//linux,default-trigger = "cpu2";
+			};
+			led06 {
+				label = "cpu3";
+				index = <6>;
+				//linux,default-trigger = "cpu3";
+			};
+			led07 {
+				label = "led07";
+				index = <7>;
+			};
+			led08 {
+				label = "led08";
+				index = <8>;
+			};
+			led09 {
+				label = "led09";
+				index = <9>;
+			};
+			led10 {
+				label = "led10";
+				index = <10>;
+			};
+			led11 {
+				label = "led11";
+				index = <11>;
+			};
+			led12 {
+				label = "led12";
+				index = <12>;
+			};
+			led13 {
+				label = "led13";
+				index = <13>;
+			};
+			led14 {
+				label = "led14";
+				index = <14>;
+			};
+			led15 {
+				label = "led15";
+				index = <15>;
+			};
+
+		};
+
+		led12 {
+		 	 label = "led12";
+                         compatible = "leds-qsp";
+                         reg = <32 0x0 0x1000>;
+
+		 	 linux,default-trigger = "default-on";
+
+			led0 {
+				label = "power";
+				index = <0>;
+				linux,default-trigger = "default-on";
+			};
+			led01 {
+				label = "heartbeat";
+				index = <1>;
+				linux,default-trigger = "heartbeat";
+			};
+			led02 {
+				label = "timer";
+				index = <2>;
+				//linux,default-trigger = "timer";
+			};
+			led03 {
+				label = "cpu0";
+				index = <3>;
+				//linux,default-trigger = "cpu0";
+			};
+			led04 {
+				label = "cpu1";
+				index = <4>;
+				//linux,default-trigger = "cpu1";
+			};
+			led05 {
+				label = "cpu2";
+				index = <5>;
+				//linux,default-trigger = "cpu2";
+			};
+			led06 {
+				label = "cpu3";
+				index = <6>;
+				//linux,default-trigger = "cpu3";
+			};
+			led07 {
+				label = "led07";
+				index = <7>;
+			};
+			led08 {
+				label = "led08";
+				index = <8>;
+			};
+			led09 {
+				label = "led09";
+				index = <9>;
+			};
+			led10 {
+				label = "led10";
+				index = <10>;
+			};
+			led11 {
+				label = "led11";
+				index = <11>;
+			};
+			led12 {
+				label = "led12";
+				index = <12>;
+			};
+			led13 {
+				label = "led13";
+				index = <13>;
+			};
+			led14 {
+				label = "led14";
+				index = <14>;
+			};
+			led15 {
+				label = "led15";
+				index = <15>;
+			};
+
+		};
+
+		led13 {
+		 	 label = "led13";
+                         compatible = "leds-qsp";
+                         reg = <33 0x0 0x1000>;
+
+		 	 linux,default-trigger = "default-on";
+
+			led0 {
+				label = "power";
+				index = <0>;
+				linux,default-trigger = "default-on";
+			};
+			led01 {
+				label = "heartbeat";
+				index = <1>;
+				linux,default-trigger = "heartbeat";
+			};
+			led02 {
+				label = "timer";
+				index = <2>;
+				//linux,default-trigger = "timer";
+			};
+			led03 {
+				label = "cpu0";
+				index = <3>;
+				//linux,default-trigger = "cpu0";
+			};
+			led04 {
+				label = "cpu1";
+				index = <4>;
+				//linux,default-trigger = "cpu1";
+			};
+			led05 {
+				label = "cpu2";
+				index = <5>;
+				//linux,default-trigger = "cpu2";
+			};
+			led06 {
+				label = "cpu3";
+				index = <6>;
+				//linux,default-trigger = "cpu3";
+			};
+			led07 {
+				label = "led07";
+				index = <7>;
+			};
+			led08 {
+				label = "led08";
+				index = <8>;
+			};
+			led09 {
+				label = "led09";
+				index = <9>;
+			};
+			led10 {
+				label = "led10";
+				index = <10>;
+			};
+			led11 {
+				label = "led11";
+				index = <11>;
+			};
+			led12 {
+				label = "led12";
+				index = <12>;
+			};
+			led13 {
+				label = "led13";
+				index = <13>;
+			};
+			led14 {
+				label = "led14";
+				index = <14>;
+			};
+			led15 {
+				label = "led15";
+				index = <15>;
+			};
+
+		};
+
+		led14 {
+		 	 label = "led14";
+                         compatible = "leds-qsp";
+                         reg = <34 0x0 0x1000>;
+
+		 	 linux,default-trigger = "default-on";
+
+			led0 {
+				label = "power";
+				index = <0>;
+				linux,default-trigger = "default-on";
+			};
+			led01 {
+				label = "heartbeat";
+				index = <1>;
+				linux,default-trigger = "heartbeat";
+			};
+			led02 {
+				label = "timer";
+				index = <2>;
+				//linux,default-trigger = "timer";
+			};
+			led03 {
+				label = "cpu0";
+				index = <3>;
+				//linux,default-trigger = "cpu0";
+			};
+			led04 {
+				label = "cpu1";
+				index = <4>;
+				//linux,default-trigger = "cpu1";
+			};
+			led05 {
+				label = "cpu2";
+				index = <5>;
+				//linux,default-trigger = "cpu2";
+			};
+			led06 {
+				label = "cpu3";
+				index = <6>;
+				//linux,default-trigger = "cpu3";
+			};
+			led07 {
+				label = "led07";
+				index = <7>;
+			};
+			led08 {
+				label = "led08";
+				index = <8>;
+			};
+			led09 {
+				label = "led09";
+				index = <9>;
+			};
+			led10 {
+				label = "led10";
+				index = <10>;
+			};
+			led11 {
+				label = "led11";
+				index = <11>;
+			};
+			led12 {
+				label = "led12";
+				index = <12>;
+			};
+			led13 {
+				label = "led13";
+				index = <13>;
+			};
+			led14 {
+				label = "led14";
+				index = <14>;
+			};
+			led15 {
+				label = "led15";
+				index = <15>;
+			};
+
+		};
+
+		led15 {
+		 	 label = "led15";
+                         compatible = "leds-qsp";
+                         reg = <35 0x0 0x1000>;
+
+		 	 linux,default-trigger = "default-on";
+
+			led0 {
+				label = "power";
+				index = <0>;
+				linux,default-trigger = "default-on";
+			};
+			led01 {
+				label = "heartbeat";
+				index = <1>;
+				linux,default-trigger = "heartbeat";
+			};
+			led02 {
+				label = "timer";
+				index = <2>;
+				//linux,default-trigger = "timer";
+			};
+			led03 {
+				label = "cpu0";
+				index = <3>;
+				//linux,default-trigger = "cpu0";
+			};
+			led04 {
+				label = "cpu1";
+				index = <4>;
+				//linux,default-trigger = "cpu1";
+			};
+			led05 {
+				label = "cpu2";
+				index = <5>;
+				//linux,default-trigger = "cpu2";
+			};
+			led06 {
+				label = "cpu3";
+				index = <6>;
+				//linux,default-trigger = "cpu3";
+			};
+			led07 {
+				label = "led07";
+				index = <7>;
+			};
+			led08 {
+				label = "led08";
+				index = <8>;
+			};
+			led09 {
+				label = "led09";
+				index = <9>;
+			};
+			led10 {
+				label = "led10";
+				index = <10>;
+			};
+			led11 {
+				label = "led11";
+				index = <11>;
+			};
+			led12 {
+				label = "led12";
+				index = <12>;
+			};
+			led13 {
+				label = "led13";
+				index = <13>;
+			};
+			led14 {
+				label = "led14";
+				index = <14>;
+			};
+			led15 {
+				label = "led15";
+				index = <15>;
+			};
+
+		};
+
+		ETH0: eth0 {
+			device_type = "eth";
+			compatible = "qsp-mac";
+			reg = <36 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <64 0x1>;
+
+		};
+
+		ETH1: eth1 {
+			device_type = "eth";
+			compatible = "qsp-mac";
+			reg = <37 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <65 0x1>;
+
+		};
+
+		ETH2: eth2 {
+			device_type = "eth";
+			compatible = "qsp-mac";
+			reg = <38 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <66 0x1>;
+
+		};
+
+		ETH3: eth3 {
+			device_type = "eth";
+			compatible = "qsp-mac";
+			reg = <39 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <67 0x1>;
+
+		};
+
+		ETH4: eth4 {
+			device_type = "eth";
+			compatible = "qsp-mac";
+			reg = <40 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <68 0x1>;
+
+		};
+
+		ETH5: eth5 {
+			device_type = "eth";
+			compatible = "qsp-mac";
+			reg = <41 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <69 0x1>;
+
+		};
+
+		ETH6: eth6 {
+			device_type = "eth";
+			compatible = "qsp-mac";
+			reg = <42 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <70 0x1>;
+
+		};
+
+		ETH7: eth7 {
+			device_type = "eth";
+			compatible = "qsp-mac";
+			reg = <43 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <71 0x1>;
+
+		};
+
+		ETH8: eth8 {
+			device_type = "eth";
+			compatible = "qsp-mac";
+			reg = <44 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <72 0x1>;
+
+		};
+
+		ETH9: eth9 {
+			device_type = "eth";
+			compatible = "qsp-mac";
+			reg = <45 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <73 0x1>;
+
+		};
+
+		ETH10: eth10 {
+			device_type = "eth";
+			compatible = "qsp-mac";
+			reg = <46 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <74 0x1>;
+
+		};
+
+		ETH11: eth11 {
+			device_type = "eth";
+			compatible = "qsp-mac";
+			reg = <47 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <75 0x1>;
+
+		};
+
+		ETH12: eth12 {
+			device_type = "eth";
+			compatible = "qsp-mac";
+			reg = <48 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <76 0x1>;
+
+		};
+
+		ETH13: eth13 {
+			device_type = "eth";
+			compatible = "qsp-mac";
+			reg = <49 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <77 0x1>;
+
+		};
+
+		ETH14: eth14 {
+			device_type = "eth";
+			compatible = "qsp-mac";
+			reg = <50 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <78 0x1>;
+
+		};
+
+		ETH15: eth15 {
+			device_type = "eth";
+			compatible = "qsp-mac";
+			reg = <51 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <79 0x1>;
+
+		};
+
+		DISKCTL0: diskctrl0 {
+			device_type = "disk-controller";
+			compatible = "qsp,disk-controller";
+			reg = <52 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <80 0x1>;
+		};
+
+		DISKCTL1: diskctrl1 {
+			device_type = "disk-controller";
+			compatible = "qsp,disk-controller";
+			reg = <53 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <81 0x1>;
+		};
+
+		DISKCTL2: diskctrl2 {
+			device_type = "disk-controller";
+			compatible = "qsp,disk-controller";
+			reg = <54 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <82 0x1>;
+		};
+
+		DISKCTL3: diskctrl3 {
+			device_type = "disk-controller";
+			compatible = "qsp,disk-controller";
+			reg = <55 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <83 0x1>;
+		};
+
+		DISKCTL4: diskctrl4 {
+			device_type = "disk-controller";
+			compatible = "qsp,disk-controller";
+			reg = <56 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <84 0x1>;
+		};
+
+		DISKCTL5: diskctrl5 {
+			device_type = "disk-controller";
+			compatible = "qsp,disk-controller";
+			reg = <57 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <85 0x1>;
+		};
+
+		DISKCTL6: diskctrl6 {
+			device_type = "disk-controller";
+			compatible = "qsp,disk-controller";
+			reg = <58 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <86 0x1>;
+		};
+
+		DISKCTL7: diskctrl7 {
+			device_type = "disk-controller";
+			compatible = "qsp,disk-controller";
+			reg = <59 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <87 0x1>;
+		};
+
+		DISKCTL8: diskctrl8 {
+			device_type = "disk-controller";
+			compatible = "qsp,disk-controller";
+			reg = <60 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <88 0x1>;
+		};
+
+		DISKCTL9: diskctrl9 {
+			device_type = "disk-controller";
+			compatible = "qsp,disk-controller";
+			reg = <61 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <89 0x1>;
+		};
+
+		DISKCTL10: diskctrl10 {
+			device_type = "disk-controller";
+			compatible = "qsp,disk-controller";
+			reg = <62 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <90 0x1>;
+		};
+
+		DISKCTL11: diskctrl11 {
+			device_type = "disk-controller";
+			compatible = "qsp,disk-controller";
+			reg = <63 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <91 0x1>;
+		};
+
+		DISKCTL12: diskctrl12 {
+			device_type = "disk-controller";
+			compatible = "qsp,disk-controller";
+			reg = <64 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <92 0x1>;
+		};
+
+		DISKCTL13: diskctrl13 {
+			device_type = "disk-controller";
+			compatible = "qsp,disk-controller";
+			reg = <65 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <93 0x1>;
+		};
+
+		DISKCTL14: diskctrl14 {
+			device_type = "disk-controller";
+			compatible = "qsp,disk-controller";
+			reg = <66 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <94 0x1>;
+		};
+
+		DISKCTL15: diskctrl15 {
+			device_type = "disk-controller";
+			compatible = "qsp,disk-controller";
+			reg = <67 0x0 0x1000>;
+			interrupt-parent = <&PIC>;
+			interrupts = <95 0x1>;
+		};
+
+	};
+};
diff -ruN linux-3.10/arch/powerpc/boot/Makefile linux-3.10_patched/arch/powerpc/boot/Makefile
--- linux-3.10/arch/powerpc/boot/Makefile	2013-06-30 22:13:29.000000000 +0000
+++ linux-3.10_patched/arch/powerpc/boot/Makefile	2025-06-14 05:48:04.949173245 +0000
@@ -288,6 +288,8 @@
 
 # Board port in arch/powerpc/platform/amigaone/Kconfig
 image-$(CONFIG_AMIGAONE)		+= cuImage.amigaone
+# Board port in arch/powerpc/platform/qsp/Kconfig
+image-$(CONFIG_PPC_QSP)			+= qsp.dtb
 
 # For 32-bit powermacs, build the COFF and miboot images
 # as well as the ELF images.
diff -ruN linux-3.10/arch/powerpc/configs/qsp_defconfig linux-3.10_patched/arch/powerpc/configs/qsp_defconfig
--- linux-3.10/arch/powerpc/configs/qsp_defconfig	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.10_patched/arch/powerpc/configs/qsp_defconfig	2025-06-14 05:48:04.949173245 +0000
@@ -0,0 +1,1363 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/powerpc 3.4.0 Kernel Configuration
+#
+# CONFIG_PPC64 is not set
+
+#
+# Processor support
+#
+CONFIG_PPC_BOOK3S_32=y
+# CONFIG_PPC_85xx is not set
+# CONFIG_PPC_8xx is not set
+# CONFIG_40x is not set
+# CONFIG_44x is not set
+# CONFIG_E200 is not set
+CONFIG_PPC_BOOK3S=y
+CONFIG_6xx=y
+CONFIG_PPC_FPU=y
+# CONFIG_ALTIVEC is not set
+CONFIG_PPC_STD_MMU=y
+CONFIG_PPC_STD_MMU_32=y
+# CONFIG_PPC_MM_SLICES is not set
+CONFIG_PPC_HAVE_PMU_SUPPORT=y
+CONFIG_SMP=y
+CONFIG_NR_CPUS=128
+CONFIG_PPC32=y
+CONFIG_32BIT=y
+CONFIG_WORD_SIZE=32
+# CONFIG_ARCH_PHYS_ADDR_T_64BIT is not set
+# CONFIG_ARCH_DMA_ADDR_T_64BIT is not set
+CONFIG_MMU=y
+CONFIG_GENERIC_CMOS_UPDATE=y
+CONFIG_GENERIC_TIME_VSYSCALL=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+# CONFIG_HAVE_SETUP_PER_CPU_AREA is not set
+# CONFIG_NEED_PER_CPU_EMBED_FIRST_CHUNK is not set
+CONFIG_NR_IRQS=1024
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_ARCH_HAS_ILOG2_U32=y
+CONFIG_ARCH_HAS_CPU_IDLE_WAIT=y
+CONFIG_GENERIC_HWEIGHT=y
+# CONFIG_ARCH_NO_VIRT_TO_BUS is not set
+CONFIG_PPC=y
+CONFIG_EARLY_PRINTK=y
+CONFIG_GENERIC_NVRAM=y
+CONFIG_SCHED_OMIT_FRAME_POINTER=y
+CONFIG_ARCH_MAY_HAVE_PC_FDC=y
+CONFIG_PPC_OF=y
+# CONFIG_PPC_UDBG_16550 is not set
+CONFIG_GENERIC_TBSYNC=y
+CONFIG_AUDIT_ARCH=y
+CONFIG_GENERIC_BUG=y
+# CONFIG_EPAPR_BOOT is not set
+# CONFIG_DEFAULT_UIMAGE is not set
+CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+# CONFIG_PPC_DCR_NATIVE is not set
+# CONFIG_PPC_DCR_MMIO is not set
+CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_HAVE_IRQ_WORK=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE=""
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_DEFAULT_HOSTNAME="(none)"
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_FHANDLE is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+CONFIG_HAVE_GENERIC_HARDIRQS=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_GENERIC_IRQ_SHOW_LEVEL=y
+CONFIG_IRQ_DOMAIN=y
+CONFIG_IRQ_FORCED_THREADING=y
+CONFIG_SPARSE_IRQ=y
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_RCU=y
+# CONFIG_PREEMPT_RCU is not set
+CONFIG_RCU_FANOUT=32
+# CONFIG_RCU_FANOUT_EXACT is not set
+# CONFIG_RCU_FAST_NO_HZ is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_CGROUPS is not set
+# CONFIG_CHECKPOINT_RESTORE is not set
+# CONFIG_NAMESPACES is not set
+# CONFIG_SCHED_AUTOGROUP is not set
+# CONFIG_SYSFS_DEPRECATED is not set
+# CONFIG_RELAY is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_XZ is not set
+# CONFIG_RD_LZO is not set
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_EXPERT=y
+# CONFIG_SYSCTL_SYSCALL is not set
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+# CONFIG_EMBEDDED is not set
+CONFIG_HAVE_PERF_EVENTS=y
+
+#
+# Kernel Performance Events And Counters
+#
+# CONFIG_PERF_EVENTS is not set
+# CONFIG_PERF_COUNTERS is not set
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLUB_DEBUG=y
+CONFIG_COMPAT_BRK=y
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+# CONFIG_JUMP_LABEL is not set
+CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS=y
+CONFIG_HAVE_IOREMAP_PROT=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_ATTRS=y
+CONFIG_USE_GENERIC_SMP_HELPERS=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+CONFIG_HAVE_RCU_TABLE_FREE=y
+CONFIG_ARCH_HAVE_NMI_SAFE_CMPXCHG=y
+CONFIG_QSP=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_HAVE_GENERIC_DMA_COHERENT is not set
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+# CONFIG_MODULE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_BSGLIB is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+# CONFIG_SYSV68_PARTITION is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+CONFIG_DEFAULT_NOOP=y
+CONFIG_DEFAULT_IOSCHED="noop"
+# CONFIG_INLINE_SPIN_TRYLOCK is not set
+# CONFIG_INLINE_SPIN_TRYLOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK is not set
+# CONFIG_INLINE_SPIN_LOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_SPIN_UNLOCK_BH is not set
+CONFIG_INLINE_SPIN_UNLOCK_IRQ=y
+# CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_READ_TRYLOCK is not set
+# CONFIG_INLINE_READ_LOCK is not set
+# CONFIG_INLINE_READ_LOCK_BH is not set
+# CONFIG_INLINE_READ_LOCK_IRQ is not set
+# CONFIG_INLINE_READ_LOCK_IRQSAVE is not set
+CONFIG_INLINE_READ_UNLOCK=y
+# CONFIG_INLINE_READ_UNLOCK_BH is not set
+CONFIG_INLINE_READ_UNLOCK_IRQ=y
+# CONFIG_INLINE_READ_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_WRITE_TRYLOCK is not set
+# CONFIG_INLINE_WRITE_LOCK is not set
+# CONFIG_INLINE_WRITE_LOCK_BH is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQSAVE is not set
+CONFIG_INLINE_WRITE_UNLOCK=y
+# CONFIG_INLINE_WRITE_UNLOCK_BH is not set
+CONFIG_INLINE_WRITE_UNLOCK_IRQ=y
+# CONFIG_INLINE_WRITE_UNLOCK_IRQRESTORE is not set
+CONFIG_MUTEX_SPIN_ON_OWNER=y
+# CONFIG_FREEZER is not set
+# CONFIG_PPC_XICS is not set
+# CONFIG_PPC_ICP_NATIVE is not set
+# CONFIG_PPC_ICP_HV is not set
+# CONFIG_PPC_ICS_RTAS is not set
+# CONFIG_GE_FPGA is not set
+
+#
+# Platform support
+#
+# CONFIG_PPC_CHRP is not set
+# CONFIG_PPC_MPC512x is not set
+# CONFIG_PPC_MPC52xx is not set
+# CONFIG_PPC_PMAC is not set
+# CONFIG_PPC_CELL is not set
+# CONFIG_PPC_CELL_NATIVE is not set
+# CONFIG_PPC_82xx is not set
+# CONFIG_PQ2ADS is not set
+# CONFIG_PPC_83xx is not set
+# CONFIG_PPC_86xx is not set
+# CONFIG_PPC_WSP is not set
+CONFIG_PPC_QSP=y
+# CONFIG_PPC_QSP_SYNC_TIMEBASE is not set
+# CONFIG_KVM_GUEST is not set
+CONFIG_PPC_OF_BOOT_TRAMPOLINE=y
+# CONFIG_IPIC is not set
+# CONFIG_MPIC is not set
+# CONFIG_PPC_EPAPR_HV_PIC is not set
+# CONFIG_MPIC_WEIRD is not set
+# CONFIG_PPC_I8259 is not set
+# CONFIG_PPC_RTAS is not set
+# CONFIG_MMIO_NVRAM is not set
+# CONFIG_MPIC_U3_HT_IRQS is not set
+# CONFIG_PPC_MPC106 is not set
+# CONFIG_PPC_970_NAP is not set
+# CONFIG_PPC_P7_NAP is not set
+
+#
+# CPU Frequency scaling
+#
+# CONFIG_CPU_FREQ is not set
+
+#
+# CPUIdle driver
+#
+# CONFIG_CPU_IDLE is not set
+# CONFIG_TAU is not set
+# CONFIG_FSL_ULI1575 is not set
+# CONFIG_SIMPLE_GPIO is not set
+
+#
+# Kernel options
+#
+CONFIG_HIGHMEM=y
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+# CONFIG_HZ_100 is not set
+CONFIG_HZ_250=y
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=250
+CONFIG_SCHED_HRTICK=y
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
+# CONFIG_PREEMPT is not set
+CONFIG_BINFMT_ELF=y
+CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS=y
+# CONFIG_HAVE_AOUT is not set
+CONFIG_BINFMT_MISC=y
+# CONFIG_IOMMU_HELPER is not set
+# CONFIG_SWIOTLB is not set
+CONFIG_ARCH_ENABLE_MEMORY_HOTPLUG=y
+CONFIG_ARCH_HAS_WALK_MEMORY=y
+CONFIG_ARCH_ENABLE_MEMORY_HOTREMOVE=y
+# CONFIG_KEXEC is not set
+# CONFIG_CRASH_DUMP is not set
+# CONFIG_IRQ_ALL_CPUS is not set
+CONFIG_MAX_ACTIVE_REGIONS=32
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_HAVE_MEMBLOCK_NODE_MAP=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_COMPACTION is not set
+CONFIG_MIGRATION=y
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_BOUNCE=y
+CONFIG_VIRT_TO_BUS=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+# CONFIG_CLEANCACHE is not set
+CONFIG_PPC_4K_PAGES=y
+CONFIG_FORCE_MAX_ZONEORDER=11
+CONFIG_CMDLINE_BOOL=y
+CONFIG_CMDLINE="console=ttyS0,115200"
+CONFIG_EXTRA_TARGETS=""
+# CONFIG_HIBERNATION is not set
+# CONFIG_PM_RUNTIME is not set
+# CONFIG_SECCOMP is not set
+# CONFIG_ISA_DMA_API is not set
+
+#
+# Bus options
+#
+CONFIG_ZONE_DMA=y
+# CONFIG_NEED_DMA_MAP_STATE is not set
+CONFIG_NEED_SG_DMA_LENGTH=y
+# CONFIG_PCI is not set
+# CONFIG_PCI_DOMAINS is not set
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+# CONFIG_HAS_RAPIDIO is not set
+# CONFIG_NONSTATIC_KERNEL is not set
+
+#
+# Advanced setup
+#
+# CONFIG_ADVANCED_OPTIONS is not set
+
+#
+# Default settings for advanced configuration options are used
+#
+CONFIG_LOWMEM_SIZE=0x30000000
+CONFIG_PAGE_OFFSET=0xc0000000
+CONFIG_KERNEL_START=0xc0000000
+CONFIG_PHYSICAL_START=0x00000000
+CONFIG_TASK_SIZE=0xc0000000
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+# CONFIG_UNIX_DIAG is not set
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=y
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE_DEMUX is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+CONFIG_SYN_COOKIES=y
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+# CONFIG_INET_LRO is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_INET_UDP_DIAG is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+# CONFIG_BATMAN_ADV is not set
+# CONFIG_OPENVSWITCH is not set
+CONFIG_RPS=y
+CONFIG_RFS_ACCEL=y
+CONFIG_XPS=y
+CONFIG_BQL=y
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+# CONFIG_WIRELESS is not set
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+# CONFIG_NFC is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_GENERIC_CPU_DEVICES is not set
+# CONFIG_DMA_SHARED_BUFFER is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_TESTS is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+CONFIG_MTD_OF_PARTS=y
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+# CONFIG_MTD_BLOCK is not set
+# CONFIG_MTD_BLOCK_RO is not set
+CONFIG_FTL=y
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_SM_FTL is not set
+# CONFIG_MTD_OOPS is not set
+# CONFIG_MTD_SWAP is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+CONFIG_MTD_QSP_FLASH=y
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+CONFIG_MTD_PHYSMAP=y
+# CONFIG_MTD_PHYSMAP_COMPAT is not set
+CONFIG_MTD_PHYSMAP_OF=y
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOCG3 is not set
+# CONFIG_MTD_NAND is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# LPDDR flash memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+CONFIG_MTD_UBI=y
+CONFIG_MTD_UBI_WL_THRESHOLD=4096
+CONFIG_MTD_UBI_BEB_RESERVE=1
+# CONFIG_MTD_UBI_GLUEBI is not set
+# CONFIG_MTD_UBI_DEBUG is not set
+CONFIG_DTC=y
+CONFIG_OF=y
+
+#
+# Device Tree and Open Firmware support
+#
+CONFIG_PROC_DEVICETREE=y
+# CONFIG_OF_SELFTEST is not set
+CONFIG_OF_FLATTREE=y
+CONFIG_OF_EARLY_FLATTREE=y
+CONFIG_OF_ADDRESS=y
+CONFIG_OF_IRQ=y
+CONFIG_OF_DEVICE=y
+CONFIG_OF_NET=y
+CONFIG_OF_MTD=y
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_LOOP_MIN_COUNT=8
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+
+#
+# DRBD disabled because PROC_FS, INET or CONNECTOR not selected
+#
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=131072
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_BLK_DEV_HD is not set
+# CONFIG_BLK_DEV_RBD is not set
+CONFIG_BLK_DEV_QSP=y
+
+#
+# Misc devices
+#
+# CONFIG_SENSORS_LIS3LV02D is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_93CX6 is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+
+#
+# Altera FPGA firmware download module
+#
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_ISCSI_BOOT_SYSFS is not set
+# CONFIG_LIBFC is not set
+# CONFIG_LIBFCOE is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+CONFIG_ATA=y
+# CONFIG_ATA_NONSTANDARD is not set
+CONFIG_ATA_VERBOSE_ERROR=y
+CONFIG_SATA_PMP=y
+
+#
+# Controllers with non-SFF native interface
+#
+# CONFIG_SATA_AHCI_PLATFORM is not set
+CONFIG_ATA_SFF=y
+
+#
+# SFF controllers with custom DMA interface
+#
+CONFIG_ATA_BMDMA=y
+
+#
+# SATA SFF controllers with BMDMA
+#
+# CONFIG_SATA_MV is not set
+
+#
+# PATA SFF controllers with BMDMA
+#
+
+#
+# PIO-only SFF controllers
+#
+# CONFIG_PATA_PLATFORM is not set
+
+#
+# Generic fallback / legacy drivers
+#
+# CONFIG_MD is not set
+# CONFIG_TARGET_CORE is not set
+# CONFIG_MACINTOSH_DRIVERS is not set
+CONFIG_NETDEVICES=y
+CONFIG_NET_CORE=y
+# CONFIG_BONDING is not set
+# CONFIG_DUMMY is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_MII is not set
+# CONFIG_NET_TEAM is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+
+#
+# CAIF transport drivers
+#
+CONFIG_ETHERNET=y
+# CONFIG_NET_VENDOR_BROADCOM is not set
+# CONFIG_NET_CALXEDA_XGMAC is not set
+# CONFIG_NET_VENDOR_CHELSIO is not set
+# CONFIG_DNET is not set
+# CONFIG_NET_VENDOR_INTEL is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
+# CONFIG_ETHOC is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+# CONFIG_NET_VENDOR_STMICRO is not set
+# CONFIG_NET_VENDOR_XILINX is not set
+CONFIG_NET_QSP=y
+# CONFIG_PHYLIB is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_WLAN is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+# CONFIG_WAN is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+# CONFIG_INPUT_SPARSEKMAP is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_N_GSM is not set
+# CONFIG_TRACE_SINK is not set
+# CONFIG_PPC_EPAPR_HV_BYTECHAN is not set
+CONFIG_DEVKMEM=y
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_UARTLITE is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_TIMBERDALE is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_XILINX_PS_UART is not set
+CONFIG_SERIAL_QSP_UART=y
+CONFIG_SERIAL_QSP_MAXPORTS=16
+CONFIG_SERIAL_QSP_CONSOLE=y
+# CONFIG_TTY_PRINTK is not set
+# CONFIG_HVC_UDBG is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_NVRAM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_RAMOOPS is not set
+# CONFIG_I2C is not set
+# CONFIG_SPI is not set
+# CONFIG_HSI is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+
+#
+# Enable Device Drivers -> PPS to see the PTP clock options.
+#
+CONFIG_ARCH_WANT_OPTIONAL_GPIOLIB=y
+# CONFIG_GPIOLIB is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Native drivers
+#
+# CONFIG_SENSORS_NTC_THERMISTOR is not set
+# CONFIG_SENSORS_SCH56XX_COMMON is not set
+# CONFIG_THERMAL is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+
+#
+# Broadcom specific AMBA
+#
+# CONFIG_BCMA is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+# CONFIG_DRM is not set
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+# CONFIG_FB is not set
+# CONFIG_EXYNOS_VIDEO is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+# CONFIG_SOUND is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+# CONFIG_HIDRAW is not set
+# CONFIG_HID_PID is not set
+
+#
+# Special HID drivers
+#
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+# CONFIG_USB_ARCH_HAS_XHCI is not set
+# CONFIG_USB_SUPPORT is not set
+# CONFIG_MMC is not set
+# CONFIG_MEMSTICK is not set
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+
+#
+# LED drivers
+#
+# CONFIG_LEDS_OT200 is not set
+CONFIG_LEDS_QSP=y
+CONFIG_LEDS_TRIGGERS=y
+
+#
+# LED Triggers
+#
+CONFIG_LEDS_TRIGGER_TIMER=y
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+# CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
+CONFIG_LEDS_TRIGGER_DEFAULT_ON=y
+
+#
+# iptables trigger is under Netfilter config (LED target)
+#
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_EDAC is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# SPI RTC drivers
+#
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_RTC_DRV_GENERIC is not set
+CONFIG_RTC_DRV_QSP=y
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+
+#
+# Virtio drivers
+#
+# CONFIG_VIRTIO_BALLOON is not set
+# CONFIG_VIRTIO_MMIO is not set
+
+#
+# Microsoft Hyper-V guest support
+#
+# CONFIG_STAGING is not set
+
+#
+# Hardware Spinlock drivers
+#
+# CONFIG_CLK_QSP is not set
+CONFIG_IOMMU_SUPPORT=y
+
+#
+# Remoteproc drivers (EXPERIMENTAL)
+#
+
+#
+# Rpmsg drivers (EXPERIMENTAL)
+#
+# CONFIG_VIRT_DRIVERS is not set
+# CONFIG_PM_DEVFREQ is not set
+CONFIG_PIC_SUPPORT=y
+CONFIG_QSP_PIC=y
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_DEFAULTS_TO_ORDERED=y
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+# CONFIG_EXT4_FS is not set
+CONFIG_JBD=y
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_FANOTIFY is not set
+# CONFIG_QUOTA is not set
+# CONFIG_QUOTACTL is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_TMPFS_XATTR is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=m
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+# CONFIG_JFFS2_LZO is not set
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_UBIFS_FS=m
+# CONFIG_UBIFS_FS_XATTR is not set
+# CONFIG_UBIFS_FS_ADVANCED_COMPR is not set
+CONFIG_UBIFS_FS_LZO=y
+CONFIG_UBIFS_FS_ZLIB=y
+# CONFIG_UBIFS_FS_DEBUG is not set
+# CONFIG_LOGFS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX6FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_PSTORE is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_SIMICSFS=y
+CONFIG_SIMICSFS_ADDRESS="0xe0200000"
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+# CONFIG_NFS_V3 is not set
+# CONFIG_NFS_V4 is not set
+CONFIG_ROOT_NFS=y
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_SUNRPC_DEBUG is not set
+# CONFIG_CEPH_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+# CONFIG_NLS is not set
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_IO=y
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC16=m
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC32_SELFTEST is not set
+CONFIG_CRC32_SLICEBY8=y
+# CONFIG_CRC32_SLICEBY4 is not set
+# CONFIG_CRC32_SARWATE is not set
+# CONFIG_CRC32_BIT is not set
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+# CONFIG_CRC8 is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=m
+CONFIG_LZO_COMPRESS=m
+CONFIG_LZO_DECOMPRESS=m
+# CONFIG_XZ_DEC is not set
+# CONFIG_XZ_DEC_BCJ is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_CPU_RMAP=y
+CONFIG_DQL=y
+CONFIG_NLATTR=y
+CONFIG_GENERIC_ATOMIC64=y
+# CONFIG_AVERAGE is not set
+# CONFIG_CORDIC is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_DEFAULT_MESSAGE_LOGLEVEL=4
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+# CONFIG_LOCKUP_DETECTOR is not set
+# CONFIG_HARDLOCKUP_DETECTOR is not set
+# CONFIG_DETECT_HUNG_TASK is not set
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_SLUB_DEBUG_ON is not set
+# CONFIG_SLUB_STATS is not set
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_SPARSE_RCU_POINTER is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_KOBJECT is not set
+# CONFIG_DEBUG_HIGHMEM is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_INFO_REDUCED is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+CONFIG_RCU_CPU_STALL_TIMEOUT=60
+# CONFIG_RCU_CPU_STALL_INFO is not set
+# CONFIG_RCU_TRACE is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# CONFIG_DEBUG_PER_CPU_MAPS is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_TRACING_SUPPORT=y
+CONFIG_FTRACE=y
+# CONFIG_FUNCTION_TRACER is not set
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_ENABLE_DEFAULT_TRACERS is not set
+# CONFIG_FTRACE_SYSCALLS is not set
+CONFIG_BRANCH_PROFILE_NONE=y
+# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
+# CONFIG_PROFILE_ALL_BRANCHES is not set
+# CONFIG_STACK_TRACER is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_PPC_DISABLE_WERROR is not set
+CONFIG_PPC_WERROR=y
+CONFIG_PRINT_STACK_DEPTH=64
+# CONFIG_DEBUG_STACKOVERFLOW is not set
+# CONFIG_CODE_PATCHING_SELFTEST is not set
+# CONFIG_FTR_FIXUP_SELFTEST is not set
+# CONFIG_MSI_BITMAP_SELFTEST is not set
+CONFIG_XMON=y
+CONFIG_XMON_DEFAULT=y
+CONFIG_XMON_DISASSEMBLY=y
+CONFIG_DEBUGGER=y
+# CONFIG_BDI_SWITCH is not set
+# CONFIG_BOOTX_TEXT is not set
+CONFIG_PPC_EARLY_DEBUG=y
+CONFIG_STRICT_DEVMEM=y
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+# CONFIG_CRYPTO_FIPS is not set
+CONFIG_CRYPTO_ALGAPI=m
+CONFIG_CRYPTO_ALGAPI2=m
+CONFIG_CRYPTO_RNG=m
+CONFIG_CRYPTO_RNG2=m
+# CONFIG_CRYPTO_MANAGER is not set
+# CONFIG_CRYPTO_MANAGER2 is not set
+# CONFIG_CRYPTO_USER is not set
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_PCRYPT is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+# CONFIG_CRYPTO_CBC is not set
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_MD4 is not set
+# CONFIG_CRYPTO_MD5 is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=m
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=m
+# CONFIG_CRYPTO_ZLIB is not set
+CONFIG_CRYPTO_LZO=m
+
+#
+# Random Number Generation
+#
+CONFIG_CRYPTO_ANSI_CPRNG=m
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+CONFIG_CRYPTO_HW=y
+# CONFIG_PPC_CLOCK is not set
+# CONFIG_VIRTUALIZATION is not set
diff -ruN linux-3.10/arch/powerpc/Kconfig linux-3.10_patched/arch/powerpc/Kconfig
--- linux-3.10/arch/powerpc/Kconfig	2013-06-30 22:13:29.000000000 +0000
+++ linux-3.10_patched/arch/powerpc/Kconfig	2025-06-14 05:48:04.945173245 +0000
@@ -732,7 +732,8 @@
 config PCI
 	bool "PCI support" if PPC_PCI_CHOICE
 	default y if !40x && !CPM2 && !8xx && !PPC_83xx \
-		&& !PPC_85xx && !PPC_86xx && !GAMECUBE_COMMON
+		&& !PPC_85xx && !PPC_86xx && !GAMECUBE_COMMON \
+                && !PPC_QSP
 	default PCI_QSPAN if !4xx && !CPM2 && 8xx
 	select ARCH_SUPPORTS_MSI
 	select GENERIC_PCI_IOMAP
diff -ruN linux-3.10/arch/powerpc/kernel/idle.c linux-3.10_patched/arch/powerpc/kernel/idle.c
--- linux-3.10/arch/powerpc/kernel/idle.c	2013-06-30 22:13:29.000000000 +0000
+++ linux-3.10_patched/arch/powerpc/kernel/idle.c	2025-06-14 05:48:04.949173245 +0000
@@ -78,8 +78,14 @@
 	HMT_medium();
 	ppc64_runlatch_on();
 }
-
+#ifdef CONFIG_QSP
+/* Enabling powersave early makes a huge difference for
+ * SMP boot speed on simulated systems.
+ */
+int powersave_nap = 1;
+#else
 int powersave_nap;
+#endif
 
 #ifdef CONFIG_SYSCTL
 /*
diff -ruN linux-3.10/arch/powerpc/kernel/time.c linux-3.10_patched/arch/powerpc/kernel/time.c
--- linux-3.10/arch/powerpc/kernel/time.c	2013-06-30 22:13:29.000000000 +0000
+++ linux-3.10_patched/arch/powerpc/kernel/time.c	2025-06-14 05:48:04.949173245 +0000
@@ -726,7 +726,21 @@
 
 static cycle_t timebase_read(struct clocksource *cs)
 {
+#ifdef CONFIG_QSP
+       /* FIXME: This is strange, I would think that this was equivalent to
+        * timebase_mode = fast-forward in simics.
+        * However, this seems to work, fast-forward doesnt....
+        *
+        * FIXME: This is not wrap-around proof. 2^64 for the default timebase
+        *      frequency (1Ghz/8) is 4679 years, however that might happen
+        *      with hypersim and NO_HZ. However I intend to analyze this
+        *      further and figure out why Simics itself can't provide this
+        *      functionality...
+        */
+       return max_t(cycle_t, cs->cycle_last, (cycle_t)get_tb());
+#else
 	return (cycle_t)get_tb();
+#endif
 }
 
 void update_vsyscall_old(struct timespec *wall_time, struct timespec *wtm,
diff -ruN linux-3.10/arch/powerpc/platforms/Kconfig linux-3.10_patched/arch/powerpc/platforms/Kconfig
--- linux-3.10/arch/powerpc/platforms/Kconfig	2013-06-30 22:13:29.000000000 +0000
+++ linux-3.10_patched/arch/powerpc/platforms/Kconfig	2025-06-14 05:48:04.949173245 +0000
@@ -20,6 +20,7 @@
 source "arch/powerpc/platforms/40x/Kconfig"
 source "arch/powerpc/platforms/amigaone/Kconfig"
 source "arch/powerpc/platforms/wsp/Kconfig"
+source "arch/powerpc/platforms/qsp/Kconfig"
 
 config KVM_GUEST
 	bool "KVM Guest support"
diff -ruN linux-3.10/arch/powerpc/platforms/Makefile linux-3.10_patched/arch/powerpc/platforms/Makefile
--- linux-3.10/arch/powerpc/platforms/Makefile	2013-06-30 22:13:29.000000000 +0000
+++ linux-3.10_patched/arch/powerpc/platforms/Makefile	2025-06-14 05:48:04.949173245 +0000
@@ -23,3 +23,4 @@
 obj-$(CONFIG_EMBEDDED6xx)	+= embedded6xx/
 obj-$(CONFIG_AMIGAONE)		+= amigaone/
 obj-$(CONFIG_PPC_WSP)		+= wsp/
+obj-$(CONFIG_PPC_QSP)		+= qsp/
diff -ruN linux-3.10/arch/powerpc/platforms/qsp/head_smp.S linux-3.10_patched/arch/powerpc/platforms/qsp/head_smp.S
--- linux-3.10/arch/powerpc/platforms/qsp/head_smp.S	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.10_patched/arch/powerpc/platforms/qsp/head_smp.S	2025-06-14 05:48:04.949173245 +0000
@@ -0,0 +1,26 @@
+
+/* This is instead of a bootloader...
+ */
+#include <asm/ppc_asm.h>
+#include <asm/reg.h>
+
+#define CPU_ID_REG 0xe0001010
+
+	.text
+	.global __secondary_start_qsp
+__secondary_start_qsp:
+	/* Enable timebase. Normally done in u-boot and will be done later
+	 * when we restore cpu context from core 0, but it doesn't
+	 * hurt to do it here since there might be some delays early on.
+	 */
+	mfspr	r11, SPRN_HID0
+	oris	r11,r11,HID0_TBEN@ha
+	mtspr	SPRN_HID0, r11
+
+	/* Fetch cpu id from sysregs and pass it on to generic code. */
+	lis	r3,CPU_ID_REG@ha
+	addi	r4,r3,CPU_ID_REG@l
+	lwbrx   r3,r5,r4 /* in wrong endian... */
+	stw	r3, __secondary_hold_acknowledge@l(0)
+	mr	r24, r3			/* cpu # */
+	b	__secondary_start
diff -ruN linux-3.10/arch/powerpc/platforms/qsp/Kconfig linux-3.10_patched/arch/powerpc/platforms/qsp/Kconfig
--- linux-3.10/arch/powerpc/platforms/qsp/Kconfig	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.10_patched/arch/powerpc/platforms/qsp/Kconfig	2025-06-14 05:48:04.949173245 +0000
@@ -0,0 +1,18 @@
+config PPC_QSP
+	bool "Simics QSP for PPC"
+	default n
+	select QSP
+	select QSP_PIC
+	help
+	  This option enables support for the QSP simics platform for PowerPC.
+
+config PPC_QSP_SYNC_TIMEBASE
+	bool "Manual sync of timebase between cores"
+	default n
+	depends on PPC_QSP && SMP
+	help
+	  This option enables generic code for manually syncing the timebase between cores
+	  on startup for SMP systems. This is very time consuming and will not yield perfect
+	  results anyway since simics runs each cores time slice in serial. When a core
+	  is enabled via the sysregs it's timebase is copied from core 0 which yields a good
+	  enough sync and a speedy boot so you can safely leave this option to N.
diff -ruN linux-3.10/arch/powerpc/platforms/qsp/Makefile linux-3.10_patched/arch/powerpc/platforms/qsp/Makefile
--- linux-3.10/arch/powerpc/platforms/qsp/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.10_patched/arch/powerpc/platforms/qsp/Makefile	2025-06-14 05:48:04.949173245 +0000
@@ -0,0 +1,4 @@
+obj-$(CONFIG_PPC_QSP)				+= setup.o
+obj-$(CONFIG_SMP)				+= smp.o head_smp.o
+
+
diff -ruN linux-3.10/arch/powerpc/platforms/qsp/setup.c linux-3.10_patched/arch/powerpc/platforms/qsp/setup.c
--- linux-3.10/arch/powerpc/platforms/qsp/setup.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.10_patched/arch/powerpc/platforms/qsp/setup.c	2025-06-14 05:48:04.949173245 +0000
@@ -0,0 +1,91 @@
+/*
+ * QSP PPC setup and early boot code plus other random bits.
+ *
+ * Copyright 2011 Wind River
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <asm/udbg.h>
+#include <linux/kernel.h>
+#include <asm/machdep.h>
+#include <linux/of_platform.h>
+#include <linux/qsp/qsp_pic.h>
+
+#include "smp.h"
+#include <linux/delay.h>
+
+static int __init declare_of_platform_devices(void)
+{
+	of_platform_populate(NULL, of_default_bus_match_table, NULL, NULL);
+	return 0;
+}
+machine_device_initcall(qsp, declare_of_platform_devices);
+
+#define SOFT_RESET_REG 0x48
+
+/*
+ * Reset the system. It is called by machine_restart().
+ */
+void qsp_restart(char *cmd)
+{
+        static void __iomem *sysregs_base;
+        struct device_node *np;
+        np = of_find_node_by_type(NULL, "sysregs");
+        BUG_ON(np == NULL);
+
+        sysregs_base = of_iomap(np, 0);
+        BUG_ON(sysregs_base == 0);
+
+        // write reset register
+        writel(1, sysregs_base + SOFT_RESET_REG);
+
+        mdelay(500);
+}
+
+static void __init qsp_setup_arch(void)
+{
+	pr_info("QSP setup arch.");
+#ifdef CONFIG_SMP
+	qsp_smp_init();
+#endif
+}
+
+static void qsp_show_cpuinfo(struct seq_file *m)
+{
+	seq_printf(m, "machine\t\t: qsp-ppc\n");
+}
+
+/*
+ * Called very early, device-tree isn't unflattened
+ */
+static int __init qsp_probe(void)
+{
+	unsigned long root = of_get_flat_dt_root();
+	pr_debug("Probe QSP\n");
+	return of_flat_dt_is_compatible(root, "simics,qsp-ppc");
+}
+
+static void __init qsp_init_early(void)
+{
+	pr_info("QSP early init\n");
+#ifdef CONFIG_SMP
+	qsp_smp_early_init();
+#endif
+}
+
+define_machine(qsp) {
+	.name			= "QSP PPC",
+	.probe			= qsp_probe,
+	.init_early             = qsp_init_early,
+	.setup_arch		= qsp_setup_arch,
+	.init_IRQ		= qsp_pic_init,
+	.show_cpuinfo		= qsp_show_cpuinfo,
+	.get_irq		= qsp_pic_get_irq,
+	.calibrate_decr		= generic_calibrate_decr,
+        .restart                = qsp_restart,
+};
+
diff -ruN linux-3.10/arch/powerpc/platforms/qsp/smp.c linux-3.10_patched/arch/powerpc/platforms/qsp/smp.c
--- linux-3.10/arch/powerpc/platforms/qsp/smp.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.10_patched/arch/powerpc/platforms/qsp/smp.c	2025-06-14 05:48:04.949173245 +0000
@@ -0,0 +1,103 @@
+#include <linux/smp.h>
+#include <linux/kernel.h>
+#include <linux/of.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <linux/qsp/qsp_pic.h>
+
+#include "smp.h"
+
+#define ID_REG	       0x00
+#define ENABLE_REG     0x04
+#define DISABLE_REG    0x08
+#define BOOT_PC_REG    0x0c
+#define CPU_STATUS_REG 0x14
+#define PROBE_REG      0x18
+
+#define QSP_MAX_CPUS 128
+
+static void __iomem *sysregs_base;
+
+/* For QSP-PPC The default dtb is populated with all possible cpus (i.e 128)
+ * since there is no bootloader competent enough to create the exact dtb.
+ *
+ * We probe sysregs early to find out how many is actually present so the
+ * cpu_possible map setup in setup-common.c is not larger than needed.
+ */
+static void __init qsp_setup_max_cpus(void)
+{
+	int hw_cpu;
+	int possible = 0;
+
+	for (hw_cpu = 0; hw_cpu < QSP_MAX_CPUS; hw_cpu++) {
+		writel(hw_cpu, sysregs_base + PROBE_REG);
+		if (readl(sysregs_base + CPU_STATUS_REG) != 1) {
+			pr_debug(KERN_INFO "Probe cpu:%d not present.", hw_cpu);
+		} else {
+			possible++;
+			pr_debug(KERN_INFO "Probe cpu:%d present.", hw_cpu);
+		}
+	}
+	pr_info("QSP found %d possible cpus from probing sysregs.", possible);
+	pr_info(" previoud maxcpus %d\n", setup_max_cpus);
+	if (possible < setup_max_cpus) {
+		pr_info(" adjusting maxcpus from %d down to %d\n",
+			setup_max_cpus, possible);
+		setup_max_cpus = possible;
+	}
+}
+
+static int __init smp_qsp_kick_cpu(int nr)
+{
+	int n;
+	int hw_cpu = get_hard_smp_processor_id(nr);
+
+	BUG_ON(sysregs_base == NULL);
+
+	writel(__pa(__secondary_start_qsp), sysregs_base + BOOT_PC_REG);
+	writel(hw_cpu, sysregs_base + ENABLE_REG);
+	if (readl(sysregs_base + CPU_STATUS_REG) != 1) {
+		printk(KERN_INFO "cpu:%d not present.", hw_cpu);
+		return -EINVAL;
+	}
+
+	n = 0;
+	/* Wait a bit for the CPU to ack. */
+	while ((__secondary_hold_acknowledge != hw_cpu) && (++n < 1000))
+		mdelay(1);
+
+	if (__secondary_hold_acknowledge != hw_cpu) {
+		printk(KERN_WARNING "cpu:%d stuck (post %08lx)\n", nr,
+		       __secondary_hold_acknowledge);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static struct smp_ops_t smp_qsp_ops = {
+	.kick_cpu       = smp_qsp_kick_cpu,
+	.message_pass   = qsp_pic_message_pass,
+	.probe          = smp_qsp_pic_probe,
+	.setup_cpu	= smp_qsp_pic_setup_cpu,
+#ifdef CONFIG_PPC_QSP_SYNC_TIMEBASE
+	.take_timebase  = smp_generic_take_timebase,
+	.give_timebase  = smp_generic_give_timebase,
+#endif
+};
+
+void __init qsp_smp_init(void)
+{
+	pr_info("QSP smp  init\n");
+}
+
+void __init qsp_smp_early_init(void)
+{
+	struct device_node *np;
+	pr_info("QSP smp early init\n");
+	np = of_find_node_by_type(NULL, "sysregs");
+	if (np)
+		sysregs_base = of_iomap(np, 0);
+	qsp_setup_max_cpus();
+	smp_ops = &smp_qsp_ops;
+}
diff -ruN linux-3.10/arch/powerpc/platforms/qsp/smp.h linux-3.10_patched/arch/powerpc/platforms/qsp/smp.h
--- linux-3.10/arch/powerpc/platforms/qsp/smp.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.10_patched/arch/powerpc/platforms/qsp/smp.h	2025-06-14 05:48:04.949173245 +0000
@@ -0,0 +1,17 @@
+/*
+ * Copyright 2012 Wind River
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#ifndef __QSP_SMP_H
+#define __QSP_SMP_H
+
+void qsp_smp_init(void);
+void qsp_smp_early_init(void);
+extern void __secondary_start_qsp(void);
+
+#endif
diff -ruN linux-3.10/Documentation/qsp/qsp.txt linux-3.10_patched/Documentation/qsp/qsp.txt
--- linux-3.10/Documentation/qsp/qsp.txt	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.10_patched/Documentation/qsp/qsp.txt	2025-06-14 05:48:04.949173245 +0000
@@ -0,0 +1,7 @@
+Simics QSP
+==========
+
+The QSP boards are pure virtual boards for the Wind River Simics (tm) system
+simulator. They serve as demonstration/example boards. The intention is to keep the Linux port as simple and elegant as possible, while maintaining code reuse across all major architectures.
+
+The devices on these boards are designed for simplicity first and perfomance second.
diff -ruN linux-3.10/drivers/block/Kconfig linux-3.10_patched/drivers/block/Kconfig
--- linux-3.10/drivers/block/Kconfig	2013-06-30 22:13:29.000000000 +0000
+++ linux-3.10_patched/drivers/block/Kconfig	2025-06-14 05:48:04.969173245 +0000
@@ -541,4 +541,11 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called rsxx.
 
+config BLK_DEV_QSP
+	tristate "QSP block device"
+	default y if QSP
+	 help
+	   Say Y here if you want include support the QSP disk controller,
+	   found on Simics virtual QSP boards.
+
 endif # BLK_DEV
diff -ruN linux-3.10/drivers/block/Makefile linux-3.10_patched/drivers/block/Makefile
--- linux-3.10/drivers/block/Makefile	2013-06-30 22:13:29.000000000 +0000
+++ linux-3.10_patched/drivers/block/Makefile	2025-06-14 05:48:04.969173245 +0000
@@ -39,6 +39,7 @@
 obj-$(CONFIG_BLK_DEV_DRBD)     += drbd/
 obj-$(CONFIG_BLK_DEV_RBD)     += rbd.o
 obj-$(CONFIG_BLK_DEV_PCIESSD_MTIP32XX)	+= mtip32xx/
+obj-$(CONFIG_BLK_DEV_QSP)     += qsp_blk.o
 
 obj-$(CONFIG_BLK_DEV_RSXX) += rsxx/
 
diff -ruN linux-3.10/drivers/block/qsp_blk.c linux-3.10_patched/drivers/block/qsp_blk.c
--- linux-3.10/drivers/block/qsp_blk.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.10_patched/drivers/block/qsp_blk.c	2025-06-14 05:48:04.969173245 +0000
@@ -0,0 +1,372 @@
+/*
+ * QSP disk controller
+ *
+ * Based on ps3disk.c, xen-blkfront.c and the example block driver in ldd.
+ *
+ * (C) Copyright 2012, Ivar Holmqvist <ivarholmqvist@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+#undef DEBUG
+
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/hdreg.h>
+#include <linux/genhd.h>
+#include <linux/blkdev.h>
+#include <linux/bio.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/interrupt.h>
+
+#include <linux/qsp/qsp.h>
+
+#define MINOR_SHIFT     4
+#define QSP_BLK_MINORS	(1<<MINOR_SHIFT)
+#define QSP_BLK_MAJOR	99
+#define DEVICE_NAME	"qspblk"
+#define QSP_DISK_NAME	"qspd"
+#define QSP_BLK_SIZE	512
+
+/* Commands */
+#define QSP_BLK_CMD_READ  0x101
+#define QSP_BLK_CMD_WRITE 0x102
+#define QSP_BLK_CMD_SENSE 0x103
+
+/* Registers */
+#define ID            0x00
+#define STATUS        0x04
+#define CONTROL       0x08
+#define CMD           0x0C
+#define CMD_RESPONSE  0x10
+#define BLOCK         0x14
+#define PADDR         0x18
+
+
+/* Status Register Bits */
+#define STATUS_CMD_COMPLETE (1<<0)
+#define STATUS_CHANN_ERR    (1<<1)
+#define STATUS_SEEK_ERR     (1<<2)
+#define STATUS_DMA_ERR      (1<<3)
+#define STATUS_DISK_PRESENT (1<<4)
+
+/* Control Register Bits */
+#define CONTROL_IE   (1<<0)
+
+static atomic_t usage_count = ATOMIC_INIT(0);
+
+static int qsp_getgeo(struct block_device *bd, struct hd_geometry *hg)
+{
+	/* We don't have real geometry info, but let's at least return
+	 * values consistent with the size of the device
+	 */
+	sector_t nsect = get_capacity(bd->bd_disk);
+	sector_t cylinders = nsect;
+
+	hg->heads = 0xff;
+	hg->sectors = 0x3f;
+	sector_div(cylinders, hg->heads * hg->sectors);
+	hg->cylinders = cylinders;
+	if ((sector_t)(hg->cylinders + 1) * hg->heads * hg->sectors < nsect)
+		hg->cylinders = 0xffff;
+	return 0;
+}
+/*
+ * The device operations structure.
+ */
+static const struct block_device_operations qsp_blk_ops = {
+	.owner   = THIS_MODULE,
+	.getgeo  = qsp_getgeo,
+};
+
+struct qsp_blk {
+	struct platform_device *ofdev;
+	struct gendisk *gd;
+	struct request_queue *queue;
+	int idx;
+	u64 size;
+	unsigned int irq;
+	void __iomem *base;
+};
+
+static void qsp_blk_write_register(struct qsp_blk *blk, int reg_num, u32 val)
+{
+	dev_dbg(&blk->ofdev->dev, "write reg %08x %08x\n", reg_num, val);
+	writel(val, blk->base + reg_num);
+}
+
+static u32 qsp_blk_read_register(struct qsp_blk *blk, int reg_num)
+{
+	u32 ret;
+	ret = readl(blk->base + reg_num);
+	dev_dbg(&blk->ofdev->dev, "read reg %08x -> %08x\n", reg_num, ret);
+	return ret;
+}
+
+/* The direct make request version.
+ */
+static void ablk_make_request(struct request_queue *q, struct bio *bio)
+{
+	struct qsp_blk *ablk = q->queuedata;
+	int i;
+	struct bio_vec *bvec;
+	sector_t sector = bio->bi_sector;
+	u32 status;
+
+	dev_dbg(&ablk->ofdev->dev, "MAKE REQUEST %lld", sector);
+
+	bio_for_each_segment(bvec, bio, i) {
+		u64 paddr = page_to_phys(bvec->bv_page) + bvec->bv_offset;
+		size_t len = bvec->bv_len;
+
+		dev_dbg(&ablk->ofdev->dev, "i=%d\n", i);
+		while (len > 0) {
+			dev_dbg(&ablk->ofdev->dev, "paddr:%llx\n", paddr);
+			qsp_blk_write_register(ablk, PADDR, (u32)paddr);
+			qsp_blk_write_register(ablk, BLOCK, (u32)(sector));
+
+			dev_dbg(&ablk->ofdev->dev,
+				"sector: %lld len:%d size:%d\n", sector, len,
+				bio->bi_size);
+
+			switch (bio_data_dir(bio)) {
+			case WRITE:
+				qsp_blk_write_register(ablk,
+						       CMD, QSP_BLK_CMD_WRITE);
+				break;
+			case READ:
+				qsp_blk_write_register(ablk,
+						       CMD, QSP_BLK_CMD_READ);
+				break;
+			}
+
+			status = qsp_blk_read_register(ablk, STATUS);
+			if (status & STATUS_CHANN_ERR) {
+				dev_err(&ablk->ofdev->dev, "channel error\n");
+				bio_endio(bio, -1);
+				return;
+			}
+			if (status & STATUS_DMA_ERR) {
+				dev_err(&ablk->ofdev->dev, "DMA error\n");
+				bio_endio(bio, -1);
+				return;
+			}
+			if (status & STATUS_SEEK_ERR) {
+				dev_err(&ablk->ofdev->dev, "seek error\n");
+				bio_endio(bio, -1);
+				return;
+			}
+			if (status & STATUS_CMD_COMPLETE)
+				dev_dbg(&ablk->ofdev->dev, "cmd complete\n");
+
+			paddr += QSP_BLK_SIZE;
+			sector += 1;
+			len -= QSP_BLK_SIZE;
+			dev_dbg(&ablk->ofdev->dev, "remain len %d\n", len);
+		}
+	}
+	bio_endio(bio, 0);
+}
+
+
+static irqreturn_t ablk_interrupt(int irq, void *dev_id)
+{
+	pr_info("FIXME: CMD_SENSE interrupt.\n");
+	return IRQ_HANDLED;
+}
+
+
+//static int __devinit qsp_blk_probe(struct platform_device *ofdev)
+static int qsp_blk_probe(struct platform_device *ofdev)
+{
+	int err;
+	struct qsp_blk *ablk;
+	u32 status;
+	u32 id;
+	pr_debug("probe\n");
+
+	ablk = kzalloc(sizeof(struct qsp_blk), GFP_KERNEL);
+	if (!ablk) {
+		err = -ENOMEM;
+		goto no_mem;
+	}
+	ablk->ofdev = ofdev;
+	dev_set_drvdata(&ofdev->dev, ablk);
+
+	ablk->base = of_iomap(ofdev->dev.of_node, 0);
+	if (ablk->base == NULL) {
+		dev_err(&ofdev->dev, "failed to map resources.\n");
+		err = -EINVAL;
+		goto no_map;
+	}
+
+	id = qsp_blk_read_register(ablk, ID);
+	if (id != QSP_BLK_ID_VAL) {
+		dev_dbg(&ofdev->dev, "Failed to probe hardware with ID=0x%08x "
+			" @%p\n", id, ablk->base);
+		err = -ENODEV;
+		goto bad_id;
+	}
+
+	/* FIXME: we assume that CMD_SENSE completes immediately if there
+	 * is a disk connected...
+	 */
+	qsp_blk_write_register(ablk, CMD, QSP_BLK_CMD_SENSE);
+	status = qsp_blk_read_register(ablk, STATUS);
+	if (!(status & STATUS_CMD_COMPLETE)) {
+		dev_info(&ofdev->dev, "No disk present, skipping this controller.");
+		goto no_disk;
+	}
+	ablk->size = qsp_blk_read_register(ablk, CMD_RESPONSE);
+	dev_info(&ofdev->dev, "Disk of size %lld attached\n", ablk->size);
+
+	/* Setup the queue
+	 * Direct make request is the easiest block device interface, would
+	 * blk_init_queue() be significantly faster?
+	 */
+	ablk->queue = blk_alloc_queue(GFP_KERNEL);
+	blk_queue_make_request(ablk->queue, ablk_make_request);
+	if (ablk->queue == NULL) {
+		err = -ENOMEM;
+		goto no_queue;
+	}
+	ablk->queue->queuedata = ablk;
+
+	/* Setup the disk
+	 */
+	ablk->gd = alloc_disk(QSP_BLK_MINORS);
+	if (ablk->gd == NULL) {
+		err = -ENOMEM;
+		goto no_disk_mem;
+	}
+
+	ablk->idx = atomic_inc_return(&usage_count);
+	ablk->gd->major = QSP_BLK_MAJOR;
+	ablk->gd->first_minor = (ablk->idx - 1) << MINOR_SHIFT;
+	ablk->gd->fops = &qsp_blk_ops;
+	ablk->gd->queue = ablk->queue;
+	ablk->gd->private_data = ofdev;
+	ablk->gd->driverfs_dev = &ofdev->dev;
+	snprintf(ablk->gd->disk_name,
+		 sizeof(ablk->gd->disk_name),
+		 "%s%c",
+		 QSP_DISK_NAME,
+		 ablk->idx+'a');
+	set_capacity(ablk->gd, ablk->size);
+	add_disk(ablk->gd);
+	dev_info(&ofdev->dev, "add disk name:%s size:%lld done\n",
+		 ablk->gd->disk_name, get_capacity(ablk->gd));
+
+	/* Setup interrupt (currently unused...)
+	 */
+	ablk->irq = irq_of_parse_and_map(ofdev->dev.of_node,  0);
+	dev_dbg(&ofdev->dev, "got irq %d\n", ablk->irq);
+	if (!ablk->irq) {
+		dev_err(&ofdev->dev, "IRQ not specified in dtb\n");
+		return -EINVAL;
+	}
+	err = request_irq(ablk->irq, ablk_interrupt, 0, "qsp_blk",
+			  ablk);
+	if (err != 0) {
+		dev_err(&ofdev->dev, "Failed to request irq %d\n",  err);
+		return err;
+	}
+
+	return 0;
+no_disk_mem:
+	blk_cleanup_queue(ablk->queue);
+no_queue:
+no_disk:
+	iounmap(ablk->base);
+no_map:
+bad_id:
+	kfree(ablk);
+no_mem:
+	return err;
+}
+
+//static int __devexit qsp_blk_remove(struct platform_device *ofdev)
+static int qsp_blk_remove(struct platform_device *ofdev)
+{
+	struct qsp_blk *ablk = dev_get_drvdata(&ofdev->dev);
+
+	dev_info(&ofdev->dev, "removing disk\n");
+	atomic_dec(&usage_count);
+
+	if (ablk->gd) {
+		dev_dbg(&ofdev->dev, "delete gendisk\n");
+		del_gendisk(ablk->gd);
+		put_disk(ablk->gd);
+	}
+	if (ablk->queue) {
+		dev_dbg(&ofdev->dev, "cleanup queue\n");
+		blk_cleanup_queue(ablk->queue);
+	}
+
+	dev_set_drvdata(&ofdev->dev, NULL);
+	kfree(ablk);
+
+	return 0;
+}
+
+static const struct of_device_id qsp_blk_match[] = {
+	{ .compatible = "qsp,disk-controller" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, qsp_blk_match);
+
+static struct platform_driver qsp_blk_driver = {
+	.probe		= qsp_blk_probe,
+	.remove		= qsp_blk_remove,
+	.driver = {
+		.name = "adb-blk",
+		.owner = THIS_MODULE,
+		.of_match_table = qsp_blk_match,
+	},
+};
+
+static int qsp_blk_init(void)
+{
+	int berror;
+	int perror;
+
+	berror = register_blkdev(QSP_BLK_MAJOR, DEVICE_NAME);
+	if (berror < 0) {
+		pr_err("%s: register_blkdev failed - %d (major %d)\n",
+		       DEVICE_NAME,
+		       berror,
+		       QSP_BLK_MAJOR);
+		return berror;
+	}
+
+	perror = platform_driver_register(&qsp_blk_driver);
+	if (perror) {
+		pr_err("%s: platform_driver_register failed - %d\n",
+		       DEVICE_NAME, berror);
+		unregister_blkdev(QSP_BLK_MAJOR, DEVICE_NAME);
+		return perror;
+	}
+
+	pr_info("%s: registered succesfully\n", DEVICE_NAME);
+	return 0;
+}
+
+static void __exit qsp_blk_exit(void)
+{
+	platform_driver_unregister(&qsp_blk_driver);
+}
+
+module_init(qsp_blk_init);
+module_exit(qsp_blk_exit);
+
+MODULE_AUTHOR("Ivar Holmqvist <ivarholmqvist@gmail.com>");
+MODULE_DESCRIPTION("Block device driver for disk controllers on QSP boards.");
+MODULE_LICENSE("GPL");
diff -ruN linux-3.10/drivers/clocksource/Kconfig linux-3.10_patched/drivers/clocksource/Kconfig
--- linux-3.10/drivers/clocksource/Kconfig	2013-06-30 22:13:29.000000000 +0000
+++ linux-3.10_patched/drivers/clocksource/Kconfig	2025-06-14 05:48:04.969173245 +0000
@@ -63,6 +63,11 @@
 	help
 	  Use the always on PRCMU Timer as sched_clock
 
+config CLK_QSP
+       bool "Clocksource/event support for QSP timers."
+       help
+         Enable clockevent/clocksource driver for QSP timers.
+
 config ARM_ARCH_TIMER
 	bool
 	select CLKSRC_OF if OF
diff -ruN linux-3.10/drivers/clocksource/Makefile linux-3.10_patched/drivers/clocksource/Makefile
--- linux-3.10/drivers/clocksource/Makefile	2013-06-30 22:13:29.000000000 +0000
+++ linux-3.10_patched/drivers/clocksource/Makefile	2025-06-14 05:48:04.969173245 +0000
@@ -29,3 +29,5 @@
 
 obj-$(CONFIG_ARM_ARCH_TIMER)		+= arm_arch_timer.o
 obj-$(CONFIG_CLKSRC_METAG_GENERIC)	+= metag_generic.o
+obj-$(CONFIG_CLK_QSP)  += qsp_clk.o
+
diff -ruN linux-3.10/drivers/clocksource/qsp_clk.c linux-3.10_patched/drivers/clocksource/qsp_clk.c
--- linux-3.10/drivers/clocksource/qsp_clk.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.10_patched/drivers/clocksource/qsp_clk.c	2025-06-14 05:48:04.973173245 +0000
@@ -0,0 +1,161 @@
+/*
+ * QSP disk controller
+ *
+ * Based on ps3disk.c, xen-blkfront.c and the example block driver in ldd.
+ *
+ * (C) Copyright 2012, Ivar Holmqvist <ivarholmqvist@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+#undef DEBUG
+
+#include <linux/clockchips.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/spinlock.h>
+#include <linux/timex.h>
+#include <linux/module.h>
+#include <linux/smp.h>
+#include <linux/irq.h>
+#include <linux/irqreturn.h>
+#include <linux/interrupt.h>
+#include <linux/qsp/qsp_clk.h>
+
+/* TODO:
+ * - This driver only supports 1 instance...
+ * - Cleanup
+ */
+
+DEFINE_RAW_SPINLOCK(qsp_lock);
+
+static void __iomem *clk_base;
+
+#define CLK_ID      0x00
+#define CLK_FREQ    0x04
+#define CLK_COUNT   0x08
+#define CLK_ONESHOT 0x0c
+#define CLK_PERIOD  0x10
+
+cycle_t qsp_read(struct clocksource *cs)
+{
+	return readl(clk_base + CLK_COUNT);
+}
+
+
+static struct clocksource qsp_cs = {
+	.name		= "qsp",
+	.rating		= 110,
+	.read		= qsp_read,
+	.mask		= CLOCKSOURCE_MASK(32),
+};
+
+
+/*
+ * Initialize the QSP timer.
+ *
+ */
+static void init_qsp_timer(enum clock_event_mode mode,
+			   struct clock_event_device *evt)
+{
+	u32 freq;
+	pr_debug("INIT TIMER\n");
+	raw_spin_lock(&qsp_lock);
+
+	switch (mode) {
+	case CLOCK_EVT_MODE_PERIODIC:
+		pr_debug("PERIODIC\n");
+		freq = readl(clk_base + CLK_FREQ);
+		pr_info("Setting up periodic mode freq:%dHz HZ:%dHz\n",
+			freq, HZ);
+		WARN_ON(freq % HZ != 0);
+		writel(freq/HZ, clk_base + CLK_PERIOD);
+		break;
+
+	case CLOCK_EVT_MODE_SHUTDOWN:
+		pr_debug("SHUTDOWN\n");
+		/* Fall-through */
+	case CLOCK_EVT_MODE_UNUSED:
+		pr_debug("UNUSED\n");
+		writel(0, clk_base + CLK_ONESHOT);
+		break;
+
+	case CLOCK_EVT_MODE_ONESHOT:
+		pr_debug("ONESHOT\n");
+		WARN_ON(evt->mode == CLOCK_EVT_MODE_ONESHOT ||
+			evt->mode == CLOCK_EVT_MODE_PERIODIC);
+		/* One shot setup not needed, all is done in next event. */
+		break;
+
+	case CLOCK_EVT_MODE_RESUME:
+		pr_debug("RESUME\n");
+		/* Nothing to do here */
+		break;
+	}
+	raw_spin_unlock(&qsp_lock);
+}
+
+/*
+ * Program the next event in oneshot mode
+ *
+ * Delta is given in QSP ticks
+ */
+static int qsp_next_event(unsigned long delta, struct clock_event_device *evt)
+{
+	WARN_ON(evt->mode != CLOCK_EVT_MODE_ONESHOT);
+	writel(delta, clk_base + CLK_ONESHOT);
+	return 0;
+}
+
+struct clock_event_device qsp_clockevent = {
+	.name		= "qsp",
+	.features	= CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT,
+	.set_mode	= init_qsp_timer,
+	.set_next_event = qsp_next_event,
+};
+
+static irqreturn_t qsp_timer_interrupt(int irq, void *dev_id)
+{
+	struct clock_event_device *evt = dev_id;
+	if (dev_id == NULL) {
+		pr_err("Spurious timer irq %d\n", irq);
+		return IRQ_NONE;
+	}
+	evt->event_handler(evt);
+
+	return IRQ_HANDLED;
+}
+
+static struct irqaction qsp_timer_irq = {
+	.name		= "timer",
+	.flags		= IRQF_TIMER,
+	.handler	= qsp_timer_interrupt,
+	.dev_id		= &qsp_clockevent,
+};
+
+
+/*
+ * Register this timer as both clocksource and clockevent.
+ */
+void __init qsp_timer_init_one(int irq, void __iomem *base)
+{
+	u32 freq;
+
+	/* FIXME: one timer per cpu? arm...
+	 */
+	qsp_clockevent.cpumask = cpumask_of(0);
+
+	freq = readl(base + CLK_FREQ);
+	pr_debug("IRQ %d freq %d\\n", irq, freq);
+	clk_base = base;
+	setup_irq(irq, &qsp_timer_irq);
+	clockevents_config_and_register(&qsp_clockevent, freq,
+					0xF, 0xFFFFFFFF);
+
+	clocksource_register_hz(&qsp_cs, freq);
+}
+
+
+
diff -ruN linux-3.10/drivers/Kconfig linux-3.10_patched/drivers/Kconfig
--- linux-3.10/drivers/Kconfig	2013-06-30 22:13:29.000000000 +0000
+++ linux-3.10_patched/drivers/Kconfig	2025-06-14 05:48:04.949173245 +0000
@@ -148,6 +148,8 @@
 
 source "drivers/devfreq/Kconfig"
 
+source "drivers/pic/Kconfig"
+
 source "drivers/extcon/Kconfig"
 
 source "drivers/memory/Kconfig"
diff -ruN linux-3.10/drivers/leds/Kconfig linux-3.10_patched/drivers/leds/Kconfig
--- linux-3.10/drivers/leds/Kconfig	2013-06-30 22:13:29.000000000 +0000
+++ linux-3.10_patched/drivers/leds/Kconfig	2025-06-14 05:48:04.969173245 +0000
@@ -471,6 +471,13 @@
 	  This option enables support for the LEDs on the Bachmann OT200.
 	  Say Y to enable LEDs on the Bachmann OT200.
 
+config LEDS_QSP
+       bool "LED support for QSP"
+       depends on LEDS_CLASS && QSP
+       default y
+       help
+         This option enables build of the LED QSP platform driver.
+
 config LEDS_BLINKM
 	tristate "LED support for the BlinkM I2C RGB LED"
 	depends on LEDS_CLASS
diff -ruN linux-3.10/drivers/leds/leds-qsp.c linux-3.10_patched/drivers/leds/leds-qsp.c
--- linux-3.10/drivers/leds/leds-qsp.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.10_patched/drivers/leds/leds-qsp.c	2025-06-14 05:48:04.969173245 +0000
@@ -0,0 +1,222 @@
+/*
+ * drivers/leds/leds-qsp.c
+ *
+ * LEDs driver for the QSP, driver based on the leds-gpio driver
+ *
+ * Copyright (c) 2012 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/leds.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/io.h>
+#include <linux/qsp/qsp.h>
+
+#define NO_OF_LEDS       16
+
+/* Register offsets */
+#define ID_REG           0x00
+#define LED_REG          0x04
+
+/* LED register bits */
+#define BRIGHTNESS_SHIFT 0
+#define BRIGHTNESS_MASK  0x00000001
+
+struct qsp_led_data {
+	struct led_classdev cdev;
+	unsigned char __iomem *reg;
+};
+
+struct qsp_leds_priv {
+	unsigned char __iomem *membase;
+	int num_leds;
+	struct qsp_led_data leds[NO_OF_LEDS];
+};
+
+static void qsp_led_set(struct led_classdev *led_cdev,
+			enum led_brightness value)
+{
+	struct qsp_led_data *led_data =
+		container_of(led_cdev, struct qsp_led_data, cdev);
+
+	pr_debug("%s: %s = %i\n", __func__, led_data->cdev.name, value);
+	writel(value, led_data->reg);
+}
+
+static enum led_brightness qsp_led_get(struct led_classdev *led_cdev)
+{
+	int value;
+	struct qsp_led_data *led_data =
+		container_of(led_cdev, struct qsp_led_data, cdev);
+
+	value = readl(led_data->reg);
+	pr_debug("%s: %i\n", __func__, value);
+
+	return value & BRIGHTNESS_MASK;
+}
+
+static int qsp_index_get(struct device_node *np)
+{
+	int index;
+
+	if (of_property_read_u32(np, "index", &index)) {
+		pr_warn("LED index not specified (%s)\n", np->name);
+		return -EINVAL;
+	}
+
+	if ((index < 0) || (index >= NO_OF_LEDS)) {
+		pr_warn("LED index outside valid area %i (0 - %i)\n",
+			index, NO_OF_LEDS);
+		return -EINVAL;
+	}
+
+	return index;
+}
+
+static char *qsp_get_led_name(struct device_node *np, struct device_node *child)
+{
+	const char *led_name;
+	const char *ctrl_name;
+	char *led_long_name;
+
+	ctrl_name = of_get_property(np, "label", NULL) ? : np->name;
+	led_name  = of_get_property(child, "label", NULL) ? : child->name;
+
+	led_long_name = kmalloc(strlen(ctrl_name) + strlen(led_name) + 2,
+				GFP_KERNEL);
+	BUG_ON(led_long_name == NULL);
+
+	strcpy(led_long_name, ctrl_name);
+	strcat(led_long_name, "-");
+	strcat(led_long_name, led_name);
+	return led_long_name;
+}
+
+static struct qsp_leds_priv * __devinit qsp_leds_create_of(
+	struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node, *child;
+	struct qsp_leds_priv *priv;
+	int ret;
+
+	dev_dbg(&pdev->dev, "%s: Controller %s\n", __func__, np->name);
+
+	priv = kzalloc(sizeof(struct qsp_leds_priv), GFP_KERNEL);
+	if (!priv)
+		return NULL;
+
+	priv->membase = of_iomap(pdev->dev.of_node, 0);
+	if (priv->membase == NULL)
+		goto err1;
+
+	if (qsp_device_valid(priv->membase, QSP_LED_ID_VAL) != 0)
+		goto err2;
+
+	for_each_child_of_node(np, child) {
+		struct qsp_led_data *led_data;
+		int index;
+
+		if (priv->num_leds >= NO_OF_LEDS) {
+			dev_warn(&pdev->dev, "To many LEDS defined in DTB\n");
+			break;
+		}
+
+		led_data = &priv->leds[priv->num_leds];
+
+		index = qsp_index_get(child);
+		if (index < 0)
+			continue;
+
+		led_data->reg = priv->membase + (LED_REG + index * 4);
+		led_data->cdev.name = qsp_get_led_name(np, child);
+		led_data->cdev.default_trigger =
+			of_get_property(child, "linux,default-trigger", NULL);
+		led_data->cdev.brightness_set = qsp_led_set;
+		led_data->cdev.brightness_get = qsp_led_get;
+		led_data->cdev.brightness = 0; /* LED_OFF */
+		led_data->cdev.max_brightness = 1;
+
+		ret = led_classdev_register(&pdev->dev, &led_data->cdev);
+		if (ret < 0) {
+			dev_err(&pdev->dev, "Can't register LED device (%i)\n",
+				ret);
+			goto err2;
+		}
+
+		priv->num_leds++;
+	}
+	return priv;
+
+err2:
+	iounmap(priv->membase);
+err1:
+	kfree(priv);
+	return NULL;
+}
+
+static int __devinit qsp_led_probe(struct platform_device *pdev)
+{
+	struct qsp_leds_priv *priv;
+
+	priv = qsp_leds_create_of(pdev);
+	if (!priv)
+		return -ENODEV;
+
+	platform_set_drvdata(pdev, priv);
+
+	return 0;
+}
+
+static int __devexit qsp_led_remove(struct platform_device *pdev)
+{
+	struct qsp_leds_priv *priv = platform_get_drvdata(pdev);
+	int i;
+
+	for (i = 0; i < priv->num_leds; i++)
+		led_classdev_unregister(&priv->leds[i].cdev);
+
+	platform_set_drvdata(pdev, NULL);
+	iounmap(priv->membase);
+
+	kfree(priv);
+	return 0;
+}
+
+static const struct of_device_id of_qsp_leds_match[] = {
+	{ .compatible = "leds-qsp", },
+	{ },
+};
+
+static struct platform_driver qsp_led_driver = {
+	.probe = qsp_led_probe,
+	.remove = __devexit_p(qsp_led_remove),
+	.driver = {
+		.name = "qsp-leds",
+		.owner = THIS_MODULE,
+		.of_match_table = of_qsp_leds_match,
+	},
+};
+
+module_platform_driver(qsp_led_driver);
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("LED support for QSP");
+MODULE_AUTHOR("Anders Wallin <anders.wallin@windriver.com>");
diff -ruN linux-3.10/drivers/leds/Makefile linux-3.10_patched/drivers/leds/Makefile
--- linux-3.10/drivers/leds/Makefile	2013-06-30 22:13:29.000000000 +0000
+++ linux-3.10_patched/drivers/leds/Makefile	2025-06-14 05:48:04.969173245 +0000
@@ -53,6 +53,7 @@
 obj-$(CONFIG_LEDS_MAX8997)		+= leds-max8997.o
 obj-$(CONFIG_LEDS_LM355x)		+= leds-lm355x.o
 obj-$(CONFIG_LEDS_BLINKM)		+= leds-blinkm.o
++obj-$(CONFIG_LEDS_QSP)			+= leds-qsp.o
 
 # LED SPI Drivers
 obj-$(CONFIG_LEDS_DAC124S085)		+= leds-dac124s085.o
diff -ruN linux-3.10/drivers/Makefile linux-3.10_patched/drivers/Makefile
--- linux-3.10/drivers/Makefile	2013-06-30 22:13:29.000000000 +0000
+++ linux-3.10_patched/drivers/Makefile	2025-06-14 05:48:04.949173245 +0000
@@ -146,6 +146,7 @@
 obj-$(CONFIG_HYPERV)		+= hv/
 
 obj-$(CONFIG_PM_DEVFREQ)	+= devfreq/
+obj-y				+= pic/
 obj-$(CONFIG_EXTCON)		+= extcon/
 obj-$(CONFIG_MEMORY)		+= memory/
 obj-$(CONFIG_IIO)		+= iio/
diff -ruN linux-3.10/drivers/mtd/chips/Kconfig linux-3.10_patched/drivers/mtd/chips/Kconfig
--- linux-3.10/drivers/mtd/chips/Kconfig	2013-06-30 22:13:29.000000000 +0000
+++ linux-3.10_patched/drivers/mtd/chips/Kconfig	2025-06-14 05:48:04.953173245 +0000
@@ -231,4 +231,13 @@
 	  used for XIP purposes.  If you're not sure what this is all about
 	  then say N.
 
+config MTD_QSP_FLASH
+       tristate "MTD Driver for QSP Flash"
+       help
+         The MTD driver for the QSP platform is very simple and has three
+         states:
+         - READ_ARRAY_MODE (initial state)
+         - WRITE_MODE
+         - PROPERTY_QUERY_MODE
+
 endmenu
diff -ruN linux-3.10/drivers/mtd/chips/Makefile linux-3.10_patched/drivers/mtd/chips/Makefile
--- linux-3.10/drivers/mtd/chips/Makefile	2013-06-30 22:13:29.000000000 +0000
+++ linux-3.10_patched/drivers/mtd/chips/Makefile	2025-06-14 05:48:04.953173245 +0000
@@ -13,3 +13,4 @@
 obj-$(CONFIG_MTD_RAM)		+= map_ram.o
 obj-$(CONFIG_MTD_ROM)		+= map_rom.o
 obj-$(CONFIG_MTD_ABSENT)	+= map_absent.o
+obj-$(CONFIG_MTD_QSP_FLASH)	+= qsp-flash.o
diff -ruN linux-3.10/drivers/mtd/chips/qsp-flash.c linux-3.10_patched/drivers/mtd/chips/qsp-flash.c
--- linux-3.10/drivers/mtd/chips/qsp-flash.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.10_patched/drivers/mtd/chips/qsp-flash.c	2025-06-14 05:48:04.953173245 +0000
@@ -0,0 +1,219 @@
+/*
+ * drivers/mtd/chips/qsp-flash.c
+ *
+ * Flash driver for the QSP platform
+ *
+ * Copyright (c) 2012 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/io.h>
+#include <asm/byteorder.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/qsp/qsp.h>
+
+#define DEVICE_TYPE "QSP Flash"
+
+static int qsp_flash_read(struct mtd_info *, loff_t, size_t,
+			  size_t *, u_char *);
+static int qsp_flash_write(struct mtd_info *, loff_t, size_t,
+			   size_t *, const u_char *);
+static int qsp_flash_erase(struct mtd_info *, struct erase_info *);
+static void qsp_flash_nop(struct mtd_info *);
+static struct mtd_info *qsp_flash_probe(struct map_info *map);
+static unsigned long qsp_flash_unmapped_area(struct mtd_info *, unsigned long,
+					     unsigned long, unsigned long);
+
+static struct mtd_chip_driver qsp_flash_chipdrv = {
+	.probe	= qsp_flash_probe,
+	.name	= "qsp-probe",
+	.module	= THIS_MODULE
+};
+
+static uint32_t flash_property_at(struct map_info *map, uint32_t at)
+{
+	volatile uint32_t *flash = (uint32_t *)map->virt;
+	*flash = 0xd00dd00d;
+	flash += at;
+	return *flash;
+}
+
+static struct mtd_info *qsp_flash_probe(struct map_info *map)
+{
+	struct mtd_info *mtd;
+	uint32_t fl_size = 0;
+	pr_info(DEVICE_TYPE ": Probing Chip at %p (virt) / 0x%x (phys)\n",
+		map->virt, map->phys);
+
+	if (flash_property_at(map, 0) == QSP_FLASH_ID_VAL)
+		pr_info(DEVICE_TYPE ": Detected QSP Flash!\n");
+	else
+		return NULL;
+
+	fl_size = flash_property_at(map, 1);
+	pr_info(DEVICE_TYPE ": Detected Size of 0x%x!\n", fl_size);
+	if (fl_size != map->size) {
+		pr_info(DEVICE_TYPE ": Size does not match kernel config!\n");
+		return NULL;
+	}
+
+	mtd = kzalloc(sizeof(*mtd), GFP_KERNEL);
+	if (!mtd)
+		return NULL;
+
+	map->fldrv = &qsp_flash_chipdrv;
+	mtd->priv = map;
+	mtd->name = map->name;
+	mtd->type = MTD_NORFLASH;
+	mtd->size = map->size;
+	mtd->_erase = qsp_flash_erase;
+	mtd->_get_unmapped_area = qsp_flash_unmapped_area;
+	mtd->_read = qsp_flash_read;
+	mtd->_write = qsp_flash_write;
+	mtd->_sync = qsp_flash_nop;
+	mtd->flags = MTD_CAP_NORFLASH;
+	mtd->writesize = 1;
+
+	mtd->erasesize = PAGE_SIZE;
+	while (mtd->size & (mtd->erasesize - 1))
+		mtd->erasesize >>= 1;
+
+	__module_get(THIS_MODULE);
+	return mtd;
+}
+
+/* Allow NOMMU mmap() to directly map the device (if not NULL)
+ * - return the address to which the offset maps
+ * - return -ENOSYS to indicate refusal to do the mapping
+ */
+static unsigned long qsp_flash_unmapped_area(struct mtd_info *mtd,
+					     unsigned long len,
+					     unsigned long offset,
+					     unsigned long flags)
+{
+	struct map_info *map = mtd->priv;
+	return (unsigned long) map->virt + offset;
+}
+
+static int qsp_flash_read(struct mtd_info *mtd, loff_t from,
+			  size_t len, size_t *retlen, u_char *buf)
+{
+	struct map_info *map = mtd->priv;
+	map_copy_from(map, buf, from, len);
+	*retlen = len;
+	return 0;
+}
+
+static int qsp_flash_write(struct mtd_info *mtd, loff_t to,
+			   size_t len, size_t *retlen, const u_char *buf)
+{
+	struct map_info *map = mtd->priv;
+	volatile uint8_t *flash = map->virt + to;
+	unsigned int i, num, left;
+	volatile uint32_t *aligned;
+	uint32_t data;
+
+	num = (uint32_t)to & 0x3;
+	aligned = (volatile uint32_t *)((unsigned long)flash - num);
+	left = len;
+
+	if (num != 0) {
+		data = *aligned;
+
+		for (i = num ; i < 4; i++) {
+			data &= ~(0xFF << ((3 - i) * 8));
+			data |= ((*(buf + i - num)) << ((3 - i) * 8));
+		}
+
+		*aligned = 0xdeadbeef;
+		*aligned = data;
+
+		buf  += (4 - num);
+		left -= (4 - num);
+		aligned++;
+	}
+
+	while (left >= 4) {
+		data = *(uint32_t *)buf;
+		*aligned = 0xdeadbeef;
+		*aligned = data;
+		buf  += 4;
+		left -= 4;
+		aligned++;
+	}
+
+	if (left > 0) {
+		data = *aligned;
+
+		for (i = 0 ; i < left; i++) {
+			data &= ~(0xFF << ((3 - i) * 8));
+			data |= ((*(buf + i)) << ((3 - i) * 8));
+		}
+
+		*aligned = 0xdeadbeef;
+		*aligned = data;
+	}
+
+	*retlen = len;
+	return 0;
+}
+
+static int qsp_flash_erase(struct mtd_info *mtd, struct erase_info *instr)
+{
+	struct map_info *map = mtd->priv;
+	unsigned long i;
+	volatile uint32_t *flash =
+		(volatile uint32_t *)((uint8_t *)map->virt + instr->addr);
+
+	for (i = 0; i < instr->len; i += 4) {
+		*flash = 0xdeadbeef;
+		*flash = 0xffffffff;
+		flash++;
+	}
+	instr->state = MTD_ERASE_DONE;
+	mtd_erase_callback(instr);
+	return 0;
+}
+
+static void qsp_flash_nop(struct mtd_info *mtd)
+{
+	/* Nothing to see here */
+}
+
+static int __init qsp_flash_init(void)
+{
+	pr_info("QSP FLash Init");
+	register_mtd_chip_driver(&qsp_flash_chipdrv);
+	return 0;
+}
+
+static void __exit qsp_flash_exit(void)
+{
+	unregister_mtd_chip_driver(&qsp_flash_chipdrv);
+}
+module_init(qsp_flash_init);
+module_exit(qsp_flash_exit);
+
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Wind River");
+MODULE_DESCRIPTION("MTD chip driver for QSP Flash");
diff -ruN linux-3.10/drivers/mtd/maps/amd76xrom.c linux-3.10_patched/drivers/mtd/maps/amd76xrom.c
--- linux-3.10/drivers/mtd/maps/amd76xrom.c	2013-06-30 22:13:29.000000000 +0000
+++ linux-3.10_patched/drivers/mtd/maps/amd76xrom.c	2025-06-14 05:48:04.953173245 +0000
@@ -100,8 +100,8 @@
 }
 
 
-static int amd76xrom_init_one(struct pci_dev *pdev,
-			      const struct pci_device_id *ent)
+static int __devinit amd76xrom_init_one (struct pci_dev *pdev,
+	const struct pci_device_id *ent)
 {
 	static char *rom_probe_types[] = { "cfi_probe", "jedec_probe", NULL };
 	u8 byte;
@@ -289,7 +289,7 @@
 }
 
 
-static void amd76xrom_remove_one(struct pci_dev *pdev)
+static void __devexit amd76xrom_remove_one (struct pci_dev *pdev)
 {
 	struct amd76xrom_window *window = &amd76xrom_window;
 
@@ -347,3 +347,4 @@
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Eric Biederman <ebiederman@lnxi.com>");
 MODULE_DESCRIPTION("MTD map driver for BIOS chips on the AMD76X southbridge");
+
diff -ruN linux-3.10/drivers/mtd/maps/autcpu12-nvram.c linux-3.10_patched/drivers/mtd/maps/autcpu12-nvram.c
--- linux-3.10/drivers/mtd/maps/autcpu12-nvram.c	2013-06-30 22:13:29.000000000 +0000
+++ linux-3.10_patched/drivers/mtd/maps/autcpu12-nvram.c	2025-06-14 05:48:04.953173245 +0000
@@ -15,53 +15,43 @@
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
  */
-#include <linux/err.h>
-#include <linux/sizes.h>
 
+#include <linux/module.h>
 #include <linux/types.h>
 #include <linux/kernel.h>
+#include <linux/ioport.h>
 #include <linux/init.h>
-#include <linux/device.h>
-#include <linux/module.h>
-#include <linux/platform_device.h>
-
+#include <asm/io.h>
+#include <asm/sizes.h>
+#include <mach/hardware.h>
+#include <mach/autcpu12.h>
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+
+static struct mtd_info *sram_mtd;
 
-struct autcpu12_nvram_priv {
-	struct mtd_info *mtd;
-	struct map_info map;
+struct map_info autcpu12_sram_map = {
+	.name = "SRAM",
+	.size = 32768,
+	.bankwidth = 4,
+	.phys = 0x12000000,
 };
 
-static int autcpu12_nvram_probe(struct platform_device *pdev)
+static int __init init_autcpu12_sram (void)
 {
-	map_word tmp, save0, save1;
-	struct resource *res;
-	struct autcpu12_nvram_priv *priv;
-
-	priv = devm_kzalloc(&pdev->dev,
-			    sizeof(struct autcpu12_nvram_priv), GFP_KERNEL);
-	if (!priv)
-		return -ENOMEM;
-
-	platform_set_drvdata(pdev, priv);
-
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!res) {
-		dev_err(&pdev->dev, "failed to get memory resource\n");
-		return -ENOENT;
-	}
-
-	priv->map.bankwidth	= 4;
-	priv->map.phys		= res->start;
-	priv->map.size		= resource_size(res);
-	priv->map.virt = devm_ioremap_resource(&pdev->dev, res);
-	strcpy((char *)priv->map.name, res->name);
-	if (IS_ERR(priv->map.virt))
-		return PTR_ERR(priv->map.virt);
+	int err, save0, save1;
 
-	simple_map_init(&priv->map);
+	autcpu12_sram_map.virt = ioremap(0x12000000, SZ_128K);
+	if (!autcpu12_sram_map.virt) {
+		printk("Failed to ioremap autcpu12 NV-RAM space\n");
+		err = -EIO;
+		goto out;
+	}
+	simple_map_init(&autcpu_sram_map);
 
 	/*
 	 * Check for 32K/128K
@@ -71,59 +61,65 @@
 	 * Read	and check result on ofs 0x0
 	 * Restore contents
 	 */
-	save0 = map_read(&priv->map, 0);
-	save1 = map_read(&priv->map, 0x10000);
-	tmp.x[0] = ~save0.x[0];
-	map_write(&priv->map, tmp, 0x10000);
-	tmp = map_read(&priv->map, 0);
-	/* if we find this pattern on 0x0, we have 32K size */
-	if (!map_word_equal(&priv->map, tmp, save0)) {
-		map_write(&priv->map, save0, 0x0);
-		priv->map.size = SZ_32K;
-	} else
-		map_write(&priv->map, save1, 0x10000);
-
-	priv->mtd = do_map_probe("map_ram", &priv->map);
-	if (!priv->mtd) {
-		dev_err(&pdev->dev, "probing failed\n");
-		return -ENXIO;
+	save0 = map_read32(&autcpu12_sram_map,0);
+	save1 = map_read32(&autcpu12_sram_map,0x10000);
+	map_write32(&autcpu12_sram_map,~save0,0x10000);
+	/* if we find this pattern on 0x0, we have 32K size
+	 * restore contents and exit
+	 */
+	if ( map_read32(&autcpu12_sram_map,0) != save0) {
+		map_write32(&autcpu12_sram_map,save0,0x0);
+		goto map;
 	}
+	/* We have a 128K found, restore 0x10000 and set size
+	 * to 128K
+	 */
+	map_write32(&autcpu12_sram_map,save1,0x10000);
+	autcpu12_sram_map.size = SZ_128K;
 
-	priv->mtd->owner	= THIS_MODULE;
-	priv->mtd->erasesize	= 16;
-	priv->mtd->dev.parent	= &pdev->dev;
-	if (!mtd_device_register(priv->mtd, NULL, 0)) {
-		dev_info(&pdev->dev,
-			 "NV-RAM device size %ldKiB registered on AUTCPU12\n",
-			 priv->map.size / SZ_1K);
-		return 0;
+map:
+	sram_mtd = do_map_probe("map_ram", &autcpu12_sram_map);
+	if (!sram_mtd) {
+		printk("NV-RAM probe failed\n");
+		err = -ENXIO;
+		goto out_ioremap;
 	}
 
-	map_destroy(priv->mtd);
-	dev_err(&pdev->dev, "NV-RAM device addition failed\n");
-	return -ENOMEM;
-}
+	sram_mtd->owner = THIS_MODULE;
+	sram_mtd->erasesize = 16;
 
-static int autcpu12_nvram_remove(struct platform_device *pdev)
-{
-	struct autcpu12_nvram_priv *priv = platform_get_drvdata(pdev);
+	if (mtd_device_register(sram_mtd, NULL, 0)) {
+		printk("NV-RAM device addition failed\n");
+		err = -ENOMEM;
+		goto out_probe;
+	}
 
-	mtd_device_unregister(priv->mtd);
-	map_destroy(priv->mtd);
+	printk("NV-RAM device size %ldKiB registered on AUTCPU12\n",autcpu12_sram_map.size/SZ_1K);
 
 	return 0;
+
+out_probe:
+	map_destroy(sram_mtd);
+	sram_mtd = 0;
+
+out_ioremap:
+	iounmap((void *)autcpu12_sram_map.virt);
+out:
+	return err;
 }
 
-static struct platform_driver autcpu12_nvram_driver = {
-	.driver		= {
-		.name	= "autcpu12_nvram",
-		.owner	= THIS_MODULE,
-	},
-	.probe		= autcpu12_nvram_probe,
-	.remove		= autcpu12_nvram_remove,
-};
-module_platform_driver(autcpu12_nvram_driver);
+static void __exit cleanup_autcpu12_maps(void)
+{
+	if (sram_mtd) {
+		mtd_device_unregister(sram_mtd);
+		map_destroy(sram_mtd);
+		iounmap((void *)autcpu12_sram_map.virt);
+	}
+}
+
+module_init(init_autcpu12_sram);
+module_exit(cleanup_autcpu12_maps);
 
 MODULE_AUTHOR("Thomas Gleixner");
-MODULE_DESCRIPTION("autcpu12 NVRAM map driver");
+MODULE_DESCRIPTION("autcpu12 NV-RAM map driver");
 MODULE_LICENSE("GPL");
diff -ruN linux-3.10/drivers/mtd/maps/bfin-async-flash.c linux-3.10_patched/drivers/mtd/maps/bfin-async-flash.c
--- linux-3.10/drivers/mtd/maps/bfin-async-flash.c	2013-06-30 22:13:29.000000000 +0000
+++ linux-3.10_patched/drivers/mtd/maps/bfin-async-flash.c	2025-06-14 05:48:04.953173245 +0000
@@ -30,8 +30,7 @@
 #include <linux/io.h>
 #include <asm/unaligned.h>
 
-#define pr_devinit(fmt, args...) \
-		({ static const char __fmt[] = fmt; printk(__fmt, ## args); })
+#define pr_devinit(fmt, args...) ({ static const __devinitconst char __fmt[] = fmt; printk(__fmt, ## args); })
 
 #define DRIVER_NAME "bfin-async-flash"
 
@@ -122,10 +121,9 @@
 	switch_back(state);
 }
 
-static const char * const part_probe_types[] = {
-	"cmdlinepart", "RedBoot", NULL };
+static const char *part_probe_types[] = { "cmdlinepart", "RedBoot", NULL };
 
-static int bfin_flash_probe(struct platform_device *pdev)
+static int __devinit bfin_flash_probe(struct platform_device *pdev)
 {
 	int ret;
 	struct physmap_flash_data *pdata = pdev->dev.platform_data;
@@ -174,7 +172,7 @@
 	return 0;
 }
 
-static int bfin_flash_remove(struct platform_device *pdev)
+static int __devexit bfin_flash_remove(struct platform_device *pdev)
 {
 	struct async_state *state = platform_get_drvdata(pdev);
 	gpio_free(state->enet_flash_pin);
@@ -186,7 +184,7 @@
 
 static struct platform_driver bfin_flash_driver = {
 	.probe		= bfin_flash_probe,
-	.remove		= bfin_flash_remove,
+	.remove		= __devexit_p(bfin_flash_remove),
 	.driver		= {
 		.name	= DRIVER_NAME,
 	},
Binary files linux-3.10/drivers/mtd/maps/built-in.o and linux-3.10_patched/drivers/mtd/maps/built-in.o differ
diff -ruN linux-3.10/drivers/mtd/maps/.built-in.o.cmd linux-3.10_patched/drivers/mtd/maps/.built-in.o.cmd
--- linux-3.10/drivers/mtd/maps/.built-in.o.cmd	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.10_patched/drivers/mtd/maps/.built-in.o.cmd	2025-06-14 05:48:04.969173245 +0000
@@ -0,0 +1 @@
+cmd_drivers/mtd/maps/built-in.o :=  /home/mike/qsp_buildroot/buildroot/output/host/usr/bin/ccache /home/mike/qsp_buildroot/buildroot/output/host/usr/bin/arm-none-linux-gnueabi-ld -EL   -r -o drivers/mtd/maps/built-in.o drivers/mtd/maps/physmap.o drivers/mtd/maps/physmap_of.o 
diff -ruN linux-3.10/drivers/mtd/maps/cdb89712.c linux-3.10_patched/drivers/mtd/maps/cdb89712.c
--- linux-3.10/drivers/mtd/maps/cdb89712.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.10_patched/drivers/mtd/maps/cdb89712.c	2025-06-14 05:48:04.953173245 +0000
@@ -0,0 +1,278 @@
+/*
+ * Flash on Cirrus CDB89712
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <asm/io.h>
+#include <mach/hardware.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+/* dynamic ioremap() areas */
+#define FLASH_START      0x00000000
+#define FLASH_SIZE       0x800000
+#define FLASH_WIDTH      4
+
+#define SRAM_START       0x60000000
+#define SRAM_SIZE        0xc000
+#define SRAM_WIDTH       4
+
+#define BOOTROM_START    0x70000000
+#define BOOTROM_SIZE     0x80
+#define BOOTROM_WIDTH    4
+
+
+static struct mtd_info *flash_mtd;
+
+struct map_info cdb89712_flash_map = {
+	.name = "flash",
+	.size = FLASH_SIZE,
+	.bankwidth = FLASH_WIDTH,
+	.phys = FLASH_START,
+};
+
+struct resource cdb89712_flash_resource = {
+	.name =   "Flash",
+	.start =  FLASH_START,
+	.end =    FLASH_START + FLASH_SIZE - 1,
+	.flags =  IORESOURCE_IO | IORESOURCE_BUSY,
+};
+
+static int __init init_cdb89712_flash (void)
+{
+	int err;
+
+	if (request_resource (&ioport_resource, &cdb89712_flash_resource)) {
+		printk(KERN_NOTICE "Failed to reserve Cdb89712 FLASH space\n");
+		err = -EBUSY;
+		goto out;
+	}
+
+	cdb89712_flash_map.virt = ioremap(FLASH_START, FLASH_SIZE);
+	if (!cdb89712_flash_map.virt) {
+		printk(KERN_NOTICE "Failed to ioremap Cdb89712 FLASH space\n");
+		err = -EIO;
+		goto out_resource;
+	}
+	simple_map_init(&cdb89712_flash_map);
+	flash_mtd = do_map_probe("cfi_probe", &cdb89712_flash_map);
+	if (!flash_mtd) {
+		flash_mtd = do_map_probe("map_rom", &cdb89712_flash_map);
+		if (flash_mtd)
+			flash_mtd->erasesize = 0x10000;
+	}
+	if (!flash_mtd) {
+		printk("FLASH probe failed\n");
+		err = -ENXIO;
+		goto out_ioremap;
+	}
+
+	flash_mtd->owner = THIS_MODULE;
+
+	if (mtd_device_register(flash_mtd, NULL, 0)) {
+		printk("FLASH device addition failed\n");
+		err = -ENOMEM;
+		goto out_probe;
+	}
+
+	return 0;
+
+out_probe:
+	map_destroy(flash_mtd);
+	flash_mtd = 0;
+out_ioremap:
+	iounmap((void *)cdb89712_flash_map.virt);
+out_resource:
+	release_resource (&cdb89712_flash_resource);
+out:
+	return err;
+}
+
+
+
+
+
+static struct mtd_info *sram_mtd;
+
+struct map_info cdb89712_sram_map = {
+	.name = "SRAM",
+	.size = SRAM_SIZE,
+	.bankwidth = SRAM_WIDTH,
+	.phys = SRAM_START,
+};
+
+struct resource cdb89712_sram_resource = {
+	.name =   "SRAM",
+	.start =  SRAM_START,
+	.end =    SRAM_START + SRAM_SIZE - 1,
+	.flags =  IORESOURCE_IO | IORESOURCE_BUSY,
+};
+
+static int __init init_cdb89712_sram (void)
+{
+	int err;
+
+	if (request_resource (&ioport_resource, &cdb89712_sram_resource)) {
+		printk(KERN_NOTICE "Failed to reserve Cdb89712 SRAM space\n");
+		err = -EBUSY;
+		goto out;
+	}
+
+	cdb89712_sram_map.virt = ioremap(SRAM_START, SRAM_SIZE);
+	if (!cdb89712_sram_map.virt) {
+		printk(KERN_NOTICE "Failed to ioremap Cdb89712 SRAM space\n");
+		err = -EIO;
+		goto out_resource;
+	}
+	simple_map_init(&cdb89712_sram_map);
+	sram_mtd = do_map_probe("map_ram", &cdb89712_sram_map);
+	if (!sram_mtd) {
+		printk("SRAM probe failed\n");
+		err = -ENXIO;
+		goto out_ioremap;
+	}
+
+	sram_mtd->owner = THIS_MODULE;
+	sram_mtd->erasesize = 16;
+
+	if (mtd_device_register(sram_mtd, NULL, 0)) {
+		printk("SRAM device addition failed\n");
+		err = -ENOMEM;
+		goto out_probe;
+	}
+
+	return 0;
+
+out_probe:
+	map_destroy(sram_mtd);
+	sram_mtd = 0;
+out_ioremap:
+	iounmap((void *)cdb89712_sram_map.virt);
+out_resource:
+	release_resource (&cdb89712_sram_resource);
+out:
+	return err;
+}
+
+
+
+
+
+
+
+static struct mtd_info *bootrom_mtd;
+
+struct map_info cdb89712_bootrom_map = {
+	.name = "BootROM",
+	.size = BOOTROM_SIZE,
+	.bankwidth = BOOTROM_WIDTH,
+	.phys = BOOTROM_START,
+};
+
+struct resource cdb89712_bootrom_resource = {
+	.name =   "BootROM",
+	.start =  BOOTROM_START,
+	.end =    BOOTROM_START + BOOTROM_SIZE - 1,
+	.flags =  IORESOURCE_IO | IORESOURCE_BUSY,
+};
+
+static int __init init_cdb89712_bootrom (void)
+{
+	int err;
+
+	if (request_resource (&ioport_resource, &cdb89712_bootrom_resource)) {
+		printk(KERN_NOTICE "Failed to reserve Cdb89712 BOOTROM space\n");
+		err = -EBUSY;
+		goto out;
+	}
+
+	cdb89712_bootrom_map.virt = ioremap(BOOTROM_START, BOOTROM_SIZE);
+	if (!cdb89712_bootrom_map.virt) {
+		printk(KERN_NOTICE "Failed to ioremap Cdb89712 BootROM space\n");
+		err = -EIO;
+		goto out_resource;
+	}
+	simple_map_init(&cdb89712_bootrom_map);
+	bootrom_mtd = do_map_probe("map_rom", &cdb89712_bootrom_map);
+	if (!bootrom_mtd) {
+		printk("BootROM probe failed\n");
+		err = -ENXIO;
+		goto out_ioremap;
+	}
+
+	bootrom_mtd->owner = THIS_MODULE;
+	bootrom_mtd->erasesize = 0x10000;
+
+	if (mtd_device_register(bootrom_mtd, NULL, 0)) {
+		printk("BootROM device addition failed\n");
+		err = -ENOMEM;
+		goto out_probe;
+	}
+
+	return 0;
+
+out_probe:
+	map_destroy(bootrom_mtd);
+	bootrom_mtd = 0;
+out_ioremap:
+	iounmap((void *)cdb89712_bootrom_map.virt);
+out_resource:
+	release_resource (&cdb89712_bootrom_resource);
+out:
+	return err;
+}
+
+
+
+
+
+static int __init init_cdb89712_maps(void)
+{
+
+       	printk(KERN_INFO "Cirrus CDB89712 MTD mappings:\n  Flash 0x%x at 0x%x\n  SRAM 0x%x at 0x%x\n  BootROM 0x%x at 0x%x\n",
+	       FLASH_SIZE, FLASH_START, SRAM_SIZE, SRAM_START, BOOTROM_SIZE, BOOTROM_START);
+
+	init_cdb89712_flash();
+	init_cdb89712_sram();
+	init_cdb89712_bootrom();
+
+	return 0;
+}
+
+
+static void __exit cleanup_cdb89712_maps(void)
+{
+	if (sram_mtd) {
+		mtd_device_unregister(sram_mtd);
+		map_destroy(sram_mtd);
+		iounmap((void *)cdb89712_sram_map.virt);
+		release_resource (&cdb89712_sram_resource);
+	}
+
+	if (flash_mtd) {
+		mtd_device_unregister(flash_mtd);
+		map_destroy(flash_mtd);
+		iounmap((void *)cdb89712_flash_map.virt);
+		release_resource (&cdb89712_flash_resource);
+	}
+
+	if (bootrom_mtd) {
+		mtd_device_unregister(bootrom_mtd);
+		map_destroy(bootrom_mtd);
+		iounmap((void *)cdb89712_bootrom_map.virt);
+		release_resource (&cdb89712_bootrom_resource);
+	}
+}
+
+module_init(init_cdb89712_maps);
+module_exit(cleanup_cdb89712_maps);
+
+MODULE_AUTHOR("Ray L");
+MODULE_DESCRIPTION("ARM CDB89712 map driver");
+MODULE_LICENSE("GPL");
diff -ruN linux-3.10/drivers/mtd/maps/ck804xrom.c linux-3.10_patched/drivers/mtd/maps/ck804xrom.c
--- linux-3.10/drivers/mtd/maps/ck804xrom.c	2013-06-30 22:13:29.000000000 +0000
+++ linux-3.10_patched/drivers/mtd/maps/ck804xrom.c	2025-06-14 05:48:04.953173245 +0000
@@ -112,8 +112,8 @@
 }
 
 
-static int ck804xrom_init_one(struct pci_dev *pdev,
-			      const struct pci_device_id *ent)
+static int __devinit ck804xrom_init_one (struct pci_dev *pdev,
+					 const struct pci_device_id *ent)
 {
 	static char *rom_probe_types[] = { "cfi_probe", "jedec_probe", NULL };
 	u8 byte;
@@ -308,7 +308,8 @@
 
  out:
 	/* Free any left over map structures */
-	kfree(map);
+	if (map)
+		kfree(map);
 
 	/* See if I have any map structures */
 	if (list_empty(&window->maps)) {
@@ -319,7 +320,7 @@
 }
 
 
-static void ck804xrom_remove_one(struct pci_dev *pdev)
+static void __devexit ck804xrom_remove_one (struct pci_dev *pdev)
 {
 	struct ck804xrom_window *window = &ck804xrom_window;
 
diff -ruN linux-3.10/drivers/mtd/maps/dbox2-flash.c linux-3.10_patched/drivers/mtd/maps/dbox2-flash.c
--- linux-3.10/drivers/mtd/maps/dbox2-flash.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.10_patched/drivers/mtd/maps/dbox2-flash.c	2025-06-14 05:48:04.953173245 +0000
@@ -0,0 +1,123 @@
+/*
+ * D-Box 2 flash driver
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <asm/io.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+#include <linux/errno.h>
+
+/* partition_info gives details on the logical partitions that the split the
+ * single flash device into. If the size if zero we use up to the end of the
+ * device. */
+static struct mtd_partition partition_info[]= {
+	{
+	.name		= "BR bootloader",
+	.size		= 128 * 1024,
+	.offset		= 0,
+	.mask_flags	= MTD_WRITEABLE
+	},
+	{
+	.name		= "FLFS (U-Boot)",
+	.size		= 128 * 1024,
+	.offset		= MTDPART_OFS_APPEND,
+	.mask_flags	= 0
+	},
+	{
+	.name		= "Root (SquashFS)",
+	.size		= 7040 * 1024,
+	.offset		= MTDPART_OFS_APPEND,
+	.mask_flags	= 0
+	},
+	{
+	.name		= "var (JFFS2)",
+	.size		= 896 * 1024,
+	.offset		= MTDPART_OFS_APPEND,
+	.mask_flags	= 0
+	},
+	{
+	.name		= "Flash without bootloader",
+	.size		= MTDPART_SIZ_FULL,
+	.offset		= 128 * 1024,
+	.mask_flags	= 0
+	},
+	{
+	.name		= "Complete Flash",
+	.size		= MTDPART_SIZ_FULL,
+	.offset		= 0,
+	.mask_flags	= MTD_WRITEABLE
+	}
+};
+
+#define NUM_PARTITIONS ARRAY_SIZE(partition_info)
+
+#define WINDOW_ADDR 0x10000000
+#define WINDOW_SIZE 0x800000
+
+static struct mtd_info *mymtd;
+
+
+struct map_info dbox2_flash_map = {
+	.name		= "D-Box 2 flash memory",
+	.size		= WINDOW_SIZE,
+	.bankwidth	= 4,
+	.phys		= WINDOW_ADDR,
+};
+
+static int __init init_dbox2_flash(void)
+{
+       	printk(KERN_NOTICE "D-Box 2 flash driver (size->0x%X mem->0x%X)\n", WINDOW_SIZE, WINDOW_ADDR);
+	dbox2_flash_map.virt = ioremap(WINDOW_ADDR, WINDOW_SIZE);
+
+	if (!dbox2_flash_map.virt) {
+		printk("Failed to ioremap\n");
+		return -EIO;
+	}
+	simple_map_init(&dbox2_flash_map);
+
+	// Probe for dual Intel 28F320 or dual AMD
+	mymtd = do_map_probe("cfi_probe", &dbox2_flash_map);
+	if (!mymtd) {
+	    // Probe for single Intel 28F640
+	    dbox2_flash_map.bankwidth = 2;
+
+	    mymtd = do_map_probe("cfi_probe", &dbox2_flash_map);
+	}
+
+	if (mymtd) {
+		mymtd->owner = THIS_MODULE;
+
+                /* Create MTD devices for each partition. */
+		mtd_device_register(mymtd, partition_info, NUM_PARTITIONS);
+
+		return 0;
+	}
+
+	iounmap((void *)dbox2_flash_map.virt);
+	return -ENXIO;
+}
+
+static void __exit cleanup_dbox2_flash(void)
+{
+	if (mymtd) {
+		mtd_device_unregister(mymtd);
+		map_destroy(mymtd);
+	}
+	if (dbox2_flash_map.virt) {
+		iounmap((void *)dbox2_flash_map.virt);
+		dbox2_flash_map.virt = 0;
+	}
+}
+
+module_init(init_dbox2_flash);
+module_exit(cleanup_dbox2_flash);
+
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Kári Davíðsson <kd@flaga.is>, Bastian Blank <waldi@tuxbox.org>, Alexander Wild <wild@te-elektronik.com>");
+MODULE_DESCRIPTION("MTD map driver for D-Box 2 board");
diff -ruN linux-3.10/drivers/mtd/maps/dc21285.c linux-3.10_patched/drivers/mtd/maps/dc21285.c
--- linux-3.10/drivers/mtd/maps/dc21285.c	2013-06-30 22:13:29.000000000 +0000
+++ linux-3.10_patched/drivers/mtd/maps/dc21285.c	2025-06-14 05:48:04.953173245 +0000
@@ -143,8 +143,9 @@
 	.copy_from = dc21285_copy_from,
 };
 
+
 /* Partition stuff */
-static const char * const probes[] = { "RedBoot", "cmdlinepart", NULL };
+static const char *probes[] = { "RedBoot", "cmdlinepart", NULL };
 
 static int __init init_dc21285(void)
 {
diff -ruN linux-3.10/drivers/mtd/maps/dilnetpc.c linux-3.10_patched/drivers/mtd/maps/dilnetpc.c
--- linux-3.10/drivers/mtd/maps/dilnetpc.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.10_patched/drivers/mtd/maps/dilnetpc.c	2025-06-14 05:48:04.953173245 +0000
@@ -0,0 +1,496 @@
+/* dilnetpc.c -- MTD map driver for SSV DIL/Net PC Boards "DNP" and "ADNP"
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
+ *
+ * The DIL/Net PC is a tiny embedded PC board made by SSV Embedded Systems
+ * featuring the AMD Elan SC410 processor. There are two variants of this
+ * board: DNP/1486 and ADNP/1486. The DNP version has 2 megs of flash
+ * ROM (Intel 28F016S3) and 8 megs of DRAM, the ADNP version has 4 megs
+ * flash and 16 megs of RAM.
+ * For details, see http://www.ssv-embedded.de/ssv/pc104/p169.htm
+ * and http://www.ssv-embedded.de/ssv/pc104/p170.htm
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/string.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/concat.h>
+
+#include <asm/io.h>
+
+/*
+** The DIL/NetPC keeps its BIOS in two distinct flash blocks.
+** Destroying any of these blocks transforms the DNPC into
+** a paperweight (albeit not a very useful one, considering
+** it only weighs a few grams).
+**
+** Therefore, the BIOS blocks must never be erased or written to
+** except by people who know exactly what they are doing (e.g.
+** to install a BIOS update). These partitions are marked read-only
+** by default, but can be made read/write by undefining
+** DNPC_BIOS_BLOCKS_WRITEPROTECTED:
+*/
+#define DNPC_BIOS_BLOCKS_WRITEPROTECTED
+
+/*
+** The ID string (in ROM) is checked to determine whether we
+** are running on a DNP/1486 or ADNP/1486
+*/
+#define BIOSID_BASE	0x000fe100
+
+#define ID_DNPC	"DNP1486"
+#define ID_ADNP	"ADNP1486"
+
+/*
+** Address where the flash should appear in CPU space
+*/
+#define FLASH_BASE	0x2000000
+
+/*
+** Chip Setup and Control (CSC) indexed register space
+*/
+#define CSC_INDEX	0x22
+#define CSC_DATA	0x23
+
+#define CSC_MMSWAR	0x30	/* MMS window C-F attributes register */
+#define CSC_MMSWDSR	0x31	/* MMS window C-F device select register */
+
+#define CSC_RBWR	0xa7	/* GPIO Read-Back/Write Register B */
+
+#define CSC_CR		0xd0	/* internal I/O device disable/Echo */
+				/* Z-bus/configuration register */
+
+#define CSC_PCCMDCR	0xf1	/* PC card mode and DMA control register */
+
+
+/*
+** PC Card indexed register space:
+*/
+
+#define PCC_INDEX	0x3e0
+#define PCC_DATA	0x3e1
+
+#define PCC_AWER_B		0x46	/* Socket B Address Window enable register */
+#define PCC_MWSAR_1_Lo	0x58	/* memory window 1 start address low register */
+#define PCC_MWSAR_1_Hi	0x59	/* memory window 1 start address high register */
+#define PCC_MWEAR_1_Lo	0x5A	/* memory window 1 stop address low register */
+#define PCC_MWEAR_1_Hi	0x5B	/* memory window 1 stop address high register */
+#define PCC_MWAOR_1_Lo	0x5C	/* memory window 1 address offset low register */
+#define PCC_MWAOR_1_Hi	0x5D	/* memory window 1 address offset high register */
+
+
+/*
+** Access to SC4x0's Chip Setup and Control (CSC)
+** and PC Card (PCC) indexed registers:
+*/
+static inline void setcsc(int reg, unsigned char data)
+{
+	outb(reg, CSC_INDEX);
+	outb(data, CSC_DATA);
+}
+
+static inline unsigned char getcsc(int reg)
+{
+	outb(reg, CSC_INDEX);
+	return(inb(CSC_DATA));
+}
+
+static inline void setpcc(int reg, unsigned char data)
+{
+	outb(reg, PCC_INDEX);
+	outb(data, PCC_DATA);
+}
+
+static inline unsigned char getpcc(int reg)
+{
+	outb(reg, PCC_INDEX);
+	return(inb(PCC_DATA));
+}
+
+
+/*
+************************************************************
+** Enable access to DIL/NetPC's flash by mapping it into
+** the SC4x0's MMS Window C.
+************************************************************
+*/
+static void dnpc_map_flash(unsigned long flash_base, unsigned long flash_size)
+{
+	unsigned long flash_end = flash_base + flash_size - 1;
+
+	/*
+	** enable setup of MMS windows C-F:
+	*/
+	/* - enable PC Card indexed register space */
+	setcsc(CSC_CR, getcsc(CSC_CR) | 0x2);
+	/* - set PC Card controller to operate in standard mode */
+	setcsc(CSC_PCCMDCR, getcsc(CSC_PCCMDCR) & ~1);
+
+	/*
+	** Program base address and end address of window
+	** where the flash ROM should appear in CPU address space
+	*/
+	setpcc(PCC_MWSAR_1_Lo, (flash_base >> 12) & 0xff);
+	setpcc(PCC_MWSAR_1_Hi, (flash_base >> 20) & 0x3f);
+	setpcc(PCC_MWEAR_1_Lo, (flash_end >> 12) & 0xff);
+	setpcc(PCC_MWEAR_1_Hi, (flash_end >> 20) & 0x3f);
+
+	/* program offset of first flash location to appear in this window (0) */
+	setpcc(PCC_MWAOR_1_Lo, ((0 - flash_base) >> 12) & 0xff);
+	setpcc(PCC_MWAOR_1_Hi, ((0 - flash_base)>> 20) & 0x3f);
+
+	/* set attributes for MMS window C: non-cacheable, write-enabled */
+	setcsc(CSC_MMSWAR, getcsc(CSC_MMSWAR) & ~0x11);
+
+	/* select physical device ROMCS0 (i.e. flash) for MMS Window C */
+	setcsc(CSC_MMSWDSR, getcsc(CSC_MMSWDSR) & ~0x03);
+
+	/* enable memory window 1 */
+	setpcc(PCC_AWER_B, getpcc(PCC_AWER_B) | 0x02);
+
+	/* now disable PC Card indexed register space again */
+	setcsc(CSC_CR, getcsc(CSC_CR) & ~0x2);
+}
+
+
+/*
+************************************************************
+** Disable access to DIL/NetPC's flash by mapping it into
+** the SC4x0's MMS Window C.
+************************************************************
+*/
+static void dnpc_unmap_flash(void)
+{
+	/* - enable PC Card indexed register space */
+	setcsc(CSC_CR, getcsc(CSC_CR) | 0x2);
+
+	/* disable memory window 1 */
+	setpcc(PCC_AWER_B, getpcc(PCC_AWER_B) & ~0x02);
+
+	/* now disable PC Card indexed register space again */
+	setcsc(CSC_CR, getcsc(CSC_CR) & ~0x2);
+}
+
+
+
+/*
+************************************************************
+** Enable/Disable VPP to write to flash
+************************************************************
+*/
+
+static DEFINE_SPINLOCK(dnpc_spin);
+static int        vpp_counter = 0;
+/*
+** This is what has to be done for the DNP board ..
+*/
+static void dnp_set_vpp(struct map_info *not_used, int on)
+{
+	spin_lock_irq(&dnpc_spin);
+
+	if (on)
+	{
+		if(++vpp_counter == 1)
+			setcsc(CSC_RBWR, getcsc(CSC_RBWR) & ~0x4);
+	}
+	else
+	{
+		if(--vpp_counter == 0)
+			setcsc(CSC_RBWR, getcsc(CSC_RBWR) | 0x4);
+		else
+			BUG_ON(vpp_counter < 0);
+	}
+	spin_unlock_irq(&dnpc_spin);
+}
+
+/*
+** .. and this the ADNP version:
+*/
+static void adnp_set_vpp(struct map_info *not_used, int on)
+{
+	spin_lock_irq(&dnpc_spin);
+
+	if (on)
+	{
+		if(++vpp_counter == 1)
+			setcsc(CSC_RBWR, getcsc(CSC_RBWR) & ~0x8);
+	}
+	else
+	{
+		if(--vpp_counter == 0)
+			setcsc(CSC_RBWR, getcsc(CSC_RBWR) | 0x8);
+		else
+			BUG_ON(vpp_counter < 0);
+	}
+	spin_unlock_irq(&dnpc_spin);
+}
+
+
+
+#define DNP_WINDOW_SIZE		0x00200000	/*  DNP flash size is 2MiB  */
+#define ADNP_WINDOW_SIZE	0x00400000	/* ADNP flash size is 4MiB */
+#define WINDOW_ADDR		FLASH_BASE
+
+static struct map_info dnpc_map = {
+	.name = "ADNP Flash Bank",
+	.size = ADNP_WINDOW_SIZE,
+	.bankwidth = 1,
+	.set_vpp = adnp_set_vpp,
+	.phys = WINDOW_ADDR
+};
+
+/*
+** The layout of the flash is somewhat "strange":
+**
+** 1.  960 KiB (15 blocks) : Space for ROM Bootloader and user data
+** 2.   64 KiB (1 block)   : System BIOS
+** 3.  960 KiB (15 blocks) : User Data (DNP model) or
+** 3. 3008 KiB (47 blocks) : User Data (ADNP model)
+** 4.   64 KiB (1 block)   : System BIOS Entry
+*/
+
+static struct mtd_partition partition_info[]=
+{
+	{
+		.name =		"ADNP boot",
+		.offset =	0,
+		.size =		0xf0000,
+	},
+	{
+		.name =		"ADNP system BIOS",
+		.offset =	MTDPART_OFS_NXTBLK,
+		.size =		0x10000,
+#ifdef DNPC_BIOS_BLOCKS_WRITEPROTECTED
+		.mask_flags =	MTD_WRITEABLE,
+#endif
+	},
+	{
+		.name =		"ADNP file system",
+		.offset =	MTDPART_OFS_NXTBLK,
+		.size =		0x2f0000,
+	},
+	{
+		.name =		"ADNP system BIOS entry",
+		.offset =	MTDPART_OFS_NXTBLK,
+		.size =		MTDPART_SIZ_FULL,
+#ifdef DNPC_BIOS_BLOCKS_WRITEPROTECTED
+		.mask_flags =	MTD_WRITEABLE,
+#endif
+	},
+};
+
+#define NUM_PARTITIONS ARRAY_SIZE(partition_info)
+
+static struct mtd_info *mymtd;
+static struct mtd_info *lowlvl_parts[NUM_PARTITIONS];
+static struct mtd_info *merged_mtd;
+
+/*
+** "Highlevel" partition info:
+**
+** Using the MTD concat layer, we can re-arrange partitions to our
+** liking: we construct a virtual MTD device by concatenating the
+** partitions, specifying the sequence such that the boot block
+** is immediately followed by the filesystem block (i.e. the stupid
+** system BIOS block is mapped to a different place). When re-partitioning
+** this concatenated MTD device, we can set the boot block size to
+** an arbitrary (though erase block aligned) value i.e. not one that
+** is dictated by the flash's physical layout. We can thus set the
+** boot block to be e.g. 64 KB (which is fully sufficient if we want
+** to boot an etherboot image) or to -say- 1.5 MB if we want to boot
+** a large kernel image. In all cases, the remainder of the flash
+** is available as file system space.
+*/
+
+static struct mtd_partition higlvl_partition_info[]=
+{
+	{
+		.name =		"ADNP boot block",
+		.offset =	0,
+		.size =		CONFIG_MTD_DILNETPC_BOOTSIZE,
+	},
+	{
+		.name =		"ADNP file system space",
+		.offset =	MTDPART_OFS_NXTBLK,
+		.size =		ADNP_WINDOW_SIZE-CONFIG_MTD_DILNETPC_BOOTSIZE-0x20000,
+	},
+	{
+		.name =		"ADNP system BIOS + BIOS Entry",
+		.offset =	MTDPART_OFS_NXTBLK,
+		.size =		MTDPART_SIZ_FULL,
+#ifdef DNPC_BIOS_BLOCKS_WRITEPROTECTED
+		.mask_flags =	MTD_WRITEABLE,
+#endif
+	},
+};
+
+#define NUM_HIGHLVL_PARTITIONS ARRAY_SIZE(higlvl_partition_info)
+
+
+static int dnp_adnp_probe(void)
+{
+	char *biosid, rc = -1;
+
+	biosid = (char*)ioremap(BIOSID_BASE, 16);
+	if(biosid)
+	{
+		if(!strcmp(biosid, ID_DNPC))
+			rc = 1;		/* this is a DNPC  */
+		else if(!strcmp(biosid, ID_ADNP))
+			rc = 0;		/* this is a ADNPC */
+	}
+	iounmap((void *)biosid);
+	return(rc);
+}
+
+
+static int __init init_dnpc(void)
+{
+	int is_dnp;
+
+	/*
+	** determine hardware (DNP/ADNP/invalid)
+	*/
+	if((is_dnp = dnp_adnp_probe()) < 0)
+		return -ENXIO;
+
+	/*
+	** Things are set up for ADNP by default
+	** -> modify all that needs to be different for DNP
+	*/
+	if(is_dnp)
+	{	/*
+		** Adjust window size, select correct set_vpp function.
+		** The partitioning scheme is identical on both DNP
+		** and ADNP except for the size of the third partition.
+		*/
+		int i;
+		dnpc_map.size          = DNP_WINDOW_SIZE;
+		dnpc_map.set_vpp       = dnp_set_vpp;
+		partition_info[2].size = 0xf0000;
+
+		/*
+		** increment all string pointers so the leading 'A' gets skipped,
+		** thus turning all occurrences of "ADNP ..." into "DNP ..."
+		*/
+		++dnpc_map.name;
+		for(i = 0; i < NUM_PARTITIONS; i++)
+			++partition_info[i].name;
+		higlvl_partition_info[1].size = DNP_WINDOW_SIZE -
+			CONFIG_MTD_DILNETPC_BOOTSIZE - 0x20000;
+		for(i = 0; i < NUM_HIGHLVL_PARTITIONS; i++)
+			++higlvl_partition_info[i].name;
+	}
+
+	printk(KERN_NOTICE "DIL/Net %s flash: 0x%lx at 0x%llx\n",
+		is_dnp ? "DNPC" : "ADNP", dnpc_map.size, (unsigned long long)dnpc_map.phys);
+
+	dnpc_map.virt = ioremap_nocache(dnpc_map.phys, dnpc_map.size);
+
+	dnpc_map_flash(dnpc_map.phys, dnpc_map.size);
+
+	if (!dnpc_map.virt) {
+		printk("Failed to ioremap_nocache\n");
+		return -EIO;
+	}
+	simple_map_init(&dnpc_map);
+
+	printk("FLASH virtual address: 0x%p\n", dnpc_map.virt);
+
+	mymtd = do_map_probe("jedec_probe", &dnpc_map);
+
+	if (!mymtd)
+		mymtd = do_map_probe("cfi_probe", &dnpc_map);
+
+	/*
+	** If flash probes fail, try to make flashes accessible
+	** at least as ROM. Ajust erasesize in this case since
+	** the default one (128M) will break our partitioning
+	*/
+	if (!mymtd)
+		if((mymtd = do_map_probe("map_rom", &dnpc_map)))
+			mymtd->erasesize = 0x10000;
+
+	if (!mymtd) {
+		iounmap(dnpc_map.virt);
+		return -ENXIO;
+	}
+
+	mymtd->owner = THIS_MODULE;
+
+	/*
+	** Supply pointers to lowlvl_parts[] array to add_mtd_partitions()
+	** -> add_mtd_partitions() will _not_ register MTD devices for
+	** the partitions, but will instead store pointers to the MTD
+	** objects it creates into our lowlvl_parts[] array.
+	** NOTE: we arrange the pointers such that the sequence of the
+	**       partitions gets re-arranged: partition #2 follows
+	**       partition #0.
+	*/
+	partition_info[0].mtdp = &lowlvl_parts[0];
+	partition_info[1].mtdp = &lowlvl_parts[2];
+	partition_info[2].mtdp = &lowlvl_parts[1];
+	partition_info[3].mtdp = &lowlvl_parts[3];
+
+	mtd_device_register(mymtd, partition_info, NUM_PARTITIONS);
+
+	/*
+	** now create a virtual MTD device by concatenating the for partitions
+	** (in the sequence given by the lowlvl_parts[] array.
+	*/
+	merged_mtd = mtd_concat_create(lowlvl_parts, NUM_PARTITIONS, "(A)DNP Flash Concatenated");
+	if(merged_mtd)
+	{	/*
+		** now partition the new device the way we want it. This time,
+		** we do not supply mtd pointers in higlvl_partition_info, so
+		** add_mtd_partitions() will register the devices.
+		*/
+		mtd_device_register(merged_mtd, higlvl_partition_info,
+				    NUM_HIGHLVL_PARTITIONS);
+	}
+
+	return 0;
+}
+
+static void __exit cleanup_dnpc(void)
+{
+	if(merged_mtd) {
+		mtd_device_unregister(merged_mtd);
+		mtd_concat_destroy(merged_mtd);
+	}
+
+	if (mymtd) {
+		mtd_device_unregister(mymtd);
+		map_destroy(mymtd);
+	}
+	if (dnpc_map.virt) {
+		iounmap(dnpc_map.virt);
+		dnpc_unmap_flash();
+		dnpc_map.virt = NULL;
+	}
+}
+
+module_init(init_dnpc);
+module_exit(cleanup_dnpc);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Sysgo Real-Time Solutions GmbH");
+MODULE_DESCRIPTION("MTD map driver for SSV DIL/NetPC DNP & ADNP");
diff -ruN linux-3.10/drivers/mtd/maps/dmv182.c linux-3.10_patched/drivers/mtd/maps/dmv182.c
--- linux-3.10/drivers/mtd/maps/dmv182.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.10_patched/drivers/mtd/maps/dmv182.c	2025-06-14 05:48:04.957173245 +0000
@@ -0,0 +1,146 @@
+
+/*
+ * drivers/mtd/maps/dmv182.c
+ *
+ * Flash map driver for the Dy4 SVME182 board
+ *
+ * Copyright 2003-2004, TimeSys Corporation
+ *
+ * Based on the SVME181 flash map, by Tom Nelson, Dot4, Inc. for TimeSys Corp.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <asm/io.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+#include <linux/errno.h>
+
+/*
+ * This driver currently handles only the 16MiB user flash bank 1 on the
+ * board.  It does not provide access to bank 0 (contains the Dy4 FFW), bank 2
+ * (VxWorks boot), or the optional 48MiB expansion flash.
+ *
+ * scott.wood@timesys.com: On the newer boards with 128MiB flash, it
+ * now supports the first 96MiB (the boot flash bank containing FFW
+ * is excluded).  The VxWorks loader is in partition 1.
+ */
+
+#define FLASH_BASE_ADDR 0xf0000000
+#define FLASH_BANK_SIZE (128*1024*1024)
+
+MODULE_AUTHOR("Scott Wood, TimeSys Corporation <scott.wood@timesys.com>");
+MODULE_DESCRIPTION("User-programmable flash device on the Dy4 SVME182 board");
+MODULE_LICENSE("GPL");
+
+static struct map_info svme182_map = {
+	.name		= "Dy4 SVME182",
+	.bankwidth	= 32,
+	.size		=  128 * 1024 * 1024
+};
+
+#define BOOTIMAGE_PART_SIZE		((6*1024*1024)-RESERVED_PART_SIZE)
+
+// Allow 6MiB for the kernel
+#define NEW_BOOTIMAGE_PART_SIZE  (6 * 1024 * 1024)
+// Allow 1MiB for the bootloader
+#define NEW_BOOTLOADER_PART_SIZE (1024 * 1024)
+// Use the remaining 9MiB at the end of flash for the RFS
+#define NEW_RFS_PART_SIZE        (0x01000000 - NEW_BOOTLOADER_PART_SIZE - \
+                                  NEW_BOOTIMAGE_PART_SIZE)
+
+static struct mtd_partition svme182_partitions[] = {
+	// The Lower PABS is only 128KiB, but the partition code doesn't
+	// like partitions that don't end on the largest erase block
+	// size of the device, even if all of the erase blocks in the
+	// partition are small ones.  The hardware should prevent
+	// writes to the actual PABS areas.
+	{
+		name:       "Lower PABS and CPU 0 bootloader or kernel",
+		size:       6*1024*1024,
+		offset:     0,
+	},
+	{
+		name:       "Root Filesystem",
+		size:       10*1024*1024,
+		offset:     MTDPART_OFS_NXTBLK
+	},
+	{
+		name:       "CPU1 Bootloader",
+		size:       1024*1024,
+		offset:     MTDPART_OFS_NXTBLK,
+	},
+	{
+		name:       "Extra",
+		size:       110*1024*1024,
+		offset:     MTDPART_OFS_NXTBLK
+	},
+	{
+		name:       "Foundation Firmware and Upper PABS",
+		size:       1024*1024,
+		offset:     MTDPART_OFS_NXTBLK,
+		mask_flags: MTD_WRITEABLE // read-only
+	}
+};
+
+static struct mtd_info *this_mtd;
+
+static int __init init_svme182(void)
+{
+	struct mtd_partition *partitions;
+	int num_parts = ARRAY_SIZE(svme182_partitions);
+
+	partitions = svme182_partitions;
+
+	svme182_map.virt = ioremap(FLASH_BASE_ADDR, svme182_map.size);
+
+	if (svme182_map.virt == 0) {
+		printk("Failed to ioremap FLASH memory area.\n");
+		return -EIO;
+	}
+
+	simple_map_init(&svme182_map);
+
+	this_mtd = do_map_probe("cfi_probe", &svme182_map);
+	if (!this_mtd)
+	{
+		iounmap((void *)svme182_map.virt);
+		return -ENXIO;
+	}
+
+	printk(KERN_NOTICE "SVME182 flash device: %dMiB at 0x%08x\n",
+		   this_mtd->size >> 20, FLASH_BASE_ADDR);
+
+	this_mtd->owner = THIS_MODULE;
+	mtd_device_register(this_mtd, partitions, num_parts);
+
+	return 0;
+}
+
+static void __exit cleanup_svme182(void)
+{
+	if (this_mtd)
+	{
+		mtd_device_unregister(this_mtd);
+		map_destroy(this_mtd);
+	}
+
+	if (svme182_map.virt)
+	{
+		iounmap((void *)svme182_map.virt);
+		svme182_map.virt = 0;
+	}
+
+	return;
+}
+
+module_init(init_svme182);
+module_exit(cleanup_svme182);
diff -ruN linux-3.10/drivers/mtd/maps/esb2rom.c linux-3.10_patched/drivers/mtd/maps/esb2rom.c
--- linux-3.10/drivers/mtd/maps/esb2rom.c	2013-06-30 22:13:29.000000000 +0000
+++ linux-3.10_patched/drivers/mtd/maps/esb2rom.c	2025-06-14 05:48:04.957173245 +0000
@@ -144,8 +144,8 @@
 	pci_dev_put(window->pdev);
 }
 
-static int esb2rom_init_one(struct pci_dev *pdev,
-			    const struct pci_device_id *ent)
+static int __devinit esb2rom_init_one(struct pci_dev *pdev,
+				      const struct pci_device_id *ent)
 {
 	static char *rom_probe_types[] = { "cfi_probe", "jedec_probe", NULL };
 	struct esb2rom_window *window = &esb2rom_window;
@@ -378,13 +378,13 @@
 	return 0;
 }
 
-static void esb2rom_remove_one(struct pci_dev *pdev)
+static void __devexit esb2rom_remove_one (struct pci_dev *pdev)
 {
 	struct esb2rom_window *window = &esb2rom_window;
 	esb2rom_cleanup(window);
 }
 
-static struct pci_device_id esb2rom_pci_tbl[] = {
+static struct pci_device_id esb2rom_pci_tbl[] __devinitdata = {
 	{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82801BA_0,
 	  PCI_ANY_ID, PCI_ANY_ID, },
 	{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82801CA_0,
diff -ruN linux-3.10/drivers/mtd/maps/fortunet.c linux-3.10_patched/drivers/mtd/maps/fortunet.c
--- linux-3.10/drivers/mtd/maps/fortunet.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.10_patched/drivers/mtd/maps/fortunet.c	2025-06-14 05:48:04.957173245 +0000
@@ -0,0 +1,277 @@
+/* fortunet.c memory map
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/string.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/io.h>
+
+#define MAX_NUM_REGIONS		4
+#define MAX_NUM_PARTITIONS	8
+
+#define DEF_WINDOW_ADDR_PHY	0x00000000
+#define DEF_WINDOW_SIZE		0x00800000		// 8 Mega Bytes
+
+#define MTD_FORTUNET_PK		"MTD FortuNet: "
+
+#define MAX_NAME_SIZE		128
+
+struct map_region
+{
+	int			window_addr_physical;
+	int			altbankwidth;
+	struct map_info		map_info;
+	struct mtd_info		*mymtd;
+	struct mtd_partition	parts[MAX_NUM_PARTITIONS];
+	char			map_name[MAX_NAME_SIZE];
+	char			parts_name[MAX_NUM_PARTITIONS][MAX_NAME_SIZE];
+};
+
+static struct map_region	map_regions[MAX_NUM_REGIONS];
+static int			map_regions_set[MAX_NUM_REGIONS] = {0,0,0,0};
+static int			map_regions_parts[MAX_NUM_REGIONS] = {0,0,0,0};
+
+
+
+struct map_info default_map = {
+	.size = DEF_WINDOW_SIZE,
+	.bankwidth = 4,
+};
+
+static char * __init get_string_option(char *dest,int dest_size,char *sor)
+{
+	if(!dest_size)
+		return sor;
+	dest_size--;
+	while(*sor)
+	{
+		if(*sor==',')
+		{
+			sor++;
+			break;
+		}
+		else if(*sor=='\"')
+		{
+			sor++;
+			while(*sor)
+			{
+				if(*sor=='\"')
+				{
+					sor++;
+					break;
+				}
+				*dest = *sor;
+				dest++;
+				sor++;
+				dest_size--;
+				if(!dest_size)
+				{
+					*dest = 0;
+					return sor;
+				}
+			}
+		}
+		else
+		{
+			*dest = *sor;
+			dest++;
+			sor++;
+			dest_size--;
+			if(!dest_size)
+			{
+				*dest = 0;
+				return sor;
+			}
+		}
+	}
+	*dest = 0;
+	return sor;
+}
+
+static int __init MTD_New_Region(char *line)
+{
+	char	string[MAX_NAME_SIZE];
+	int	params[6];
+	get_options (get_string_option(string,sizeof(string),line),6,params);
+	if(params[0]<1)
+	{
+		printk(MTD_FORTUNET_PK "Bad parameters for MTD Region "
+			" name,region-number[,base,size,bankwidth,altbankwidth]\n");
+		return 1;
+	}
+	if((params[1]<0)||(params[1]>=MAX_NUM_REGIONS))
+	{
+		printk(MTD_FORTUNET_PK "Bad region index of %d only have 0..%u regions\n",
+			params[1],MAX_NUM_REGIONS-1);
+		return 1;
+	}
+	memset(&map_regions[params[1]],0,sizeof(map_regions[params[1]]));
+	memcpy(&map_regions[params[1]].map_info,
+		&default_map,sizeof(map_regions[params[1]].map_info));
+        map_regions_set[params[1]] = 1;
+        map_regions[params[1]].window_addr_physical = DEF_WINDOW_ADDR_PHY;
+        map_regions[params[1]].altbankwidth = 2;
+        map_regions[params[1]].mymtd = NULL;
+	map_regions[params[1]].map_info.name = map_regions[params[1]].map_name;
+	strcpy(map_regions[params[1]].map_info.name,string);
+	if(params[0]>1)
+	{
+		map_regions[params[1]].window_addr_physical = params[2];
+	}
+	if(params[0]>2)
+	{
+		map_regions[params[1]].map_info.size = params[3];
+	}
+	if(params[0]>3)
+	{
+		map_regions[params[1]].map_info.bankwidth = params[4];
+	}
+	if(params[0]>4)
+	{
+		map_regions[params[1]].altbankwidth = params[5];
+	}
+	return 1;
+}
+
+static int __init MTD_New_Partition(char *line)
+{
+	char	string[MAX_NAME_SIZE];
+	int	params[4];
+	get_options (get_string_option(string,sizeof(string),line),4,params);
+	if(params[0]<3)
+	{
+		printk(MTD_FORTUNET_PK "Bad parameters for MTD Partition "
+			" name,region-number,size,offset\n");
+		return 1;
+	}
+	if((params[1]<0)||(params[1]>=MAX_NUM_REGIONS))
+	{
+		printk(MTD_FORTUNET_PK "Bad region index of %d only have 0..%u regions\n",
+			params[1],MAX_NUM_REGIONS-1);
+		return 1;
+	}
+	if(map_regions_parts[params[1]]>=MAX_NUM_PARTITIONS)
+	{
+		printk(MTD_FORTUNET_PK "Out of space for partition in this region\n");
+		return 1;
+	}
+	map_regions[params[1]].parts[map_regions_parts[params[1]]].name =
+		map_regions[params[1]].	parts_name[map_regions_parts[params[1]]];
+	strcpy(map_regions[params[1]].parts[map_regions_parts[params[1]]].name,string);
+	map_regions[params[1]].parts[map_regions_parts[params[1]]].size =
+		params[2];
+	map_regions[params[1]].parts[map_regions_parts[params[1]]].offset =
+		params[3];
+	map_regions[params[1]].parts[map_regions_parts[params[1]]].mask_flags = 0;
+	map_regions_parts[params[1]]++;
+	return 1;
+}
+
+__setup("MTD_Region=", MTD_New_Region);
+__setup("MTD_Partition=", MTD_New_Partition);
+
+/* Backwards-spelling-compatibility */
+__setup("MTD_Partion=", MTD_New_Partition);
+
+static int __init init_fortunet(void)
+{
+	int	ix,iy;
+	for(iy=ix=0;ix<MAX_NUM_REGIONS;ix++)
+	{
+		if(map_regions_parts[ix]&&(!map_regions_set[ix]))
+		{
+			printk(MTD_FORTUNET_PK "Region %d is not setup (Setting to default)\n",
+				ix);
+			memset(&map_regions[ix],0,sizeof(map_regions[ix]));
+			memcpy(&map_regions[ix].map_info,&default_map,
+				sizeof(map_regions[ix].map_info));
+			map_regions_set[ix] = 1;
+			map_regions[ix].window_addr_physical = DEF_WINDOW_ADDR_PHY;
+			map_regions[ix].altbankwidth = 2;
+			map_regions[ix].mymtd = NULL;
+			map_regions[ix].map_info.name = map_regions[ix].map_name;
+			strcpy(map_regions[ix].map_info.name,"FORTUNET");
+		}
+		if(map_regions_set[ix])
+		{
+			iy++;
+			printk(KERN_NOTICE MTD_FORTUNET_PK "%s flash device at physically "
+				" address %x size %x\n",
+				map_regions[ix].map_info.name,
+				map_regions[ix].window_addr_physical,
+				map_regions[ix].map_info.size);
+
+			map_regions[ix].map_info.phys =	map_regions[ix].window_addr_physical,
+
+			map_regions[ix].map_info.virt =
+				ioremap_nocache(
+				map_regions[ix].window_addr_physical,
+				map_regions[ix].map_info.size);
+			if(!map_regions[ix].map_info.virt)
+			{
+				int j = 0;
+				printk(MTD_FORTUNET_PK "%s flash failed to ioremap!\n",
+					map_regions[ix].map_info.name);
+				for (j = 0 ; j < ix; j++)
+					iounmap(map_regions[j].map_info.virt);
+				return -ENXIO;
+			}
+			simple_map_init(&map_regions[ix].map_info);
+
+			printk(KERN_NOTICE MTD_FORTUNET_PK "%s flash is virtually at: %x\n",
+				map_regions[ix].map_info.name,
+				map_regions[ix].map_info.virt);
+			map_regions[ix].mymtd = do_map_probe("cfi_probe",
+				&map_regions[ix].map_info);
+			if((!map_regions[ix].mymtd)&&(
+				map_regions[ix].altbankwidth!=map_regions[ix].map_info.bankwidth))
+			{
+				printk(KERN_NOTICE MTD_FORTUNET_PK "Trying alternate bankwidth "
+					"for %s flash.\n",
+					map_regions[ix].map_info.name);
+				map_regions[ix].map_info.bankwidth =
+					map_regions[ix].altbankwidth;
+				map_regions[ix].mymtd = do_map_probe("cfi_probe",
+					&map_regions[ix].map_info);
+			}
+			map_regions[ix].mymtd->owner = THIS_MODULE;
+			mtd_device_register(map_regions[ix].mymtd,
+					    map_regions[ix].parts,
+					    map_regions_parts[ix]);
+		}
+	}
+	if(iy)
+		return 0;
+	return -ENXIO;
+}
+
+static void __exit cleanup_fortunet(void)
+{
+	int	ix;
+	for(ix=0;ix<MAX_NUM_REGIONS;ix++)
+	{
+		if(map_regions_set[ix])
+		{
+			if( map_regions[ix].mymtd )
+			{
+				mtd_device_unregister(map_regions[ix].mymtd);
+				map_destroy( map_regions[ix].mymtd );
+			}
+			iounmap((void *)map_regions[ix].map_info.virt);
+		}
+	}
+}
+
+module_init(init_fortunet);
+module_exit(cleanup_fortunet);
+
+MODULE_AUTHOR("FortuNet, Inc.");
+MODULE_DESCRIPTION("MTD map driver for FortuNet boards");
diff -ruN linux-3.10/drivers/mtd/maps/gpio-addr-flash.c linux-3.10_patched/drivers/mtd/maps/gpio-addr-flash.c
--- linux-3.10/drivers/mtd/maps/gpio-addr-flash.c	2013-06-30 22:13:29.000000000 +0000
+++ linux-3.10_patched/drivers/mtd/maps/gpio-addr-flash.c	2025-06-14 05:48:04.957173245 +0000
@@ -26,8 +26,7 @@
 #include <linux/slab.h>
 #include <linux/types.h>
 
-#define pr_devinit(fmt, args...) \
-	({ static const char __fmt[] = fmt; printk(__fmt, ## args); })
+#define pr_devinit(fmt, args...) ({ static const __devinitconst char __fmt[] = fmt; printk(__fmt, ## args); })
 
 #define DRIVER_NAME "gpio-addr-flash"
 #define PFX DRIVER_NAME ": "
@@ -143,8 +142,7 @@
  *
  * See gf_copy_from() caveat.
  */
-static void gf_copy_to(struct map_info *map, unsigned long to,
-		       const void *from, ssize_t len)
+static void gf_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
 {
 	struct async_state *state = gf_map_info_to_state(map);
 
@@ -157,8 +155,7 @@
 	memcpy_toio(map->virt + (to % state->win_size), from, len);
 }
 
-static const char * const part_probe_types[] = {
-	"cmdlinepart", "RedBoot", NULL };
+static const char *part_probe_types[] = { "cmdlinepart", "RedBoot", NULL };
 
 /**
  * gpio_flash_probe() - setup a mapping for a GPIO assisted flash
@@ -188,7 +185,7 @@
  *	...
  * };
  */
-static int gpio_flash_probe(struct platform_device *pdev)
+static int __devinit gpio_flash_probe(struct platform_device *pdev)
 {
 	size_t i, arr_size;
 	struct physmap_flash_data *pdata;
@@ -261,7 +258,7 @@
 	return 0;
 }
 
-static int gpio_flash_remove(struct platform_device *pdev)
+static int __devexit gpio_flash_remove(struct platform_device *pdev)
 {
 	struct async_state *state = platform_get_drvdata(pdev);
 	size_t i = 0;
@@ -276,7 +273,7 @@
 
 static struct platform_driver gpio_flash_driver = {
 	.probe		= gpio_flash_probe,
-	.remove		= gpio_flash_remove,
+	.remove		= __devexit_p(gpio_flash_remove),
 	.driver		= {
 		.name	= DRIVER_NAME,
 	},
diff -ruN linux-3.10/drivers/mtd/maps/h720x-flash.c linux-3.10_patched/drivers/mtd/maps/h720x-flash.c
--- linux-3.10/drivers/mtd/maps/h720x-flash.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.10_patched/drivers/mtd/maps/h720x-flash.c	2025-06-14 05:48:04.957173245 +0000
@@ -0,0 +1,120 @@
+/*
+ * Flash memory access on Hynix GMS30C7201/HMS30C7202 based
+ * evaluation boards
+ *
+ * (C) 2002 Jungjun Kim <jungjun.kim@hynix.com>
+ *     2003 Thomas Gleixner <tglx@linutronix.de>
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+#include <mach/hardware.h>
+#include <asm/io.h>
+
+static struct mtd_info *mymtd;
+
+static struct map_info h720x_map = {
+	.name =		"H720X",
+	.bankwidth =	4,
+	.size =		H720X_FLASH_SIZE,
+	.phys =		H720X_FLASH_PHYS,
+};
+
+static struct mtd_partition h720x_partitions[] = {
+        {
+                .name = "ArMon",
+                .size = 0x00080000,
+                .offset = 0,
+                .mask_flags = MTD_WRITEABLE
+        },{
+                .name = "Env",
+                .size = 0x00040000,
+                .offset = 0x00080000,
+                .mask_flags = MTD_WRITEABLE
+        },{
+                .name = "Kernel",
+                .size = 0x00180000,
+                .offset = 0x000c0000,
+                .mask_flags = MTD_WRITEABLE
+        },{
+                .name = "Ramdisk",
+                .size = 0x00400000,
+                .offset = 0x00240000,
+                .mask_flags = MTD_WRITEABLE
+        },{
+                .name = "jffs2",
+                .size = MTDPART_SIZ_FULL,
+                .offset = MTDPART_OFS_APPEND
+        }
+};
+
+#define NUM_PARTITIONS ARRAY_SIZE(h720x_partitions)
+
+/*
+ * Initialize FLASH support
+ */
+static int __init h720x_mtd_init(void)
+{
+	h720x_map.virt = ioremap(h720x_map.phys, h720x_map.size);
+
+	if (!h720x_map.virt) {
+		printk(KERN_ERR "H720x-MTD: ioremap failed\n");
+		return -EIO;
+	}
+
+	simple_map_init(&h720x_map);
+
+	// Probe for flash bankwidth 4
+	printk (KERN_INFO "H720x-MTD probing 32bit FLASH\n");
+	mymtd = do_map_probe("cfi_probe", &h720x_map);
+	if (!mymtd) {
+		printk (KERN_INFO "H720x-MTD probing 16bit FLASH\n");
+	    // Probe for bankwidth 2
+	    h720x_map.bankwidth = 2;
+	    mymtd = do_map_probe("cfi_probe", &h720x_map);
+	}
+
+	if (mymtd) {
+		mymtd->owner = THIS_MODULE;
+
+		mtd_device_parse_register(mymtd, NULL, NULL,
+					  h720x_partitions, NUM_PARTITIONS);
+		return 0;
+	}
+
+	iounmap((void *)h720x_map.virt);
+	return -ENXIO;
+}
+
+/*
+ * Cleanup
+ */
+static void __exit h720x_mtd_cleanup(void)
+{
+
+	if (mymtd) {
+		mtd_device_unregister(mymtd);
+		map_destroy(mymtd);
+	}
+
+	if (h720x_map.virt) {
+		iounmap((void *)h720x_map.virt);
+		h720x_map.virt = 0;
+	}
+}
+
+
+module_init(h720x_mtd_init);
+module_exit(h720x_mtd_cleanup);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Thomas Gleixner <tglx@linutronix.de>");
+MODULE_DESCRIPTION("MTD map driver for Hynix evaluation boards");
diff -ruN linux-3.10/drivers/mtd/maps/ichxrom.c linux-3.10_patched/drivers/mtd/maps/ichxrom.c
--- linux-3.10/drivers/mtd/maps/ichxrom.c	2013-06-30 22:13:29.000000000 +0000
+++ linux-3.10_patched/drivers/mtd/maps/ichxrom.c	2025-06-14 05:48:04.957173245 +0000
@@ -84,8 +84,8 @@
 }
 
 
-static int ichxrom_init_one(struct pci_dev *pdev,
-			    const struct pci_device_id *ent)
+static int __devinit ichxrom_init_one (struct pci_dev *pdev,
+	const struct pci_device_id *ent)
 {
 	static char *rom_probe_types[] = { "cfi_probe", "jedec_probe", NULL };
 	struct ichxrom_window *window = &ichxrom_window;
@@ -315,13 +315,13 @@
 }
 
 
-static void ichxrom_remove_one(struct pci_dev *pdev)
+static void __devexit ichxrom_remove_one (struct pci_dev *pdev)
 {
 	struct ichxrom_window *window = &ichxrom_window;
 	ichxrom_cleanup(window);
 }
 
-static struct pci_device_id ichxrom_pci_tbl[] = {
+static struct pci_device_id ichxrom_pci_tbl[] __devinitdata = {
 	{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82801BA_0,
 	  PCI_ANY_ID, PCI_ANY_ID, },
 	{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82801CA_0,
diff -ruN linux-3.10/drivers/mtd/maps/impa7.c linux-3.10_patched/drivers/mtd/maps/impa7.c
--- linux-3.10/drivers/mtd/maps/impa7.c	2013-06-30 22:13:29.000000000 +0000
+++ linux-3.10_patched/drivers/mtd/maps/impa7.c	2025-06-14 05:48:04.957173245 +0000
@@ -24,12 +24,14 @@
 #define NUM_FLASHBANKS 2
 #define BUSWIDTH     4
 
+/* can be { "cfi_probe", "jedec_probe", "map_rom", NULL } */
+#define PROBETYPES { "jedec_probe", NULL }
+
 #define MSG_PREFIX "impA7:"   /* prefix for our printk()'s */
 #define MTDID      "impa7-%d"  /* for mtdparts= partitioning */
 
 static struct mtd_info *impa7_mtd[NUM_FLASHBANKS];
 
-static const char * const rom_probe_types[] = { "jedec_probe", NULL };
 
 static struct map_info impa7_map[NUM_FLASHBANKS] = {
 	{
@@ -58,7 +60,8 @@
 
 static int __init init_impa7(void)
 {
-	const char * const *type;
+	static const char *rom_probe_types[] = PROBETYPES;
+	const char **type;
 	int i;
 	static struct { u_long addr; u_long size; } pt[NUM_FLASHBANKS] = {
 	  { WINDOW_ADDR0, WINDOW_SIZE0 },
diff -ruN linux-3.10/drivers/mtd/maps/intel_vr_nor.c linux-3.10_patched/drivers/mtd/maps/intel_vr_nor.c
--- linux-3.10/drivers/mtd/maps/intel_vr_nor.c	2013-06-30 22:13:29.000000000 +0000
+++ linux-3.10_patched/drivers/mtd/maps/intel_vr_nor.c	2025-06-14 05:48:04.957173245 +0000
@@ -63,28 +63,28 @@
 #define TIMING_BYTE_EN		(1 <<  0)	/* 8-bit vs 16-bit bus */
 #define TIMING_MASK		0x3FFF0000
 
-static void vr_nor_destroy_partitions(struct vr_nor_mtd *p)
+static void __devexit vr_nor_destroy_partitions(struct vr_nor_mtd *p)
 {
 	mtd_device_unregister(p->info);
 }
 
-static int vr_nor_init_partitions(struct vr_nor_mtd *p)
+static int __devinit vr_nor_init_partitions(struct vr_nor_mtd *p)
 {
 	/* register the flash bank */
 	/* partition the flash bank */
 	return mtd_device_parse_register(p->info, NULL, NULL, NULL, 0);
 }
 
-static void vr_nor_destroy_mtd_setup(struct vr_nor_mtd *p)
+static void __devexit vr_nor_destroy_mtd_setup(struct vr_nor_mtd *p)
 {
 	map_destroy(p->info);
 }
 
-static int vr_nor_mtd_setup(struct vr_nor_mtd *p)
+static int __devinit vr_nor_mtd_setup(struct vr_nor_mtd *p)
 {
-	static const char * const probe_types[] =
+	static const char *probe_types[] =
 	    { "cfi_probe", "jedec_probe", NULL };
-	const char * const *type;
+	const char **type;
 
 	for (type = probe_types; !p->info && *type; type++)
 		p->info = do_map_probe(*type, &p->map);
@@ -96,7 +96,7 @@
 	return 0;
 }
 
-static void vr_nor_destroy_maps(struct vr_nor_mtd *p)
+static void __devexit vr_nor_destroy_maps(struct vr_nor_mtd *p)
 {
 	unsigned int exp_timing_cs0;
 
@@ -116,7 +116,7 @@
  * Initialize the map_info structure and map the flash.
  * Returns 0 on success, nonzero otherwise.
  */
-static int vr_nor_init_maps(struct vr_nor_mtd *p)
+static int __devinit vr_nor_init_maps(struct vr_nor_mtd *p)
 {
 	unsigned long csr_phys, csr_len;
 	unsigned long win_phys, win_len;
@@ -176,7 +176,7 @@
 	{0,}
 };
 
-static void vr_nor_pci_remove(struct pci_dev *dev)
+static void __devexit vr_nor_pci_remove(struct pci_dev *dev)
 {
 	struct vr_nor_mtd *p = pci_get_drvdata(dev);
 
@@ -189,7 +189,8 @@
 	pci_disable_device(dev);
 }
 
-static int vr_nor_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
+static int __devinit
+vr_nor_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
 {
 	struct vr_nor_mtd *p = NULL;
 	unsigned int exp_timing_cs0;
@@ -255,11 +256,22 @@
 static struct pci_driver vr_nor_pci_driver = {
 	.name = DRV_NAME,
 	.probe = vr_nor_pci_probe,
-	.remove = vr_nor_pci_remove,
+	.remove = __devexit_p(vr_nor_pci_remove),
 	.id_table = vr_nor_pci_ids,
 };
 
-module_pci_driver(vr_nor_pci_driver);
+static int __init vr_nor_mtd_init(void)
+{
+	return pci_register_driver(&vr_nor_pci_driver);
+}
+
+static void __exit vr_nor_mtd_exit(void)
+{
+	pci_unregister_driver(&vr_nor_pci_driver);
+}
+
+module_init(vr_nor_mtd_init);
+module_exit(vr_nor_mtd_exit);
 
 MODULE_AUTHOR("Andy Lowe");
 MODULE_DESCRIPTION("MTD map driver for NOR flash on Intel Vermilion Range");
diff -ruN linux-3.10/drivers/mtd/maps/ixp2000.c linux-3.10_patched/drivers/mtd/maps/ixp2000.c
--- linux-3.10/drivers/mtd/maps/ixp2000.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.10_patched/drivers/mtd/maps/ixp2000.c	2025-06-14 05:48:04.957173245 +0000
@@ -0,0 +1,253 @@
+/*
+ * drivers/mtd/maps/ixp2000.c
+ *
+ * Mapping for the Intel XScale IXP2000 based systems
+ *
+ * Copyright (C) 2002 Intel Corp.
+ * Copyright (C) 2003-2004 MontaVista Software, Inc.
+ *
+ * Original Author: Naeem M Afzal <naeem.m.afzal@intel.com>
+ * Maintainer: Deepak Saxena <dsaxena@plexity.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/ioport.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/io.h>
+#include <mach/hardware.h>
+#include <asm/mach/flash.h>
+
+#include <linux/reboot.h>
+
+struct ixp2000_flash_info {
+	struct		mtd_info *mtd;
+	struct		map_info map;
+	struct		resource *res;
+};
+
+static inline unsigned long flash_bank_setup(struct map_info *map, unsigned long ofs)
+{
+	unsigned long (*set_bank)(unsigned long) =
+		(unsigned long(*)(unsigned long))map->map_priv_2;
+
+	return (set_bank ? set_bank(ofs) : ofs);
+}
+
+#ifdef __ARMEB__
+/*
+ * Rev A0 and A1 of IXP2400 silicon have a broken addressing unit which
+ * causes the lower address bits to be XORed with 0x11 on 8 bit accesses
+ * and XORed with 0x10 on 16 bit accesses. See the spec update, erratum 44.
+ */
+static int erratum44_workaround = 0;
+
+static inline unsigned long address_fix8_write(unsigned long addr)
+{
+	if (erratum44_workaround) {
+		return (addr ^ 3);
+	}
+	return addr;
+}
+#else
+
+#define address_fix8_write(x)	(x)
+#endif
+
+static map_word ixp2000_flash_read8(struct map_info *map, unsigned long ofs)
+{
+	map_word val;
+
+	val.x[0] =  *((u8 *)(map->map_priv_1 + flash_bank_setup(map, ofs)));
+	return val;
+}
+
+/*
+ * We can't use the standard memcpy due to the broken SlowPort
+ * address translation on rev A0 and A1 silicon and the fact that
+ * we have banked flash.
+ */
+static void ixp2000_flash_copy_from(struct map_info *map, void *to,
+			      unsigned long from, ssize_t len)
+{
+	from = flash_bank_setup(map, from);
+	while(len--)
+		*(__u8 *) to++ = *(__u8 *)(map->map_priv_1 + from++);
+}
+
+static void ixp2000_flash_write8(struct map_info *map, map_word d, unsigned long ofs)
+{
+	*(__u8 *) (address_fix8_write(map->map_priv_1 +
+				      flash_bank_setup(map, ofs))) = d.x[0];
+}
+
+static void ixp2000_flash_copy_to(struct map_info *map, unsigned long to,
+			    const void *from, ssize_t len)
+{
+	to = flash_bank_setup(map, to);
+	while(len--) {
+		unsigned long tmp = address_fix8_write(map->map_priv_1 + to++);
+		*(__u8 *)(tmp) = *(__u8 *)(from++);
+	}
+}
+
+
+static int ixp2000_flash_remove(struct platform_device *dev)
+{
+	struct flash_platform_data *plat = dev->dev.platform_data;
+	struct ixp2000_flash_info *info = platform_get_drvdata(dev);
+
+	platform_set_drvdata(dev, NULL);
+
+	if(!info)
+		return 0;
+
+	if (info->mtd) {
+		mtd_device_unregister(info->mtd);
+		map_destroy(info->mtd);
+	}
+	if (info->map.map_priv_1)
+		iounmap((void *) info->map.map_priv_1);
+
+	if (info->res) {
+		release_resource(info->res);
+		kfree(info->res);
+	}
+
+	if (plat->exit)
+		plat->exit();
+
+	return 0;
+}
+
+
+static int ixp2000_flash_probe(struct platform_device *dev)
+{
+	static const char *probes[] = { "RedBoot", "cmdlinepart", NULL };
+	struct ixp2000_flash_data *ixp_data = dev->dev.platform_data;
+	struct flash_platform_data *plat;
+	struct ixp2000_flash_info *info;
+	unsigned long window_size;
+	int err = -1;
+
+	if (!ixp_data)
+		return -ENODEV;
+
+	plat = ixp_data->platform_data;
+	if (!plat)
+		return -ENODEV;
+
+	window_size = resource_size(dev->resource);
+	dev_info(&dev->dev, "Probe of IXP2000 flash(%d banks x %dMiB)\n",
+		 ixp_data->nr_banks, ((u32)window_size >> 20));
+
+	if (plat->width != 1) {
+		dev_err(&dev->dev, "IXP2000 MTD map only supports 8-bit mode, asking for %d\n",
+			plat->width * 8);
+		return -EIO;
+	}
+
+	info = kzalloc(sizeof(struct ixp2000_flash_info), GFP_KERNEL);
+	if(!info) {
+		err = -ENOMEM;
+		goto Error;
+	}
+
+	platform_set_drvdata(dev, info);
+
+	/*
+	 * Tell the MTD layer we're not 1:1 mapped so that it does
+	 * not attempt to do a direct access on us.
+	 */
+	info->map.phys = NO_XIP;
+
+	info->map.size = ixp_data->nr_banks * window_size;
+	info->map.bankwidth = 1;
+
+	/*
+ 	 * map_priv_2 is used to store a ptr to the bank_setup routine
+ 	 */
+	info->map.map_priv_2 = (unsigned long) ixp_data->bank_setup;
+
+	info->map.name = dev_name(&dev->dev);
+	info->map.read = ixp2000_flash_read8;
+	info->map.write = ixp2000_flash_write8;
+	info->map.copy_from = ixp2000_flash_copy_from;
+	info->map.copy_to = ixp2000_flash_copy_to;
+
+	info->res = request_mem_region(dev->resource->start,
+				       resource_size(dev->resource),
+				       dev_name(&dev->dev));
+	if (!info->res) {
+		dev_err(&dev->dev, "Could not reserve memory region\n");
+		err = -ENOMEM;
+		goto Error;
+	}
+
+	info->map.map_priv_1 =
+		(unsigned long)ioremap(dev->resource->start,
+				       resource_size(dev->resource));
+	if (!info->map.map_priv_1) {
+		dev_err(&dev->dev, "Failed to ioremap flash region\n");
+		err = -EIO;
+		goto Error;
+	}
+
+#if defined(__ARMEB__)
+	/*
+	 * Enable erratum 44 workaround for NPUs with broken slowport
+	 */
+
+	erratum44_workaround = ixp2000_has_broken_slowport();
+	dev_info(&dev->dev, "Erratum 44 workaround %s\n",
+	       erratum44_workaround ? "enabled" : "disabled");
+#endif
+
+	info->mtd = do_map_probe(plat->map_name, &info->map);
+	if (!info->mtd) {
+		dev_err(&dev->dev, "map_probe failed\n");
+		err = -ENXIO;
+		goto Error;
+	}
+	info->mtd->owner = THIS_MODULE;
+
+	err = mtd_device_parse_register(info->mtd, probes, NULL, NULL, 0);
+	if (err)
+		goto Error;
+
+	return 0;
+
+Error:
+	ixp2000_flash_remove(dev);
+	return err;
+}
+
+static struct platform_driver ixp2000_flash_driver = {
+	.probe		= ixp2000_flash_probe,
+	.remove		= ixp2000_flash_remove,
+	.driver		= {
+		.name	= "IXP2000-Flash",
+		.owner	= THIS_MODULE,
+	},
+};
+
+module_platform_driver(ixp2000_flash_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Deepak Saxena <dsaxena@plexity.net>");
+MODULE_ALIAS("platform:IXP2000-Flash");
diff -ruN linux-3.10/drivers/mtd/maps/ixp4xx.c linux-3.10_patched/drivers/mtd/maps/ixp4xx.c
--- linux-3.10/drivers/mtd/maps/ixp4xx.c	2013-06-30 22:13:29.000000000 +0000
+++ linux-3.10_patched/drivers/mtd/maps/ixp4xx.c	2025-06-14 05:48:04.957173245 +0000
@@ -148,7 +148,7 @@
 	struct resource *res;
 };
 
-static const char * const probes[] = { "RedBoot", "cmdlinepart", NULL };
+static const char *probes[] = { "RedBoot", "cmdlinepart", NULL };
 
 static int ixp4xx_flash_remove(struct platform_device *dev)
 {
diff -ruN linux-3.10/drivers/mtd/maps/Kconfig linux-3.10_patched/drivers/mtd/maps/Kconfig
--- linux-3.10/drivers/mtd/maps/Kconfig	2013-06-30 22:13:29.000000000 +0000
+++ linux-3.10_patched/drivers/mtd/maps/Kconfig	2025-06-14 05:48:04.961173245 +0000
@@ -10,7 +10,7 @@
 
 config MTD_PHYSMAP
 	tristate "Flash device in physical memory map"
-	depends on MTD_CFI || MTD_JEDECPROBE || MTD_ROM || MTD_LPDDR
+	depends on MTD_CFI || MTD_JEDECPROBE || MTD_ROM || MTD_LPDDR || MTD_QSP_FLASH
 	help
 	  This provides a 'mapping' driver which allows the NOR Flash and
 	  ROM driver code to communicate with chips which are mapped
@@ -67,7 +67,7 @@
 
 config MTD_PHYSMAP_OF
 	tristate "Flash device in physical memory map based on OF description"
-	depends on OF && (MTD_CFI || MTD_JEDECPROBE || MTD_ROM)
+	depends on OF && (MTD_CFI || MTD_JEDECPROBE || MTD_ROM || MTD_QSP_FLASH)
 	help
 	  This provides a 'mapping' driver which allows the NOR Flash and
 	  ROM driver code to communicate with chips which are mapped
@@ -224,7 +224,7 @@
 
 config MTD_SCB2_FLASH
 	tristate "BIOS flash chip on Intel SCB2 boards"
-	depends on X86 && MTD_JEDECPROBE && PCI
+	depends on X86 && MTD_JEDECPROBE
 	help
 	  Support for treating the BIOS flash chip on Intel SCB2 boards
 	  as an MTD device - with this you can reprogram your BIOS.
@@ -249,6 +249,22 @@
 	help
 	  Support for NOR flash attached to the Lantiq SoC's External Bus Unit.
 
+config MTD_DILNETPC
+	tristate "CFI Flash device mapped on DIL/Net PC"
+	depends on X86 && MTD_CFI_INTELEXT && BROKEN
+	help
+	  MTD map driver for SSV DIL/Net PC Boards "DNP" and "ADNP".
+	  For details, see <http://www.ssv-embedded.de/ssv/pc104/p169.htm>
+ 	  and <http://www.ssv-embedded.de/ssv/pc104/p170.htm>
+
+config MTD_DILNETPC_BOOTSIZE
+	hex "Size of DIL/Net PC flash boot partition"
+	depends on MTD_DILNETPC
+	default "0x80000"
+	help
+	  The amount of space taken up by the kernel or Etherboot
+	  on the DIL/Net PC flash chips.
+
 config MTD_L440GX
 	tristate "BIOS flash chip on Intel L440GX boards"
 	depends on X86 && MTD_JEDECPROBE
@@ -258,6 +274,42 @@
 
 	  BE VERY CAREFUL.
 
+config MTD_TQM8XXL
+	tristate "CFI Flash device mapped on TQM8XXL"
+	depends on MTD_CFI && TQM8xxL
+	help
+	  The TQM8xxL PowerPC board has up to two banks of CFI-compliant
+	  chips, currently uses AMD one. This 'mapping' driver supports
+	  that arrangement, allowing the CFI probe and command set driver
+	  code to communicate with the chips on the TQM8xxL board. More at
+	  <http://www.denx.de/wiki/PPCEmbedded/>.
+
+config MTD_RPXLITE
+	tristate "CFI Flash device mapped on RPX Lite or CLLF"
+	depends on MTD_CFI && (RPXCLASSIC || RPXLITE)
+	help
+	  The RPXLite PowerPC board has CFI-compliant chips mapped in
+	  a strange sparse mapping. This 'mapping' driver supports that
+	  arrangement, allowing the CFI probe and command set driver code
+	  to communicate with the chips on the RPXLite board. More at
+	  <http://www.embeddedplanet.com/>.
+
+config MTD_MBX860
+	tristate "System flash on MBX860 board"
+	depends on MTD_CFI && MBX
+	help
+	  This enables access routines for the flash chips on the Motorola
+	  MBX860 board. If you have one of these boards and would like
+	  to use the flash chips on it, say 'Y'.
+
+config MTD_DBOX2
+	tristate "CFI Flash device mapped on D-Box2"
+	depends on DBOX2 && MTD_CFI_INTELSTD && MTD_CFI_INTELEXT && MTD_CFI_AMDSTD
+	help
+	  This enables access routines for the flash chips on the Nokia/Sagem
+	  D-Box 2 board. If you have one of these boards and would like to use
+	  the flash chips on it, say 'Y'.
+
 config MTD_CFI_FLAGADM
 	tristate "CFI Flash device mapping on FlagaDM"
 	depends on 8xx && MTD_CFI
@@ -272,6 +324,13 @@
 	  This enables access to the flash chips on the Hitachi SolutionEngine and
 	  similar boards. Say 'Y' if you are building a kernel for such a board.
 
+config MTD_CDB89712
+	tristate "Cirrus CDB89712 evaluation board mappings"
+	depends on MTD_CFI && ARCH_CDB89712
+	help
+	  This enables access to the flash or ROM chips on the CDB89712 board.
+	  If you have such a board, say 'Y'.
+
 config MTD_SA1100
 	tristate "CFI Flash device mapped on StrongARM SA11x0"
 	depends on MTD_CFI && ARCH_SA1100
@@ -297,8 +356,24 @@
 	  IXDP425 and Coyote. If you have an IXP4xx based board and
 	  would like to use the flash chips on it, say 'Y'.
 
+config MTD_IXP2000
+	tristate "CFI Flash device mapped on Intel IXP2000 based systems"
+	depends on MTD_CFI && MTD_COMPLEX_MAPPINGS && ARCH_IXP2000
+	help
+	  This enables MTD access to flash devices on platforms based
+	  on Intel's IXP2000 family of network processors. If you have an
+	  IXP2000 based board and would like to use the flash chips on it,
+	  say 'Y'.
+
+config MTD_FORTUNET
+	tristate "CFI Flash device mapped on the FortuNet board"
+	depends on MTD_CFI && SA1100_FORTUNET
+	help
+	  This enables access to the Flash on the FortuNet board.  If you
+	  have such a board, say 'Y'.
+
 config MTD_AUTCPU12
-	bool "NV-RAM mapping AUTCPU12 board"
+	tristate "NV-RAM mapping AUTCPU12 board"
 	depends on ARCH_AUTCPU12
 	help
 	  This enables access to the NV-RAM on autronix autcpu12 board.
@@ -311,6 +386,13 @@
 	  This enables access to the NOR Flash on the impA7 board of
 	  implementa GmbH. If you have such a board, say 'Y' here.
 
+config MTD_H720X
+	tristate "Hynix evaluation board mappings"
+	depends on MTD_CFI && ( ARCH_H7201 || ARCH_H7202 )
+	help
+	  This enables access to the flash chips on the Hynix evaluation boards.
+	  If you have such a board, say 'Y'.
+
 # This needs CFI or JEDEC, depending on the cards found.
 config MTD_PCI
 	tristate "PCI MTD driver"
@@ -351,7 +433,7 @@
 
 config MTD_GPIO_ADDR
 	tristate "GPIO-assisted Flash Chip Support"
-	depends on GPIOLIB
+	depends on GENERIC_GPIO || GPIOLIB
 	depends on MTD_COMPLEX_MAPPINGS
 	help
 	  Map driver which allows flashes to be partially physically addressed
@@ -361,10 +443,31 @@
 
 config MTD_UCLINUX
 	bool "Generic uClinux RAM/ROM filesystem support"
-	depends on (MTD_RAM=y || MTD_ROM=y) && (!MMU || COLDFIRE)
+	depends on MTD_RAM=y && !MMU
 	help
 	  Map driver to support image based filesystems for uClinux.
 
+config MTD_WRSBC8260
+	tristate "Map driver for WindRiver PowerQUICC II MPC82xx board"
+	depends on (SBC82xx || SBC8560)
+	select MTD_MAP_BANK_WIDTH_4
+	select MTD_MAP_BANK_WIDTH_1
+	select MTD_CFI_I1
+	select MTD_CFI_I4
+	help
+	  Map driver for WindRiver PowerQUICC II MPC82xx board. Drives
+	  all three flash regions on CS0, CS1 and CS6 if they are configured
+	  correctly by the boot loader.
+
+config MTD_DMV182
+        tristate "Map driver for Dy-4 SVME/DMV-182 board."
+        depends on DMV182
+	select MTD_MAP_BANK_WIDTH_32
+	select MTD_CFI_I8
+	select MTD_CFI_AMDSTD
+        help
+          Map driver for Dy-4 SVME/DMV-182 board.
+
 config MTD_INTEL_VR_NOR
 	tristate "NOR flash on Intel Vermilion Range Expansion Bus CS0"
 	depends on PCI
diff -ruN linux-3.10/drivers/mtd/maps/lantiq-flash.c linux-3.10_patched/drivers/mtd/maps/lantiq-flash.c
--- linux-3.10/drivers/mtd/maps/lantiq-flash.c	2013-06-30 22:13:29.000000000 +0000
+++ linux-3.10_patched/drivers/mtd/maps/lantiq-flash.c	2025-06-14 05:48:04.957173245 +0000
@@ -7,7 +7,6 @@
  *  Copyright (C) 2010 John Crispin <blogic@openwrt.org>
  */
 
-#include <linux/err.h>
 #include <linux/module.h>
 #include <linux/types.h>
 #include <linux/kernel.h>
@@ -20,9 +19,9 @@
 #include <linux/mtd/cfi.h>
 #include <linux/platform_device.h>
 #include <linux/mtd/physmap.h>
-#include <linux/of.h>
 
 #include <lantiq_soc.h>
+#include <lantiq_platform.h>
 
 /*
  * The NOR flash is connected to the same external bus unit (EBU) as PCI.
@@ -45,8 +44,8 @@
 	struct map_info *map;
 };
 
-static const char ltq_map_name[] = "ltq_nor";
-static const char * const ltq_probe_types[] = { "cmdlinepart", "ofpart", NULL };
+static char ltq_map_name[] = "ltq_nor";
+static const char *ltq_probe_types[] __devinitconst = { "cmdlinepart", NULL };
 
 static map_word
 ltq_read16(struct map_info *map, unsigned long adr)
@@ -109,39 +108,44 @@
 	spin_unlock_irqrestore(&ebu_lock, flags);
 }
 
-static int
+static int __init
 ltq_mtd_probe(struct platform_device *pdev)
 {
-	struct mtd_part_parser_data ppdata;
+	struct physmap_flash_data *ltq_mtd_data = dev_get_platdata(&pdev->dev);
 	struct ltq_mtd *ltq_mtd;
+	struct resource *res;
 	struct cfi_private *cfi;
 	int err;
 
-	if (of_machine_is_compatible("lantiq,falcon") &&
-			(ltq_boot_select() != BS_FLASH)) {
-		dev_err(&pdev->dev, "invalid bootstrap options\n");
-		return -ENODEV;
-	}
-
 	ltq_mtd = kzalloc(sizeof(struct ltq_mtd), GFP_KERNEL);
 	platform_set_drvdata(pdev, ltq_mtd);
 
 	ltq_mtd->res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!ltq_mtd->res) {
-		dev_err(&pdev->dev, "failed to get memory resource\n");
+		dev_err(&pdev->dev, "failed to get memory resource");
 		err = -ENOENT;
 		goto err_out;
 	}
 
-	ltq_mtd->map = kzalloc(sizeof(struct map_info), GFP_KERNEL);
-	ltq_mtd->map->phys = ltq_mtd->res->start;
-	ltq_mtd->map->size = resource_size(ltq_mtd->res);
-	ltq_mtd->map->virt = devm_ioremap_resource(&pdev->dev, ltq_mtd->res);
-	if (IS_ERR(ltq_mtd->map->virt)) {
-		err = PTR_ERR(ltq_mtd->map->virt);
+	res = devm_request_mem_region(&pdev->dev, ltq_mtd->res->start,
+		resource_size(ltq_mtd->res), dev_name(&pdev->dev));
+	if (!ltq_mtd->res) {
+		dev_err(&pdev->dev, "failed to request mem resource");
+		err = -EBUSY;
 		goto err_out;
 	}
 
+	ltq_mtd->map = kzalloc(sizeof(struct map_info), GFP_KERNEL);
+	ltq_mtd->map->phys = res->start;
+	ltq_mtd->map->size = resource_size(res);
+	ltq_mtd->map->virt = devm_ioremap_nocache(&pdev->dev,
+				ltq_mtd->map->phys, ltq_mtd->map->size);
+	if (!ltq_mtd->map->virt) {
+		dev_err(&pdev->dev, "failed to ioremap!\n");
+		err = -ENOMEM;
+		goto err_free;
+	}
+
 	ltq_mtd->map->name = ltq_map_name;
 	ltq_mtd->map->bankwidth = 2;
 	ltq_mtd->map->read = ltq_read16;
@@ -165,9 +169,9 @@
 	cfi->addr_unlock1 ^= 1;
 	cfi->addr_unlock2 ^= 1;
 
-	ppdata.of_node = pdev->dev.of_node;
-	err = mtd_device_parse_register(ltq_mtd->mtd, ltq_probe_types,
-					&ppdata, NULL, 0);
+	err = mtd_device_parse_register(ltq_mtd->mtd, ltq_probe_types, NULL,
+					ltq_mtd_data->parts,
+					ltq_mtd_data->nr_parts);
 	if (err) {
 		dev_err(&pdev->dev, "failed to add partitions\n");
 		goto err_destroy;
@@ -184,7 +188,7 @@
 	return err;
 }
 
-static int
+static int __devexit
 ltq_mtd_remove(struct platform_device *pdev)
 {
 	struct ltq_mtd *ltq_mtd = platform_get_drvdata(pdev);
@@ -200,23 +204,32 @@
 	return 0;
 }
 
-static const struct of_device_id ltq_mtd_match[] = {
-	{ .compatible = "lantiq,nor" },
-	{},
-};
-MODULE_DEVICE_TABLE(of, ltq_mtd_match);
-
 static struct platform_driver ltq_mtd_driver = {
-	.probe = ltq_mtd_probe,
-	.remove = ltq_mtd_remove,
+	.remove = __devexit_p(ltq_mtd_remove),
 	.driver = {
-		.name = "ltq-nor",
+		.name = "ltq_nor",
 		.owner = THIS_MODULE,
-		.of_match_table = ltq_mtd_match,
 	},
 };
 
-module_platform_driver(ltq_mtd_driver);
+static int __init
+init_ltq_mtd(void)
+{
+	int ret = platform_driver_probe(&ltq_mtd_driver, ltq_mtd_probe);
+
+	if (ret)
+		pr_err("ltq_nor: error registering platform driver");
+	return ret;
+}
+
+static void __exit
+exit_ltq_mtd(void)
+{
+	platform_driver_unregister(&ltq_mtd_driver);
+}
+
+module_init(init_ltq_mtd);
+module_exit(exit_ltq_mtd);
 
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("John Crispin <blogic@openwrt.org>");
diff -ruN linux-3.10/drivers/mtd/maps/latch-addr-flash.c linux-3.10_patched/drivers/mtd/maps/latch-addr-flash.c
--- linux-3.10/drivers/mtd/maps/latch-addr-flash.c	2013-06-30 22:13:29.000000000 +0000
+++ linux-3.10_patched/drivers/mtd/maps/latch-addr-flash.c	2025-06-14 05:48:04.957173245 +0000
@@ -125,7 +125,7 @@
 	return 0;
 }
 
-static int latch_addr_flash_probe(struct platform_device *dev)
+static int __devinit latch_addr_flash_probe(struct platform_device *dev)
 {
 	struct latch_addr_flash_data *latch_addr_data;
 	struct latch_addr_flash_info *info;
@@ -218,7 +218,7 @@
 
 static struct platform_driver latch_addr_flash_driver = {
 	.probe		= latch_addr_flash_probe,
-	.remove		= latch_addr_flash_remove,
+	.remove		= __devexit_p(latch_addr_flash_remove),
 	.driver		= {
 		.name	= DRIVER_NAME,
 	},
diff -ruN linux-3.10/drivers/mtd/maps/Makefile linux-3.10_patched/drivers/mtd/maps/Makefile
--- linux-3.10/drivers/mtd/maps/Makefile	2013-06-30 22:13:29.000000000 +0000
+++ linux-3.10_patched/drivers/mtd/maps/Makefile	2025-06-14 05:48:04.953173245 +0000
@@ -7,8 +7,10 @@
 endif
 
 # Chip mappings
+obj-$(CONFIG_MTD_CDB89712)	+= cdb89712.o
 obj-$(CONFIG_MTD_CFI_FLAGADM)	+= cfi_flagadm.o
 obj-$(CONFIG_MTD_DC21285)	+= dc21285.o
+obj-$(CONFIG_MTD_DILNETPC)	+= dilnetpc.o
 obj-$(CONFIG_MTD_L440GX)	+= l440gx.o
 obj-$(CONFIG_MTD_AMD76XROM)	+= amd76xrom.o
 obj-$(CONFIG_MTD_ESB2ROM)	+= esb2rom.o
@@ -16,12 +18,15 @@
 obj-$(CONFIG_MTD_CK804XROM)	+= ck804xrom.o
 obj-$(CONFIG_MTD_TSUNAMI)	+= tsunami_flash.o
 obj-$(CONFIG_MTD_PXA2XX)	+= pxa2xx-flash.o
+obj-$(CONFIG_MTD_MBX860)	+= mbx860.o
 obj-$(CONFIG_MTD_OCTAGON)	+= octagon-5066.o
 obj-$(CONFIG_MTD_PHYSMAP)	+= physmap.o
 obj-$(CONFIG_MTD_PHYSMAP_OF)	+= physmap_of.o
 obj-$(CONFIG_MTD_PISMO)		+= pismo.o
 obj-$(CONFIG_MTD_PMC_MSP_EVM)   += pmcmsp-flash.o
 obj-$(CONFIG_MTD_PCMCIA)	+= pcmciamtd.o
+obj-$(CONFIG_MTD_RPXLITE)	+= rpxlite.o
+obj-$(CONFIG_MTD_TQM8XXL)	+= tqm8xxl.o
 obj-$(CONFIG_MTD_SA1100)	+= sa1100-flash.o
 obj-$(CONFIG_MTD_SBC_GXX)	+= sbc_gxx.o
 obj-$(CONFIG_MTD_SC520CDP)	+= sc520cdp.o
@@ -30,14 +35,20 @@
 obj-$(CONFIG_MTD_SUN_UFLASH)	+= sun_uflash.o
 obj-$(CONFIG_MTD_VMAX)		+= vmax301.o
 obj-$(CONFIG_MTD_SCx200_DOCFLASH)+= scx200_docflash.o
+obj-$(CONFIG_MTD_DBOX2)		+= dbox2-flash.o
 obj-$(CONFIG_MTD_SOLUTIONENGINE)+= solutionengine.o
 obj-$(CONFIG_MTD_PCI)		+= pci.o
 obj-$(CONFIG_MTD_AUTCPU12)	+= autcpu12-nvram.o
 obj-$(CONFIG_MTD_IMPA7)		+= impa7.o
+obj-$(CONFIG_MTD_FORTUNET)	+= fortunet.o
 obj-$(CONFIG_MTD_UCLINUX)	+= uclinux.o
 obj-$(CONFIG_MTD_NETtel)	+= nettel.o
 obj-$(CONFIG_MTD_SCB2_FLASH)	+= scb2_flash.o
+obj-$(CONFIG_MTD_H720X)		+= h720x-flash.o
 obj-$(CONFIG_MTD_IXP4XX)	+= ixp4xx.o
+obj-$(CONFIG_MTD_IXP2000)	+= ixp2000.o
+obj-$(CONFIG_MTD_WRSBC8260)	+= wr_sbc82xx_flash.o
+obj-$(CONFIG_MTD_DMV182)	+= dmv182.o
 obj-$(CONFIG_MTD_PLATRAM)	+= plat-ram.o
 obj-$(CONFIG_MTD_INTEL_VR_NOR)	+= intel_vr_nor.o
 obj-$(CONFIG_MTD_BFIN_ASYNC)	+= bfin-async-flash.o
diff -ruN linux-3.10/drivers/mtd/maps/mbx860.c linux-3.10_patched/drivers/mtd/maps/mbx860.c
--- linux-3.10/drivers/mtd/maps/mbx860.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.10_patched/drivers/mtd/maps/mbx860.c	2025-06-14 05:48:04.957173245 +0000
@@ -0,0 +1,98 @@
+/*
+ * Handle mapping of the flash on MBX860 boards
+ *
+ * Author:	Anton Todorov
+ * Copyright:	(C) 2001 Emness Technology
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <asm/io.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+
+#define WINDOW_ADDR 0xfe000000
+#define WINDOW_SIZE 0x00200000
+
+/* Flash / Partition sizing */
+#define MAX_SIZE_KiB              8192
+#define BOOT_PARTITION_SIZE_KiB    512
+#define KERNEL_PARTITION_SIZE_KiB 5632
+#define APP_PARTITION_SIZE_KiB    2048
+
+#define NUM_PARTITIONS 3
+
+/* partition_info gives details on the logical partitions that the split the
+ * single flash device into. If the size if zero we use up to the end of the
+ * device. */
+static struct mtd_partition partition_info[]={
+	{ .name = "MBX flash BOOT partition",
+	.offset = 0,
+	.size =   BOOT_PARTITION_SIZE_KiB*1024 },
+	{ .name = "MBX flash DATA partition",
+	.offset = BOOT_PARTITION_SIZE_KiB*1024,
+	.size = (KERNEL_PARTITION_SIZE_KiB)*1024 },
+	{ .name = "MBX flash APPLICATION partition",
+	.offset = (BOOT_PARTITION_SIZE_KiB+KERNEL_PARTITION_SIZE_KiB)*1024 }
+};
+
+
+static struct mtd_info *mymtd;
+
+struct map_info mbx_map = {
+	.name = "MBX flash",
+	.size = WINDOW_SIZE,
+	.phys = WINDOW_ADDR,
+	.bankwidth = 4,
+};
+
+static int __init init_mbx(void)
+{
+	printk(KERN_NOTICE "Motorola MBX flash device: 0x%x at 0x%x\n", WINDOW_SIZE*4, WINDOW_ADDR);
+	mbx_map.virt = ioremap(WINDOW_ADDR, WINDOW_SIZE * 4);
+
+	if (!mbx_map.virt) {
+		printk("Failed to ioremap\n");
+		return -EIO;
+	}
+	simple_map_init(&mbx_map);
+
+	mymtd = do_map_probe("jedec_probe", &mbx_map);
+	if (mymtd) {
+		mymtd->owner = THIS_MODULE;
+		mtd_device_register(mymtd, NULL, 0);
+		mtd_device_register(mymtd, partition_info, NUM_PARTITIONS);
+		return 0;
+	}
+
+	iounmap((void *)mbx_map.virt);
+	return -ENXIO;
+}
+
+static void __exit cleanup_mbx(void)
+{
+	if (mymtd) {
+		mtd_device_unregister(mymtd);
+		map_destroy(mymtd);
+	}
+	if (mbx_map.virt) {
+		iounmap((void *)mbx_map.virt);
+		mbx_map.virt = 0;
+	}
+}
+
+module_init(init_mbx);
+module_exit(cleanup_mbx);
+
+MODULE_AUTHOR("Anton Todorov <a.todorov@emness.com>");
+MODULE_DESCRIPTION("MTD map driver for Motorola MBX860 board");
+MODULE_LICENSE("GPL");
diff -ruN linux-3.10/drivers/mtd/maps/modules.builtin linux-3.10_patched/drivers/mtd/maps/modules.builtin
--- linux-3.10/drivers/mtd/maps/modules.builtin	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.10_patched/drivers/mtd/maps/modules.builtin	2025-06-14 05:48:04.969173245 +0000
@@ -0,0 +1,2 @@
+kernel/drivers/mtd/maps/physmap.ko
+kernel/drivers/mtd/maps/physmap_of.ko
diff -ruN linux-3.10/drivers/mtd/maps/pci.c linux-3.10_patched/drivers/mtd/maps/pci.c
--- linux-3.10/drivers/mtd/maps/pci.c	2013-06-30 22:13:29.000000000 +0000
+++ linux-3.10_patched/drivers/mtd/maps/pci.c	2025-06-14 05:48:04.961173245 +0000
@@ -43,14 +43,26 @@
 	struct map_pci_info *map = (struct map_pci_info *)_map;
 	map_word val;
 	val.x[0]= readb(map->base + map->translate(map, ofs));
+//	printk("read8 : %08lx => %02x\n", ofs, val.x[0]);
 	return val;
 }
 
+#if 0
+static map_word mtd_pci_read16(struct map_info *_map, unsigned long ofs)
+{
+	struct map_pci_info *map = (struct map_pci_info *)_map;
+	map_word val;
+	val.x[0] = readw(map->base + map->translate(map, ofs));
+//	printk("read16: %08lx => %04x\n", ofs, val.x[0]);
+	return val;
+}
+#endif
 static map_word mtd_pci_read32(struct map_info *_map, unsigned long ofs)
 {
 	struct map_pci_info *map = (struct map_pci_info *)_map;
 	map_word val;
 	val.x[0] = readl(map->base + map->translate(map, ofs));
+//	printk("read32: %08lx => %08x\n", ofs, val.x[0]);
 	return val;
 }
 
@@ -63,12 +75,22 @@
 static void mtd_pci_write8(struct map_info *_map, map_word val, unsigned long ofs)
 {
 	struct map_pci_info *map = (struct map_pci_info *)_map;
+//	printk("write8 : %08lx <= %02x\n", ofs, val.x[0]);
 	writeb(val.x[0], map->base + map->translate(map, ofs));
 }
 
+#if 0
+static void mtd_pci_write16(struct map_info *_map, map_word val, unsigned long ofs)
+{
+	struct map_pci_info *map = (struct map_pci_info *)_map;
+//	printk("write16: %08lx <= %04x\n", ofs, val.x[0]);
+	writew(val.x[0], map->base + map->translate(map, ofs));
+}
+#endif
 static void mtd_pci_write32(struct map_info *_map, map_word val, unsigned long ofs)
 {
 	struct map_pci_info *map = (struct map_pci_info *)_map;
+//	printk("write32: %08lx <= %08x\n", ofs, val.x[0]);
 	writel(val.x[0], map->base + map->translate(map, ofs));
 }
 
@@ -253,7 +275,8 @@
  * Generic code follows.
  */
 
-static int mtd_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
+static int __devinit
+mtd_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
 {
 	struct mtd_pci_info *info = (struct mtd_pci_info *)id->driver_data;
 	struct map_pci_info *map = NULL;
@@ -283,7 +306,8 @@
 	if (err)
 		goto release;
 
-	mtd = do_map_probe(info->map_name, &map->map);
+	/* tsk - do_map_probe should take const char * */
+	mtd = do_map_probe((char *)info->map_name, &map->map);
 	err = -ENODEV;
 	if (!mtd)
 		goto release;
@@ -306,7 +330,8 @@
 	return err;
 }
 
-static void mtd_pci_remove(struct pci_dev *dev)
+static void __devexit
+mtd_pci_remove(struct pci_dev *dev)
 {
 	struct mtd_info *mtd = pci_get_drvdata(dev);
 	struct map_pci_info *map = mtd->priv;
@@ -323,13 +348,25 @@
 static struct pci_driver mtd_pci_driver = {
 	.name =		"MTD PCI",
 	.probe =	mtd_pci_probe,
-	.remove =	mtd_pci_remove,
+	.remove =	__devexit_p(mtd_pci_remove),
 	.id_table =	mtd_pci_ids,
 };
 
-module_pci_driver(mtd_pci_driver);
+static int __init mtd_pci_maps_init(void)
+{
+	return pci_register_driver(&mtd_pci_driver);
+}
+
+static void __exit mtd_pci_maps_exit(void)
+{
+	pci_unregister_driver(&mtd_pci_driver);
+}
+
+module_init(mtd_pci_maps_init);
+module_exit(mtd_pci_maps_exit);
 
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Russell King <rmk@arm.linux.org.uk>");
 MODULE_DESCRIPTION("Generic PCI map driver");
 MODULE_DEVICE_TABLE(pci, mtd_pci_ids);
+
diff -ruN linux-3.10/drivers/mtd/maps/physmap.c linux-3.10_patched/drivers/mtd/maps/physmap.c
--- linux-3.10/drivers/mtd/maps/physmap.c	2013-06-30 22:13:29.000000000 +0000
+++ linux-3.10_patched/drivers/mtd/maps/physmap.c	2025-06-14 05:48:04.965173245 +0000
@@ -87,18 +87,22 @@
 	spin_unlock_irqrestore(&info->vpp_lock, flags);
 }
 
-static const char * const rom_probe_types[] = {
-	"cfi_probe", "jedec_probe", "qinfo_probe", "map_rom", NULL };
-
-static const char * const part_probe_types[] = {
-	"cmdlinepart", "RedBoot", "afs", NULL };
+static const char *rom_probe_types[] = {
+					"cfi_probe",
+					"jedec_probe",
+					"qinfo_probe",
+					"map_rom",
+					"qsp-flash",
+					NULL };
+static const char *part_probe_types[] = { "cmdlinepart", "RedBoot", "afs",
+					  NULL };
 
 static int physmap_flash_probe(struct platform_device *dev)
 {
 	struct physmap_flash_data *physmap_data;
 	struct physmap_flash_info *info;
-	const char * const *probe_type;
-	const char * const *part_types;
+	const char **probe_type;
+	const char **part_types;
 	int err = 0;
 	int i;
 	int devices_found = 0;
Binary files linux-3.10/drivers/mtd/maps/physmap.o and linux-3.10_patched/drivers/mtd/maps/physmap.o differ
diff -ruN linux-3.10/drivers/mtd/maps/.physmap.o.cmd linux-3.10_patched/drivers/mtd/maps/.physmap.o.cmd
--- linux-3.10/drivers/mtd/maps/.physmap.o.cmd	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.10_patched/drivers/mtd/maps/.physmap.o.cmd	2025-06-14 05:48:04.965173245 +0000
@@ -0,0 +1,434 @@
+cmd_drivers/mtd/maps/physmap.o := /home/mike/qsp_buildroot/buildroot/output/host/usr/bin/ccache /home/mike/qsp_buildroot/buildroot/output/host/usr/bin/arm-none-linux-gnueabi-gcc -Wp,-MD,drivers/mtd/maps/.physmap.o.d -nostdinc -isystem /home/mike/qsp_buildroot/buildroot/output/host/opt/ext-toolchain/bin/../lib/gcc/arm-none-linux-gnueabi/4.8.1/include -I/home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include -Iarch/arm/include/generated -Iinclude  -include /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/include/linux/kconfig.h -D__KERNEL__ -mlittle-endian -Iarch/arm/mach-qsp/include -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -Wno-format-security -fno-delete-null-pointer-checks -O2 -marm -fno-dwarf2-cfi-asm -mabi=aapcs-linux -mno-thumb-interwork -funwind-tables -D__LINUX_ARM_ARCH__=7 -march=armv7-a -msoft-float -Uarm -Wframe-larger-than=1024 -fno-stack-protector -Wno-unused-but-set-variable -fomit-frame-pointer -g -Wdeclaration-after-statement -Wno-pointer-sign -fno-strict-overflow -fconserve-stack -DCC_HAVE_ASM_GOTO    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(physmap)"  -D"KBUILD_MODNAME=KBUILD_STR(physmap)" -c -o drivers/mtd/maps/physmap.o drivers/mtd/maps/physmap.c
+
+source_drivers/mtd/maps/physmap.o := drivers/mtd/maps/physmap.c
+
+deps_drivers/mtd/maps/physmap.o := \
+    $(wildcard include/config/pm.h) \
+    $(wildcard include/config/mtd/physmap/compat.h) \
+    $(wildcard include/config/mtd/physmap/bankwidth.h) \
+    $(wildcard include/config/mtd/physmap/start.h) \
+    $(wildcard include/config/mtd/physmap/len.h) \
+  include/linux/module.h \
+    $(wildcard include/config/sysfs.h) \
+    $(wildcard include/config/modules.h) \
+    $(wildcard include/config/unused/symbols.h) \
+    $(wildcard include/config/generic/bug.h) \
+    $(wildcard include/config/kallsyms.h) \
+    $(wildcard include/config/smp.h) \
+    $(wildcard include/config/tracepoints.h) \
+    $(wildcard include/config/tracing.h) \
+    $(wildcard include/config/event/tracing.h) \
+    $(wildcard include/config/ftrace/mcount/record.h) \
+    $(wildcard include/config/module/unload.h) \
+    $(wildcard include/config/constructors.h) \
+    $(wildcard include/config/debug/set/module/ronx.h) \
+  include/linux/list.h \
+    $(wildcard include/config/debug/list.h) \
+  include/linux/types.h \
+    $(wildcard include/config/uid16.h) \
+    $(wildcard include/config/lbdaf.h) \
+    $(wildcard include/config/arch/dma/addr/t/64bit.h) \
+    $(wildcard include/config/phys/addr/t/64bit.h) \
+    $(wildcard include/config/64bit.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/types.h \
+  include/asm-generic/int-ll64.h \
+  arch/arm/include/generated/asm/bitsperlong.h \
+  include/asm-generic/bitsperlong.h \
+  include/linux/posix_types.h \
+  include/linux/stddef.h \
+  include/linux/compiler.h \
+    $(wildcard include/config/sparse/rcu/pointer.h) \
+    $(wildcard include/config/trace/branch/profiling.h) \
+    $(wildcard include/config/profile/all/branches.h) \
+    $(wildcard include/config/enable/must/check.h) \
+    $(wildcard include/config/enable/warn/deprecated.h) \
+  include/linux/compiler-gcc.h \
+    $(wildcard include/config/arch/supports/optimized/inlining.h) \
+    $(wildcard include/config/optimize/inlining.h) \
+  include/linux/compiler-gcc4.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/posix_types.h \
+  include/asm-generic/posix_types.h \
+  include/linux/poison.h \
+    $(wildcard include/config/illegal/pointer/value.h) \
+  include/linux/const.h \
+  include/linux/stat.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/stat.h \
+  include/linux/time.h \
+    $(wildcard include/config/arch/uses/gettimeoffset.h) \
+  include/linux/cache.h \
+    $(wildcard include/config/arch/has/cache/line/size.h) \
+  include/linux/kernel.h \
+    $(wildcard include/config/preempt/voluntary.h) \
+    $(wildcard include/config/debug/atomic/sleep.h) \
+    $(wildcard include/config/prove/locking.h) \
+    $(wildcard include/config/ring/buffer.h) \
+    $(wildcard include/config/numa.h) \
+    $(wildcard include/config/compaction.h) \
+  include/linux/sysinfo.h \
+  /home/mike/qsp_buildroot/buildroot/output/host/opt/ext-toolchain/lib/gcc/arm-none-linux-gnueabi/4.8.1/include/stdarg.h \
+  include/linux/linkage.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/linkage.h \
+  include/linux/bitops.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/bitops.h \
+  include/linux/irqflags.h \
+    $(wildcard include/config/trace/irqflags.h) \
+    $(wildcard include/config/irqsoff/tracer.h) \
+    $(wildcard include/config/preempt/tracer.h) \
+    $(wildcard include/config/trace/irqflags/support.h) \
+  include/linux/typecheck.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/irqflags.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/ptrace.h \
+    $(wildcard include/config/cpu/endian/be8.h) \
+    $(wildcard include/config/arm/thumb.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/hwcap.h \
+  include/asm-generic/bitops/non-atomic.h \
+  include/asm-generic/bitops/fls64.h \
+  include/asm-generic/bitops/sched.h \
+  include/asm-generic/bitops/hweight.h \
+  include/asm-generic/bitops/arch_hweight.h \
+  include/asm-generic/bitops/const_hweight.h \
+  include/asm-generic/bitops/lock.h \
+  include/asm-generic/bitops/le.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/byteorder.h \
+  include/linux/byteorder/little_endian.h \
+  include/linux/swab.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/swab.h \
+  include/linux/byteorder/generic.h \
+  include/asm-generic/bitops/ext2-atomic-setbit.h \
+  include/linux/log2.h \
+    $(wildcard include/config/arch/has/ilog2/u32.h) \
+    $(wildcard include/config/arch/has/ilog2/u64.h) \
+  include/linux/printk.h \
+    $(wildcard include/config/printk.h) \
+    $(wildcard include/config/dynamic/debug.h) \
+  include/linux/init.h \
+    $(wildcard include/config/hotplug.h) \
+  include/linux/dynamic_debug.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/div64.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/compiler.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/bug.h \
+    $(wildcard include/config/bug.h) \
+    $(wildcard include/config/thumb2/kernel.h) \
+    $(wildcard include/config/debug/bugverbose.h) \
+    $(wildcard include/config/arm/lpae.h) \
+  include/asm-generic/bug.h \
+    $(wildcard include/config/generic/bug/relative/pointers.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/cache.h \
+    $(wildcard include/config/arm/l1/cache/shift.h) \
+    $(wildcard include/config/aeabi.h) \
+  include/linux/seqlock.h \
+  include/linux/spinlock.h \
+    $(wildcard include/config/debug/spinlock.h) \
+    $(wildcard include/config/generic/lockbreak.h) \
+    $(wildcard include/config/preempt.h) \
+    $(wildcard include/config/debug/lock/alloc.h) \
+  include/linux/preempt.h \
+    $(wildcard include/config/debug/preempt.h) \
+    $(wildcard include/config/preempt/count.h) \
+    $(wildcard include/config/preempt/notifiers.h) \
+  include/linux/thread_info.h \
+    $(wildcard include/config/compat.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/thread_info.h \
+    $(wildcard include/config/arm/thumbee.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/fpstate.h \
+    $(wildcard include/config/vfpv3.h) \
+    $(wildcard include/config/iwmmxt.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/domain.h \
+    $(wildcard include/config/io/36.h) \
+    $(wildcard include/config/cpu/use/domains.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/barrier.h \
+    $(wildcard include/config/cpu/32v6k.h) \
+    $(wildcard include/config/cpu/xsc3.h) \
+    $(wildcard include/config/cpu/fa526.h) \
+    $(wildcard include/config/arch/has/barriers.h) \
+    $(wildcard include/config/arm/dma/mem/bufferable.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/outercache.h \
+    $(wildcard include/config/outer/cache/sync.h) \
+    $(wildcard include/config/outer/cache.h) \
+  include/linux/stringify.h \
+  include/linux/bottom_half.h \
+  include/linux/spinlock_types.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/spinlock_types.h \
+  include/linux/lockdep.h \
+    $(wildcard include/config/lockdep.h) \
+    $(wildcard include/config/lock/stat.h) \
+    $(wildcard include/config/prove/rcu.h) \
+  include/linux/rwlock_types.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/spinlock.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/processor.h \
+    $(wildcard include/config/have/hw/breakpoint.h) \
+    $(wildcard include/config/mmu.h) \
+    $(wildcard include/config/arm/errata/754327.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/hw_breakpoint.h \
+  include/linux/rwlock.h \
+  include/linux/spinlock_api_smp.h \
+    $(wildcard include/config/inline/spin/lock.h) \
+    $(wildcard include/config/inline/spin/lock/bh.h) \
+    $(wildcard include/config/inline/spin/lock/irq.h) \
+    $(wildcard include/config/inline/spin/lock/irqsave.h) \
+    $(wildcard include/config/inline/spin/trylock.h) \
+    $(wildcard include/config/inline/spin/trylock/bh.h) \
+    $(wildcard include/config/uninline/spin/unlock.h) \
+    $(wildcard include/config/inline/spin/unlock/bh.h) \
+    $(wildcard include/config/inline/spin/unlock/irq.h) \
+    $(wildcard include/config/inline/spin/unlock/irqrestore.h) \
+  include/linux/rwlock_api_smp.h \
+    $(wildcard include/config/inline/read/lock.h) \
+    $(wildcard include/config/inline/write/lock.h) \
+    $(wildcard include/config/inline/read/lock/bh.h) \
+    $(wildcard include/config/inline/write/lock/bh.h) \
+    $(wildcard include/config/inline/read/lock/irq.h) \
+    $(wildcard include/config/inline/write/lock/irq.h) \
+    $(wildcard include/config/inline/read/lock/irqsave.h) \
+    $(wildcard include/config/inline/write/lock/irqsave.h) \
+    $(wildcard include/config/inline/read/trylock.h) \
+    $(wildcard include/config/inline/write/trylock.h) \
+    $(wildcard include/config/inline/read/unlock.h) \
+    $(wildcard include/config/inline/write/unlock.h) \
+    $(wildcard include/config/inline/read/unlock/bh.h) \
+    $(wildcard include/config/inline/write/unlock/bh.h) \
+    $(wildcard include/config/inline/read/unlock/irq.h) \
+    $(wildcard include/config/inline/write/unlock/irq.h) \
+    $(wildcard include/config/inline/read/unlock/irqrestore.h) \
+    $(wildcard include/config/inline/write/unlock/irqrestore.h) \
+  include/linux/atomic.h \
+    $(wildcard include/config/arch/has/atomic/or.h) \
+    $(wildcard include/config/generic/atomic64.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/atomic.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/cmpxchg.h \
+    $(wildcard include/config/cpu/sa1100.h) \
+    $(wildcard include/config/cpu/sa110.h) \
+    $(wildcard include/config/cpu/v6.h) \
+  include/asm-generic/cmpxchg-local.h \
+  include/asm-generic/atomic-long.h \
+  include/linux/math64.h \
+  include/linux/kmod.h \
+  include/linux/gfp.h \
+    $(wildcard include/config/kmemcheck.h) \
+    $(wildcard include/config/highmem.h) \
+    $(wildcard include/config/zone/dma.h) \
+    $(wildcard include/config/zone/dma32.h) \
+    $(wildcard include/config/pm/sleep.h) \
+  include/linux/mmzone.h \
+    $(wildcard include/config/force/max/zoneorder.h) \
+    $(wildcard include/config/memory/hotplug.h) \
+    $(wildcard include/config/sparsemem.h) \
+    $(wildcard include/config/have/memblock/node/map.h) \
+    $(wildcard include/config/discontigmem.h) \
+    $(wildcard include/config/flat/node/mem/map.h) \
+    $(wildcard include/config/cgroup/mem/res/ctlr.h) \
+    $(wildcard include/config/no/bootmem.h) \
+    $(wildcard include/config/have/memory/present.h) \
+    $(wildcard include/config/have/memoryless/nodes.h) \
+    $(wildcard include/config/need/node/memmap/size.h) \
+    $(wildcard include/config/have/memblock/node.h) \
+    $(wildcard include/config/need/multiple/nodes.h) \
+    $(wildcard include/config/have/arch/early/pfn/to/nid.h) \
+    $(wildcard include/config/flatmem.h) \
+    $(wildcard include/config/sparsemem/extreme.h) \
+    $(wildcard include/config/have/arch/pfn/valid.h) \
+    $(wildcard include/config/nodes/span/other/nodes.h) \
+    $(wildcard include/config/holes/in/zone.h) \
+    $(wildcard include/config/arch/has/holes/memorymodel.h) \
+  include/linux/wait.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/current.h \
+  include/linux/threads.h \
+    $(wildcard include/config/nr/cpus.h) \
+    $(wildcard include/config/base/small.h) \
+  include/linux/numa.h \
+    $(wildcard include/config/nodes/shift.h) \
+  include/linux/nodemask.h \
+  include/linux/bitmap.h \
+  include/linux/string.h \
+    $(wildcard include/config/binary/printf.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/string.h \
+  include/linux/pageblock-flags.h \
+    $(wildcard include/config/hugetlb/page.h) \
+    $(wildcard include/config/hugetlb/page/size/variable.h) \
+  include/generated/bounds.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/page.h \
+    $(wildcard include/config/cpu/copy/v3.h) \
+    $(wildcard include/config/cpu/copy/v4wt.h) \
+    $(wildcard include/config/cpu/copy/v4wb.h) \
+    $(wildcard include/config/cpu/copy/feroceon.h) \
+    $(wildcard include/config/cpu/copy/fa.h) \
+    $(wildcard include/config/cpu/xscale.h) \
+    $(wildcard include/config/cpu/copy/v6.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/glue.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/pgtable-2level-types.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/memory.h \
+    $(wildcard include/config/need/mach/memory/h.h) \
+    $(wildcard include/config/page/offset.h) \
+    $(wildcard include/config/dram/size.h) \
+    $(wildcard include/config/dram/base.h) \
+    $(wildcard include/config/have/tcm.h) \
+    $(wildcard include/config/arm/patch/phys/virt.h) \
+    $(wildcard include/config/phys/offset.h) \
+  arch/arm/include/generated/asm/sizes.h \
+  include/asm-generic/sizes.h \
+  include/asm-generic/memory_model.h \
+    $(wildcard include/config/sparsemem/vmemmap.h) \
+  include/asm-generic/getorder.h \
+  include/linux/memory_hotplug.h \
+    $(wildcard include/config/memory/hotremove.h) \
+    $(wildcard include/config/have/arch/nodedata/extension.h) \
+  include/linux/notifier.h \
+  include/linux/errno.h \
+  arch/arm/include/generated/asm/errno.h \
+  include/asm-generic/errno.h \
+  include/asm-generic/errno-base.h \
+  include/linux/mutex.h \
+    $(wildcard include/config/debug/mutexes.h) \
+    $(wildcard include/config/have/arch/mutex/cpu/relax.h) \
+  include/linux/rwsem.h \
+    $(wildcard include/config/rwsem/generic/spinlock.h) \
+  include/linux/rwsem-spinlock.h \
+  include/linux/srcu.h \
+  include/linux/rcupdate.h \
+    $(wildcard include/config/rcu/torture/test.h) \
+    $(wildcard include/config/tree/rcu.h) \
+    $(wildcard include/config/tree/preempt/rcu.h) \
+    $(wildcard include/config/rcu/trace.h) \
+    $(wildcard include/config/preempt/rcu.h) \
+    $(wildcard include/config/tiny/rcu.h) \
+    $(wildcard include/config/tiny/preempt/rcu.h) \
+    $(wildcard include/config/debug/objects/rcu/head.h) \
+    $(wildcard include/config/hotplug/cpu.h) \
+    $(wildcard include/config/preempt/rt.h) \
+  include/linux/cpumask.h \
+    $(wildcard include/config/cpumask/offstack.h) \
+    $(wildcard include/config/debug/per/cpu/maps.h) \
+    $(wildcard include/config/disable/obsolete/cpumask/functions.h) \
+  include/linux/bug.h \
+  include/linux/completion.h \
+  include/linux/debugobjects.h \
+    $(wildcard include/config/debug/objects.h) \
+    $(wildcard include/config/debug/objects/free.h) \
+  include/linux/rcutree.h \
+  include/linux/topology.h \
+    $(wildcard include/config/sched/smt.h) \
+    $(wildcard include/config/sched/mc.h) \
+    $(wildcard include/config/sched/book.h) \
+    $(wildcard include/config/use/percpu/numa/node/id.h) \
+  include/linux/smp.h \
+    $(wildcard include/config/use/generic/smp/helpers.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/smp.h \
+  include/linux/percpu.h \
+    $(wildcard include/config/need/per/cpu/embed/first/chunk.h) \
+    $(wildcard include/config/need/per/cpu/page/first/chunk.h) \
+    $(wildcard include/config/have/setup/per/cpu/area.h) \
+  include/linux/pfn.h \
+  arch/arm/include/generated/asm/percpu.h \
+  include/asm-generic/percpu.h \
+  include/linux/percpu-defs.h \
+    $(wildcard include/config/debug/force/weak/per/cpu.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/topology.h \
+    $(wildcard include/config/arm/cpu/topology.h) \
+  include/asm-generic/topology.h \
+  include/linux/mmdebug.h \
+    $(wildcard include/config/debug/vm.h) \
+    $(wildcard include/config/debug/virtual.h) \
+  include/linux/workqueue.h \
+    $(wildcard include/config/debug/objects/work.h) \
+    $(wildcard include/config/freezer.h) \
+  include/linux/timer.h \
+    $(wildcard include/config/timer/stats.h) \
+    $(wildcard include/config/debug/objects/timers.h) \
+  include/linux/ktime.h \
+    $(wildcard include/config/ktime/scalar.h) \
+  include/linux/jiffies.h \
+  include/linux/timex.h \
+  include/linux/param.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/param.h \
+    $(wildcard include/config/hz.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/timex.h \
+  arch/arm/mach-qsp/include/mach/timex.h \
+  include/linux/sysctl.h \
+    $(wildcard include/config/sysctl.h) \
+  include/linux/rbtree.h \
+  include/linux/elf.h \
+  include/linux/elf-em.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/elf.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/user.h \
+  include/linux/kobject.h \
+  include/linux/sysfs.h \
+  include/linux/kobject_ns.h \
+  include/linux/kref.h \
+  include/linux/moduleparam.h \
+    $(wildcard include/config/alpha.h) \
+    $(wildcard include/config/ia64.h) \
+    $(wildcard include/config/ppc64.h) \
+  include/linux/tracepoint.h \
+  include/linux/static_key.h \
+  include/linux/jump_label.h \
+    $(wildcard include/config/jump/label.h) \
+  include/linux/export.h \
+    $(wildcard include/config/symbol/prefix.h) \
+    $(wildcard include/config/modversions.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/module.h \
+    $(wildcard include/config/arm/unwind.h) \
+  include/linux/slab.h \
+    $(wildcard include/config/slab/debug.h) \
+    $(wildcard include/config/failslab.h) \
+    $(wildcard include/config/slub.h) \
+    $(wildcard include/config/slob.h) \
+    $(wildcard include/config/debug/slab.h) \
+    $(wildcard include/config/slab.h) \
+  include/linux/slub_def.h \
+    $(wildcard include/config/slub/stats.h) \
+    $(wildcard include/config/slub/debug.h) \
+  include/linux/kmemleak.h \
+    $(wildcard include/config/debug/kmemleak.h) \
+  include/linux/device.h \
+    $(wildcard include/config/debug/devres.h) \
+    $(wildcard include/config/devtmpfs.h) \
+    $(wildcard include/config/sysfs/deprecated.h) \
+  include/linux/ioport.h \
+  include/linux/klist.h \
+  include/linux/pm.h \
+    $(wildcard include/config/pm/runtime.h) \
+    $(wildcard include/config/pm/clk.h) \
+    $(wildcard include/config/pm/generic/domains.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/device.h \
+    $(wildcard include/config/dmabounce.h) \
+    $(wildcard include/config/iommu/api.h) \
+    $(wildcard include/config/arch/omap.h) \
+  include/linux/pm_wakeup.h \
+  include/linux/platform_device.h \
+    $(wildcard include/config/suspend.h) \
+    $(wildcard include/config/hibernate/callbacks.h) \
+  include/linux/mod_devicetable.h \
+  include/linux/mtd/mtd.h \
+  include/linux/uio.h \
+  include/mtd/mtd-abi.h \
+  include/linux/mtd/map.h \
+    $(wildcard include/config/mtd/map/bank/width/1.h) \
+    $(wildcard include/config/mtd/map/bank/width/2.h) \
+    $(wildcard include/config/mtd/map/bank/width/4.h) \
+    $(wildcard include/config/mtd/map/bank/width/8.h) \
+    $(wildcard include/config/mtd/map/bank/width/16.h) \
+    $(wildcard include/config/mtd/map/bank/width/32.h) \
+    $(wildcard include/config/mtd/map/bank/width/xx.h) \
+    $(wildcard include/config/mtd/complex/mappings.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/unaligned.h \
+  include/linux/unaligned/le_byteshift.h \
+  include/linux/unaligned/be_byteshift.h \
+  include/linux/unaligned/generic.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/io.h \
+    $(wildcard include/config/need/mach/io/h.h) \
+    $(wildcard include/config/pcmcia/soc/common.h) \
+    $(wildcard include/config/pci.h) \
+    $(wildcard include/config/isa.h) \
+    $(wildcard include/config/pccard.h) \
+  include/asm-generic/pci_iomap.h \
+    $(wildcard include/config/no/generic/pci/ioport/map.h) \
+    $(wildcard include/config/generic/pci/iomap.h) \
+  include/linux/mtd/partitions.h \
+  include/linux/mtd/physmap.h \
+  include/linux/mtd/concat.h \
+  include/linux/io.h \
+    $(wildcard include/config/has/ioport.h) \
+
+drivers/mtd/maps/physmap.o: $(deps_drivers/mtd/maps/physmap.o)
+
+$(deps_drivers/mtd/maps/physmap.o):
diff -ruN linux-3.10/drivers/mtd/maps/physmap_of.c linux-3.10_patched/drivers/mtd/maps/physmap_of.c
--- linux-3.10/drivers/mtd/maps/physmap_of.c	2013-06-30 22:13:29.000000000 +0000
+++ linux-3.10_patched/drivers/mtd/maps/physmap_of.c	2025-06-14 05:48:04.965173245 +0000
@@ -68,21 +68,23 @@
 			kfree(info->list[i].res);
 		}
 	}
+
+	kfree(info);
+
 	return 0;
 }
 
-static const char * const rom_probe_types[] = {
-	"cfi_probe", "jedec_probe", "map_rom" };
-
 /* Helper function to handle probing of the obsolete "direct-mapped"
  * compatible binding, which has an extra "probe-type" property
  * describing the type of flash probe necessary. */
-static struct mtd_info *obsolete_probe(struct platform_device *dev,
-				       struct map_info *map)
+static struct mtd_info * obsolete_probe(struct platform_device *dev,
+						  struct map_info *map)
 {
 	struct device_node *dp = dev->dev.of_node;
 	const char *of_probe;
 	struct mtd_info *mtd;
+	static const char *rom_probe_types[]
+		= { "cfi_probe", "jedec_probe", "map_rom"};
 	int i;
 
 	dev_warn(&dev->dev, "Device tree uses obsolete \"direct-mapped\" "
@@ -112,10 +114,9 @@
    specifies the list of partition probers to use. If none is given then the
    default is use. These take precedence over other device tree
    information. */
-static const char * const part_probe_types_def[] = {
-	"cmdlinepart", "RedBoot", "ofpart", "ofoldpart", NULL };
-
-static const char * const *of_get_probes(struct device_node *dp)
+static const char *part_probe_types_def[] = { "cmdlinepart", "RedBoot",
+					"ofpart", "ofoldpart", NULL };
+static const char ** of_get_probes(struct device_node *dp)
 {
 	const char *cp;
 	int cplen;
@@ -144,7 +145,7 @@
 	return res;
 }
 
-static void of_free_probes(const char * const *probes)
+static void of_free_probes(const char **probes)
 {
 	if (probes != part_probe_types_def)
 		kfree(probes);
@@ -153,7 +154,7 @@
 static struct of_device_id of_flash_match[];
 static int of_flash_probe(struct platform_device *dev)
 {
-	const char * const *part_probe_types;
+	const char **part_probe_types;
 	const struct of_device_id *match;
 	struct device_node *dp = dev->dev.of_node;
 	struct resource res;
@@ -168,8 +169,6 @@
 	struct mtd_info **mtd_list = NULL;
 	resource_size_t res_size;
 	struct mtd_part_parser_data ppdata;
-	bool map_indirect;
-	const char *mtd_name = NULL;
 
 	match = of_match_device(of_flash_match, &dev->dev);
 	if (!match)
@@ -178,8 +177,6 @@
 
 	reg_tuple_size = (of_n_addr_cells(dp) + of_n_size_cells(dp)) * sizeof(u32);
 
-	of_property_read_string(dp, "linux,mtd-name", &mtd_name);
-
 	/*
 	 * Get number of "reg" tuples. Scan for MTD devices on area's
 	 * described by each "reg" region. This makes it possible (including
@@ -195,12 +192,9 @@
 	}
 	count /= reg_tuple_size;
 
-	map_indirect = of_property_read_bool(dp, "no-unaligned-direct-access");
-
 	err = -ENOMEM;
-	info = devm_kzalloc(&dev->dev,
-			    sizeof(struct of_flash) +
-			    sizeof(struct of_flash_list) * count, GFP_KERNEL);
+	info = kzalloc(sizeof(struct of_flash) +
+		       sizeof(struct of_flash_list) * count, GFP_KERNEL);
 	if (!info)
 		goto err_flash_remove;
 
@@ -237,11 +231,10 @@
 			goto err_out;
 		}
 
-		info->list[i].map.name = mtd_name ?: dev_name(&dev->dev);
+		info->list[i].map.name = dev_name(&dev->dev);
 		info->list[i].map.phys = res.start;
 		info->list[i].map.size = res_size;
 		info->list[i].map.bankwidth = be32_to_cpup(width);
-		info->list[i].map.device_node = dp;
 
 		err = -ENOMEM;
 		info->list[i].map.virt = ioremap(info->list[i].map.phys,
@@ -254,17 +247,6 @@
 
 		simple_map_init(&info->list[i].map);
 
-		/*
-		 * On some platforms (e.g. MPC5200) a direct 1:1 mapping
-		 * may cause problems with JFFS2 usage, as the local bus (LPB)
-		 * doesn't support unaligned accesses as implemented in the
-		 * JFFS2 code via memcpy(). By setting NO_XIP, the
-		 * flash will not be exposed directly to the MTD users
-		 * (e.g. JFFS2) any more.
-		 */
-		if (map_indirect)
-			info->list[i].map.phys = NO_XIP;
-
 		if (probe_type) {
 			info->list[i].mtd = do_map_probe(probe_type,
 							 &info->list[i].map);
@@ -286,7 +268,6 @@
 	}
 
 	err = 0;
-	info->cmtd = NULL;
 	if (info->list_size == 1) {
 		info->cmtd = info->list[0].mtd;
 	} else if (info->list_size > 1) {
@@ -295,10 +276,9 @@
 		 */
 		info->cmtd = mtd_concat_create(mtd_list, info->list_size,
 					       dev_name(&dev->dev));
+		if (info->cmtd == NULL)
+			err = -ENXIO;
 	}
-	if (info->cmtd == NULL)
-		err = -ENXIO;
-
 	if (err)
 		goto err_out;
 
@@ -344,6 +324,10 @@
 		.type		= "rom",
 		.compatible	= "direct-mapped"
 	},
+	{
+		.compatible     = "qsp-flash",
+		.data	= (void *)"qsp-probe"
+	},
 	{ },
 };
 MODULE_DEVICE_TABLE(of, of_flash_match);
Binary files linux-3.10/drivers/mtd/maps/physmap_of.o and linux-3.10_patched/drivers/mtd/maps/physmap_of.o differ
diff -ruN linux-3.10/drivers/mtd/maps/.physmap_of.o.cmd linux-3.10_patched/drivers/mtd/maps/.physmap_of.o.cmd
--- linux-3.10/drivers/mtd/maps/.physmap_of.o.cmd	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.10_patched/drivers/mtd/maps/.physmap_of.o.cmd	2025-06-14 05:48:04.965173245 +0000
@@ -0,0 +1,437 @@
+cmd_drivers/mtd/maps/physmap_of.o := /home/mike/qsp_buildroot/buildroot/output/host/usr/bin/ccache /home/mike/qsp_buildroot/buildroot/output/host/usr/bin/arm-none-linux-gnueabi-gcc -Wp,-MD,drivers/mtd/maps/.physmap_of.o.d -nostdinc -isystem /home/mike/qsp_buildroot/buildroot/output/host/opt/ext-toolchain/bin/../lib/gcc/arm-none-linux-gnueabi/4.8.1/include -I/home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include -Iarch/arm/include/generated -Iinclude  -include /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/include/linux/kconfig.h -D__KERNEL__ -mlittle-endian -Iarch/arm/mach-qsp/include -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -Wno-format-security -fno-delete-null-pointer-checks -O2 -marm -fno-dwarf2-cfi-asm -mabi=aapcs-linux -mno-thumb-interwork -funwind-tables -D__LINUX_ARM_ARCH__=7 -march=armv7-a -msoft-float -Uarm -Wframe-larger-than=1024 -fno-stack-protector -Wno-unused-but-set-variable -fomit-frame-pointer -g -Wdeclaration-after-statement -Wno-pointer-sign -fno-strict-overflow -fconserve-stack -DCC_HAVE_ASM_GOTO    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(physmap_of)"  -D"KBUILD_MODNAME=KBUILD_STR(physmap_of)" -c -o drivers/mtd/maps/physmap_of.o drivers/mtd/maps/physmap_of.c
+
+source_drivers/mtd/maps/physmap_of.o := drivers/mtd/maps/physmap_of.c
+
+deps_drivers/mtd/maps/physmap_of.o := \
+  include/linux/module.h \
+    $(wildcard include/config/sysfs.h) \
+    $(wildcard include/config/modules.h) \
+    $(wildcard include/config/unused/symbols.h) \
+    $(wildcard include/config/generic/bug.h) \
+    $(wildcard include/config/kallsyms.h) \
+    $(wildcard include/config/smp.h) \
+    $(wildcard include/config/tracepoints.h) \
+    $(wildcard include/config/tracing.h) \
+    $(wildcard include/config/event/tracing.h) \
+    $(wildcard include/config/ftrace/mcount/record.h) \
+    $(wildcard include/config/module/unload.h) \
+    $(wildcard include/config/constructors.h) \
+    $(wildcard include/config/debug/set/module/ronx.h) \
+  include/linux/list.h \
+    $(wildcard include/config/debug/list.h) \
+  include/linux/types.h \
+    $(wildcard include/config/uid16.h) \
+    $(wildcard include/config/lbdaf.h) \
+    $(wildcard include/config/arch/dma/addr/t/64bit.h) \
+    $(wildcard include/config/phys/addr/t/64bit.h) \
+    $(wildcard include/config/64bit.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/types.h \
+  include/asm-generic/int-ll64.h \
+  arch/arm/include/generated/asm/bitsperlong.h \
+  include/asm-generic/bitsperlong.h \
+  include/linux/posix_types.h \
+  include/linux/stddef.h \
+  include/linux/compiler.h \
+    $(wildcard include/config/sparse/rcu/pointer.h) \
+    $(wildcard include/config/trace/branch/profiling.h) \
+    $(wildcard include/config/profile/all/branches.h) \
+    $(wildcard include/config/enable/must/check.h) \
+    $(wildcard include/config/enable/warn/deprecated.h) \
+  include/linux/compiler-gcc.h \
+    $(wildcard include/config/arch/supports/optimized/inlining.h) \
+    $(wildcard include/config/optimize/inlining.h) \
+  include/linux/compiler-gcc4.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/posix_types.h \
+  include/asm-generic/posix_types.h \
+  include/linux/poison.h \
+    $(wildcard include/config/illegal/pointer/value.h) \
+  include/linux/const.h \
+  include/linux/stat.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/stat.h \
+  include/linux/time.h \
+    $(wildcard include/config/arch/uses/gettimeoffset.h) \
+  include/linux/cache.h \
+    $(wildcard include/config/arch/has/cache/line/size.h) \
+  include/linux/kernel.h \
+    $(wildcard include/config/preempt/voluntary.h) \
+    $(wildcard include/config/debug/atomic/sleep.h) \
+    $(wildcard include/config/prove/locking.h) \
+    $(wildcard include/config/ring/buffer.h) \
+    $(wildcard include/config/numa.h) \
+    $(wildcard include/config/compaction.h) \
+  include/linux/sysinfo.h \
+  /home/mike/qsp_buildroot/buildroot/output/host/opt/ext-toolchain/lib/gcc/arm-none-linux-gnueabi/4.8.1/include/stdarg.h \
+  include/linux/linkage.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/linkage.h \
+  include/linux/bitops.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/bitops.h \
+  include/linux/irqflags.h \
+    $(wildcard include/config/trace/irqflags.h) \
+    $(wildcard include/config/irqsoff/tracer.h) \
+    $(wildcard include/config/preempt/tracer.h) \
+    $(wildcard include/config/trace/irqflags/support.h) \
+  include/linux/typecheck.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/irqflags.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/ptrace.h \
+    $(wildcard include/config/cpu/endian/be8.h) \
+    $(wildcard include/config/arm/thumb.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/hwcap.h \
+  include/asm-generic/bitops/non-atomic.h \
+  include/asm-generic/bitops/fls64.h \
+  include/asm-generic/bitops/sched.h \
+  include/asm-generic/bitops/hweight.h \
+  include/asm-generic/bitops/arch_hweight.h \
+  include/asm-generic/bitops/const_hweight.h \
+  include/asm-generic/bitops/lock.h \
+  include/asm-generic/bitops/le.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/byteorder.h \
+  include/linux/byteorder/little_endian.h \
+  include/linux/swab.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/swab.h \
+  include/linux/byteorder/generic.h \
+  include/asm-generic/bitops/ext2-atomic-setbit.h \
+  include/linux/log2.h \
+    $(wildcard include/config/arch/has/ilog2/u32.h) \
+    $(wildcard include/config/arch/has/ilog2/u64.h) \
+  include/linux/printk.h \
+    $(wildcard include/config/printk.h) \
+    $(wildcard include/config/dynamic/debug.h) \
+  include/linux/init.h \
+    $(wildcard include/config/hotplug.h) \
+  include/linux/dynamic_debug.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/div64.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/compiler.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/bug.h \
+    $(wildcard include/config/bug.h) \
+    $(wildcard include/config/thumb2/kernel.h) \
+    $(wildcard include/config/debug/bugverbose.h) \
+    $(wildcard include/config/arm/lpae.h) \
+  include/asm-generic/bug.h \
+    $(wildcard include/config/generic/bug/relative/pointers.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/cache.h \
+    $(wildcard include/config/arm/l1/cache/shift.h) \
+    $(wildcard include/config/aeabi.h) \
+  include/linux/seqlock.h \
+  include/linux/spinlock.h \
+    $(wildcard include/config/debug/spinlock.h) \
+    $(wildcard include/config/generic/lockbreak.h) \
+    $(wildcard include/config/preempt.h) \
+    $(wildcard include/config/debug/lock/alloc.h) \
+  include/linux/preempt.h \
+    $(wildcard include/config/debug/preempt.h) \
+    $(wildcard include/config/preempt/count.h) \
+    $(wildcard include/config/preempt/notifiers.h) \
+  include/linux/thread_info.h \
+    $(wildcard include/config/compat.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/thread_info.h \
+    $(wildcard include/config/arm/thumbee.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/fpstate.h \
+    $(wildcard include/config/vfpv3.h) \
+    $(wildcard include/config/iwmmxt.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/domain.h \
+    $(wildcard include/config/io/36.h) \
+    $(wildcard include/config/cpu/use/domains.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/barrier.h \
+    $(wildcard include/config/cpu/32v6k.h) \
+    $(wildcard include/config/cpu/xsc3.h) \
+    $(wildcard include/config/cpu/fa526.h) \
+    $(wildcard include/config/arch/has/barriers.h) \
+    $(wildcard include/config/arm/dma/mem/bufferable.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/outercache.h \
+    $(wildcard include/config/outer/cache/sync.h) \
+    $(wildcard include/config/outer/cache.h) \
+  include/linux/stringify.h \
+  include/linux/bottom_half.h \
+  include/linux/spinlock_types.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/spinlock_types.h \
+  include/linux/lockdep.h \
+    $(wildcard include/config/lockdep.h) \
+    $(wildcard include/config/lock/stat.h) \
+    $(wildcard include/config/prove/rcu.h) \
+  include/linux/rwlock_types.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/spinlock.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/processor.h \
+    $(wildcard include/config/have/hw/breakpoint.h) \
+    $(wildcard include/config/mmu.h) \
+    $(wildcard include/config/arm/errata/754327.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/hw_breakpoint.h \
+  include/linux/rwlock.h \
+  include/linux/spinlock_api_smp.h \
+    $(wildcard include/config/inline/spin/lock.h) \
+    $(wildcard include/config/inline/spin/lock/bh.h) \
+    $(wildcard include/config/inline/spin/lock/irq.h) \
+    $(wildcard include/config/inline/spin/lock/irqsave.h) \
+    $(wildcard include/config/inline/spin/trylock.h) \
+    $(wildcard include/config/inline/spin/trylock/bh.h) \
+    $(wildcard include/config/uninline/spin/unlock.h) \
+    $(wildcard include/config/inline/spin/unlock/bh.h) \
+    $(wildcard include/config/inline/spin/unlock/irq.h) \
+    $(wildcard include/config/inline/spin/unlock/irqrestore.h) \
+  include/linux/rwlock_api_smp.h \
+    $(wildcard include/config/inline/read/lock.h) \
+    $(wildcard include/config/inline/write/lock.h) \
+    $(wildcard include/config/inline/read/lock/bh.h) \
+    $(wildcard include/config/inline/write/lock/bh.h) \
+    $(wildcard include/config/inline/read/lock/irq.h) \
+    $(wildcard include/config/inline/write/lock/irq.h) \
+    $(wildcard include/config/inline/read/lock/irqsave.h) \
+    $(wildcard include/config/inline/write/lock/irqsave.h) \
+    $(wildcard include/config/inline/read/trylock.h) \
+    $(wildcard include/config/inline/write/trylock.h) \
+    $(wildcard include/config/inline/read/unlock.h) \
+    $(wildcard include/config/inline/write/unlock.h) \
+    $(wildcard include/config/inline/read/unlock/bh.h) \
+    $(wildcard include/config/inline/write/unlock/bh.h) \
+    $(wildcard include/config/inline/read/unlock/irq.h) \
+    $(wildcard include/config/inline/write/unlock/irq.h) \
+    $(wildcard include/config/inline/read/unlock/irqrestore.h) \
+    $(wildcard include/config/inline/write/unlock/irqrestore.h) \
+  include/linux/atomic.h \
+    $(wildcard include/config/arch/has/atomic/or.h) \
+    $(wildcard include/config/generic/atomic64.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/atomic.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/cmpxchg.h \
+    $(wildcard include/config/cpu/sa1100.h) \
+    $(wildcard include/config/cpu/sa110.h) \
+    $(wildcard include/config/cpu/v6.h) \
+  include/asm-generic/cmpxchg-local.h \
+  include/asm-generic/atomic-long.h \
+  include/linux/math64.h \
+  include/linux/kmod.h \
+  include/linux/gfp.h \
+    $(wildcard include/config/kmemcheck.h) \
+    $(wildcard include/config/highmem.h) \
+    $(wildcard include/config/zone/dma.h) \
+    $(wildcard include/config/zone/dma32.h) \
+    $(wildcard include/config/pm/sleep.h) \
+  include/linux/mmzone.h \
+    $(wildcard include/config/force/max/zoneorder.h) \
+    $(wildcard include/config/memory/hotplug.h) \
+    $(wildcard include/config/sparsemem.h) \
+    $(wildcard include/config/have/memblock/node/map.h) \
+    $(wildcard include/config/discontigmem.h) \
+    $(wildcard include/config/flat/node/mem/map.h) \
+    $(wildcard include/config/cgroup/mem/res/ctlr.h) \
+    $(wildcard include/config/no/bootmem.h) \
+    $(wildcard include/config/have/memory/present.h) \
+    $(wildcard include/config/have/memoryless/nodes.h) \
+    $(wildcard include/config/need/node/memmap/size.h) \
+    $(wildcard include/config/have/memblock/node.h) \
+    $(wildcard include/config/need/multiple/nodes.h) \
+    $(wildcard include/config/have/arch/early/pfn/to/nid.h) \
+    $(wildcard include/config/flatmem.h) \
+    $(wildcard include/config/sparsemem/extreme.h) \
+    $(wildcard include/config/have/arch/pfn/valid.h) \
+    $(wildcard include/config/nodes/span/other/nodes.h) \
+    $(wildcard include/config/holes/in/zone.h) \
+    $(wildcard include/config/arch/has/holes/memorymodel.h) \
+  include/linux/wait.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/current.h \
+  include/linux/threads.h \
+    $(wildcard include/config/nr/cpus.h) \
+    $(wildcard include/config/base/small.h) \
+  include/linux/numa.h \
+    $(wildcard include/config/nodes/shift.h) \
+  include/linux/nodemask.h \
+  include/linux/bitmap.h \
+  include/linux/string.h \
+    $(wildcard include/config/binary/printf.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/string.h \
+  include/linux/pageblock-flags.h \
+    $(wildcard include/config/hugetlb/page.h) \
+    $(wildcard include/config/hugetlb/page/size/variable.h) \
+  include/generated/bounds.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/page.h \
+    $(wildcard include/config/cpu/copy/v3.h) \
+    $(wildcard include/config/cpu/copy/v4wt.h) \
+    $(wildcard include/config/cpu/copy/v4wb.h) \
+    $(wildcard include/config/cpu/copy/feroceon.h) \
+    $(wildcard include/config/cpu/copy/fa.h) \
+    $(wildcard include/config/cpu/xscale.h) \
+    $(wildcard include/config/cpu/copy/v6.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/glue.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/pgtable-2level-types.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/memory.h \
+    $(wildcard include/config/need/mach/memory/h.h) \
+    $(wildcard include/config/page/offset.h) \
+    $(wildcard include/config/dram/size.h) \
+    $(wildcard include/config/dram/base.h) \
+    $(wildcard include/config/have/tcm.h) \
+    $(wildcard include/config/arm/patch/phys/virt.h) \
+    $(wildcard include/config/phys/offset.h) \
+  arch/arm/include/generated/asm/sizes.h \
+  include/asm-generic/sizes.h \
+  include/asm-generic/memory_model.h \
+    $(wildcard include/config/sparsemem/vmemmap.h) \
+  include/asm-generic/getorder.h \
+  include/linux/memory_hotplug.h \
+    $(wildcard include/config/memory/hotremove.h) \
+    $(wildcard include/config/have/arch/nodedata/extension.h) \
+  include/linux/notifier.h \
+  include/linux/errno.h \
+  arch/arm/include/generated/asm/errno.h \
+  include/asm-generic/errno.h \
+  include/asm-generic/errno-base.h \
+  include/linux/mutex.h \
+    $(wildcard include/config/debug/mutexes.h) \
+    $(wildcard include/config/have/arch/mutex/cpu/relax.h) \
+  include/linux/rwsem.h \
+    $(wildcard include/config/rwsem/generic/spinlock.h) \
+  include/linux/rwsem-spinlock.h \
+  include/linux/srcu.h \
+  include/linux/rcupdate.h \
+    $(wildcard include/config/rcu/torture/test.h) \
+    $(wildcard include/config/tree/rcu.h) \
+    $(wildcard include/config/tree/preempt/rcu.h) \
+    $(wildcard include/config/rcu/trace.h) \
+    $(wildcard include/config/preempt/rcu.h) \
+    $(wildcard include/config/tiny/rcu.h) \
+    $(wildcard include/config/tiny/preempt/rcu.h) \
+    $(wildcard include/config/debug/objects/rcu/head.h) \
+    $(wildcard include/config/hotplug/cpu.h) \
+    $(wildcard include/config/preempt/rt.h) \
+  include/linux/cpumask.h \
+    $(wildcard include/config/cpumask/offstack.h) \
+    $(wildcard include/config/debug/per/cpu/maps.h) \
+    $(wildcard include/config/disable/obsolete/cpumask/functions.h) \
+  include/linux/bug.h \
+  include/linux/completion.h \
+  include/linux/debugobjects.h \
+    $(wildcard include/config/debug/objects.h) \
+    $(wildcard include/config/debug/objects/free.h) \
+  include/linux/rcutree.h \
+  include/linux/topology.h \
+    $(wildcard include/config/sched/smt.h) \
+    $(wildcard include/config/sched/mc.h) \
+    $(wildcard include/config/sched/book.h) \
+    $(wildcard include/config/use/percpu/numa/node/id.h) \
+  include/linux/smp.h \
+    $(wildcard include/config/use/generic/smp/helpers.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/smp.h \
+  include/linux/percpu.h \
+    $(wildcard include/config/need/per/cpu/embed/first/chunk.h) \
+    $(wildcard include/config/need/per/cpu/page/first/chunk.h) \
+    $(wildcard include/config/have/setup/per/cpu/area.h) \
+  include/linux/pfn.h \
+  arch/arm/include/generated/asm/percpu.h \
+  include/asm-generic/percpu.h \
+  include/linux/percpu-defs.h \
+    $(wildcard include/config/debug/force/weak/per/cpu.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/topology.h \
+    $(wildcard include/config/arm/cpu/topology.h) \
+  include/asm-generic/topology.h \
+  include/linux/mmdebug.h \
+    $(wildcard include/config/debug/vm.h) \
+    $(wildcard include/config/debug/virtual.h) \
+  include/linux/workqueue.h \
+    $(wildcard include/config/debug/objects/work.h) \
+    $(wildcard include/config/freezer.h) \
+  include/linux/timer.h \
+    $(wildcard include/config/timer/stats.h) \
+    $(wildcard include/config/debug/objects/timers.h) \
+  include/linux/ktime.h \
+    $(wildcard include/config/ktime/scalar.h) \
+  include/linux/jiffies.h \
+  include/linux/timex.h \
+  include/linux/param.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/param.h \
+    $(wildcard include/config/hz.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/timex.h \
+  arch/arm/mach-qsp/include/mach/timex.h \
+  include/linux/sysctl.h \
+    $(wildcard include/config/sysctl.h) \
+  include/linux/rbtree.h \
+  include/linux/elf.h \
+  include/linux/elf-em.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/elf.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/user.h \
+  include/linux/kobject.h \
+  include/linux/sysfs.h \
+  include/linux/kobject_ns.h \
+  include/linux/kref.h \
+  include/linux/moduleparam.h \
+    $(wildcard include/config/alpha.h) \
+    $(wildcard include/config/ia64.h) \
+    $(wildcard include/config/ppc64.h) \
+  include/linux/tracepoint.h \
+  include/linux/static_key.h \
+  include/linux/jump_label.h \
+    $(wildcard include/config/jump/label.h) \
+  include/linux/export.h \
+    $(wildcard include/config/symbol/prefix.h) \
+    $(wildcard include/config/modversions.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/module.h \
+    $(wildcard include/config/arm/unwind.h) \
+  include/linux/device.h \
+    $(wildcard include/config/debug/devres.h) \
+    $(wildcard include/config/devtmpfs.h) \
+    $(wildcard include/config/sysfs/deprecated.h) \
+  include/linux/ioport.h \
+  include/linux/klist.h \
+  include/linux/pm.h \
+    $(wildcard include/config/pm.h) \
+    $(wildcard include/config/pm/runtime.h) \
+    $(wildcard include/config/pm/clk.h) \
+    $(wildcard include/config/pm/generic/domains.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/device.h \
+    $(wildcard include/config/dmabounce.h) \
+    $(wildcard include/config/iommu/api.h) \
+    $(wildcard include/config/arch/omap.h) \
+  include/linux/pm_wakeup.h \
+  include/linux/mtd/mtd.h \
+  include/linux/uio.h \
+  include/mtd/mtd-abi.h \
+  include/linux/mtd/map.h \
+    $(wildcard include/config/mtd/map/bank/width/1.h) \
+    $(wildcard include/config/mtd/map/bank/width/2.h) \
+    $(wildcard include/config/mtd/map/bank/width/4.h) \
+    $(wildcard include/config/mtd/map/bank/width/8.h) \
+    $(wildcard include/config/mtd/map/bank/width/16.h) \
+    $(wildcard include/config/mtd/map/bank/width/32.h) \
+    $(wildcard include/config/mtd/map/bank/width/xx.h) \
+    $(wildcard include/config/mtd/complex/mappings.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/unaligned.h \
+  include/linux/unaligned/le_byteshift.h \
+  include/linux/unaligned/be_byteshift.h \
+  include/linux/unaligned/generic.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/io.h \
+    $(wildcard include/config/need/mach/io/h.h) \
+    $(wildcard include/config/pcmcia/soc/common.h) \
+    $(wildcard include/config/pci.h) \
+    $(wildcard include/config/isa.h) \
+    $(wildcard include/config/pccard.h) \
+  include/asm-generic/pci_iomap.h \
+    $(wildcard include/config/no/generic/pci/ioport/map.h) \
+    $(wildcard include/config/generic/pci/iomap.h) \
+  include/linux/mtd/partitions.h \
+  include/linux/mtd/concat.h \
+  include/linux/of.h \
+    $(wildcard include/config/sparc.h) \
+    $(wildcard include/config/of/dynamic.h) \
+    $(wildcard include/config/of.h) \
+  include/linux/mod_devicetable.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/prom.h \
+  include/linux/of_address.h \
+    $(wildcard include/config/of/address.h) \
+  include/linux/of_platform.h \
+    $(wildcard include/config/of/device.h) \
+  include/linux/of_device.h \
+  include/linux/platform_device.h \
+    $(wildcard include/config/suspend.h) \
+    $(wildcard include/config/hibernate/callbacks.h) \
+  include/linux/slab.h \
+    $(wildcard include/config/slab/debug.h) \
+    $(wildcard include/config/failslab.h) \
+    $(wildcard include/config/slub.h) \
+    $(wildcard include/config/slob.h) \
+    $(wildcard include/config/debug/slab.h) \
+    $(wildcard include/config/slab.h) \
+  include/linux/slub_def.h \
+    $(wildcard include/config/slub/stats.h) \
+    $(wildcard include/config/slub/debug.h) \
+  include/linux/kmemleak.h \
+    $(wildcard include/config/debug/kmemleak.h) \
+
+drivers/mtd/maps/physmap_of.o: $(deps_drivers/mtd/maps/physmap_of.o)
+
+$(deps_drivers/mtd/maps/physmap_of.o):
diff -ruN linux-3.10/drivers/mtd/maps/pismo.c linux-3.10_patched/drivers/mtd/maps/pismo.c
--- linux-3.10/drivers/mtd/maps/pismo.c	2013-06-30 22:13:29.000000000 +0000
+++ linux-3.10_patched/drivers/mtd/maps/pismo.c	2025-06-14 05:48:04.961173245 +0000
@@ -58,7 +58,7 @@
 	pismo->vpp(pismo->vpp_data, on);
 }
 
-static unsigned int pismo_width_to_bytes(unsigned int width)
+static unsigned int __devinit pismo_width_to_bytes(unsigned int width)
 {
 	width &= 15;
 	if (width > 2)
@@ -66,8 +66,8 @@
 	return 1 << width;
 }
 
-static int pismo_eeprom_read(struct i2c_client *client, void *buf, u8 addr,
-			     size_t size)
+static int __devinit pismo_eeprom_read(struct i2c_client *client, void *buf,
+	u8 addr, size_t size)
 {
 	int ret;
 	struct i2c_msg msg[] = {
@@ -88,9 +88,8 @@
 	return ret == ARRAY_SIZE(msg) ? size : -EIO;
 }
 
-static int pismo_add_device(struct pismo_data *pismo, int i,
-			    struct pismo_mem *region, const char *name,
-			    void *pdata, size_t psize)
+static int __devinit pismo_add_device(struct pismo_data *pismo, int i,
+	struct pismo_mem *region, const char *name, void *pdata, size_t psize)
 {
 	struct platform_device *dev;
 	struct resource res = { };
@@ -130,8 +129,8 @@
 	return ret;
 }
 
-static int pismo_add_nor(struct pismo_data *pismo, int i,
-			 struct pismo_mem *region)
+static int __devinit pismo_add_nor(struct pismo_data *pismo, int i,
+	struct pismo_mem *region)
 {
 	struct physmap_flash_data data = {
 		.width = region->width,
@@ -144,8 +143,8 @@
 		&data, sizeof(data));
 }
 
-static int pismo_add_sram(struct pismo_data *pismo, int i,
-			  struct pismo_mem *region)
+static int __devinit pismo_add_sram(struct pismo_data *pismo, int i,
+	struct pismo_mem *region)
 {
 	struct platdata_mtd_ram data = {
 		.bankwidth = region->width,
@@ -155,8 +154,8 @@
 		&data, sizeof(data));
 }
 
-static void pismo_add_one(struct pismo_data *pismo, int i,
-			  const struct pismo_cs_block *cs, phys_addr_t base)
+static void __devinit pismo_add_one(struct pismo_data *pismo, int i,
+	const struct pismo_cs_block *cs, phys_addr_t base)
 {
 	struct device *dev = &pismo->client->dev;
 	struct pismo_mem region;
@@ -198,7 +197,7 @@
 	}
 }
 
-static int pismo_remove(struct i2c_client *client)
+static int __devexit pismo_remove(struct i2c_client *client)
 {
 	struct pismo_data *pismo = i2c_get_clientdata(client);
 	int i;
@@ -211,8 +210,8 @@
 	return 0;
 }
 
-static int pismo_probe(struct i2c_client *client,
-		       const struct i2c_device_id *id)
+static int __devinit pismo_probe(struct i2c_client *client,
+				 const struct i2c_device_id *id)
 {
 	struct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);
 	struct pismo_pdata *pdata = client->dev.platform_data;
@@ -268,7 +267,7 @@
 		.owner	= THIS_MODULE,
 	},
 	.probe		= pismo_probe,
-	.remove		= pismo_remove,
+	.remove		= __devexit_p(pismo_remove),
 	.id_table	= pismo_id,
 };
 
diff -ruN linux-3.10/drivers/mtd/maps/plat-ram.c linux-3.10_patched/drivers/mtd/maps/plat-ram.c
--- linux-3.10/drivers/mtd/maps/plat-ram.c	2013-06-30 22:13:29.000000000 +0000
+++ linux-3.10_patched/drivers/mtd/maps/plat-ram.c	2025-06-14 05:48:04.961173245 +0000
@@ -199,7 +199,7 @@
 	 * supplied by the platform_data struct */
 
 	if (pdata->map_probes) {
-		const char * const *map_probes = pdata->map_probes;
+		const char **map_probes = pdata->map_probes;
 
 		for ( ; !info->mtd && *map_probes; map_probes++)
 			info->mtd = do_map_probe(*map_probes , &info->map);
@@ -219,7 +219,7 @@
 
 	platram_setrw(info, PLATRAM_RW);
 
-	/* check to see if there are any available partitions, or whether
+	/* check to see if there are any available partitions, or wether
 	 * to add this device whole */
 
 	err = mtd_device_parse_register(info->mtd, pdata->probes, NULL,
diff -ruN linux-3.10/drivers/mtd/maps/pxa2xx-flash.c linux-3.10_patched/drivers/mtd/maps/pxa2xx-flash.c
--- linux-3.10/drivers/mtd/maps/pxa2xx-flash.c	2013-06-30 22:13:29.000000000 +0000
+++ linux-3.10_patched/drivers/mtd/maps/pxa2xx-flash.c	2025-06-14 05:48:04.961173245 +0000
@@ -45,9 +45,11 @@
 	struct map_info		map;
 };
 
-static const char * const probes[] = { "RedBoot", "cmdlinepart", NULL };
 
-static int pxa2xx_flash_probe(struct platform_device *pdev)
+static const char *probes[] = { "RedBoot", "cmdlinepart", NULL };
+
+
+static int __devinit pxa2xx_flash_probe(struct platform_device *pdev)
 {
 	struct flash_platform_data *flash = pdev->dev.platform_data;
 	struct pxa2xx_flash_info *info;
@@ -103,7 +105,7 @@
 	return 0;
 }
 
-static int pxa2xx_flash_remove(struct platform_device *dev)
+static int __devexit pxa2xx_flash_remove(struct platform_device *dev)
 {
 	struct pxa2xx_flash_info *info = platform_get_drvdata(dev);
 
@@ -137,7 +139,7 @@
 		.owner		= THIS_MODULE,
 	},
 	.probe		= pxa2xx_flash_probe,
-	.remove		= pxa2xx_flash_remove,
+	.remove		= __devexit_p(pxa2xx_flash_remove),
 	.shutdown	= pxa2xx_flash_shutdown,
 };
 
diff -ruN linux-3.10/drivers/mtd/maps/rbtx4939-flash.c linux-3.10_patched/drivers/mtd/maps/rbtx4939-flash.c
--- linux-3.10/drivers/mtd/maps/rbtx4939-flash.c	2013-06-30 22:13:29.000000000 +0000
+++ linux-3.10_patched/drivers/mtd/maps/rbtx4939-flash.c	2025-06-14 05:48:04.961173245 +0000
@@ -45,15 +45,14 @@
 	return 0;
 }
 
-static const char * const rom_probe_types[] = {
-	"cfi_probe", "jedec_probe", NULL };
+static const char *rom_probe_types[] = { "cfi_probe", "jedec_probe", NULL };
 
 static int rbtx4939_flash_probe(struct platform_device *dev)
 {
 	struct rbtx4939_flash_data *pdata;
 	struct rbtx4939_flash_info *info;
 	struct resource *res;
-	const char * const *probe_type;
+	const char **probe_type;
 	int err = 0;
 	unsigned long size;
 
@@ -101,6 +100,8 @@
 		goto err_out;
 	}
 	info->mtd->owner = THIS_MODULE;
+	if (err)
+		goto err_out;
 	err = mtd_device_parse_register(info->mtd, NULL, NULL, pdata->parts,
 					pdata->nr_parts);
 
diff -ruN linux-3.10/drivers/mtd/maps/rpxlite.c linux-3.10_patched/drivers/mtd/maps/rpxlite.c
--- linux-3.10/drivers/mtd/maps/rpxlite.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.10_patched/drivers/mtd/maps/rpxlite.c	2025-06-14 05:48:04.961173245 +0000
@@ -0,0 +1,64 @@
+/*
+ * Handle mapping of the flash on the RPX Lite and CLLF boards
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <asm/io.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+
+
+#define WINDOW_ADDR 0xfe000000
+#define WINDOW_SIZE 0x800000
+
+static struct mtd_info *mymtd;
+
+static struct map_info rpxlite_map = {
+	.name = "RPX",
+	.size = WINDOW_SIZE,
+	.bankwidth = 4,
+	.phys = WINDOW_ADDR,
+};
+
+static int __init init_rpxlite(void)
+{
+	printk(KERN_NOTICE "RPX Lite or CLLF flash device: %x at %x\n", WINDOW_SIZE*4, WINDOW_ADDR);
+	rpxlite_map.virt = ioremap(WINDOW_ADDR, WINDOW_SIZE * 4);
+
+	if (!rpxlite_map.virt) {
+		printk("Failed to ioremap\n");
+		return -EIO;
+	}
+	simple_map_init(&rpxlite_map);
+	mymtd = do_map_probe("cfi_probe", &rpxlite_map);
+	if (mymtd) {
+		mymtd->owner = THIS_MODULE;
+		mtd_device_register(mymtd, NULL, 0);
+		return 0;
+	}
+
+	iounmap((void *)rpxlite_map.virt);
+	return -ENXIO;
+}
+
+static void __exit cleanup_rpxlite(void)
+{
+	if (mymtd) {
+		mtd_device_unregister(mymtd);
+		map_destroy(mymtd);
+	}
+	if (rpxlite_map.virt) {
+		iounmap((void *)rpxlite_map.virt);
+		rpxlite_map.virt = 0;
+	}
+}
+
+module_init(init_rpxlite);
+module_exit(cleanup_rpxlite);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Arnold Christensen <AKC@pel.dk>");
+MODULE_DESCRIPTION("MTD map driver for RPX Lite and CLLF boards");
diff -ruN linux-3.10/drivers/mtd/maps/sa1100-flash.c linux-3.10_patched/drivers/mtd/maps/sa1100-flash.c
--- linux-3.10/drivers/mtd/maps/sa1100-flash.c	2013-06-30 22:13:29.000000000 +0000
+++ linux-3.10_patched/drivers/mtd/maps/sa1100-flash.c	2025-06-14 05:48:04.961173245 +0000
@@ -149,8 +149,8 @@
 		plat->exit();
 }
 
-static struct sa_info *sa1100_setup_mtd(struct platform_device *pdev,
-					struct flash_platform_data *plat)
+static struct sa_info *__devinit
+sa1100_setup_mtd(struct platform_device *pdev, struct flash_platform_data *plat)
 {
 	struct sa_info *info;
 	int nr, size, i, ret = 0;
@@ -244,9 +244,9 @@
 	return ERR_PTR(ret);
 }
 
-static const char * const part_probes[] = { "cmdlinepart", "RedBoot", NULL };
+static const char *part_probes[] = { "cmdlinepart", "RedBoot", NULL };
 
-static int sa1100_mtd_probe(struct platform_device *pdev)
+static int __devinit sa1100_mtd_probe(struct platform_device *pdev)
 {
 	struct flash_platform_data *plat = pdev->dev.platform_data;
 	struct sa_info *info;
diff -ruN linux-3.10/drivers/mtd/maps/scb2_flash.c linux-3.10_patched/drivers/mtd/maps/scb2_flash.c
--- linux-3.10/drivers/mtd/maps/scb2_flash.c	2013-06-30 22:13:29.000000000 +0000
+++ linux-3.10_patched/drivers/mtd/maps/scb2_flash.c	2025-06-14 05:48:04.965173245 +0000
@@ -69,7 +69,8 @@
 };
 static int region_fail;
 
-static int scb2_fixup_mtd(struct mtd_info *mtd)
+static int __devinit
+scb2_fixup_mtd(struct mtd_info *mtd)
 {
 	int i;
 	int done = 0;
@@ -132,8 +133,8 @@
 /* CSB5's 'Function Control Register' has bits for decoding @ >= 0xffc00000 */
 #define CSB5_FCR	0x41
 #define CSB5_FCR_DECODE_ALL 0x0e
-static int scb2_flash_probe(struct pci_dev *dev,
-			    const struct pci_device_id *ent)
+static int __devinit
+scb2_flash_probe(struct pci_dev *dev, const struct pci_device_id *ent)
 {
 	u8 reg;
 
@@ -196,7 +197,8 @@
 	return 0;
 }
 
-static void scb2_flash_remove(struct pci_dev *dev)
+static void __devexit
+scb2_flash_remove(struct pci_dev *dev)
 {
 	if (!scb2_mtd)
 		return;
@@ -229,10 +231,23 @@
 	.name =     "Intel SCB2 BIOS Flash",
 	.id_table = scb2_flash_pci_ids,
 	.probe =    scb2_flash_probe,
-	.remove =   scb2_flash_remove,
+	.remove =   __devexit_p(scb2_flash_remove),
 };
 
-module_pci_driver(scb2_flash_driver);
+static int __init
+scb2_flash_init(void)
+{
+	return pci_register_driver(&scb2_flash_driver);
+}
+
+static void __exit
+scb2_flash_exit(void)
+{
+	pci_unregister_driver(&scb2_flash_driver);
+}
+
+module_init(scb2_flash_init);
+module_exit(scb2_flash_exit);
 
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Tim Hockin <thockin@sun.com>");
diff -ruN linux-3.10/drivers/mtd/maps/solutionengine.c linux-3.10_patched/drivers/mtd/maps/solutionengine.c
--- linux-3.10/drivers/mtd/maps/solutionengine.c	2013-06-30 22:13:29.000000000 +0000
+++ linux-3.10_patched/drivers/mtd/maps/solutionengine.c	2025-06-14 05:48:04.965173245 +0000
@@ -31,7 +31,7 @@
 	.bankwidth = 4,
 };
 
-static const char * const probes[] = { "RedBoot", "cmdlinepart", NULL };
+static const char *probes[] = { "RedBoot", "cmdlinepart", NULL };
 
 #ifdef CONFIG_MTD_SUPERH_RESERVE
 static struct mtd_partition superh_se_partitions[] = {
diff -ruN linux-3.10/drivers/mtd/maps/sun_uflash.c linux-3.10_patched/drivers/mtd/maps/sun_uflash.c
--- linux-3.10/drivers/mtd/maps/sun_uflash.c	2013-06-30 22:13:29.000000000 +0000
+++ linux-3.10_patched/drivers/mtd/maps/sun_uflash.c	2025-06-14 05:48:04.965173245 +0000
@@ -108,7 +108,7 @@
 	return 0;
 }
 
-static int uflash_probe(struct platform_device *op)
+static int __devinit uflash_probe(struct platform_device *op)
 {
 	struct device_node *dp = op->dev.of_node;
 
@@ -121,7 +121,7 @@
 	return uflash_devinit(op, dp);
 }
 
-static int uflash_remove(struct platform_device *op)
+static int __devexit uflash_remove(struct platform_device *op)
 {
 	struct uflash_dev *up = dev_get_drvdata(&op->dev);
 
@@ -155,7 +155,7 @@
 		.of_match_table = uflash_match,
 	},
 	.probe		= uflash_probe,
-	.remove		= uflash_remove,
+	.remove		= __devexit_p(uflash_remove),
 };
 
 module_platform_driver(uflash_driver);
diff -ruN linux-3.10/drivers/mtd/maps/tqm8xxl.c linux-3.10_patched/drivers/mtd/maps/tqm8xxl.c
--- linux-3.10/drivers/mtd/maps/tqm8xxl.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.10_patched/drivers/mtd/maps/tqm8xxl.c	2025-06-14 05:48:04.965173245 +0000
@@ -0,0 +1,249 @@
+/*
+ * Handle mapping of the flash memory access routines
+ * on TQM8xxL based devices.
+ *
+ * based on rpxlite.c
+ *
+ * Copyright(C) 2001 Kirk Lee <kirk@hpc.ee.ntu.edu.tw>
+ *
+ * This code is GPLed
+ *
+ */
+
+/*
+ * According to TQM8xxL hardware manual, TQM8xxL series have
+ * following flash memory organisations:
+ *	| capacity |	| chip type |	| bank0 |	| bank1 |
+ *	    2MiB	   512Kx16	  2MiB		   0
+ *	    4MiB	   1Mx16	  4MiB		   0
+ *	    8MiB	   1Mx16	  4MiB		   4MiB
+ * Thus, we choose CONFIG_MTD_CFI_I2 & CONFIG_MTD_CFI_B4 at
+ * kernel configuration.
+ */
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/io.h>
+
+#define FLASH_ADDR 0x40000000
+#define FLASH_SIZE 0x00800000
+#define FLASH_BANK_MAX 4
+
+// trivial struct to describe partition information
+struct mtd_part_def
+{
+	int nums;
+	unsigned char *type;
+	struct mtd_partition* mtd_part;
+};
+
+//static struct mtd_info *mymtd;
+static struct mtd_info* mtd_banks[FLASH_BANK_MAX];
+static struct map_info* map_banks[FLASH_BANK_MAX];
+static struct mtd_part_def part_banks[FLASH_BANK_MAX];
+static unsigned long num_banks;
+static void __iomem *start_scan_addr;
+
+/*
+ * Here are partition information for all known TQM8xxL series devices.
+ * See include/linux/mtd/partitions.h for definition of the mtd_partition
+ * structure.
+ *
+ * The *_max_flash_size is the maximum possible mapped flash size which
+ * is not necessarily the actual flash size.  It must correspond to the
+ * value specified in the mapping definition defined by the
+ * "struct map_desc *_io_desc" for the corresponding machine.
+ */
+
+/* Currently, TQM8xxL has up to 8MiB flash */
+static unsigned long tqm8xxl_max_flash_size = 0x00800000;
+
+/* partition definition for first flash bank
+ * (cf. "drivers/char/flash_config.c")
+ */
+static struct mtd_partition tqm8xxl_partitions[] = {
+	{
+	  .name = "ppcboot",
+	  .offset = 0x00000000,
+	  .size = 0x00020000,           /* 128KB           */
+	  .mask_flags = MTD_WRITEABLE,  /* force read-only */
+	},
+	{
+	  .name = "kernel",             /* default kernel image */
+	  .offset = 0x00020000,
+	  .size = 0x000e0000,
+	  .mask_flags = MTD_WRITEABLE,  /* force read-only */
+	},
+	{
+	  .name = "user",
+	  .offset = 0x00100000,
+	  .size = 0x00100000,
+	},
+	{
+	  .name = "initrd",
+	  .offset = 0x00200000,
+	  .size = 0x00200000,
+	}
+};
+/* partition definition for second flash bank */
+static struct mtd_partition tqm8xxl_fs_partitions[] = {
+	{
+	  .name = "cramfs",
+	  .offset = 0x00000000,
+	  .size = 0x00200000,
+	},
+	{
+	  .name = "jffs",
+	  .offset = 0x00200000,
+	  .size = 0x00200000,
+	  //.size = MTDPART_SIZ_FULL,
+	}
+};
+
+static int __init init_tqm_mtd(void)
+{
+	int idx = 0, ret = 0;
+	unsigned long flash_addr, flash_size, mtd_size = 0;
+	/* pointer to TQM8xxL board info data */
+	bd_t *bd = (bd_t *)__res;
+
+	flash_addr = bd->bi_flashstart;
+	flash_size = bd->bi_flashsize;
+
+	//request maximum flash size address space
+	start_scan_addr = ioremap(flash_addr, flash_size);
+	if (!start_scan_addr) {
+		printk(KERN_WARNING "%s:Failed to ioremap address:0x%x\n", __func__, flash_addr);
+		return -EIO;
+	}
+
+	for (idx = 0 ; idx < FLASH_BANK_MAX ; idx++) {
+		if(mtd_size >= flash_size)
+			break;
+
+		printk(KERN_INFO "%s: chip probing count %d\n", __func__, idx);
+
+		map_banks[idx] = kzalloc(sizeof(struct map_info), GFP_KERNEL);
+		if(map_banks[idx] == NULL) {
+			ret = -ENOMEM;
+			/* FIXME: What if some MTD devices were probed already? */
+			goto error_mem;
+		}
+
+		map_banks[idx]->name = kmalloc(16, GFP_KERNEL);
+
+		if (!map_banks[idx]->name) {
+			ret = -ENOMEM;
+			/* FIXME: What if some MTD devices were probed already? */
+			goto error_mem;
+		}
+		sprintf(map_banks[idx]->name, "TQM8xxL%d", idx);
+
+		map_banks[idx]->size = flash_size;
+		map_banks[idx]->bankwidth = 4;
+
+		simple_map_init(map_banks[idx]);
+
+		map_banks[idx]->virt = start_scan_addr;
+		map_banks[idx]->phys = flash_addr;
+		/* FIXME: This looks utterly bogus, but I'm trying to
+		   preserve the behaviour of the original (shown here)...
+
+		map_banks[idx]->map_priv_1 =
+		start_scan_addr + ((idx > 0) ?
+		(mtd_banks[idx-1] ? mtd_banks[idx-1]->size : 0) : 0);
+		*/
+
+		if (idx && mtd_banks[idx-1]) {
+			map_banks[idx]->virt += mtd_banks[idx-1]->size;
+			map_banks[idx]->phys += mtd_banks[idx-1]->size;
+		}
+
+		//start to probe flash chips
+		mtd_banks[idx] = do_map_probe("cfi_probe", map_banks[idx]);
+
+		if (mtd_banks[idx]) {
+			mtd_banks[idx]->owner = THIS_MODULE;
+			mtd_size += mtd_banks[idx]->size;
+			num_banks++;
+
+			printk(KERN_INFO "%s: bank%d, name:%s, size:%dbytes \n", __func__, num_banks,
+			mtd_banks[idx]->name, mtd_banks[idx]->size);
+		}
+	}
+
+	/* no supported flash chips found */
+	if (!num_banks) {
+		printk(KERN_NOTICE "TQM8xxL: No support flash chips found!\n");
+		ret = -ENXIO;
+		goto error_mem;
+	}
+
+	/*
+	 * Select Static partition definitions
+	 */
+	part_banks[0].mtd_part = tqm8xxl_partitions;
+	part_banks[0].type = "Static image";
+	part_banks[0].nums = ARRAY_SIZE(tqm8xxl_partitions);
+
+	part_banks[1].mtd_part = tqm8xxl_fs_partitions;
+	part_banks[1].type = "Static file system";
+	part_banks[1].nums = ARRAY_SIZE(tqm8xxl_fs_partitions);
+
+	for(idx = 0; idx < num_banks ; idx++) {
+		if (part_banks[idx].nums == 0)
+			printk(KERN_NOTICE "TQM flash%d: no partition info available, registering whole flash at once\n", idx);
+		else
+			printk(KERN_NOTICE "TQM flash%d: Using %s partition definition\n",
+					idx, part_banks[idx].type);
+		mtd_device_register(mtd_banks[idx], part_banks[idx].mtd_part,
+		part_banks[idx].nums);
+	}
+	return 0;
+error_mem:
+	for(idx = 0 ; idx < FLASH_BANK_MAX ; idx++) {
+		if(map_banks[idx] != NULL) {
+			kfree(map_banks[idx]->name);
+			map_banks[idx]->name = NULL;
+			kfree(map_banks[idx]);
+			map_banks[idx] = NULL;
+		}
+	}
+error:
+	iounmap(start_scan_addr);
+	return ret;
+}
+
+static void __exit cleanup_tqm_mtd(void)
+{
+	unsigned int idx = 0;
+	for(idx = 0 ; idx < num_banks ; idx++) {
+		/* destroy mtd_info previously allocated */
+		if (mtd_banks[idx]) {
+			mtd_device_unregister(mtd_banks[idx]);
+			map_destroy(mtd_banks[idx]);
+		}
+		/* release map_info not used anymore */
+		kfree(map_banks[idx]->name);
+		kfree(map_banks[idx]);
+	}
+
+	if (start_scan_addr) {
+		iounmap(start_scan_addr);
+		start_scan_addr = 0;
+	}
+}
+
+module_init(init_tqm_mtd);
+module_exit(cleanup_tqm_mtd);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Kirk Lee <kirk@hpc.ee.ntu.edu.tw>");
+MODULE_DESCRIPTION("MTD map driver for TQM8xxL boards");
diff -ruN linux-3.10/drivers/mtd/maps/tsunami_flash.c linux-3.10_patched/drivers/mtd/maps/tsunami_flash.c
--- linux-3.10/drivers/mtd/maps/tsunami_flash.c	2013-06-30 22:13:29.000000000 +0000
+++ linux-3.10_patched/drivers/mtd/maps/tsunami_flash.c	2025-06-14 05:48:04.965173245 +0000
@@ -82,12 +82,11 @@
 	tsunami_flash_mtd = 0;
 }
 
-static const char * const rom_probe_types[] = {
-	"cfi_probe", "jedec_probe", "map_rom", NULL };
 
 static int __init init_tsunami_flash(void)
 {
-	const char * const *type;
+	static const char *rom_probe_types[] = { "cfi_probe", "jedec_probe", "map_rom", NULL };
+	char **type;
 
 	tsunami_tig_writeb(FLASH_ENABLE_BYTE, FLASH_ENABLE_PORT);
 
diff -ruN linux-3.10/drivers/mtd/maps/uclinux.c linux-3.10_patched/drivers/mtd/maps/uclinux.c
--- linux-3.10/drivers/mtd/maps/uclinux.c	2013-06-30 22:13:29.000000000 +0000
+++ linux-3.10_patched/drivers/mtd/maps/uclinux.c	2025-06-14 05:48:04.965173245 +0000
@@ -19,30 +19,17 @@
 #include <linux/mtd/map.h>
 #include <linux/mtd/partitions.h>
 #include <asm/io.h>
-#include <asm/sections.h>
 
 /****************************************************************************/
 
-#ifdef CONFIG_MTD_ROM
-#define MAP_NAME "rom"
-#else
-#define MAP_NAME "ram"
-#endif
-
-/*
- * Blackfin uses uclinux_ram_map during startup, so it must not be static.
- * Provide a dummy declaration to make sparse happy.
- */
-extern struct map_info uclinux_ram_map;
+extern char _ebss;
 
 struct map_info uclinux_ram_map = {
-	.name = MAP_NAME,
+	.name = "RAM",
+	.phys = (unsigned long)&_ebss,
 	.size = 0,
 };
 
-static unsigned long physaddr = -1;
-module_param(physaddr, ulong, S_IRUGO);
-
 static struct mtd_info *uclinux_ram_mtdinfo;
 
 /****************************************************************************/
@@ -74,37 +61,26 @@
 	struct map_info *mapp;
 
 	mapp = &uclinux_ram_map;
-
-	if (physaddr == -1)
-		mapp->phys = (resource_size_t)__bss_stop;
-	else
-		mapp->phys = physaddr;
-
 	if (!mapp->size)
 		mapp->size = PAGE_ALIGN(ntohl(*((unsigned long *)(mapp->phys + 8))));
 	mapp->bankwidth = 4;
 
-	printk("uclinux[mtd]: probe address=0x%x size=0x%x\n",
+	printk("uclinux[mtd]: RAM probe address=0x%x size=0x%x\n",
 	       	(int) mapp->phys, (int) mapp->size);
 
-	/*
-	 * The filesystem is guaranteed to be in direct mapped memory. It is
-	 * directly following the kernels own bss region. Following the same
-	 * mechanism used by architectures setting up traditional initrds we
-	 * use phys_to_virt to get the virtual address of its start.
-	 */
-	mapp->virt = phys_to_virt(mapp->phys);
+	mapp->virt = ioremap_nocache(mapp->phys, mapp->size);
 
 	if (mapp->virt == 0) {
-		printk("uclinux[mtd]: no virtual mapping?\n");
+		printk("uclinux[mtd]: ioremap_nocache() failed\n");
 		return(-EIO);
 	}
 
 	simple_map_init(mapp);
 
-	mtd = do_map_probe("map_" MAP_NAME, mapp);
+	mtd = do_map_probe("map_ram", mapp);
 	if (!mtd) {
 		printk("uclinux[mtd]: failed to find a mapping?\n");
+		iounmap(mapp->virt);
 		return(-ENXIO);
 	}
 
@@ -127,8 +103,10 @@
 		map_destroy(uclinux_ram_mtdinfo);
 		uclinux_ram_mtdinfo = NULL;
 	}
-	if (uclinux_ram_map.virt)
+	if (uclinux_ram_map.virt) {
+		iounmap((void *) uclinux_ram_map.virt);
 		uclinux_ram_map.virt = 0;
+	}
 }
 
 /****************************************************************************/
@@ -138,6 +116,6 @@
 
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Greg Ungerer <gerg@snapgear.com>");
-MODULE_DESCRIPTION("Generic MTD for uClinux");
+MODULE_DESCRIPTION("Generic RAM based MTD for uClinux");
 
 /****************************************************************************/
diff -ruN linux-3.10/drivers/mtd/maps/vmu-flash.c linux-3.10_patched/drivers/mtd/maps/vmu-flash.c
--- linux-3.10/drivers/mtd/maps/vmu-flash.c	2013-06-30 22:13:29.000000000 +0000
+++ linux-3.10_patched/drivers/mtd/maps/vmu-flash.c	2025-06-14 05:48:04.965173245 +0000
@@ -596,7 +596,7 @@
 }
 
 /* Handles very basic info about the flash, queries for details */
-static int vmu_connect(struct maple_device *mdev)
+static int __devinit vmu_connect(struct maple_device *mdev)
 {
 	unsigned long test_flash_data, basic_flash_data;
 	int c, error;
@@ -690,7 +690,7 @@
 	return error;
 }
 
-static void vmu_disconnect(struct maple_device *mdev)
+static void __devexit vmu_disconnect(struct maple_device *mdev)
 {
 	struct memcard *card;
 	struct mdev_part *mpart;
@@ -772,7 +772,7 @@
 }
 
 
-static int probe_maple_vmu(struct device *dev)
+static int __devinit probe_maple_vmu(struct device *dev)
 {
 	int error;
 	struct maple_device *mdev = to_maple_dev(dev);
@@ -789,7 +789,7 @@
 	return 0;
 }
 
-static int remove_maple_vmu(struct device *dev)
+static int __devexit remove_maple_vmu(struct device *dev)
 {
 	struct maple_device *mdev = to_maple_dev(dev);
 
@@ -802,7 +802,7 @@
 	.drv = {
 		.name =		"Dreamcast_visual_memory",
 		.probe =	probe_maple_vmu,
-		.remove =	remove_maple_vmu,
+		.remove = 	__devexit_p(remove_maple_vmu),
 	},
 };
 
diff -ruN linux-3.10/drivers/mtd/maps/wr_sbc82xx_flash.c linux-3.10_patched/drivers/mtd/maps/wr_sbc82xx_flash.c
--- linux-3.10/drivers/mtd/maps/wr_sbc82xx_flash.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.10_patched/drivers/mtd/maps/wr_sbc82xx_flash.c	2025-06-14 05:48:04.965173245 +0000
@@ -0,0 +1,174 @@
+/*
+ * Map for flash chips on Wind River PowerQUICC II SBC82xx board.
+ *
+ * Copyright (C) 2004 Red Hat, Inc.
+ *
+ * Author: David Woodhouse <dwmw2@infradead.org>
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <asm/io.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/immap_cpm2.h>
+
+static struct mtd_info *sbcmtd[3];
+
+struct map_info sbc82xx_flash_map[3] = {
+	{.name = "Boot flash"},
+	{.name = "Alternate boot flash"},
+	{.name = "User flash"}
+};
+
+static struct mtd_partition smallflash_parts[] = {
+	{
+		.name =		"space",
+		.size =		0x100000,
+		.offset =	0,
+	}, {
+		.name =		"bootloader",
+		.size =		MTDPART_SIZ_FULL,
+		.offset =	MTDPART_OFS_APPEND,
+	}
+};
+
+static struct mtd_partition bigflash_parts[] = {
+	{
+		.name =		"bootloader",
+		.size =		0x00100000,
+		.offset =	0,
+	}, {
+		.name =		"file system",
+		.size =		0x01f00000,
+		.offset =	MTDPART_OFS_APPEND,
+	}, {
+		.name =		"boot config",
+		.size =		0x00100000,
+		.offset =	MTDPART_OFS_APPEND,
+	}, {
+		.name =		"space",
+		.size =		0x01f00000,
+		.offset =	MTDPART_OFS_APPEND,
+	}
+};
+
+static const char *part_probes[] __initdata = {"cmdlinepart", "RedBoot", NULL};
+
+#define init_sbc82xx_one_flash(map, br, or)			\
+do {								\
+	(map).phys = (br & 1) ? (br & 0xffff8000) : 0;		\
+	(map).size = (br & 1) ? (~(or & 0xffff8000) + 1) : 0;	\
+	switch (br & 0x00001800) {				\
+	case 0x00000000:					\
+	case 0x00000800:	(map).bankwidth = 1;	break;	\
+	case 0x00001000:	(map).bankwidth = 2;	break;	\
+	case 0x00001800:	(map).bankwidth = 4;	break;	\
+	}							\
+} while (0);
+
+static int __init init_sbc82xx_flash(void)
+{
+	volatile memctl_cpm2_t *mc = &cpm2_immr->im_memctl;
+	int bigflash;
+	int i;
+
+#ifdef CONFIG_SBC8560
+	mc = ioremap(0xff700000 + 0x5000, sizeof(memctl_cpm2_t));
+#else
+	mc = &cpm2_immr->im_memctl;
+#endif
+
+	bigflash = 1;
+	if ((mc->memc_br0 & 0x00001800) == 0x00001800)
+		bigflash = 0;
+
+	init_sbc82xx_one_flash(sbc82xx_flash_map[0], mc->memc_br0, mc->memc_or0);
+	init_sbc82xx_one_flash(sbc82xx_flash_map[1], mc->memc_br6, mc->memc_or6);
+	init_sbc82xx_one_flash(sbc82xx_flash_map[2], mc->memc_br1, mc->memc_or1);
+
+#ifdef CONFIG_SBC8560
+	iounmap((void *) mc);
+#endif
+
+	for (i=0; i<3; i++) {
+		int8_t flashcs[3] = { 0, 6, 1 };
+		int nr_parts;
+		struct mtd_partition *defparts;
+
+		printk(KERN_NOTICE "PowerQUICC II %s (%ld MiB on CS%d",
+		       sbc82xx_flash_map[i].name,
+		       (sbc82xx_flash_map[i].size >> 20),
+		       flashcs[i]);
+		if (!sbc82xx_flash_map[i].phys) {
+			/* We know it can't be at zero. */
+			printk("): disabled by bootloader.\n");
+			continue;
+		}
+		printk(" at %08lx)\n",  sbc82xx_flash_map[i].phys);
+
+		sbc82xx_flash_map[i].virt = ioremap(sbc82xx_flash_map[i].phys,
+						    sbc82xx_flash_map[i].size);
+
+		if (!sbc82xx_flash_map[i].virt) {
+			printk("Failed to ioremap\n");
+			continue;
+		}
+
+		simple_map_init(&sbc82xx_flash_map[i]);
+
+		sbcmtd[i] = do_map_probe("cfi_probe", &sbc82xx_flash_map[i]);
+
+		if (!sbcmtd[i])
+			continue;
+
+		sbcmtd[i]->owner = THIS_MODULE;
+
+		/* No partitioning detected. Use default */
+		if (i == 2) {
+			defparts = NULL;
+			nr_parts = 0;
+		} else if (i == bigflash) {
+			defparts = bigflash_parts;
+			nr_parts = ARRAY_SIZE(bigflash_parts);
+		} else {
+			defparts = smallflash_parts;
+			nr_parts = ARRAY_SIZE(smallflash_parts);
+		}
+
+		mtd_device_parse_register(sbcmtd[i], part_probes, NULL,
+					  defparts, nr_parts);
+	}
+	return 0;
+}
+
+static void __exit cleanup_sbc82xx_flash(void)
+{
+	int i;
+
+	for (i=0; i<3; i++) {
+		if (!sbcmtd[i])
+			continue;
+
+		mtd_device_unregister(sbcmtd[i]);
+
+		map_destroy(sbcmtd[i]);
+
+		iounmap((void *)sbc82xx_flash_map[i].virt);
+		sbc82xx_flash_map[i].virt = 0;
+	}
+}
+
+module_init(init_sbc82xx_flash);
+module_exit(cleanup_sbc82xx_flash);
+
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("David Woodhouse <dwmw2@infradead.org>");
+MODULE_DESCRIPTION("Flash map driver for WindRiver PowerQUICC II");
diff -ruN linux-3.10/drivers/mtd/mtdchar.c linux-3.10_patched/drivers/mtd/mtdchar.c
--- linux-3.10/drivers/mtd/mtdchar.c	2013-06-30 22:13:29.000000000 +0000
+++ linux-3.10_patched/drivers/mtd/mtdchar.c	2025-06-14 05:48:04.949173245 +0000
@@ -41,6 +41,7 @@
 #include "mtdcore.h"
 
 static DEFINE_MUTEX(mtd_mutex);
+static struct vfsmount *mtd_inode_mnt __read_mostly;
 
 /*
  * Data structure to hold the pointer to the mtd device as well
@@ -76,9 +77,7 @@
 	return -EINVAL;
 }
 
-static int count;
-static struct vfsmount *mnt;
-static struct file_system_type mtd_inodefs_type;
+
 
 static int mtdchar_open(struct inode *inode, struct file *file)
 {
@@ -95,10 +94,6 @@
 	if ((file->f_mode & FMODE_WRITE) && (minor & 1))
 		return -EACCES;
 
-	ret = simple_pin_fs(&mtd_inodefs_type, &mnt, &count);
-	if (ret)
-		return ret;
-
 	mutex_lock(&mtd_mutex);
 	mtd = get_mtd_device(NULL, devnum);
 
@@ -112,7 +107,7 @@
 		goto out1;
 	}
 
-	mtd_ino = iget_locked(mnt->mnt_sb, devnum);
+	mtd_ino = iget_locked(mtd_inode_mnt->mnt_sb, devnum);
 	if (!mtd_ino) {
 		ret = -ENOMEM;
 		goto out1;
@@ -148,7 +143,6 @@
 	put_mtd_device(mtd);
 out:
 	mutex_unlock(&mtd_mutex);
-	simple_release_fs(&mnt, &count);
 	return ret;
 } /* mtdchar_open */
 
@@ -170,7 +164,6 @@
 	put_mtd_device(mtd);
 	file->private_data = NULL;
 	kfree(mfi);
-	simple_release_fs(&mnt, &count);
 
 	return 0;
 } /* mtdchar_close */
@@ -1165,15 +1158,10 @@
 #endif
 };
 
-static const struct super_operations mtd_ops = {
-	.drop_inode = generic_delete_inode,
-	.statfs = simple_statfs,
-};
-
 static struct dentry *mtd_inodefs_mount(struct file_system_type *fs_type,
 				int flags, const char *dev_name, void *data)
 {
-	return mount_pseudo(fs_type, "mtd_inode:", &mtd_ops, NULL, MTD_INODE_FS_MAGIC);
+	return mount_pseudo(fs_type, "mtd_inode:", NULL, NULL, MTD_INODE_FS_MAGIC);
 }
 
 static struct file_system_type mtd_inodefs_type = {
@@ -1181,6 +1169,27 @@
        .mount = mtd_inodefs_mount,
        .kill_sb = kill_anon_super,
 };
+static void mtdchar_notify_add(struct mtd_info *mtd)
+{
+}
+
+static void mtdchar_notify_remove(struct mtd_info *mtd)
+{
+       struct inode *mtd_ino = ilookup(mtd_inode_mnt->mnt_sb, mtd->index);
+
+       if (mtd_ino) {
+               /* Destroy the inode if it exists */
+               clear_nlink(mtd_ino);
+               iput(mtd_ino);
+       }
+}
+
+static struct mtd_notifier mtdchar_notifier = {
+       .add = mtdchar_notify_add,
+       .remove = mtdchar_notify_remove,
+};
+
+
 MODULE_ALIAS_FS("mtd_inodefs");
 
 int __init init_mtdchar(void)
@@ -1201,8 +1210,18 @@
 		       ret);
 		goto err_unregister_chdev;
 	}
+	mtd_inode_mnt = kern_mount(&mtd_inodefs_type);
+        if (IS_ERR(mtd_inode_mnt)) {
+                ret = PTR_ERR(mtd_inode_mnt);
+                pr_notice("Error mounting mtd_inodefs filesystem: %d\n", ret);
+                goto err_unregister_filesystem;
+        }
+        register_mtd_user(&mtdchar_notifier);
 
 	return ret;
+err_unregister_filesystem:
+        unregister_filesystem(&mtd_inodefs_type);
+
 
 err_unregister_chdev:
 	__unregister_chrdev(MTD_CHAR_MAJOR, 0, 1 << MINORBITS, "mtd");
@@ -1211,6 +1230,8 @@
 
 void __exit cleanup_mtdchar(void)
 {
+	unregister_mtd_user(&mtdchar_notifier);
+	kern_unmount(mtd_inode_mnt);
 	unregister_filesystem(&mtd_inodefs_type);
 	__unregister_chrdev(MTD_CHAR_MAJOR, 0, 1 << MINORBITS, "mtd");
 }
diff -ruN linux-3.10/drivers/net/ethernet/Kconfig linux-3.10_patched/drivers/net/ethernet/Kconfig
--- linux-3.10/drivers/net/ethernet/Kconfig	2013-06-30 22:13:29.000000000 +0000
+++ linux-3.10_patched/drivers/net/ethernet/Kconfig	2025-06-14 05:48:04.973173245 +0000
@@ -167,5 +167,6 @@
 source "drivers/net/ethernet/wiznet/Kconfig"
 source "drivers/net/ethernet/xilinx/Kconfig"
 source "drivers/net/ethernet/xircom/Kconfig"
+source "drivers/net/ethernet/qsp/Kconfig"
 
 endif # ETHERNET
diff -ruN linux-3.10/drivers/net/ethernet/Makefile linux-3.10_patched/drivers/net/ethernet/Makefile
--- linux-3.10/drivers/net/ethernet/Makefile	2013-06-30 22:13:29.000000000 +0000
+++ linux-3.10_patched/drivers/net/ethernet/Makefile	2025-06-14 05:48:04.973173245 +0000
@@ -74,3 +74,4 @@
 obj-$(CONFIG_NET_VENDOR_WIZNET) += wiznet/
 obj-$(CONFIG_NET_VENDOR_XILINX) += xilinx/
 obj-$(CONFIG_NET_VENDOR_XIRCOM) += xircom/
+obj-$(CONFIG_NET_QSP) += qsp/
Binary files linux-3.10/drivers/net/ethernet/qsp/built-in.o and linux-3.10_patched/drivers/net/ethernet/qsp/built-in.o differ
diff -ruN linux-3.10/drivers/net/ethernet/qsp/.built-in.o.cmd linux-3.10_patched/drivers/net/ethernet/qsp/.built-in.o.cmd
--- linux-3.10/drivers/net/ethernet/qsp/.built-in.o.cmd	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.10_patched/drivers/net/ethernet/qsp/.built-in.o.cmd	2025-06-14 05:48:04.977173245 +0000
@@ -0,0 +1 @@
+cmd_drivers/net/ethernet/qsp/built-in.o :=  /home/mike/qsp_buildroot/buildroot/output/host/usr/bin/ccache /home/mike/qsp_buildroot/buildroot/output/host/usr/bin/arm-none-linux-gnueabi-ld -EL   -r -o drivers/net/ethernet/qsp/built-in.o drivers/net/ethernet/qsp/qsp_main.o 
diff -ruN linux-3.10/drivers/net/ethernet/qsp/Kconfig linux-3.10_patched/drivers/net/ethernet/qsp/Kconfig
--- linux-3.10/drivers/net/ethernet/qsp/Kconfig	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.10_patched/drivers/net/ethernet/qsp/Kconfig	2025-06-14 05:48:04.973173245 +0000
@@ -0,0 +1,15 @@
+#
+# QSP ethernet device configuration
+#
+
+config NET_QSP
+	tristate "QSP Ethernet MAC driver"
+	default n
+	depends on QSP
+	---help---
+	  If you have a network (Ethernet) card belonging to this class, say Y
+	  and read the Ethernet-HOWTO, available from
+	  <http://www.tldp.org/docs.html#howto>.
+
+	  This driver supports the QSP Ethernet MAC used on the Wind River
+	  QSP simics platform
diff -ruN linux-3.10/drivers/net/ethernet/qsp/Makefile linux-3.10_patched/drivers/net/ethernet/qsp/Makefile
--- linux-3.10/drivers/net/ethernet/qsp/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.10_patched/drivers/net/ethernet/qsp/Makefile	2025-06-14 05:48:04.973173245 +0000
@@ -0,0 +1,6 @@
+#
+# Makefile for the QSP network device driver.
+#
+
+#qsp_mac-objs := qsp_main.o qsp_mdio.o
+obj-$(CONFIG_NET_QSP) += qsp_main.o
diff -ruN linux-3.10/drivers/net/ethernet/qsp/modules.builtin linux-3.10_patched/drivers/net/ethernet/qsp/modules.builtin
--- linux-3.10/drivers/net/ethernet/qsp/modules.builtin	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.10_patched/drivers/net/ethernet/qsp/modules.builtin	2025-06-14 05:48:04.977173245 +0000
@@ -0,0 +1 @@
+kernel/drivers/net/ethernet/qsp/qsp_main.ko
diff -ruN linux-3.10/drivers/net/ethernet/qsp/qsp_main.c linux-3.10_patched/drivers/net/ethernet/qsp/qsp_main.c
--- linux-3.10/drivers/net/ethernet/qsp/qsp_main.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.10_patched/drivers/net/ethernet/qsp/qsp_main.c	2025-06-14 05:48:04.973173245 +0000
@@ -0,0 +1,627 @@
+/*
+ * Driver for QSP Ethernet device
+ *
+ * Copyright (c) 2012 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+#include <linux/delay.h>
+#include <linux/etherdevice.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/skbuff.h>
+#include <linux/spinlock.h>
+#include <linux/phy.h>
+#include <linux/in.h>
+#include <linux/io.h>
+#include <linux/ip.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/dma-mapping.h>
+#include <linux/spinlock.h>
+#include <linux/qsp/qsp.h>
+
+
+#define TX_BD_NUM   128
+#define RX_BD_NUM   128
+
+#define QSP_FRAME_SIZE 1518
+
+/* Register offsets.
+ */
+#define QSP_NET_ID       0x0000
+#define QSP_NET_STATUS   0x0004
+#define QSP_NET_CONTROL  0x0008
+#define QSP_NET_TX_DESC  0x0010
+#define QSP_NET_TX_SZ    0x0014
+#define QSP_NET_TX_CI    0x0018
+#define QSP_NET_TX_PI    0x001c
+#define QSP_NET_RX_DESC  0x0020
+#define QSP_NET_RX_SZ    0x0024
+#define QSP_NET_RX_CI    0x0028
+#define QSP_NET_RX_PI    0x002c
+#define QSP_NET_MDIO     0x0100
+
+#define QSP_NET_MAC_ADDR(i)     (0x030+(i)*4)
+
+/* Bit defines.
+ */
+#define CONTROL_RESET (1<<0)
+
+
+struct qsp_net_bd {
+	u32 __phys;
+	u32 __len;
+};
+
+/* Don't access the buffer descriptors directly. They are big-endian.
+ */
+#define BD_GET_PHYS(bd) be32_to_cpu((bd).__phys)
+#define BD_GET_LEN(bd)  be32_to_cpu((bd).__len)
+#define BD_SET_PHYS(bd, p) do {(bd).__phys = cpu_to_be32(p); } while (0)
+#define BD_SET_LEN(bd, l)  do {(bd).__len = cpu_to_be32(l); } while (0)
+
+struct qsp_net_local {
+	struct net_device *ndev;
+	struct device *dev;
+
+	void __iomem *regs;
+	int tx_irq;
+
+	struct sk_buff **rx_skb;
+	struct sk_buff **tx_skb;
+	spinlock_t tx_lock;
+
+	/* Buffer descriptors */
+	struct qsp_net_bd *tx_bd_v;
+	dma_addr_t tx_bd_p;
+	struct qsp_net_bd *rx_bd_v;
+	dma_addr_t rx_bd_p;
+};
+
+
+/*
+ * Low level register access functions
+ */
+u32 qsp_net_readl(struct qsp_net_local *lp, int offset)
+{
+	u32 ret;
+	ret = readl(lp->regs + offset);
+	pr_debug("read %08x regs @ %p -> %08x\n", offset, lp->regs, ret);
+	return ret;
+}
+
+u8 qsp_net_readb(struct qsp_net_local *lp, int offset)
+{
+	u8 ret;
+	ret = (u8)readl(lp->regs + offset);
+	pr_debug("read %08x regs @ %p -> %08x\n", offset, lp->regs, ret);
+	return ret;
+}
+
+void qsp_net_writel(struct qsp_net_local *lp, int offset, u32 value)
+{
+	pr_debug("write %08x %08x regs @ %p\n", value, offset, lp->regs);
+	writel(value, lp->regs + offset);
+}
+
+void qsp_net_writeb(struct qsp_net_local *lp, int offset, u8 value)
+{
+	pr_debug("write %08x %08x regs @ %p\n", value, offset, lp->regs);
+	writel((u32)value, lp->regs + offset);
+}
+
+/**
+ *  qsp_net_bd_release - Release buffer descriptor rings
+ */
+static void qsp_net_bd_release(struct net_device *ndev)
+{
+	struct qsp_net_local *lp = netdev_priv(ndev);
+	int i;
+
+	/* Release/free descriptors, skb:s and ptr arrays.
+	 */
+	if (lp->rx_skb) {
+		for (i = 0; i < RX_BD_NUM; i++) {
+			if (!lp->rx_skb[i])
+				continue;
+			pr_debug("Release RX skb %p\n", lp->rx_skb[i]);
+			dev_kfree_skb(lp->rx_skb[i]);
+			lp->rx_skb[i] = 0;
+		}
+		pr_debug("Release RX skb_arr %p\n", lp->rx_skb);
+		kfree(lp->rx_skb);
+		lp->rx_skb = 0;
+	}
+	if (lp->rx_bd_v) {
+		pr_debug("Release rx_bd_v %p\n", lp->rx_bd_v);
+		kfree(lp->rx_bd_v);
+		lp->rx_bd_v = 0;
+	}
+
+	if (lp->tx_skb) {
+		for (i = 0; i < TX_BD_NUM; i++) {
+			if (!lp->tx_skb[i])
+				continue;
+			pr_debug("Release TX skb %p\n", lp->tx_skb[i]);
+			dev_kfree_skb(lp->tx_skb[i]);
+			lp->tx_skb[i] = 0;
+		}
+		pr_debug("Release TX skb_arr %p\n", lp->tx_skb);
+		kfree(lp->tx_skb);
+		lp->tx_skb = 0;
+	}
+	if (lp->tx_bd_v) {
+		pr_debug("Release tx_bd_v %p\n", lp->tx_bd_v);
+		kfree(lp->tx_bd_v);
+		lp->tx_bd_v = 0;
+	}
+	pr_debug("bd_release done.\n");
+}
+
+static int add_one_rx_bd(struct net_device *ndev)
+{
+	struct qsp_net_local *lp = netdev_priv(ndev);
+	struct sk_buff *skb;
+	int pi;
+
+	pi  = qsp_net_readl(lp, QSP_NET_RX_PI);
+	if (pi == RX_BD_NUM)
+		return 0;
+
+	skb = netdev_alloc_skb_ip_align(ndev,
+					QSP_FRAME_SIZE);
+	if (skb == 0) {
+		dev_err(&ndev->dev, "alloc_skb error %d\n", pi);
+		return 0;
+	}
+	pr_debug("num_frags %d\n", skb_shinfo(skb)->nr_frags);
+	BUG_ON(skb_shinfo(skb)->nr_frags > 1);
+	lp->rx_skb[pi] = skb;
+	/* returns physical address of skb->data */
+	BD_SET_PHYS(lp->rx_bd_v[pi], virt_to_phys(skb->data));
+	BD_SET_LEN(lp->rx_bd_v[pi], QSP_FRAME_SIZE);
+
+	pr_debug("add_one_rx_bd[%d]: phys:%08x len:%d (%d)\n",
+		 pi,
+		 BD_GET_PHYS(lp->rx_bd_v[pi]),
+		 BD_GET_LEN(lp->rx_bd_v[pi]), QSP_FRAME_SIZE);
+	qsp_net_writel(lp, QSP_NET_RX_PI, pi);
+	return 1;
+}
+
+static void process_tx(struct net_device *ndev, int in_interrupt)
+{
+	struct qsp_net_local *lp = netdev_priv(ndev);
+	int ti;
+	struct sk_buff *skb;
+	int loops;
+
+	/* Check for transmitted entries on the consumer index.
+	 */
+	loops = 0;
+	while ((ti = qsp_net_readl(lp, QSP_NET_TX_CI)) != TX_BD_NUM) {
+		pr_debug("got tx index %d\n", ti);
+		loops++;
+		skb = lp->tx_skb[ti];
+		WARN_ON(skb == NULL);
+		if (in_interrupt)
+			dev_kfree_skb_irq(skb);
+		else
+			dev_kfree_skb(skb);
+		lp->tx_skb[ti] = 0;
+		ndev->stats.tx_packets++;
+		ndev->stats.tx_bytes += BD_GET_LEN(lp->tx_bd_v[ti]);
+
+		/* Release the entry back to the mac
+		 */
+		qsp_net_writel(lp, QSP_NET_TX_CI, ti);
+		netif_wake_queue(ndev);
+	}
+	pr_debug("process_tx: Handled %d skb:s in %s mode\n",
+		 loops, in_interrupt ? "interrupt" : "normal");
+}
+
+
+/**
+ * qsp_net_bd_init - Setup buffer descriptor rings
+ */
+static int qsp_net_bd_init(struct net_device *ndev)
+{
+	struct qsp_net_local *lp = netdev_priv(ndev);
+
+	int num_rx;
+
+	lp->rx_skb = kcalloc(RX_BD_NUM, sizeof(*lp->rx_skb), GFP_KERNEL);
+	if (!lp->rx_skb) {
+		dev_err(&ndev->dev,
+			"can't allocate memory for DMA RX skb pointers.\n");
+		goto out;
+	}
+	lp->tx_skb = kcalloc(TX_BD_NUM, sizeof(*lp->tx_skb), GFP_KERNEL);
+	if (!lp->tx_skb) {
+		dev_err(&ndev->dev,
+			"can't allocate memory for DMA TX skb pointers.\n");
+		goto out;
+	}
+	/* allocate the tx and rx ring buffer descriptors. */
+	/* returns a virtual address and a physical address. */
+	lp->rx_skb = kcalloc(RX_BD_NUM, sizeof(*lp->rx_skb), GFP_KERNEL);
+	lp->tx_bd_v = kcalloc(TX_BD_NUM, sizeof(struct qsp_net_bd), GFP_KERNEL);
+	if (!lp->tx_bd_v) {
+		dev_err(&ndev->dev,
+				"unable to allocate DMA TX buffer descriptors");
+		goto out;
+	}
+	lp->rx_bd_v = kcalloc(RX_BD_NUM, sizeof(struct qsp_net_bd), GFP_KERNEL);
+	if (!lp->rx_bd_v) {
+		dev_err(&ndev->dev,
+				"unable to allocate DMA RX buffer descriptors");
+		goto out;
+	}
+
+	memset(lp->tx_bd_v, 0, sizeof(*lp->tx_bd_v) * TX_BD_NUM);
+	qsp_net_writel(lp, QSP_NET_TX_DESC, virt_to_phys(lp->tx_bd_v));
+	qsp_net_writel(lp, QSP_NET_TX_SZ, TX_BD_NUM);
+
+	qsp_net_writel(lp, QSP_NET_RX_DESC, virt_to_phys(lp->rx_bd_v));
+	qsp_net_writel(lp, QSP_NET_RX_SZ, RX_BD_NUM);
+
+	num_rx = 0;
+	while (add_one_rx_bd(ndev) == 1)
+		num_rx++;
+
+	pr_debug("%d != %d\n", num_rx, RX_BD_NUM);
+	WARN_ON(num_rx+1 != RX_BD_NUM);
+
+	return 0;
+
+out:
+	qsp_net_bd_release(ndev);
+	return -ENOMEM;
+}
+
+/* ---------------------------------------------------------------------
+ * net_device_ops
+ */
+
+static int qsp_net_set_mac_address(struct net_device *ndev, void *address)
+{
+	int i;
+	struct qsp_net_local *lp = netdev_priv(ndev);
+
+	if (address)
+		memcpy(ndev->dev_addr, address, ETH_ALEN);
+
+	if (!is_valid_ether_addr(ndev->dev_addr))
+		eth_hw_addr_random(ndev);
+	else
+		ndev->addr_assign_type &= ~NET_ADDR_RANDOM;
+
+	for (i = 0; i < 6; i++)
+		qsp_net_writeb(lp, QSP_NET_MAC_ADDR(i), ndev->dev_addr[i]);
+
+	return 0;
+}
+
+static int netdev_set_mac_address(struct net_device *ndev, void *p)
+{
+	struct sockaddr *addr = p;
+
+	return qsp_net_set_mac_address(ndev, addr->sa_data);
+}
+
+/* Initialize qsp_net */
+static void qsp_net_device_reset(struct net_device *ndev)
+{
+	if (qsp_net_bd_init(ndev)) {
+		dev_err(&ndev->dev,
+			"qsp_net_device_reset descriptor allocation failed\n");
+	}
+
+	qsp_net_set_mac_address(ndev, NULL);
+
+	/* Init Driver variable */
+	ndev->trans_start = jiffies; /* prevent tx timeout */
+}
+
+
+static int qsp_net_start_xmit(struct sk_buff *skb, struct net_device *ndev)
+{
+	struct qsp_net_local *lp = netdev_priv(ndev);
+
+	pr_debug("Transmit %p %p\n", skb, skb->data);
+	BUG_ON(skb_shinfo(skb)->nr_frags > 1);
+	{
+		int ti;
+		unsigned long flags;
+
+		/* Try to get a fresh producer index in the ring.
+		 */
+		ti = qsp_net_readl(lp, QSP_NET_TX_PI);
+		if (ti == TX_BD_NUM) {
+			pr_debug("Not enough free tx descriptors in ring.\n");
+			if (!netif_queue_stopped(ndev)) {
+				pr_debug("Stopping queue\n");
+				netif_stop_queue(ndev);
+			}
+			return NETDEV_TX_BUSY;
+		}
+		pr_debug("xmit index %d\n", ti);
+
+		/* Fill in the buffer descriptor at that index.
+		 */
+		BD_SET_PHYS(lp->tx_bd_v[ti], virt_to_phys(skb->data));
+		BD_SET_LEN(lp->tx_bd_v[ti], skb->len);
+
+		pr_debug("Send packet of len %d\n", skb->len);
+
+		/* Kick off the transfer.
+		 */
+		pr_debug("tx_desc[%d]: %08x %d\n", ti,
+			 BD_GET_PHYS(lp->tx_bd_v[ti]),
+			 BD_GET_LEN(lp->tx_bd_v[ti]));
+		lp->tx_skb[ti] = skb;
+		spin_lock_irqsave(&lp->tx_lock, flags);
+		qsp_net_writel(lp, QSP_NET_TX_PI, ti);
+		skb_tx_timestamp(skb);
+		/* Check if it trasmitted immediately?
+		 */
+		process_tx(ndev, 0);
+		spin_unlock_irqrestore(&lp->tx_lock, flags);
+	}
+
+	return NETDEV_TX_OK;
+}
+
+
+static void process_rx(struct net_device *ndev)
+{
+	struct qsp_net_local *lp = netdev_priv(ndev);
+	struct sk_buff *skb;
+	struct qsp_net_bd *cur_p;
+	int ci;
+
+	do {
+		ci = qsp_net_readl(lp, QSP_NET_RX_CI);
+		if (ci == RX_BD_NUM) {
+			pr_debug("No more rx descriptors in ring.\n");
+			break;
+		}
+		pr_debug("Got rx index %d\n", ci);
+		qsp_net_writel(lp, QSP_NET_RX_CI, ci);
+
+		cur_p = &lp->rx_bd_v[ci];
+		skb = lp->rx_skb[ci];
+		pr_debug("bd[%d] skb:%p phys:0x%08x : %d\n",
+			 ci, skb, BD_GET_PHYS(*cur_p), BD_GET_LEN(*cur_p));
+		skb_put(skb, BD_GET_LEN(*cur_p));
+
+		skb->dev = ndev;
+		skb->protocol = eth_type_trans(skb, ndev);
+
+		if (!skb_defer_rx_timestamp(skb)) {
+			lp->rx_skb[ci] = 0;
+			netif_rx(skb);
+		} else {
+			/* FIXME: needs investigation... */
+			BUG_ON(1);
+		}
+
+		ndev->stats.rx_packets++;
+		ndev->stats.rx_bytes += BD_GET_LEN(*cur_p);
+
+		add_one_rx_bd(ndev);
+
+	} while (1);
+}
+
+static irqreturn_t ll_qsp_net_irq(int irq, void *_ndev)
+{
+	struct net_device *ndev = _ndev;
+	struct qsp_net_local *lp = netdev_priv(ndev);
+
+	pr_debug("GOT IRQ\n");
+	process_rx(ndev);
+	spin_lock(&lp->tx_lock);
+	process_tx(ndev, 1);
+	spin_unlock(&lp->tx_lock);
+	return IRQ_HANDLED;
+}
+
+static int qsp_net_open(struct net_device *ndev)
+{
+	struct qsp_net_local *lp = netdev_priv(ndev);
+	int rc;
+
+	dev_dbg(&ndev->dev, "qsp_net_open()\n");
+
+	qsp_net_device_reset(ndev);
+
+	rc = request_irq(lp->tx_irq, ll_qsp_net_irq, 0, ndev->name, ndev);
+	if (rc) {
+		dev_err(lp->dev, "request_irq() failed\n");
+		return rc;
+	}
+	return 0;
+}
+
+static int qsp_net_stop(struct net_device *ndev)
+{
+	struct qsp_net_local *lp = netdev_priv(ndev);
+
+	/* Stop tx/rx
+	 */
+	qsp_net_writel(lp, QSP_NET_CONTROL, CONTROL_RESET);
+
+	dev_dbg(&ndev->dev, "qsp_net_close()\n");
+
+	free_irq(lp->tx_irq, ndev);
+
+#if 0
+	if (lp->phy_dev)
+		phy_disconnect(lp->phy_dev);
+	lp->phy_dev = NULL;
+#endif
+	qsp_net_bd_release(ndev);
+
+	return 0;
+}
+
+static int qsp_net_ioctl(struct net_device *ndev, struct ifreq *rq, int cmd)
+{
+	return -EINVAL;
+}
+
+static const struct net_device_ops qsp_net_netdev_ops = {
+	.ndo_open = qsp_net_open,
+	.ndo_stop = qsp_net_stop,
+	.ndo_start_xmit = qsp_net_start_xmit,
+	.ndo_set_mac_address = netdev_set_mac_address,
+	.ndo_validate_addr = eth_validate_addr,
+	.ndo_do_ioctl = qsp_net_ioctl,
+#ifdef CONFIG_NET_POLL_CONTROLLER
+	.ndo_poll_controller = qsp_net_poll_controller,
+#endif
+};
+
+
+static int qsp_mac_probe(struct platform_device *op)
+{
+	struct device_node *np;
+	struct qsp_net_local *lp;
+	struct net_device *ndev;
+	u8 macaddr[6];
+
+	int rc = 0;
+	int i;
+
+	/* Init network device structure */
+	ndev = alloc_etherdev(sizeof(*lp));
+	if (!ndev) {
+		pr_err("Failed to alloc etherdev\n");
+		return -ENOMEM;
+	}
+	ether_setup(ndev);
+	dev_set_drvdata(&op->dev, ndev);
+	SET_NETDEV_DEV(ndev, &op->dev);
+	ndev->flags &= ~IFF_MULTICAST;  /* clear multicast */
+#if 0
+	ndev->features = NETIF_F_SG | NETIF_F_FRAGLIST;
+#endif
+	ndev->netdev_ops = &qsp_net_netdev_ops;
+
+	ndev->features |= NETIF_F_HIGHDMA; /* Can DMA to high memory. */
+
+	/* setup qsp_net private info structure */
+	lp = netdev_priv(ndev);
+	lp->ndev = ndev;
+	lp->dev = &op->dev;
+
+	spin_lock_init(&lp->tx_lock);
+
+	/* map device registers */
+	lp->regs = of_iomap(op->dev.of_node, 0);
+	if (!lp->regs) {
+		dev_err(&op->dev, "could not map qsp_net regs eth.\n");
+		goto nodev;
+	}
+	pr_debug("regs @ %p\n", lp->regs);
+
+	/* Check that it's instantiated.
+	 */
+	if (qsp_net_readl(lp, QSP_NET_ID) != QSP_NET_ID_VAL) {
+		pr_debug("Could not find eth\n");
+		goto nodev;
+	}
+
+	np = op->dev.of_node;
+	pr_debug("IRQ 0 %p\n", np);
+	lp->tx_irq = irq_of_parse_and_map(np, 0);
+	pr_debug("ok %d\n", lp->tx_irq);
+
+	of_node_put(np); /* Finished with the node; drop the reference */
+
+	if (!lp->tx_irq) {
+		dev_err(&op->dev, "could not determine irq\n");
+		rc = -ENOMEM;
+		goto err_no_irq;
+	}
+
+
+	for (i = 0; i < 6; i++) {
+		/* Retrieve the MAC address */
+		macaddr[i] = qsp_net_readb(lp, QSP_NET_MAC_ADDR(i));
+		pr_debug("MAC%d %02x\n", i, macaddr[i]);
+	}
+	qsp_net_set_mac_address(ndev, (void *)macaddr);
+
+	rc = register_netdev(lp->ndev);
+	if (rc) {
+		dev_err(lp->dev, "register_netdev() error (%i)\n", rc);
+		goto err_register_ndev;
+	}
+	pr_info("qsp_net: succesfully probed\n");
+	return 0;
+
+ err_no_irq:
+ err_register_ndev:
+	iounmap(lp->regs);
+ nodev:
+	free_netdev(ndev);
+	ndev = NULL;
+	return rc;
+}
+
+static int qsp_mac_remove(struct platform_device *op)
+{
+	struct net_device *ndev = dev_get_drvdata(&op->dev);
+	struct qsp_net_local *lp = netdev_priv(ndev);
+
+	unregister_netdev(ndev);
+
+	dev_set_drvdata(&op->dev, NULL);
+	iounmap(lp->regs);
+	free_netdev(ndev);
+	return 0;
+}
+
+static struct of_device_id qsp_mac_match[] = {
+	{ .compatible = "qsp-mac", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, qsp_mac_match);
+
+static struct platform_driver qsp_mac_driver = {
+	.probe = qsp_mac_probe,
+	.remove = qsp_mac_remove,
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "qsp-mac",
+		.of_match_table = qsp_mac_match,
+	},
+};
+
+module_platform_driver(qsp_mac_driver);
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("Ethernet support for QSP");
+MODULE_AUTHOR("Anders Wallin <anders.wallin@windriver.com>");
Binary files linux-3.10/drivers/net/ethernet/qsp/qsp_main.o and linux-3.10_patched/drivers/net/ethernet/qsp/qsp_main.o differ
diff -ruN linux-3.10/drivers/net/ethernet/qsp/.qsp_main.o.cmd linux-3.10_patched/drivers/net/ethernet/qsp/.qsp_main.o.cmd
--- linux-3.10/drivers/net/ethernet/qsp/.qsp_main.o.cmd	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.10_patched/drivers/net/ethernet/qsp/.qsp_main.o.cmd	2025-06-14 05:48:04.977173245 +0000
@@ -0,0 +1,755 @@
+cmd_drivers/net/ethernet/qsp/qsp_main.o := /home/mike/qsp_buildroot/buildroot/output/host/usr/bin/ccache /home/mike/qsp_buildroot/buildroot/output/host/usr/bin/arm-none-linux-gnueabi-gcc -Wp,-MD,drivers/net/ethernet/qsp/.qsp_main.o.d -nostdinc -isystem /home/mike/qsp_buildroot/buildroot/output/host/opt/ext-toolchain/bin/../lib/gcc/arm-none-linux-gnueabi/4.8.1/include -I/home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include -Iarch/arm/include/generated -Iinclude  -include /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/include/linux/kconfig.h -D__KERNEL__ -mlittle-endian -Iarch/arm/mach-qsp/include -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -Wno-format-security -fno-delete-null-pointer-checks -O2 -marm -fno-dwarf2-cfi-asm -mabi=aapcs-linux -mno-thumb-interwork -funwind-tables -D__LINUX_ARM_ARCH__=7 -march=armv7-a -msoft-float -Uarm -Wframe-larger-than=1024 -fno-stack-protector -Wno-unused-but-set-variable -fomit-frame-pointer -g -Wdeclaration-after-statement -Wno-pointer-sign -fno-strict-overflow -fconserve-stack -DCC_HAVE_ASM_GOTO    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(qsp_main)"  -D"KBUILD_MODNAME=KBUILD_STR(qsp_main)" -c -o drivers/net/ethernet/qsp/qsp_main.o drivers/net/ethernet/qsp/qsp_main.c
+
+source_drivers/net/ethernet/qsp/qsp_main.o := drivers/net/ethernet/qsp/qsp_main.c
+
+deps_drivers/net/ethernet/qsp/qsp_main.o := \
+    $(wildcard include/config/net/poll/controller.h) \
+  include/linux/delay.h \
+  include/linux/kernel.h \
+    $(wildcard include/config/lbdaf.h) \
+    $(wildcard include/config/preempt/voluntary.h) \
+    $(wildcard include/config/debug/atomic/sleep.h) \
+    $(wildcard include/config/prove/locking.h) \
+    $(wildcard include/config/ring/buffer.h) \
+    $(wildcard include/config/tracing.h) \
+    $(wildcard include/config/numa.h) \
+    $(wildcard include/config/compaction.h) \
+    $(wildcard include/config/ftrace/mcount/record.h) \
+  include/linux/sysinfo.h \
+  include/linux/types.h \
+    $(wildcard include/config/uid16.h) \
+    $(wildcard include/config/arch/dma/addr/t/64bit.h) \
+    $(wildcard include/config/phys/addr/t/64bit.h) \
+    $(wildcard include/config/64bit.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/types.h \
+  include/asm-generic/int-ll64.h \
+  arch/arm/include/generated/asm/bitsperlong.h \
+  include/asm-generic/bitsperlong.h \
+  include/linux/posix_types.h \
+  include/linux/stddef.h \
+  include/linux/compiler.h \
+    $(wildcard include/config/sparse/rcu/pointer.h) \
+    $(wildcard include/config/trace/branch/profiling.h) \
+    $(wildcard include/config/profile/all/branches.h) \
+    $(wildcard include/config/enable/must/check.h) \
+    $(wildcard include/config/enable/warn/deprecated.h) \
+  include/linux/compiler-gcc.h \
+    $(wildcard include/config/arch/supports/optimized/inlining.h) \
+    $(wildcard include/config/optimize/inlining.h) \
+  include/linux/compiler-gcc4.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/posix_types.h \
+  include/asm-generic/posix_types.h \
+  /home/mike/qsp_buildroot/buildroot/output/host/opt/ext-toolchain/lib/gcc/arm-none-linux-gnueabi/4.8.1/include/stdarg.h \
+  include/linux/linkage.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/linkage.h \
+  include/linux/bitops.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/bitops.h \
+    $(wildcard include/config/smp.h) \
+  include/linux/irqflags.h \
+    $(wildcard include/config/trace/irqflags.h) \
+    $(wildcard include/config/irqsoff/tracer.h) \
+    $(wildcard include/config/preempt/tracer.h) \
+    $(wildcard include/config/trace/irqflags/support.h) \
+  include/linux/typecheck.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/irqflags.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/ptrace.h \
+    $(wildcard include/config/cpu/endian/be8.h) \
+    $(wildcard include/config/arm/thumb.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/hwcap.h \
+  include/asm-generic/bitops/non-atomic.h \
+  include/asm-generic/bitops/fls64.h \
+  include/asm-generic/bitops/sched.h \
+  include/asm-generic/bitops/hweight.h \
+  include/asm-generic/bitops/arch_hweight.h \
+  include/asm-generic/bitops/const_hweight.h \
+  include/asm-generic/bitops/lock.h \
+  include/asm-generic/bitops/le.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/byteorder.h \
+  include/linux/byteorder/little_endian.h \
+  include/linux/swab.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/swab.h \
+  include/linux/byteorder/generic.h \
+  include/asm-generic/bitops/ext2-atomic-setbit.h \
+  include/linux/log2.h \
+    $(wildcard include/config/arch/has/ilog2/u32.h) \
+    $(wildcard include/config/arch/has/ilog2/u64.h) \
+  include/linux/printk.h \
+    $(wildcard include/config/printk.h) \
+    $(wildcard include/config/dynamic/debug.h) \
+  include/linux/init.h \
+    $(wildcard include/config/modules.h) \
+    $(wildcard include/config/hotplug.h) \
+  include/linux/dynamic_debug.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/div64.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/compiler.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/bug.h \
+    $(wildcard include/config/bug.h) \
+    $(wildcard include/config/thumb2/kernel.h) \
+    $(wildcard include/config/debug/bugverbose.h) \
+    $(wildcard include/config/arm/lpae.h) \
+  include/asm-generic/bug.h \
+    $(wildcard include/config/generic/bug.h) \
+    $(wildcard include/config/generic/bug/relative/pointers.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/delay.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/param.h \
+    $(wildcard include/config/hz.h) \
+  include/linux/etherdevice.h \
+    $(wildcard include/config/have/efficient/unaligned/access.h) \
+  include/linux/if_ether.h \
+  include/linux/skbuff.h \
+    $(wildcard include/config/nf/conntrack.h) \
+    $(wildcard include/config/bridge/netfilter.h) \
+    $(wildcard include/config/nf/defrag/ipv4.h) \
+    $(wildcard include/config/nf/defrag/ipv6.h) \
+    $(wildcard include/config/xfrm.h) \
+    $(wildcard include/config/net/sched.h) \
+    $(wildcard include/config/net/cls/act.h) \
+    $(wildcard include/config/ipv6/ndisc/nodetype.h) \
+    $(wildcard include/config/net/dma.h) \
+    $(wildcard include/config/network/secmark.h) \
+    $(wildcard include/config/network/phy/timestamping.h) \
+  include/linux/kmemcheck.h \
+    $(wildcard include/config/kmemcheck.h) \
+  include/linux/mm_types.h \
+    $(wildcard include/config/split/ptlock/cpus.h) \
+    $(wildcard include/config/want/page/debug/flags.h) \
+    $(wildcard include/config/have/aligned/struct/page.h) \
+    $(wildcard include/config/mmu.h) \
+    $(wildcard include/config/aio.h) \
+    $(wildcard include/config/mm/owner.h) \
+    $(wildcard include/config/mmu/notifier.h) \
+    $(wildcard include/config/transparent/hugepage.h) \
+    $(wildcard include/config/cpumask/offstack.h) \
+  include/linux/auxvec.h \
+  arch/arm/include/generated/asm/auxvec.h \
+  include/asm-generic/auxvec.h \
+  include/linux/threads.h \
+    $(wildcard include/config/nr/cpus.h) \
+    $(wildcard include/config/base/small.h) \
+  include/linux/list.h \
+    $(wildcard include/config/debug/list.h) \
+  include/linux/poison.h \
+    $(wildcard include/config/illegal/pointer/value.h) \
+  include/linux/const.h \
+  include/linux/spinlock.h \
+    $(wildcard include/config/debug/spinlock.h) \
+    $(wildcard include/config/generic/lockbreak.h) \
+    $(wildcard include/config/preempt.h) \
+    $(wildcard include/config/debug/lock/alloc.h) \
+  include/linux/preempt.h \
+    $(wildcard include/config/debug/preempt.h) \
+    $(wildcard include/config/preempt/count.h) \
+    $(wildcard include/config/preempt/notifiers.h) \
+  include/linux/thread_info.h \
+    $(wildcard include/config/compat.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/thread_info.h \
+    $(wildcard include/config/arm/thumbee.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/fpstate.h \
+    $(wildcard include/config/vfpv3.h) \
+    $(wildcard include/config/iwmmxt.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/domain.h \
+    $(wildcard include/config/io/36.h) \
+    $(wildcard include/config/cpu/use/domains.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/barrier.h \
+    $(wildcard include/config/cpu/32v6k.h) \
+    $(wildcard include/config/cpu/xsc3.h) \
+    $(wildcard include/config/cpu/fa526.h) \
+    $(wildcard include/config/arch/has/barriers.h) \
+    $(wildcard include/config/arm/dma/mem/bufferable.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/outercache.h \
+    $(wildcard include/config/outer/cache/sync.h) \
+    $(wildcard include/config/outer/cache.h) \
+  include/linux/stringify.h \
+  include/linux/bottom_half.h \
+  include/linux/spinlock_types.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/spinlock_types.h \
+  include/linux/lockdep.h \
+    $(wildcard include/config/lockdep.h) \
+    $(wildcard include/config/lock/stat.h) \
+    $(wildcard include/config/prove/rcu.h) \
+  include/linux/rwlock_types.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/spinlock.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/processor.h \
+    $(wildcard include/config/have/hw/breakpoint.h) \
+    $(wildcard include/config/arm/errata/754327.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/hw_breakpoint.h \
+  include/linux/rwlock.h \
+  include/linux/spinlock_api_smp.h \
+    $(wildcard include/config/inline/spin/lock.h) \
+    $(wildcard include/config/inline/spin/lock/bh.h) \
+    $(wildcard include/config/inline/spin/lock/irq.h) \
+    $(wildcard include/config/inline/spin/lock/irqsave.h) \
+    $(wildcard include/config/inline/spin/trylock.h) \
+    $(wildcard include/config/inline/spin/trylock/bh.h) \
+    $(wildcard include/config/uninline/spin/unlock.h) \
+    $(wildcard include/config/inline/spin/unlock/bh.h) \
+    $(wildcard include/config/inline/spin/unlock/irq.h) \
+    $(wildcard include/config/inline/spin/unlock/irqrestore.h) \
+  include/linux/rwlock_api_smp.h \
+    $(wildcard include/config/inline/read/lock.h) \
+    $(wildcard include/config/inline/write/lock.h) \
+    $(wildcard include/config/inline/read/lock/bh.h) \
+    $(wildcard include/config/inline/write/lock/bh.h) \
+    $(wildcard include/config/inline/read/lock/irq.h) \
+    $(wildcard include/config/inline/write/lock/irq.h) \
+    $(wildcard include/config/inline/read/lock/irqsave.h) \
+    $(wildcard include/config/inline/write/lock/irqsave.h) \
+    $(wildcard include/config/inline/read/trylock.h) \
+    $(wildcard include/config/inline/write/trylock.h) \
+    $(wildcard include/config/inline/read/unlock.h) \
+    $(wildcard include/config/inline/write/unlock.h) \
+    $(wildcard include/config/inline/read/unlock/bh.h) \
+    $(wildcard include/config/inline/write/unlock/bh.h) \
+    $(wildcard include/config/inline/read/unlock/irq.h) \
+    $(wildcard include/config/inline/write/unlock/irq.h) \
+    $(wildcard include/config/inline/read/unlock/irqrestore.h) \
+    $(wildcard include/config/inline/write/unlock/irqrestore.h) \
+  include/linux/atomic.h \
+    $(wildcard include/config/arch/has/atomic/or.h) \
+    $(wildcard include/config/generic/atomic64.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/atomic.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/cmpxchg.h \
+    $(wildcard include/config/cpu/sa1100.h) \
+    $(wildcard include/config/cpu/sa110.h) \
+    $(wildcard include/config/cpu/v6.h) \
+  include/asm-generic/cmpxchg-local.h \
+  include/asm-generic/atomic-long.h \
+  include/linux/prio_tree.h \
+  include/linux/rbtree.h \
+  include/linux/rwsem.h \
+    $(wildcard include/config/rwsem/generic/spinlock.h) \
+  include/linux/rwsem-spinlock.h \
+  include/linux/completion.h \
+  include/linux/wait.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/current.h \
+  include/linux/cpumask.h \
+    $(wildcard include/config/hotplug/cpu.h) \
+    $(wildcard include/config/debug/per/cpu/maps.h) \
+    $(wildcard include/config/disable/obsolete/cpumask/functions.h) \
+  include/linux/bitmap.h \
+  include/linux/string.h \
+    $(wildcard include/config/binary/printf.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/string.h \
+  include/linux/bug.h \
+  include/linux/page-debug-flags.h \
+    $(wildcard include/config/page/poisoning.h) \
+    $(wildcard include/config/page/guard.h) \
+    $(wildcard include/config/page/debug/something/else.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/page.h \
+    $(wildcard include/config/cpu/copy/v3.h) \
+    $(wildcard include/config/cpu/copy/v4wt.h) \
+    $(wildcard include/config/cpu/copy/v4wb.h) \
+    $(wildcard include/config/cpu/copy/feroceon.h) \
+    $(wildcard include/config/cpu/copy/fa.h) \
+    $(wildcard include/config/cpu/xscale.h) \
+    $(wildcard include/config/cpu/copy/v6.h) \
+    $(wildcard include/config/have/arch/pfn/valid.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/glue.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/pgtable-2level-types.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/memory.h \
+    $(wildcard include/config/need/mach/memory/h.h) \
+    $(wildcard include/config/page/offset.h) \
+    $(wildcard include/config/highmem.h) \
+    $(wildcard include/config/dram/size.h) \
+    $(wildcard include/config/dram/base.h) \
+    $(wildcard include/config/have/tcm.h) \
+    $(wildcard include/config/arm/patch/phys/virt.h) \
+    $(wildcard include/config/phys/offset.h) \
+  arch/arm/include/generated/asm/sizes.h \
+  include/asm-generic/sizes.h \
+  include/asm-generic/memory_model.h \
+    $(wildcard include/config/flatmem.h) \
+    $(wildcard include/config/discontigmem.h) \
+    $(wildcard include/config/sparsemem/vmemmap.h) \
+    $(wildcard include/config/sparsemem.h) \
+  include/asm-generic/getorder.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/mmu.h \
+    $(wildcard include/config/cpu/has/asid.h) \
+  include/linux/time.h \
+    $(wildcard include/config/arch/uses/gettimeoffset.h) \
+  include/linux/cache.h \
+    $(wildcard include/config/arch/has/cache/line/size.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/cache.h \
+    $(wildcard include/config/arm/l1/cache/shift.h) \
+    $(wildcard include/config/aeabi.h) \
+  include/linux/seqlock.h \
+  include/linux/math64.h \
+  include/linux/net.h \
+  include/linux/socket.h \
+    $(wildcard include/config/proc/fs.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/socket.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/sockios.h \
+  include/linux/sockios.h \
+  include/linux/uio.h \
+  include/linux/random.h \
+    $(wildcard include/config/arch/random.h) \
+  include/linux/ioctl.h \
+  arch/arm/include/generated/asm/ioctl.h \
+  include/asm-generic/ioctl.h \
+  include/linux/irqnr.h \
+    $(wildcard include/config/generic/hardirqs.h) \
+  include/linux/fcntl.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/fcntl.h \
+  include/asm-generic/fcntl.h \
+  include/linux/rcupdate.h \
+    $(wildcard include/config/rcu/torture/test.h) \
+    $(wildcard include/config/tree/rcu.h) \
+    $(wildcard include/config/tree/preempt/rcu.h) \
+    $(wildcard include/config/rcu/trace.h) \
+    $(wildcard include/config/preempt/rcu.h) \
+    $(wildcard include/config/tiny/rcu.h) \
+    $(wildcard include/config/tiny/preempt/rcu.h) \
+    $(wildcard include/config/debug/objects/rcu/head.h) \
+    $(wildcard include/config/preempt/rt.h) \
+  include/linux/debugobjects.h \
+    $(wildcard include/config/debug/objects.h) \
+    $(wildcard include/config/debug/objects/free.h) \
+  include/linux/rcutree.h \
+  include/linux/textsearch.h \
+  include/linux/err.h \
+  arch/arm/include/generated/asm/errno.h \
+  include/asm-generic/errno.h \
+  include/asm-generic/errno-base.h \
+  include/linux/slab.h \
+    $(wildcard include/config/slab/debug.h) \
+    $(wildcard include/config/failslab.h) \
+    $(wildcard include/config/slub.h) \
+    $(wildcard include/config/slob.h) \
+    $(wildcard include/config/debug/slab.h) \
+    $(wildcard include/config/slab.h) \
+  include/linux/gfp.h \
+    $(wildcard include/config/zone/dma.h) \
+    $(wildcard include/config/zone/dma32.h) \
+    $(wildcard include/config/pm/sleep.h) \
+  include/linux/mmzone.h \
+    $(wildcard include/config/force/max/zoneorder.h) \
+    $(wildcard include/config/memory/hotplug.h) \
+    $(wildcard include/config/have/memblock/node/map.h) \
+    $(wildcard include/config/flat/node/mem/map.h) \
+    $(wildcard include/config/cgroup/mem/res/ctlr.h) \
+    $(wildcard include/config/no/bootmem.h) \
+    $(wildcard include/config/have/memory/present.h) \
+    $(wildcard include/config/have/memoryless/nodes.h) \
+    $(wildcard include/config/need/node/memmap/size.h) \
+    $(wildcard include/config/have/memblock/node.h) \
+    $(wildcard include/config/need/multiple/nodes.h) \
+    $(wildcard include/config/have/arch/early/pfn/to/nid.h) \
+    $(wildcard include/config/sparsemem/extreme.h) \
+    $(wildcard include/config/nodes/span/other/nodes.h) \
+    $(wildcard include/config/holes/in/zone.h) \
+    $(wildcard include/config/arch/has/holes/memorymodel.h) \
+  include/linux/numa.h \
+    $(wildcard include/config/nodes/shift.h) \
+  include/linux/nodemask.h \
+  include/linux/pageblock-flags.h \
+    $(wildcard include/config/hugetlb/page.h) \
+    $(wildcard include/config/hugetlb/page/size/variable.h) \
+  include/generated/bounds.h \
+  include/linux/memory_hotplug.h \
+    $(wildcard include/config/memory/hotremove.h) \
+    $(wildcard include/config/have/arch/nodedata/extension.h) \
+  include/linux/notifier.h \
+  include/linux/errno.h \
+  include/linux/mutex.h \
+    $(wildcard include/config/debug/mutexes.h) \
+    $(wildcard include/config/have/arch/mutex/cpu/relax.h) \
+  include/linux/srcu.h \
+  include/linux/topology.h \
+    $(wildcard include/config/sched/smt.h) \
+    $(wildcard include/config/sched/mc.h) \
+    $(wildcard include/config/sched/book.h) \
+    $(wildcard include/config/use/percpu/numa/node/id.h) \
+  include/linux/smp.h \
+    $(wildcard include/config/use/generic/smp/helpers.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/smp.h \
+  include/linux/percpu.h \
+    $(wildcard include/config/need/per/cpu/embed/first/chunk.h) \
+    $(wildcard include/config/need/per/cpu/page/first/chunk.h) \
+    $(wildcard include/config/have/setup/per/cpu/area.h) \
+  include/linux/pfn.h \
+  arch/arm/include/generated/asm/percpu.h \
+  include/asm-generic/percpu.h \
+  include/linux/percpu-defs.h \
+    $(wildcard include/config/debug/force/weak/per/cpu.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/topology.h \
+    $(wildcard include/config/arm/cpu/topology.h) \
+  include/asm-generic/topology.h \
+  include/linux/mmdebug.h \
+    $(wildcard include/config/debug/vm.h) \
+    $(wildcard include/config/debug/virtual.h) \
+  include/linux/slub_def.h \
+    $(wildcard include/config/slub/stats.h) \
+    $(wildcard include/config/slub/debug.h) \
+    $(wildcard include/config/sysfs.h) \
+  include/linux/workqueue.h \
+    $(wildcard include/config/debug/objects/work.h) \
+    $(wildcard include/config/freezer.h) \
+  include/linux/timer.h \
+    $(wildcard include/config/timer/stats.h) \
+    $(wildcard include/config/debug/objects/timers.h) \
+  include/linux/ktime.h \
+    $(wildcard include/config/ktime/scalar.h) \
+  include/linux/jiffies.h \
+  include/linux/timex.h \
+  include/linux/param.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/timex.h \
+  arch/arm/mach-qsp/include/mach/timex.h \
+  include/linux/kobject.h \
+  include/linux/sysfs.h \
+  include/linux/kobject_ns.h \
+  include/linux/kref.h \
+  include/linux/kmemleak.h \
+    $(wildcard include/config/debug/kmemleak.h) \
+  include/net/checksum.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/uaccess.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/unified.h \
+    $(wildcard include/config/arm/asm/unified.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/checksum.h \
+  include/linux/in6.h \
+  include/linux/dmaengine.h \
+    $(wildcard include/config/async/tx/enable/channel/switch.h) \
+    $(wildcard include/config/dma/engine.h) \
+    $(wildcard include/config/async/tx/dma.h) \
+  include/linux/device.h \
+    $(wildcard include/config/debug/devres.h) \
+    $(wildcard include/config/devtmpfs.h) \
+    $(wildcard include/config/sysfs/deprecated.h) \
+  include/linux/ioport.h \
+  include/linux/klist.h \
+  include/linux/pm.h \
+    $(wildcard include/config/pm.h) \
+    $(wildcard include/config/pm/runtime.h) \
+    $(wildcard include/config/pm/clk.h) \
+    $(wildcard include/config/pm/generic/domains.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/device.h \
+    $(wildcard include/config/dmabounce.h) \
+    $(wildcard include/config/iommu/api.h) \
+    $(wildcard include/config/arch/omap.h) \
+  include/linux/pm_wakeup.h \
+  include/linux/scatterlist.h \
+    $(wildcard include/config/debug/sg.h) \
+  include/linux/mm.h \
+    $(wildcard include/config/sysctl.h) \
+    $(wildcard include/config/stack/growsup.h) \
+    $(wildcard include/config/ia64.h) \
+    $(wildcard include/config/ksm.h) \
+    $(wildcard include/config/debug/pagealloc.h) \
+    $(wildcard include/config/hibernation.h) \
+    $(wildcard include/config/hugetlbfs.h) \
+  include/linux/debug_locks.h \
+    $(wildcard include/config/debug/locking/api/selftests.h) \
+  include/linux/range.h \
+  include/linux/bit_spinlock.h \
+  include/linux/shrinker.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/pgtable.h \
+    $(wildcard include/config/highpte.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/proc-fns.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/glue-proc.h \
+    $(wildcard include/config/cpu/arm610.h) \
+    $(wildcard include/config/cpu/arm7tdmi.h) \
+    $(wildcard include/config/cpu/arm710.h) \
+    $(wildcard include/config/cpu/arm720t.h) \
+    $(wildcard include/config/cpu/arm740t.h) \
+    $(wildcard include/config/cpu/arm9tdmi.h) \
+    $(wildcard include/config/cpu/arm920t.h) \
+    $(wildcard include/config/cpu/arm922t.h) \
+    $(wildcard include/config/cpu/arm925t.h) \
+    $(wildcard include/config/cpu/arm926t.h) \
+    $(wildcard include/config/cpu/arm940t.h) \
+    $(wildcard include/config/cpu/arm946e.h) \
+    $(wildcard include/config/cpu/arm1020.h) \
+    $(wildcard include/config/cpu/arm1020e.h) \
+    $(wildcard include/config/cpu/arm1022.h) \
+    $(wildcard include/config/cpu/arm1026.h) \
+    $(wildcard include/config/cpu/mohawk.h) \
+    $(wildcard include/config/cpu/feroceon.h) \
+    $(wildcard include/config/cpu/v6k.h) \
+    $(wildcard include/config/cpu/v7.h) \
+  include/asm-generic/pgtable-nopud.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/pgtable-hwdef.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/pgtable-2level-hwdef.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/pgtable-2level.h \
+  include/asm-generic/pgtable.h \
+  include/linux/page-flags.h \
+    $(wildcard include/config/pageflags/extended.h) \
+    $(wildcard include/config/arch/uses/pg/uncached.h) \
+    $(wildcard include/config/memory/failure.h) \
+    $(wildcard include/config/swap.h) \
+    $(wildcard include/config/s390.h) \
+  include/linux/huge_mm.h \
+  include/linux/vmstat.h \
+    $(wildcard include/config/vm/event/counters.h) \
+  include/linux/vm_event_item.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/scatterlist.h \
+    $(wildcard include/config/arm/has/sg/chain.h) \
+  include/asm-generic/scatterlist.h \
+    $(wildcard include/config/need/sg/dma/length.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/io.h \
+    $(wildcard include/config/need/mach/io/h.h) \
+    $(wildcard include/config/pcmcia/soc/common.h) \
+    $(wildcard include/config/pci.h) \
+    $(wildcard include/config/isa.h) \
+    $(wildcard include/config/pccard.h) \
+  include/asm-generic/pci_iomap.h \
+    $(wildcard include/config/no/generic/pci/ioport/map.h) \
+    $(wildcard include/config/generic/pci/iomap.h) \
+  include/linux/hrtimer.h \
+    $(wildcard include/config/high/res/timers.h) \
+    $(wildcard include/config/timerfd.h) \
+  include/linux/timerqueue.h \
+  include/linux/dma-mapping.h \
+    $(wildcard include/config/has/dma.h) \
+    $(wildcard include/config/arch/has/dma/set/coherent/mask.h) \
+    $(wildcard include/config/have/dma/attrs.h) \
+    $(wildcard include/config/need/dma/map/state.h) \
+  include/linux/dma-attrs.h \
+  include/linux/dma-direction.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/dma-mapping.h \
+  include/linux/dma-debug.h \
+    $(wildcard include/config/dma/api/debug.h) \
+  include/asm-generic/dma-coherent.h \
+    $(wildcard include/config/have/generic/dma/coherent.h) \
+  include/linux/netdev_features.h \
+  include/linux/netdevice.h \
+    $(wildcard include/config/dcb.h) \
+    $(wildcard include/config/wlan.h) \
+    $(wildcard include/config/ax25.h) \
+    $(wildcard include/config/mac80211/mesh.h) \
+    $(wildcard include/config/tr.h) \
+    $(wildcard include/config/net/ipip.h) \
+    $(wildcard include/config/net/ipgre.h) \
+    $(wildcard include/config/ipv6/sit.h) \
+    $(wildcard include/config/ipv6/tunnel.h) \
+    $(wildcard include/config/rps.h) \
+    $(wildcard include/config/netpoll.h) \
+    $(wildcard include/config/xps.h) \
+    $(wildcard include/config/bql.h) \
+    $(wildcard include/config/rfs/accel.h) \
+    $(wildcard include/config/fcoe.h) \
+    $(wildcard include/config/libfcoe.h) \
+    $(wildcard include/config/wireless/ext.h) \
+    $(wildcard include/config/vlan/8021q.h) \
+    $(wildcard include/config/net/dsa.h) \
+    $(wildcard include/config/net/ns.h) \
+    $(wildcard include/config/netprio/cgroup.h) \
+    $(wildcard include/config/net/dsa/tag/dsa.h) \
+    $(wildcard include/config/net/dsa/tag/trailer.h) \
+    $(wildcard include/config/netpoll/trap.h) \
+  include/linux/if.h \
+  include/linux/hdlc/ioctl.h \
+  include/linux/if_packet.h \
+  include/linux/if_link.h \
+  include/linux/netlink.h \
+  include/linux/capability.h \
+  include/linux/pm_qos.h \
+  include/linux/plist.h \
+    $(wildcard include/config/debug/pi/list.h) \
+  include/linux/miscdevice.h \
+  include/linux/major.h \
+  include/linux/rculist.h \
+  include/linux/dynamic_queue_limits.h \
+  include/linux/ethtool.h \
+  include/linux/compat.h \
+    $(wildcard include/config/arch/want/old/compat/ipc.h) \
+  include/net/net_namespace.h \
+    $(wildcard include/config/ipv6.h) \
+    $(wildcard include/config/ip/dccp.h) \
+    $(wildcard include/config/netfilter.h) \
+    $(wildcard include/config/wext/core.h) \
+    $(wildcard include/config/net.h) \
+  include/linux/sysctl.h \
+  include/net/netns/core.h \
+  include/net/netns/mib.h \
+    $(wildcard include/config/xfrm/statistics.h) \
+  include/net/snmp.h \
+  include/linux/snmp.h \
+  include/linux/u64_stats_sync.h \
+  include/net/netns/unix.h \
+  include/net/netns/packet.h \
+  include/net/netns/ipv4.h \
+    $(wildcard include/config/ip/multiple/tables.h) \
+    $(wildcard include/config/security.h) \
+    $(wildcard include/config/ip/mroute.h) \
+    $(wildcard include/config/ip/mroute/multiple/tables.h) \
+  include/net/inet_frag.h \
+  include/net/netns/ipv6.h \
+    $(wildcard include/config/ipv6/multiple/tables.h) \
+    $(wildcard include/config/ipv6/mroute.h) \
+    $(wildcard include/config/ipv6/mroute/multiple/tables.h) \
+  include/net/dst_ops.h \
+  include/linux/percpu_counter.h \
+  include/net/netns/dccp.h \
+  include/net/netns/x_tables.h \
+    $(wildcard include/config/bridge/nf/ebtables.h) \
+  include/linux/netfilter.h \
+    $(wildcard include/config/jump/label.h) \
+    $(wildcard include/config/nf/nat/needed.h) \
+  include/linux/in.h \
+  include/net/netns/xfrm.h \
+  include/linux/xfrm.h \
+  include/linux/seq_file_net.h \
+  include/linux/seq_file.h \
+  include/net/dsa.h \
+  include/net/netprio_cgroup.h \
+    $(wildcard include/config/cgroups.h) \
+  include/linux/cgroup.h \
+  include/linux/sched.h \
+    $(wildcard include/config/sched/debug.h) \
+    $(wildcard include/config/no/hz.h) \
+    $(wildcard include/config/lockup/detector.h) \
+    $(wildcard include/config/detect/hung/task.h) \
+    $(wildcard include/config/core/dump/default/elf/headers.h) \
+    $(wildcard include/config/sched/autogroup.h) \
+    $(wildcard include/config/virt/cpu/accounting.h) \
+    $(wildcard include/config/bsd/process/acct.h) \
+    $(wildcard include/config/taskstats.h) \
+    $(wildcard include/config/audit.h) \
+    $(wildcard include/config/inotify/user.h) \
+    $(wildcard include/config/fanotify.h) \
+    $(wildcard include/config/epoll.h) \
+    $(wildcard include/config/posix/mqueue.h) \
+    $(wildcard include/config/keys.h) \
+    $(wildcard include/config/perf/events.h) \
+    $(wildcard include/config/schedstats.h) \
+    $(wildcard include/config/task/delay/acct.h) \
+    $(wildcard include/config/fair/group/sched.h) \
+    $(wildcard include/config/rt/group/sched.h) \
+    $(wildcard include/config/blk/dev/io/trace.h) \
+    $(wildcard include/config/rcu/boost.h) \
+    $(wildcard include/config/compat/brk.h) \
+    $(wildcard include/config/cc/stackprotector.h) \
+    $(wildcard include/config/sysvipc.h) \
+    $(wildcard include/config/auditsyscall.h) \
+    $(wildcard include/config/rt/mutexes.h) \
+    $(wildcard include/config/block.h) \
+    $(wildcard include/config/task/xacct.h) \
+    $(wildcard include/config/cpusets.h) \
+    $(wildcard include/config/futex.h) \
+    $(wildcard include/config/fault/injection.h) \
+    $(wildcard include/config/latencytop.h) \
+    $(wildcard include/config/function/graph/tracer.h) \
+    $(wildcard include/config/have/unstable/sched/clock.h) \
+    $(wildcard include/config/irq/time/accounting.h) \
+    $(wildcard include/config/cfs/bandwidth.h) \
+    $(wildcard include/config/debug/stack/usage.h) \
+    $(wildcard include/config/cgroup/sched.h) \
+  arch/arm/include/generated/asm/cputime.h \
+  include/asm-generic/cputime.h \
+  include/linux/sem.h \
+  include/linux/ipc.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/ipcbuf.h \
+  include/asm-generic/ipcbuf.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/sembuf.h \
+  include/linux/signal.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/signal.h \
+  include/asm-generic/signal-defs.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/sigcontext.h \
+  arch/arm/include/generated/asm/siginfo.h \
+  include/asm-generic/siginfo.h \
+  include/linux/pid.h \
+  include/linux/proportions.h \
+  include/linux/seccomp.h \
+    $(wildcard include/config/seccomp.h) \
+  include/linux/rtmutex.h \
+    $(wildcard include/config/debug/rt/mutexes.h) \
+  include/linux/resource.h \
+  arch/arm/include/generated/asm/resource.h \
+  include/asm-generic/resource.h \
+  include/linux/task_io_accounting.h \
+    $(wildcard include/config/task/io/accounting.h) \
+  include/linux/latencytop.h \
+  include/linux/cred.h \
+    $(wildcard include/config/debug/credentials.h) \
+    $(wildcard include/config/user/ns.h) \
+  include/linux/key.h \
+  include/linux/selinux.h \
+    $(wildcard include/config/security/selinux.h) \
+  include/linux/llist.h \
+    $(wildcard include/config/arch/have/nmi/safe/cmpxchg.h) \
+  include/linux/aio.h \
+  include/linux/aio_abi.h \
+  include/linux/cgroupstats.h \
+  include/linux/taskstats.h \
+  include/linux/prio_heap.h \
+  include/linux/idr.h \
+  include/linux/hardirq.h \
+  include/linux/ftrace_irq.h \
+    $(wildcard include/config/ftrace/nmi/enter.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/hardirq.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/irq.h \
+    $(wildcard include/config/sparse/irq.h) \
+  arch/arm/mach-qsp/include/mach/irqs.h \
+  include/linux/irq_cpustat.h \
+  include/linux/static_key.h \
+  include/linux/jump_label.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/unaligned.h \
+  include/linux/unaligned/le_byteshift.h \
+  include/linux/unaligned/be_byteshift.h \
+  include/linux/unaligned/generic.h \
+  include/linux/module.h \
+    $(wildcard include/config/unused/symbols.h) \
+    $(wildcard include/config/kallsyms.h) \
+    $(wildcard include/config/tracepoints.h) \
+    $(wildcard include/config/event/tracing.h) \
+    $(wildcard include/config/module/unload.h) \
+    $(wildcard include/config/constructors.h) \
+    $(wildcard include/config/debug/set/module/ronx.h) \
+  include/linux/stat.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/stat.h \
+  include/linux/kmod.h \
+  include/linux/elf.h \
+  include/linux/elf-em.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/elf.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/user.h \
+  include/linux/moduleparam.h \
+    $(wildcard include/config/alpha.h) \
+    $(wildcard include/config/ppc64.h) \
+  include/linux/tracepoint.h \
+  include/linux/export.h \
+    $(wildcard include/config/symbol/prefix.h) \
+    $(wildcard include/config/modversions.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/module.h \
+    $(wildcard include/config/arm/unwind.h) \
+  include/linux/of.h \
+    $(wildcard include/config/sparc.h) \
+    $(wildcard include/config/of/dynamic.h) \
+    $(wildcard include/config/of.h) \
+  include/linux/mod_devicetable.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/prom.h \
+  include/linux/of_device.h \
+    $(wildcard include/config/of/device.h) \
+  include/linux/platform_device.h \
+    $(wildcard include/config/suspend.h) \
+    $(wildcard include/config/hibernate/callbacks.h) \
+  include/linux/of_platform.h \
+    $(wildcard include/config/of/address.h) \
+  include/linux/of_address.h \
+  include/linux/of_irq.h \
+    $(wildcard include/config/of/irq.h) \
+    $(wildcard include/config/ppc32.h) \
+    $(wildcard include/config/ppc/pmac.h) \
+  include/linux/irq.h \
+    $(wildcard include/config/irq/release/method.h) \
+    $(wildcard include/config/generic/pending/irq.h) \
+  include/linux/irqreturn.h \
+  arch/arm/include/generated/asm/irq_regs.h \
+  include/asm-generic/irq_regs.h \
+  include/linux/irqdesc.h \
+    $(wildcard include/config/irq/preflow/fasteoi.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/hw_irq.h \
+  include/linux/irqdomain.h \
+    $(wildcard include/config/irq/domain.h) \
+  include/linux/radix-tree.h \
+  include/linux/phy.h \
+  include/linux/mii.h \
+  include/linux/io.h \
+    $(wildcard include/config/has/ioport.h) \
+  include/linux/ip.h \
+  include/linux/interrupt.h \
+    $(wildcard include/config/irq/forced/threading.h) \
+    $(wildcard include/config/generic/irq/probe.h) \
+  include/linux/qsp/qsp.h \
+
+drivers/net/ethernet/qsp/qsp_main.o: $(deps_drivers/net/ethernet/qsp/qsp_main.o)
+
+$(deps_drivers/net/ethernet/qsp/qsp_main.o):
diff -ruN linux-3.10/drivers/pic/.built-in.o.cmd linux-3.10_patched/drivers/pic/.built-in.o.cmd
--- linux-3.10/drivers/pic/.built-in.o.cmd	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.10_patched/drivers/pic/.built-in.o.cmd	2025-06-14 05:48:04.969173245 +0000
@@ -0,0 +1 @@
+cmd_drivers/pic/built-in.o :=  /home/mike/qsp_buildroot/buildroot/output/host/usr/bin/ccache /home/mike/qsp_buildroot/buildroot/output/host/usr/bin/arm-none-linux-gnueabi-ld -EL   -r -o drivers/pic/built-in.o drivers/pic/qsp_pic.o 
diff -ruN linux-3.10/drivers/pic/Kconfig linux-3.10_patched/drivers/pic/Kconfig
--- linux-3.10/drivers/pic/Kconfig	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.10_patched/drivers/pic/Kconfig	2025-06-14 05:48:04.969173245 +0000
@@ -0,0 +1,16 @@
+menuconfig PIC_SUPPORT
+	bool "Support for programmable interrupt controllers"
+	help
+	  Say Y to enable Linux PIC support.  This allows control of supported
+	  programmable intterupt controllers. Note that these are normally
+	  enabled by the platform/machine support.
+
+config QSP_PIC
+	boolean "QSP Programmable interrupt controller"
+	default y if QSP
+	depends on PIC_SUPPORT
+	help
+	  QSP Programmable interrupt controller
+	  This driver is required if you want to use any QSP style boards.
+
+	  Say Y here to compile support for QSP PIC into the kernel.
diff -ruN linux-3.10/drivers/pic/Makefile linux-3.10_patched/drivers/pic/Makefile
--- linux-3.10/drivers/pic/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.10_patched/drivers/pic/Makefile	2025-06-14 05:48:04.969173245 +0000
@@ -0,0 +1 @@
+obj-$(CONFIG_QSP_PIC) += qsp_pic.o
diff -ruN linux-3.10/drivers/pic/qsp_pic.c linux-3.10_patched/drivers/pic/qsp_pic.c
--- linux-3.10/drivers/pic/qsp_pic.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.10_patched/drivers/pic/qsp_pic.c	2025-06-14 05:48:04.969173245 +0000
@@ -0,0 +1,444 @@
+/*
+
+ * QSP Programmable Interrup Controller
+ *
+ * Copyright 2011 Ivar Holmqvist <ivar.holmqvist@windriver.com> Wind River
+ * Copyright 2007 David Gibson <dwg@au1.ibm.com>, IBM Corporation.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * Most code stolen from uic.c/mpic.c
+ */
+
+/* This is an attempt to create a arch independant interrupt controller.
+ * It's been tested on arm (cortexA9) and ppc (e600)
+ *
+ * Currently the major difference is that ppc version
+ * assumes that the platform/arch code registers normal handlers
+ * for IPIs (i.e requst_irq()). When compiled for arm, we shortcut
+ * this and directly enables IPIs and they are handled separately
+ * in the machine specific parts.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/reboot.h>
+#include <linux/slab.h>
+#include <linux/stddef.h>
+#include <linux/sched.h>
+#include <linux/signal.h>
+#include <linux/device.h>
+#include <linux/bootmem.h>
+#include <linux/spinlock.h>
+#include <linux/irq.h>
+#include <linux/irqdomain.h>
+#include <linux/interrupt.h>
+#include <linux/kernel_stat.h>
+#include <linux/io.h>
+#include <linux/err.h>
+
+#include <asm/irq.h>
+
+#include <linux/of_fdt.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/platform_device.h>
+
+#include <linux/qsp/qsp.h>
+#include <linux/qsp/qsp_pic.h>
+
+#if 0
+#define DEBUG_IPI
+#define DBG(fmt, args...) printk(KERN_DEBUG "PIC:" fmt, ## args)
+#else
+#define DBG(fmt, args...) do {} while (0)
+#endif
+#define NR_QSP_PIC_INTS	1024
+
+/* Register offsets */
+#define QSP_PIC_ID      0x00
+#define QSP_PIC_ENABLE  0x04
+#define QSP_PIC_DISABLE 0x08
+#define QSP_PIC_DST     0x10
+#define QSP_PIC_GEN     0x14
+#define QSP_PIC_TYPE    0x18
+
+#define QSP_PIC_PENDING 0x20
+#define QSP_PIC_EOI     0x24
+
+#define QSP_NO_IRQ      (NR_QSP_PIC_INTS + 1)
+
+/* bit definitions */
+#define TYPE_EDGE (1<<16)
+
+#define CPU_DST_SHIFT (16)
+
+
+static struct qsp_pic *primary_qsp_pic;
+
+/* TODO: Need to properly investigate which handlers are best
+ * for this interrupt controller (keeping in mind that I can
+ * rewrite the controller itself if needed). Seems like the
+ * lockless percpu handlers would be best.
+ */
+
+struct qsp_pic {
+	int index;
+	void __iomem *base;
+	struct irq_domain *domain;
+};
+
+static void qsp_pic_write_register(struct qsp_pic *pic, int reg_num, u32 val)
+{
+	writel(val, pic->base + reg_num);
+}
+
+static u32 qsp_pic_read_register(struct qsp_pic *pic, int reg_num)
+{
+	u32 ret;
+	ret = readl(pic->base + reg_num);
+	return ret;
+}
+
+
+static void qsp_pic_unmask_irq(struct irq_data *d)
+{
+	struct qsp_pic *qsp_pic = irq_data_get_irq_chip_data(d);
+
+	DBG("unamsk %d\n", d->hwirq);
+	qsp_pic_write_register(qsp_pic, QSP_PIC_ENABLE, d->hwirq);
+}
+
+static void qsp_pic_mask_irq(struct irq_data *d)
+{
+	struct qsp_pic *qsp_pic = irq_data_get_irq_chip_data(d);
+
+	DBG("mask %d\n", d->hwirq);
+	qsp_pic_write_register(qsp_pic, QSP_PIC_DISABLE, d->hwirq);
+}
+
+static void qsp_pic_eoi(struct irq_data *d)
+{
+	struct qsp_pic *qsp_pic = irq_data_get_irq_chip_data(d);
+
+	DBG("EOI %d hw:%d\n", d->irq, d->hwirq);
+	qsp_pic_write_register(qsp_pic, QSP_PIC_EOI, d->hwirq);
+}
+
+/* Only used by arm machines.
+ */
+void qsp_ipi_eoi(int irq)
+{
+	struct qsp_pic *qsp_pic = primary_qsp_pic;
+	qsp_pic_write_register(qsp_pic, QSP_PIC_EOI, irq);
+}
+
+static int qsp_pic_set_irq_type(struct irq_data *d, unsigned int flow_type)
+{
+	struct qsp_pic *qsp_pic = irq_data_get_irq_chip_data(d);
+	u32 edge;
+
+	switch (flow_type & IRQ_TYPE_SENSE_MASK) {
+	case IRQ_TYPE_NONE:
+		DBG("set type none %d\n", d->hwirq);
+		qsp_pic_mask_irq(d);
+		return 0;
+
+	case IRQ_TYPE_EDGE_RISING:
+		DBG("set type edge rising %d\n", d->hwirq);
+		edge = TYPE_EDGE;
+		break;
+
+	case IRQ_TYPE_LEVEL_HIGH:
+		DBG("set type level high %d\n", d->hwirq);
+		edge = 0;
+		break;
+
+	case IRQ_TYPE_LEVEL_LOW:
+	case IRQ_TYPE_EDGE_FALLING:
+		printk(KERN_ERR "Unhandled flow type %d\n", flow_type);
+		BUG();
+		break;
+
+	default:
+		printk(KERN_ERR "Illegal flow type %d\n", flow_type);
+		BUG();
+		return -EINVAL;
+	}
+
+
+	qsp_pic_write_register(qsp_pic, QSP_PIC_TYPE, edge | d->hwirq);
+	irqd_set_trigger_type(d, flow_type);
+
+	return 0;
+}
+
+#ifdef CONFIG_SMP
+
+static void qsp_pic_request_ipis(int nr_cpus)
+{
+	struct qsp_pic *qsp_pic = primary_qsp_pic;
+	int i;
+	int cpu;
+	cpumask_t tmpmask;
+
+	BUG_ON(qsp_pic == NULL);
+
+	for (cpu = 0; cpu < nr_cpus; cpu++) {
+		cpumask_clear(&tmpmask);
+		cpumask_set_cpu(cpu, &tmpmask);
+		for (i = 0; i < IPI_NUM_TYPES; i++) {
+
+			unsigned int vipi = irq_create_mapping(qsp_pic->domain,
+							       IPI_NR(cpu, i));
+			if (vipi == NO_IRQ) {
+				printk(KERN_ERR "Failed to map ipi %d\n", i);
+				continue;
+			}
+			irq_set_irq_type(vipi, IRQ_TYPE_EDGE_RISING);
+			irq_set_affinity(vipi, &tmpmask);
+
+#ifdef CONFIG_ARM
+			/* FIXME: Maybe we should switch to request_irq()
+			 * based ipi handling in arm as well instead of
+			 * shortcutting it in machine->handle_irq()
+			 */
+			qsp_pic_write_register(qsp_pic,
+					       QSP_PIC_ENABLE,
+					       IPI_NR(cpu, i));
+#else
+			/* powerpc does a simple request_irq() here.*/
+			smp_request_message_ipi(vipi, i);
+#endif
+		}
+	}
+}
+
+int smp_qsp_pic_probe(void)
+{
+	int nr_possible;
+	int nr_ipis;
+
+	pr_debug("smp_qsp_pic_probe()...\n");
+	/* QSP-PPC updates setup_max_cpus since possible_map is always "full".
+	 * We just wan't as few IPIs as possible.
+	 */
+	nr_possible = cpumask_weight(cpu_possible_mask);
+	nr_ipis = min_t(int, nr_possible, setup_max_cpus);
+
+	if (nr_ipis > 1) {
+		pr_info("qps-pic: Requesting %d ipis (cpu_possible=%d, maxcpus=%d)\n",
+			nr_ipis,
+			nr_possible,
+			setup_max_cpus);
+		qsp_pic_request_ipis(nr_ipis);
+	}
+
+	return nr_ipis;
+}
+
+void smp_qsp_pic_setup_cpu(int cpu)
+{
+}
+
+static int qsp_pic_set_affinity(struct irq_data *d,
+				const struct cpumask *cpumask,
+				bool force)
+{
+	struct qsp_pic *qsp_pic = irq_data_get_irq_chip_data(d);
+	unsigned int irq = d->hwirq;
+	int cpuid;
+
+	BUG_ON(cpumask_weight(cpumask) == 0);
+	cpuid = cpumask_first(cpumask);
+
+	DBG("single dest cpu -> %d (mask;%08lx)\n",
+	    cpuid, cpumask_bits(cpumask)[0]);
+	qsp_pic_write_register(qsp_pic, QSP_PIC_DST,
+			       (cpuid<<CPU_DST_SHIFT) | irq);
+
+	return 0;
+}
+
+void qsp_pic_message_pass(int cpu, int msg)
+{
+	struct qsp_pic *qsp_pic = primary_qsp_pic;
+
+	BUG_ON(qsp_pic == NULL);
+
+	/* make sure we're sending something that translates to an IPI */
+	if ((unsigned int)msg > (IPI_NUM_TYPES - 1)) {
+		printk(KERN_ERR "SMP %d: smp_message_pass: unknown msg %d\n",
+		       smp_processor_id(), msg);
+		return;
+	}
+
+#ifdef DEBUG_IPI
+	DBG("%s: %d->%d (vipi:%d) send_ipi(ipi_no: %d)\n", "qsp_pic",
+	    smp_processor_id(), cpu, IPI_NR(cpu, msg), msg);
+#endif
+	qsp_pic_write_register(qsp_pic, QSP_PIC_GEN, IPI_NR(cpu, msg));
+}
+#endif
+
+
+static struct irq_chip qsp_pic_irq_chip = {
+	.name		= "QSP_PIC",
+	.irq_unmask	= qsp_pic_unmask_irq,
+	.irq_mask	= qsp_pic_mask_irq,
+	.irq_set_type	= qsp_pic_set_irq_type,
+	.irq_eoi	= qsp_pic_eoi,
+#ifdef CONFIG_SMP
+	.irq_set_affinity = qsp_pic_set_affinity,
+#endif
+};
+
+
+static int qsp_pic_domain_map(struct irq_domain *d, unsigned int virq,
+			    unsigned long hw)
+{
+	struct qsp_pic *qsp_pic = d->host_data;
+
+	irq_set_chip_data(virq, qsp_pic);
+
+	if ((hw - IPI_BASE) > 0 && (hw - IPI_BASE) < IPI_NUM_TYPES) {
+		DBG("MAP IPI %ld (%ld:%ld)\n", hw,
+		    IPI_GET_CPU(hw), IPI_GET_MSG(hw));
+		irq_set_chip_data(virq, qsp_pic);
+		irq_set_chip_and_handler(virq, &qsp_pic_irq_chip,
+					 handle_percpu_irq);
+		return 0;
+	}
+
+	/* Use fasteoi_irq as handler.
+	 */
+	irq_set_chip_and_handler(virq, &qsp_pic_irq_chip, handle_fasteoi_irq);
+
+	/* Set default irq type */
+	irq_set_irq_type(virq, IRQ_TYPE_NONE);
+
+	return 0;
+}
+
+static int qsp_pic_domain_xlate(struct irq_domain *d, struct device_node *ct,
+			      const u32 *intspec, unsigned int intsize,
+			      unsigned long *out_hwirq,
+			      unsigned int *out_type)
+
+{
+	/* QSP_PIC intspecs must have 2 cells src and type.
+	 */
+	BUG_ON(intsize != 2);
+	*out_hwirq = intspec[0];
+	*out_type = intspec[1]; /* i.e edge or level */
+	return 0;
+}
+
+const struct irq_domain_ops qsp_irq_domain_ops = {
+	.map = qsp_pic_domain_map,
+	.xlate = qsp_pic_domain_xlate,
+};
+
+static struct qsp_pic * qsp_pic_init_one(struct device_node *node)
+{
+	struct qsp_pic *qsp_pic;
+	const u32 *indexp, *reg;
+	int len;
+	int i;
+	u32 id;
+
+	BUG_ON(!of_device_is_compatible(node, "qsp-pic"));
+	WARN_ON(NR_QSP_PIC_INTS > NR_IRQS);
+
+	qsp_pic = kzalloc(sizeof(*qsp_pic), GFP_KERNEL);
+	if (!qsp_pic)
+		return NULL;
+
+	indexp = of_get_property(node, "cell-index", &len);
+	if (!indexp || (len != sizeof(u32))) {
+		printk(KERN_ERR "qsp_pic: Device node %s has missing or" \
+		       "invalid cell-index property\n", node->full_name);
+		return NULL;
+	}
+	qsp_pic->index = *indexp;
+
+	reg = of_get_property(node, "reg", &len);
+	if (!reg || (len != 3*sizeof(u32))) {
+		printk(KERN_ERR "qsp_pic: Device node %s has missing or"\
+		       "invalid reg property\n", node->full_name);
+		return NULL;
+	}
+	qsp_pic->base = of_iomap(node, 0);
+	BUG_ON(qsp_pic->base == NULL);
+
+	/* Probe ID of pic.
+	 */
+	id = qsp_pic_read_register(qsp_pic, QSP_PIC_ID);
+	if (id != QSP_PIC_ID_VAL)
+		panic("pic id %08x != %08x\n", id, QSP_PIC_ID_VAL);
+
+	/* Disable all interrupts. */
+	for (i = 0; i < NR_QSP_PIC_INTS; i++)
+		qsp_pic_write_register(qsp_pic, QSP_PIC_DISABLE, i);
+
+	qsp_pic->domain = irq_domain_add_tree(node,
+					      &qsp_irq_domain_ops,
+					      (void *)qsp_pic);
+
+	DBG("QSP_PIC%d (%d IRQ sources) @%p\n", qsp_pic->index,
+	    NR_QSP_PIC_INTS, qsp_pic->base);
+
+	return qsp_pic;
+}
+
+void qsp_pic_init(void)
+{
+	struct device_node *np;
+	const u32 *interrupts;
+
+	/* First locate and initialize the top-level QSP_PIC */
+	for_each_compatible_node(np, NULL, "qsp-pic") {
+		interrupts = of_get_property(np, "interrupts", NULL);
+		if (!interrupts)
+			break;
+	}
+
+	BUG_ON(!np); /* qsp_pic_init_tree() assumes there's a QSP_PIC as the
+		      * top-level interrupt controller */
+	primary_qsp_pic = qsp_pic_init_one(np);
+	if (!primary_qsp_pic)
+		panic("Unable to initialize primary QSP_PIC %s\n",
+		      np->full_name);
+
+	of_node_put(np);
+
+}
+
+/* Return an interrupt vector or NO_IRQ if no interrupt is pending. */
+unsigned int qsp_pic_get_irq(void)
+{
+	u32 pending;
+	u32 rev;
+	BUG_ON(!primary_qsp_pic);
+
+	pending = qsp_pic_read_register(primary_qsp_pic, QSP_PIC_PENDING);
+	DBG("get irq %d\n", pending);
+
+	if (pending == QSP_NO_IRQ)
+		return NO_IRQ;
+
+	rev = irq_find_mapping(primary_qsp_pic->domain, pending);
+
+#ifdef DEBUG_IPI
+	if (rev > IPI_BASE)
+		DBG("%s IPI  %d -> cpu:%d msg:%d\n", __func__, rev,
+		    IPI_GET_CPU(rev), IPI_GET_MSG(rev));
+#endif
+	return rev;
+}
+
diff -ruN linux-3.10/drivers/pic/.qsp_pic.o.cmd linux-3.10_patched/drivers/pic/.qsp_pic.o.cmd
--- linux-3.10/drivers/pic/.qsp_pic.o.cmd	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.10_patched/drivers/pic/.qsp_pic.o.cmd	2025-06-14 05:48:04.969173245 +0000
@@ -0,0 +1,571 @@
+cmd_drivers/pic/qsp_pic.o := /home/mike/qsp_buildroot/buildroot/output/host/usr/bin/ccache /home/mike/qsp_buildroot/buildroot/output/host/usr/bin/arm-none-linux-gnueabi-gcc -Wp,-MD,drivers/pic/.qsp_pic.o.d -nostdinc -isystem /home/mike/qsp_buildroot/buildroot/output/host/opt/ext-toolchain/bin/../lib/gcc/arm-none-linux-gnueabi/4.8.1/include -I/home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include -Iarch/arm/include/generated -Iinclude  -include /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/include/linux/kconfig.h -D__KERNEL__ -mlittle-endian -Iarch/arm/mach-qsp/include -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -Wno-format-security -fno-delete-null-pointer-checks -O2 -marm -fno-dwarf2-cfi-asm -mabi=aapcs-linux -mno-thumb-interwork -funwind-tables -D__LINUX_ARM_ARCH__=7 -march=armv7-a -msoft-float -Uarm -Wframe-larger-than=1024 -fno-stack-protector -Wno-unused-but-set-variable -fomit-frame-pointer -g -Wdeclaration-after-statement -Wno-pointer-sign -fno-strict-overflow -fconserve-stack -DCC_HAVE_ASM_GOTO    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(qsp_pic)"  -D"KBUILD_MODNAME=KBUILD_STR(qsp_pic)" -c -o drivers/pic/qsp_pic.o drivers/pic/qsp_pic.c
+
+source_drivers/pic/qsp_pic.o := drivers/pic/qsp_pic.c
+
+deps_drivers/pic/qsp_pic.o := \
+    $(wildcard include/config/smp.h) \
+    $(wildcard include/config/arm.h) \
+  include/linux/kernel.h \
+    $(wildcard include/config/lbdaf.h) \
+    $(wildcard include/config/preempt/voluntary.h) \
+    $(wildcard include/config/debug/atomic/sleep.h) \
+    $(wildcard include/config/prove/locking.h) \
+    $(wildcard include/config/ring/buffer.h) \
+    $(wildcard include/config/tracing.h) \
+    $(wildcard include/config/numa.h) \
+    $(wildcard include/config/compaction.h) \
+    $(wildcard include/config/ftrace/mcount/record.h) \
+  include/linux/sysinfo.h \
+  include/linux/types.h \
+    $(wildcard include/config/uid16.h) \
+    $(wildcard include/config/arch/dma/addr/t/64bit.h) \
+    $(wildcard include/config/phys/addr/t/64bit.h) \
+    $(wildcard include/config/64bit.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/types.h \
+  include/asm-generic/int-ll64.h \
+  arch/arm/include/generated/asm/bitsperlong.h \
+  include/asm-generic/bitsperlong.h \
+  include/linux/posix_types.h \
+  include/linux/stddef.h \
+  include/linux/compiler.h \
+    $(wildcard include/config/sparse/rcu/pointer.h) \
+    $(wildcard include/config/trace/branch/profiling.h) \
+    $(wildcard include/config/profile/all/branches.h) \
+    $(wildcard include/config/enable/must/check.h) \
+    $(wildcard include/config/enable/warn/deprecated.h) \
+  include/linux/compiler-gcc.h \
+    $(wildcard include/config/arch/supports/optimized/inlining.h) \
+    $(wildcard include/config/optimize/inlining.h) \
+  include/linux/compiler-gcc4.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/posix_types.h \
+  include/asm-generic/posix_types.h \
+  /home/mike/qsp_buildroot/buildroot/output/host/opt/ext-toolchain/lib/gcc/arm-none-linux-gnueabi/4.8.1/include/stdarg.h \
+  include/linux/linkage.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/linkage.h \
+  include/linux/bitops.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/bitops.h \
+  include/linux/irqflags.h \
+    $(wildcard include/config/trace/irqflags.h) \
+    $(wildcard include/config/irqsoff/tracer.h) \
+    $(wildcard include/config/preempt/tracer.h) \
+    $(wildcard include/config/trace/irqflags/support.h) \
+  include/linux/typecheck.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/irqflags.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/ptrace.h \
+    $(wildcard include/config/cpu/endian/be8.h) \
+    $(wildcard include/config/arm/thumb.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/hwcap.h \
+  include/asm-generic/bitops/non-atomic.h \
+  include/asm-generic/bitops/fls64.h \
+  include/asm-generic/bitops/sched.h \
+  include/asm-generic/bitops/hweight.h \
+  include/asm-generic/bitops/arch_hweight.h \
+  include/asm-generic/bitops/const_hweight.h \
+  include/asm-generic/bitops/lock.h \
+  include/asm-generic/bitops/le.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/byteorder.h \
+  include/linux/byteorder/little_endian.h \
+  include/linux/swab.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/swab.h \
+  include/linux/byteorder/generic.h \
+  include/asm-generic/bitops/ext2-atomic-setbit.h \
+  include/linux/log2.h \
+    $(wildcard include/config/arch/has/ilog2/u32.h) \
+    $(wildcard include/config/arch/has/ilog2/u64.h) \
+  include/linux/printk.h \
+    $(wildcard include/config/printk.h) \
+    $(wildcard include/config/dynamic/debug.h) \
+  include/linux/init.h \
+    $(wildcard include/config/modules.h) \
+    $(wildcard include/config/hotplug.h) \
+  include/linux/dynamic_debug.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/div64.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/compiler.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/bug.h \
+    $(wildcard include/config/bug.h) \
+    $(wildcard include/config/thumb2/kernel.h) \
+    $(wildcard include/config/debug/bugverbose.h) \
+    $(wildcard include/config/arm/lpae.h) \
+  include/asm-generic/bug.h \
+    $(wildcard include/config/generic/bug.h) \
+    $(wildcard include/config/generic/bug/relative/pointers.h) \
+  include/linux/module.h \
+    $(wildcard include/config/sysfs.h) \
+    $(wildcard include/config/unused/symbols.h) \
+    $(wildcard include/config/kallsyms.h) \
+    $(wildcard include/config/tracepoints.h) \
+    $(wildcard include/config/event/tracing.h) \
+    $(wildcard include/config/module/unload.h) \
+    $(wildcard include/config/constructors.h) \
+    $(wildcard include/config/debug/set/module/ronx.h) \
+  include/linux/list.h \
+    $(wildcard include/config/debug/list.h) \
+  include/linux/poison.h \
+    $(wildcard include/config/illegal/pointer/value.h) \
+  include/linux/const.h \
+  include/linux/stat.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/stat.h \
+  include/linux/time.h \
+    $(wildcard include/config/arch/uses/gettimeoffset.h) \
+  include/linux/cache.h \
+    $(wildcard include/config/arch/has/cache/line/size.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/cache.h \
+    $(wildcard include/config/arm/l1/cache/shift.h) \
+    $(wildcard include/config/aeabi.h) \
+  include/linux/seqlock.h \
+  include/linux/spinlock.h \
+    $(wildcard include/config/debug/spinlock.h) \
+    $(wildcard include/config/generic/lockbreak.h) \
+    $(wildcard include/config/preempt.h) \
+    $(wildcard include/config/debug/lock/alloc.h) \
+  include/linux/preempt.h \
+    $(wildcard include/config/debug/preempt.h) \
+    $(wildcard include/config/preempt/count.h) \
+    $(wildcard include/config/preempt/notifiers.h) \
+  include/linux/thread_info.h \
+    $(wildcard include/config/compat.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/thread_info.h \
+    $(wildcard include/config/arm/thumbee.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/fpstate.h \
+    $(wildcard include/config/vfpv3.h) \
+    $(wildcard include/config/iwmmxt.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/domain.h \
+    $(wildcard include/config/io/36.h) \
+    $(wildcard include/config/cpu/use/domains.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/barrier.h \
+    $(wildcard include/config/cpu/32v6k.h) \
+    $(wildcard include/config/cpu/xsc3.h) \
+    $(wildcard include/config/cpu/fa526.h) \
+    $(wildcard include/config/arch/has/barriers.h) \
+    $(wildcard include/config/arm/dma/mem/bufferable.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/outercache.h \
+    $(wildcard include/config/outer/cache/sync.h) \
+    $(wildcard include/config/outer/cache.h) \
+  include/linux/stringify.h \
+  include/linux/bottom_half.h \
+  include/linux/spinlock_types.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/spinlock_types.h \
+  include/linux/lockdep.h \
+    $(wildcard include/config/lockdep.h) \
+    $(wildcard include/config/lock/stat.h) \
+    $(wildcard include/config/prove/rcu.h) \
+  include/linux/rwlock_types.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/spinlock.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/processor.h \
+    $(wildcard include/config/have/hw/breakpoint.h) \
+    $(wildcard include/config/mmu.h) \
+    $(wildcard include/config/arm/errata/754327.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/hw_breakpoint.h \
+  include/linux/rwlock.h \
+  include/linux/spinlock_api_smp.h \
+    $(wildcard include/config/inline/spin/lock.h) \
+    $(wildcard include/config/inline/spin/lock/bh.h) \
+    $(wildcard include/config/inline/spin/lock/irq.h) \
+    $(wildcard include/config/inline/spin/lock/irqsave.h) \
+    $(wildcard include/config/inline/spin/trylock.h) \
+    $(wildcard include/config/inline/spin/trylock/bh.h) \
+    $(wildcard include/config/uninline/spin/unlock.h) \
+    $(wildcard include/config/inline/spin/unlock/bh.h) \
+    $(wildcard include/config/inline/spin/unlock/irq.h) \
+    $(wildcard include/config/inline/spin/unlock/irqrestore.h) \
+  include/linux/rwlock_api_smp.h \
+    $(wildcard include/config/inline/read/lock.h) \
+    $(wildcard include/config/inline/write/lock.h) \
+    $(wildcard include/config/inline/read/lock/bh.h) \
+    $(wildcard include/config/inline/write/lock/bh.h) \
+    $(wildcard include/config/inline/read/lock/irq.h) \
+    $(wildcard include/config/inline/write/lock/irq.h) \
+    $(wildcard include/config/inline/read/lock/irqsave.h) \
+    $(wildcard include/config/inline/write/lock/irqsave.h) \
+    $(wildcard include/config/inline/read/trylock.h) \
+    $(wildcard include/config/inline/write/trylock.h) \
+    $(wildcard include/config/inline/read/unlock.h) \
+    $(wildcard include/config/inline/write/unlock.h) \
+    $(wildcard include/config/inline/read/unlock/bh.h) \
+    $(wildcard include/config/inline/write/unlock/bh.h) \
+    $(wildcard include/config/inline/read/unlock/irq.h) \
+    $(wildcard include/config/inline/write/unlock/irq.h) \
+    $(wildcard include/config/inline/read/unlock/irqrestore.h) \
+    $(wildcard include/config/inline/write/unlock/irqrestore.h) \
+  include/linux/atomic.h \
+    $(wildcard include/config/arch/has/atomic/or.h) \
+    $(wildcard include/config/generic/atomic64.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/atomic.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/cmpxchg.h \
+    $(wildcard include/config/cpu/sa1100.h) \
+    $(wildcard include/config/cpu/sa110.h) \
+    $(wildcard include/config/cpu/v6.h) \
+  include/asm-generic/cmpxchg-local.h \
+  include/asm-generic/atomic-long.h \
+  include/linux/math64.h \
+  include/linux/kmod.h \
+  include/linux/gfp.h \
+    $(wildcard include/config/kmemcheck.h) \
+    $(wildcard include/config/highmem.h) \
+    $(wildcard include/config/zone/dma.h) \
+    $(wildcard include/config/zone/dma32.h) \
+    $(wildcard include/config/pm/sleep.h) \
+  include/linux/mmzone.h \
+    $(wildcard include/config/force/max/zoneorder.h) \
+    $(wildcard include/config/memory/hotplug.h) \
+    $(wildcard include/config/sparsemem.h) \
+    $(wildcard include/config/have/memblock/node/map.h) \
+    $(wildcard include/config/discontigmem.h) \
+    $(wildcard include/config/flat/node/mem/map.h) \
+    $(wildcard include/config/cgroup/mem/res/ctlr.h) \
+    $(wildcard include/config/no/bootmem.h) \
+    $(wildcard include/config/have/memory/present.h) \
+    $(wildcard include/config/have/memoryless/nodes.h) \
+    $(wildcard include/config/need/node/memmap/size.h) \
+    $(wildcard include/config/have/memblock/node.h) \
+    $(wildcard include/config/need/multiple/nodes.h) \
+    $(wildcard include/config/have/arch/early/pfn/to/nid.h) \
+    $(wildcard include/config/flatmem.h) \
+    $(wildcard include/config/sparsemem/extreme.h) \
+    $(wildcard include/config/have/arch/pfn/valid.h) \
+    $(wildcard include/config/nodes/span/other/nodes.h) \
+    $(wildcard include/config/holes/in/zone.h) \
+    $(wildcard include/config/arch/has/holes/memorymodel.h) \
+  include/linux/wait.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/current.h \
+  include/linux/threads.h \
+    $(wildcard include/config/nr/cpus.h) \
+    $(wildcard include/config/base/small.h) \
+  include/linux/numa.h \
+    $(wildcard include/config/nodes/shift.h) \
+  include/linux/nodemask.h \
+  include/linux/bitmap.h \
+  include/linux/string.h \
+    $(wildcard include/config/binary/printf.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/string.h \
+  include/linux/pageblock-flags.h \
+    $(wildcard include/config/hugetlb/page.h) \
+    $(wildcard include/config/hugetlb/page/size/variable.h) \
+  include/generated/bounds.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/page.h \
+    $(wildcard include/config/cpu/copy/v3.h) \
+    $(wildcard include/config/cpu/copy/v4wt.h) \
+    $(wildcard include/config/cpu/copy/v4wb.h) \
+    $(wildcard include/config/cpu/copy/feroceon.h) \
+    $(wildcard include/config/cpu/copy/fa.h) \
+    $(wildcard include/config/cpu/xscale.h) \
+    $(wildcard include/config/cpu/copy/v6.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/glue.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/pgtable-2level-types.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/memory.h \
+    $(wildcard include/config/need/mach/memory/h.h) \
+    $(wildcard include/config/page/offset.h) \
+    $(wildcard include/config/dram/size.h) \
+    $(wildcard include/config/dram/base.h) \
+    $(wildcard include/config/have/tcm.h) \
+    $(wildcard include/config/arm/patch/phys/virt.h) \
+    $(wildcard include/config/phys/offset.h) \
+  arch/arm/include/generated/asm/sizes.h \
+  include/asm-generic/sizes.h \
+  include/asm-generic/memory_model.h \
+    $(wildcard include/config/sparsemem/vmemmap.h) \
+  include/asm-generic/getorder.h \
+  include/linux/memory_hotplug.h \
+    $(wildcard include/config/memory/hotremove.h) \
+    $(wildcard include/config/have/arch/nodedata/extension.h) \
+  include/linux/notifier.h \
+  include/linux/errno.h \
+  arch/arm/include/generated/asm/errno.h \
+  include/asm-generic/errno.h \
+  include/asm-generic/errno-base.h \
+  include/linux/mutex.h \
+    $(wildcard include/config/debug/mutexes.h) \
+    $(wildcard include/config/have/arch/mutex/cpu/relax.h) \
+  include/linux/rwsem.h \
+    $(wildcard include/config/rwsem/generic/spinlock.h) \
+  include/linux/rwsem-spinlock.h \
+  include/linux/srcu.h \
+  include/linux/rcupdate.h \
+    $(wildcard include/config/rcu/torture/test.h) \
+    $(wildcard include/config/tree/rcu.h) \
+    $(wildcard include/config/tree/preempt/rcu.h) \
+    $(wildcard include/config/rcu/trace.h) \
+    $(wildcard include/config/preempt/rcu.h) \
+    $(wildcard include/config/tiny/rcu.h) \
+    $(wildcard include/config/tiny/preempt/rcu.h) \
+    $(wildcard include/config/debug/objects/rcu/head.h) \
+    $(wildcard include/config/hotplug/cpu.h) \
+    $(wildcard include/config/preempt/rt.h) \
+  include/linux/cpumask.h \
+    $(wildcard include/config/cpumask/offstack.h) \
+    $(wildcard include/config/debug/per/cpu/maps.h) \
+    $(wildcard include/config/disable/obsolete/cpumask/functions.h) \
+  include/linux/bug.h \
+  include/linux/completion.h \
+  include/linux/debugobjects.h \
+    $(wildcard include/config/debug/objects.h) \
+    $(wildcard include/config/debug/objects/free.h) \
+  include/linux/rcutree.h \
+  include/linux/topology.h \
+    $(wildcard include/config/sched/smt.h) \
+    $(wildcard include/config/sched/mc.h) \
+    $(wildcard include/config/sched/book.h) \
+    $(wildcard include/config/use/percpu/numa/node/id.h) \
+  include/linux/smp.h \
+    $(wildcard include/config/use/generic/smp/helpers.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/smp.h \
+  include/linux/percpu.h \
+    $(wildcard include/config/need/per/cpu/embed/first/chunk.h) \
+    $(wildcard include/config/need/per/cpu/page/first/chunk.h) \
+    $(wildcard include/config/have/setup/per/cpu/area.h) \
+  include/linux/pfn.h \
+  arch/arm/include/generated/asm/percpu.h \
+  include/asm-generic/percpu.h \
+  include/linux/percpu-defs.h \
+    $(wildcard include/config/debug/force/weak/per/cpu.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/topology.h \
+    $(wildcard include/config/arm/cpu/topology.h) \
+  include/asm-generic/topology.h \
+  include/linux/mmdebug.h \
+    $(wildcard include/config/debug/vm.h) \
+    $(wildcard include/config/debug/virtual.h) \
+  include/linux/workqueue.h \
+    $(wildcard include/config/debug/objects/work.h) \
+    $(wildcard include/config/freezer.h) \
+  include/linux/timer.h \
+    $(wildcard include/config/timer/stats.h) \
+    $(wildcard include/config/debug/objects/timers.h) \
+  include/linux/ktime.h \
+    $(wildcard include/config/ktime/scalar.h) \
+  include/linux/jiffies.h \
+  include/linux/timex.h \
+  include/linux/param.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/param.h \
+    $(wildcard include/config/hz.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/timex.h \
+  arch/arm/mach-qsp/include/mach/timex.h \
+  include/linux/sysctl.h \
+    $(wildcard include/config/sysctl.h) \
+  include/linux/rbtree.h \
+  include/linux/elf.h \
+  include/linux/elf-em.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/elf.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/user.h \
+  include/linux/kobject.h \
+  include/linux/sysfs.h \
+  include/linux/kobject_ns.h \
+  include/linux/kref.h \
+  include/linux/moduleparam.h \
+    $(wildcard include/config/alpha.h) \
+    $(wildcard include/config/ia64.h) \
+    $(wildcard include/config/ppc64.h) \
+  include/linux/tracepoint.h \
+  include/linux/static_key.h \
+  include/linux/jump_label.h \
+    $(wildcard include/config/jump/label.h) \
+  include/linux/export.h \
+    $(wildcard include/config/symbol/prefix.h) \
+    $(wildcard include/config/modversions.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/module.h \
+    $(wildcard include/config/arm/unwind.h) \
+  include/linux/reboot.h \
+  arch/arm/include/generated/asm/emergency-restart.h \
+  include/asm-generic/emergency-restart.h \
+  include/linux/slab.h \
+    $(wildcard include/config/slab/debug.h) \
+    $(wildcard include/config/failslab.h) \
+    $(wildcard include/config/slub.h) \
+    $(wildcard include/config/slob.h) \
+    $(wildcard include/config/debug/slab.h) \
+    $(wildcard include/config/slab.h) \
+  include/linux/slub_def.h \
+    $(wildcard include/config/slub/stats.h) \
+    $(wildcard include/config/slub/debug.h) \
+  include/linux/kmemleak.h \
+    $(wildcard include/config/debug/kmemleak.h) \
+  include/linux/sched.h \
+    $(wildcard include/config/sched/debug.h) \
+    $(wildcard include/config/no/hz.h) \
+    $(wildcard include/config/lockup/detector.h) \
+    $(wildcard include/config/detect/hung/task.h) \
+    $(wildcard include/config/core/dump/default/elf/headers.h) \
+    $(wildcard include/config/sched/autogroup.h) \
+    $(wildcard include/config/virt/cpu/accounting.h) \
+    $(wildcard include/config/bsd/process/acct.h) \
+    $(wildcard include/config/taskstats.h) \
+    $(wildcard include/config/audit.h) \
+    $(wildcard include/config/cgroups.h) \
+    $(wildcard include/config/inotify/user.h) \
+    $(wildcard include/config/fanotify.h) \
+    $(wildcard include/config/epoll.h) \
+    $(wildcard include/config/posix/mqueue.h) \
+    $(wildcard include/config/keys.h) \
+    $(wildcard include/config/perf/events.h) \
+    $(wildcard include/config/schedstats.h) \
+    $(wildcard include/config/task/delay/acct.h) \
+    $(wildcard include/config/fair/group/sched.h) \
+    $(wildcard include/config/rt/group/sched.h) \
+    $(wildcard include/config/blk/dev/io/trace.h) \
+    $(wildcard include/config/rcu/boost.h) \
+    $(wildcard include/config/compat/brk.h) \
+    $(wildcard include/config/generic/hardirqs.h) \
+    $(wildcard include/config/cc/stackprotector.h) \
+    $(wildcard include/config/sysvipc.h) \
+    $(wildcard include/config/auditsyscall.h) \
+    $(wildcard include/config/rt/mutexes.h) \
+    $(wildcard include/config/block.h) \
+    $(wildcard include/config/task/xacct.h) \
+    $(wildcard include/config/cpusets.h) \
+    $(wildcard include/config/futex.h) \
+    $(wildcard include/config/fault/injection.h) \
+    $(wildcard include/config/latencytop.h) \
+    $(wildcard include/config/function/graph/tracer.h) \
+    $(wildcard include/config/have/unstable/sched/clock.h) \
+    $(wildcard include/config/irq/time/accounting.h) \
+    $(wildcard include/config/proc/fs.h) \
+    $(wildcard include/config/cfs/bandwidth.h) \
+    $(wildcard include/config/stack/growsup.h) \
+    $(wildcard include/config/debug/stack/usage.h) \
+    $(wildcard include/config/cgroup/sched.h) \
+    $(wildcard include/config/mm/owner.h) \
+  include/linux/capability.h \
+  include/linux/mm_types.h \
+    $(wildcard include/config/split/ptlock/cpus.h) \
+    $(wildcard include/config/want/page/debug/flags.h) \
+    $(wildcard include/config/have/aligned/struct/page.h) \
+    $(wildcard include/config/aio.h) \
+    $(wildcard include/config/mmu/notifier.h) \
+    $(wildcard include/config/transparent/hugepage.h) \
+  include/linux/auxvec.h \
+  arch/arm/include/generated/asm/auxvec.h \
+  include/asm-generic/auxvec.h \
+  include/linux/prio_tree.h \
+  include/linux/page-debug-flags.h \
+    $(wildcard include/config/page/poisoning.h) \
+    $(wildcard include/config/page/guard.h) \
+    $(wildcard include/config/page/debug/something/else.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/mmu.h \
+    $(wildcard include/config/cpu/has/asid.h) \
+  arch/arm/include/generated/asm/cputime.h \
+  include/asm-generic/cputime.h \
+  include/linux/sem.h \
+  include/linux/ipc.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/ipcbuf.h \
+  include/asm-generic/ipcbuf.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/sembuf.h \
+  include/linux/signal.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/signal.h \
+  include/asm-generic/signal-defs.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/sigcontext.h \
+  arch/arm/include/generated/asm/siginfo.h \
+  include/asm-generic/siginfo.h \
+  include/linux/pid.h \
+  include/linux/proportions.h \
+  include/linux/percpu_counter.h \
+  include/linux/seccomp.h \
+    $(wildcard include/config/seccomp.h) \
+  include/linux/rculist.h \
+  include/linux/rtmutex.h \
+    $(wildcard include/config/debug/rt/mutexes.h) \
+  include/linux/plist.h \
+    $(wildcard include/config/debug/pi/list.h) \
+  include/linux/resource.h \
+  arch/arm/include/generated/asm/resource.h \
+  include/asm-generic/resource.h \
+  include/linux/hrtimer.h \
+    $(wildcard include/config/high/res/timers.h) \
+    $(wildcard include/config/timerfd.h) \
+  include/linux/timerqueue.h \
+  include/linux/task_io_accounting.h \
+    $(wildcard include/config/task/io/accounting.h) \
+  include/linux/latencytop.h \
+  include/linux/cred.h \
+    $(wildcard include/config/debug/credentials.h) \
+    $(wildcard include/config/security.h) \
+    $(wildcard include/config/user/ns.h) \
+  include/linux/key.h \
+  include/linux/selinux.h \
+    $(wildcard include/config/security/selinux.h) \
+  include/linux/llist.h \
+    $(wildcard include/config/arch/have/nmi/safe/cmpxchg.h) \
+  include/linux/aio.h \
+  include/linux/aio_abi.h \
+  include/linux/uio.h \
+  include/linux/device.h \
+    $(wildcard include/config/debug/devres.h) \
+    $(wildcard include/config/devtmpfs.h) \
+    $(wildcard include/config/sysfs/deprecated.h) \
+  include/linux/ioport.h \
+  include/linux/klist.h \
+  include/linux/pm.h \
+    $(wildcard include/config/pm.h) \
+    $(wildcard include/config/pm/runtime.h) \
+    $(wildcard include/config/pm/clk.h) \
+    $(wildcard include/config/pm/generic/domains.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/device.h \
+    $(wildcard include/config/dmabounce.h) \
+    $(wildcard include/config/iommu/api.h) \
+    $(wildcard include/config/arch/omap.h) \
+  include/linux/pm_wakeup.h \
+  include/linux/bootmem.h \
+    $(wildcard include/config/have/arch/bootmem/node.h) \
+    $(wildcard include/config/have/arch/alloc/remap.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/dma.h \
+    $(wildcard include/config/isa/dma/api.h) \
+    $(wildcard include/config/pci.h) \
+  include/linux/irq.h \
+    $(wildcard include/config/s390.h) \
+    $(wildcard include/config/irq/release/method.h) \
+    $(wildcard include/config/generic/pending/irq.h) \
+  include/linux/irqreturn.h \
+  include/linux/irqnr.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/irq.h \
+    $(wildcard include/config/sparse/irq.h) \
+  arch/arm/mach-qsp/include/mach/irqs.h \
+  arch/arm/include/generated/asm/irq_regs.h \
+  include/asm-generic/irq_regs.h \
+  include/linux/irqdesc.h \
+    $(wildcard include/config/irq/preflow/fasteoi.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/hw_irq.h \
+  include/linux/irqdomain.h \
+    $(wildcard include/config/irq/domain.h) \
+    $(wildcard include/config/of/irq.h) \
+  include/linux/radix-tree.h \
+  include/linux/interrupt.h \
+    $(wildcard include/config/irq/forced/threading.h) \
+    $(wildcard include/config/generic/irq/probe.h) \
+  include/linux/hardirq.h \
+  include/linux/ftrace_irq.h \
+    $(wildcard include/config/ftrace/nmi/enter.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/hardirq.h \
+  include/linux/irq_cpustat.h \
+  include/linux/kernel_stat.h \
+  include/linux/io.h \
+    $(wildcard include/config/has/ioport.h) \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/io.h \
+    $(wildcard include/config/need/mach/io/h.h) \
+    $(wildcard include/config/pcmcia/soc/common.h) \
+    $(wildcard include/config/isa.h) \
+    $(wildcard include/config/pccard.h) \
+  include/asm-generic/pci_iomap.h \
+    $(wildcard include/config/no/generic/pci/ioport/map.h) \
+    $(wildcard include/config/generic/pci/iomap.h) \
+  include/linux/err.h \
+  include/linux/of_fdt.h \
+    $(wildcard include/config/of/flattree.h) \
+    $(wildcard include/config/blk/dev/initrd.h) \
+  include/linux/of_address.h \
+    $(wildcard include/config/of/address.h) \
+  include/linux/of.h \
+    $(wildcard include/config/sparc.h) \
+    $(wildcard include/config/of/dynamic.h) \
+    $(wildcard include/config/of.h) \
+  include/linux/mod_devicetable.h \
+  /home/mike/qsp_buildroot/buildroot/output/build/linux-3.4/arch/arm/include/asm/prom.h \
+  include/linux/of_irq.h \
+    $(wildcard include/config/ppc32.h) \
+    $(wildcard include/config/ppc/pmac.h) \
+  include/linux/platform_device.h \
+    $(wildcard include/config/suspend.h) \
+    $(wildcard include/config/hibernate/callbacks.h) \
+  include/linux/qsp/qsp.h \
+  include/linux/qsp/qsp_pic.h \
+
+drivers/pic/qsp_pic.o: $(deps_drivers/pic/qsp_pic.o)
+
+$(deps_drivers/pic/qsp_pic.o):
diff -ruN linux-3.10/drivers/rtc/Kconfig linux-3.10_patched/drivers/rtc/Kconfig
--- linux-3.10/drivers/rtc/Kconfig	2013-06-30 22:13:29.000000000 +0000
+++ linux-3.10_patched/drivers/rtc/Kconfig	2025-06-14 05:48:04.973173245 +0000
@@ -1248,5 +1248,11 @@
 	  If this driver is compiled as a module, it will be named
 	  rtc-hid-sensor-time.
 
+config RTC_DRV_QSP
+       tristate "RTC support for QSP"
+       depends on RTC_CLASS || QSP
+       default y
+       help
+         This option enables build of the RTC QSP platform driver.
 
 endif # RTC_CLASS
diff -ruN linux-3.10/drivers/rtc/Makefile linux-3.10_patched/drivers/rtc/Makefile
--- linux-3.10/drivers/rtc/Makefile	2013-06-30 22:13:29.000000000 +0000
+++ linux-3.10_patched/drivers/rtc/Makefile	2025-06-14 05:48:04.973173245 +0000
@@ -128,3 +128,4 @@
 obj-$(CONFIG_RTC_DRV_WM831X)	+= rtc-wm831x.o
 obj-$(CONFIG_RTC_DRV_WM8350)	+= rtc-wm8350.o
 obj-$(CONFIG_RTC_DRV_X1205)	+= rtc-x1205.o
+obj-$(CONFIG_RTC_DRV_QSP)	+= rtc-qsp.o
diff -ruN linux-3.10/drivers/rtc/rtc-qsp.c linux-3.10_patched/drivers/rtc/rtc-qsp.c
--- linux-3.10/drivers/rtc/rtc-qsp.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.10_patched/drivers/rtc/rtc-qsp.c	2025-06-14 05:48:04.973173245 +0000
@@ -0,0 +1,145 @@
+/*
+ * .../drivers/rtc/rtc-qsp.c
+ *
+ * Real-time clock driver for the QSP platform
+ *
+ * Copyright (c) 2012 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/rtc.h>
+#include <linux/of_device.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <linux/qsp/qsp.h>
+
+/* Register offsets */
+#define ID_REG           0x00
+#define TIME_REG         0x04
+#define OFFSET_REG       0x08
+
+struct qsp_rtc_priv {
+	unsigned char __iomem *membase;
+	struct rtc_device *rtc;
+};
+
+static int qsp_rtc_read_time(struct device *dev, struct rtc_time *tm)
+{
+	struct qsp_rtc_priv *priv = dev_get_drvdata(dev);
+	unsigned long now;
+
+	now = readl(priv->membase + TIME_REG) +
+		readl(priv->membase + OFFSET_REG);
+	pr_debug("%s: %li\n", __func__, now);
+	rtc_time_to_tm(now, tm);
+
+	return 0;
+}
+
+
+static int qsp_rtc_set_time(struct device *dev, struct rtc_time *tm)
+{
+	struct qsp_rtc_priv *priv = dev_get_drvdata(dev);
+	unsigned long now;
+
+	rtc_tm_to_time(tm, &now);
+	now = now - readl(priv->membase + TIME_REG);
+
+	pr_debug("%s: %li\n", __func__, now);
+	writel(now, priv->membase + OFFSET_REG);
+
+	return 0;
+}
+
+static const struct rtc_class_ops qsp_rtc_ops = {
+	.read_time = qsp_rtc_read_time,
+	.set_time = qsp_rtc_set_time,
+};
+
+static int qsp_rtc_probe(struct platform_device *pdev)
+{
+	struct qsp_rtc_priv *priv;
+
+	dev_dbg(&pdev->dev, "%s\n", __func__);
+
+	priv = kzalloc(sizeof(struct qsp_rtc_priv), GFP_KERNEL);
+	if (!priv)
+		return -ENODEV;
+
+	priv->membase = of_iomap(pdev->dev.of_node, 0);
+	if (priv->membase == NULL)
+		goto err1;
+
+	if (qsp_device_valid(priv->membase, QSP_RTC_ID_VAL) != 0)
+		goto err2;
+
+	platform_set_drvdata(pdev, priv);
+
+	priv->rtc = rtc_device_register("qsp-rtc", &pdev->dev,
+					&qsp_rtc_ops, THIS_MODULE);
+	if (IS_ERR_OR_NULL(priv->rtc)) {
+		dev_err(&pdev->dev, "Can't register RTC device (%p)\n",
+			priv->rtc);
+		goto err2;
+	}
+
+	return 0;
+
+err2:
+	iounmap(priv->membase);
+err1:
+	kfree(priv);
+	return -ENODEV;
+}
+
+static int qsp_rtc_remove(struct platform_device *pdev)
+{
+	struct qsp_rtc_priv *priv = platform_get_drvdata(pdev);
+
+	dev_dbg(&pdev->dev, "%s\n", __func__);
+
+	rtc_device_unregister(priv->rtc);
+	platform_set_drvdata(pdev, NULL);
+	iounmap(priv->membase);
+	kfree(priv);
+
+	return 0;
+}
+
+static struct of_device_id of_qsp_rtc_match[] = {
+	{ .compatible = "qsp-rtc", },
+	{},
+};
+
+static struct platform_driver qsp_rtc_driver = {
+	.probe = qsp_rtc_probe,
+	.remove = qsp_rtc_remove,
+	.driver = {
+		.name = "qsp-rtc",
+		.owner = THIS_MODULE,
+		.of_match_table = of_qsp_rtc_match,
+	},
+};
+
+module_platform_driver(qsp_rtc_driver);
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("LED support for QSP");
+MODULE_AUTHOR("Anders Wallin <anders.wallin@windriver.com>");
diff -ruN linux-3.10/drivers/staging/csr/csr_wifi_hip_card_sdio.c linux-3.10_patched/drivers/staging/csr/csr_wifi_hip_card_sdio.c
--- linux-3.10/drivers/staging/csr/csr_wifi_hip_card_sdio.c	2013-06-30 22:13:29.000000000 +0000
+++ linux-3.10_patched/drivers/staging/csr/csr_wifi_hip_card_sdio.c	2025-06-14 05:47:37.729173137 +0000
@@ -1,4001 +0,0 @@
-/*****************************************************************************
-
-            (c) Cambridge Silicon Radio Limited 2012
-            All rights reserved and confidential information of CSR
-
-            Refer to LICENSE.txt included with this source for details
-            on the license terms.
-
-*****************************************************************************/
-
-/*
- * ---------------------------------------------------------------------------
- * FILE: csr_wifi_hip_card_sdio.c
- *
- * PURPOSE: Implementation of the Card API for SDIO.
- *
- * NOTES:
- *      CardInit() is called from the SDIO probe callback when a card is
- *      inserted. This performs the basic SDIO initialisation, enabling i/o
- *      etc.
- *
- * ---------------------------------------------------------------------------
- */
-#include <linux/slab.h>
-#include "csr_wifi_hip_unifi.h"
-#include "csr_wifi_hip_conversions.h"
-#include "csr_wifi_hip_unifiversion.h"
-#include "csr_wifi_hip_card.h"
-#include "csr_wifi_hip_card_sdio.h"
-#include "csr_wifi_hip_chiphelper.h"
-
-
-/* Time to wait between attempts to read MAILBOX0 */
-#define MAILBOX1_TIMEOUT                10  /* in millisecs */
-#define MAILBOX1_ATTEMPTS               200 /* 2 seconds */
-
-#define MAILBOX2_TIMEOUT                5   /* in millisecs */
-#define MAILBOX2_ATTEMPTS               10  /* 50ms */
-
-#define RESET_SETTLE_DELAY              25  /* in millisecs */
-
-static CsrResult card_init_slots(card_t *card);
-static CsrResult card_hw_init(card_t *card);
-static CsrResult firmware_present_in_flash(card_t *card);
-static void bootstrap_chip_hw(card_t *card);
-static CsrResult unifi_reset_hardware(card_t *card);
-static CsrResult unifi_hip_init(card_t *card);
-static CsrResult card_access_panic(card_t *card);
-static CsrResult unifi_read_chip_version(card_t *card);
-
-/*
- * ---------------------------------------------------------------------------
- *  unifi_alloc_card
- *
- *      Allocate and initialise the card context structure.
- *
- *  Arguments:
- *      sdio            Pointer to SDIO context pointer to pass to low
- *                      level i/o functions.
- *      ospriv          Pointer to O/S private struct to pass when calling
- *                      callbacks to the higher level system.
- *
- *  Returns:
- *      Pointer to card struct, which represents the driver context or
- *      NULL if the allocation failed.
- * ---------------------------------------------------------------------------
- */
-card_t* unifi_alloc_card(CsrSdioFunction *sdio, void *ospriv)
-{
-    card_t *card;
-    u32 i;
-
-
-    card = kzalloc(sizeof(card_t), GFP_KERNEL);
-    if (card == NULL)
-    {
-        return NULL;
-    }
-
-    card->sdio_if = sdio;
-    card->ospriv  = ospriv;
-
-    card->unifi_interrupt_seq = 1;
-
-    /* Make these invalid. */
-    card->proc_select = (u32)(-1);
-    card->dmem_page = (u32)(-1);
-    card->pmem_page = (u32)(-1);
-
-    card->bh_reason_host = 0;
-    card->bh_reason_unifi = 0;
-
-    for (i = 0; i < sizeof(card->tx_q_paused_flag) / sizeof(card->tx_q_paused_flag[0]); i++)
-    {
-        card->tx_q_paused_flag[i] = 0;
-    }
-    card->memory_resources_allocated = 0;
-
-    card->low_power_mode = UNIFI_LOW_POWER_DISABLED;
-    card->periodic_wake_mode = UNIFI_PERIODIC_WAKE_HOST_DISABLED;
-
-    card->host_state = UNIFI_HOST_STATE_AWAKE;
-    card->intmode = CSR_WIFI_INTMODE_DEFAULT;
-
-    /*
-     * Memory resources for buffers are allocated when the chip is initialised
-     * because we need configuration information from the firmware.
-     */
-
-    /*
-     * Initialise wait queues and lists
-     */
-    card->fh_command_queue.q_body = card->fh_command_q_body;
-    card->fh_command_queue.q_length = UNIFI_SOFT_COMMAND_Q_LENGTH;
-
-    for (i = 0; i < UNIFI_NO_OF_TX_QS; i++)
-    {
-        card->fh_traffic_queue[i].q_body = card->fh_traffic_q_body[i];
-        card->fh_traffic_queue[i].q_length = UNIFI_SOFT_TRAFFIC_Q_LENGTH;
-    }
-
-
-    /* Initialise mini-coredump pointers in case no coredump buffers
-     * are requested by the OS layer.
-     */
-    card->request_coredump_on_reset = 0;
-    card->dump_next_write = NULL;
-    card->dump_cur_read = NULL;
-    card->dump_buf = NULL;
-
-#ifdef UNIFI_DEBUG
-    /* Determine offset of LSB in pointer for later alignment sanity check.
-     * Synergy integer types have specific widths, which cause compiler
-     * warnings when casting pointer types, e.g. on 64-bit systems.
-     */
-    {
-        u32 val = 0x01234567;
-
-        if (*((u8 *)&val) == 0x01)
-        {
-            card->lsb = sizeof(void *) - 1;     /* BE */
-        }
-        else
-        {
-            card->lsb = 0;                      /* LE */
-        }
-    }
-#endif
-    return card;
-} /* unifi_alloc_card() */
-
-
-/*
- * ---------------------------------------------------------------------------
- *  unifi_init_card
- *
- *      Reset the hardware and perform HIP initialization
- *
- *  Arguments:
- *      card        Pointer to card struct
- *
- *  Returns:
- *      CsrResult code
- *      CSR_RESULT_SUCCESS if successful
- * ---------------------------------------------------------------------------
- */
-CsrResult unifi_init_card(card_t *card, s32 led_mask)
-{
-    CsrResult r;
-
-
-    if (card == NULL)
-    {
-        return CSR_WIFI_HIP_RESULT_INVALID_VALUE;
-    }
-
-    r = unifi_init(card);
-    if (r != CSR_RESULT_SUCCESS)
-    {
-        return r;
-    }
-
-    r = unifi_hip_init(card);
-    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
-    {
-        return r;
-    }
-    if (r != CSR_RESULT_SUCCESS)
-    {
-        unifi_error(card->ospriv, "Failed to start host protocol.\n");
-        return r;
-    }
-
-    return CSR_RESULT_SUCCESS;
-}
-
-
-/*
- * ---------------------------------------------------------------------------
- *  unifi_init
- *
- *      Init the hardware.
- *
- *  Arguments:
- *      card        Pointer to card struct
- *
- *  Returns:
- *      CsrResult code
- *      CSR_RESULT_SUCCESS if successful
- * ---------------------------------------------------------------------------
- */
-CsrResult unifi_init(card_t *card)
-{
-    CsrResult r;
-    CsrResult csrResult;
-
-    if (card == NULL)
-    {
-        return CSR_WIFI_HIP_RESULT_INVALID_VALUE;
-    }
-
-    /*
-     * Disable the SDIO interrupts while initialising UniFi.
-     * Re-enable them when f/w is running.
-     */
-    csrResult = CsrSdioInterruptDisable(card->sdio_if);
-    if (csrResult == CSR_SDIO_RESULT_NO_DEVICE)
-    {
-        return CSR_WIFI_HIP_RESULT_NO_DEVICE;
-    }
-
-    /*
-     * UniFi's PLL may start with a slow clock (~ 1 MHz) so initially
-     * set the SDIO bus clock to a similar value or SDIO accesses may
-     * fail.
-     */
-    csrResult = CsrSdioMaxBusClockFrequencySet(card->sdio_if, UNIFI_SDIO_CLOCK_SAFE_HZ);
-    if (csrResult != CSR_RESULT_SUCCESS)
-    {
-        r = ConvertCsrSdioToCsrHipResult(card, csrResult);
-        return r;
-    }
-    card->sdio_clock_speed = UNIFI_SDIO_CLOCK_SAFE_HZ;
-
-    /*
-     * Reset UniFi. Note, this only resets the WLAN function part of the chip,
-     * the SDIO interface is not reset.
-     */
-    unifi_trace(card->ospriv, UDBG1, "Resetting UniFi\n");
-    r = unifi_reset_hardware(card);
-    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
-    {
-        return r;
-    }
-    if (r != CSR_RESULT_SUCCESS)
-    {
-        unifi_error(card->ospriv, "Failed to reset UniFi\n");
-        return r;
-    }
-
-    /* Reset the power save mode, to be active until the MLME-reset is complete */
-    r = unifi_configure_low_power_mode(card,
-                                       UNIFI_LOW_POWER_DISABLED, UNIFI_PERIODIC_WAKE_HOST_DISABLED);
-    if (r != CSR_RESULT_SUCCESS)
-    {
-        unifi_error(card->ospriv, "Failed to set power save mode\n");
-        return r;
-    }
-
-    /*
-     * Set initial value of page registers.
-     * The page registers will be maintained by unifi_read...() and
-     * unifi_write...().
-     */
-    card->proc_select = (u32)(-1);
-    card->dmem_page = (u32)(-1);
-    card->pmem_page = (u32)(-1);
-    r = unifi_write_direct16(card, ChipHelper_HOST_WINDOW3_PAGE(card->helper) * 2, 0);
-    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
-    {
-        return r;
-    }
-    if (r != CSR_RESULT_SUCCESS)
-    {
-        unifi_error(card->ospriv, "Failed to write SHARED_DMEM_PAGE\n");
-        return r;
-    }
-    r = unifi_write_direct16(card, ChipHelper_HOST_WINDOW2_PAGE(card->helper) * 2, 0);
-    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
-    {
-        return r;
-    }
-    if (r != CSR_RESULT_SUCCESS)
-    {
-        unifi_error(card->ospriv, "Failed to write PROG_MEM2_PAGE\n");
-        return r;
-    }
-
-    /*
-     * If the driver has reset UniFi due to previous SDIO failure, this may
-     * have been due to a chip watchdog reset. In this case, the driver may
-     * have requested a mini-coredump which needs to be captured now the
-     * SDIO interface is alive.
-     */
-    (void)unifi_coredump_handle_request(card);
-
-    /*
-     * Probe to see if the UniFi has ROM/flash to boot from. CSR6xxx should do.
-     */
-    r = firmware_present_in_flash(card);
-    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
-    {
-        return r;
-    }
-    if (r == CSR_WIFI_HIP_RESULT_NOT_FOUND)
-    {
-        unifi_error(card->ospriv, "No firmware found\n");
-    }
-    else if (r != CSR_RESULT_SUCCESS)
-    {
-        unifi_error(card->ospriv, "Probe for Flash failed\n");
-    }
-
-    return r;
-} /* unifi_init() */
-
-
-/*
- * ---------------------------------------------------------------------------
- *  unifi_download
- *
- *      Load the firmware.
- *
- *  Arguments:
- *      card        Pointer to card struct
- *      led_mask    Loader LED mask
- *
- *  Returns:
- *      CSR_RESULT_SUCCESS on success
- *      CsrResult error code on failure.
- * ---------------------------------------------------------------------------
- */
-CsrResult unifi_download(card_t *card, s32 led_mask)
-{
-    CsrResult r;
-    void *dlpriv;
-
-    if (card == NULL)
-    {
-        return CSR_WIFI_HIP_RESULT_INVALID_VALUE;
-    }
-
-    /* Set the loader led mask */
-    card->loader_led_mask = led_mask;
-
-    /* Get the firmware file information */
-    unifi_trace(card->ospriv, UDBG1, "downloading firmware...\n");
-
-    dlpriv = unifi_dl_fw_read_start(card, UNIFI_FW_STA);
-    if (dlpriv == NULL)
-    {
-        return CSR_WIFI_HIP_RESULT_NOT_FOUND;
-    }
-
-    /* Download the firmware. */
-    r = unifi_dl_firmware(card, dlpriv);
-    if (r != CSR_RESULT_SUCCESS)
-    {
-        unifi_error(card->ospriv, "Failed to download firmware\n");
-        return r;
-    }
-
-    /* Free the firmware file information. */
-    unifi_fw_read_stop(card->ospriv, dlpriv);
-
-    return CSR_RESULT_SUCCESS;
-} /* unifi_download() */
-
-
-/*
- * ---------------------------------------------------------------------------
- *  unifi_hip_init
- *
- *      This function performs the f/w initialisation sequence as described
- *      in the Unifi Host Interface Protocol Specification.
- *      It allocates memory for host-side slot data and signal queues.
- *
- *  Arguments:
- *      card        Pointer to card struct
- *
- *  Returns:
- *      CSR_RESULT_SUCCESS on success or else a CSR error code
- *
- *  Notes:
- *      The firmware must have been downloaded.
- * ---------------------------------------------------------------------------
- */
-static CsrResult unifi_hip_init(card_t *card)
-{
-    CsrResult r;
-    CsrResult csrResult;
-
-    r = card_hw_init(card);
-    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
-    {
-        return r;
-    }
-    if (r != CSR_RESULT_SUCCESS)
-    {
-        unifi_error(card->ospriv, "Failed to establish communication with UniFi\n");
-        return r;
-    }
-#ifdef CSR_PRE_ALLOC_NET_DATA
-    /* if there is any preallocated netdata left from the prev session free it now */
-    prealloc_netdata_free(card);
-#endif
-    /*
-     * Allocate memory for host-side slot data and signal queues.
-     * We need the config info read from the firmware to know how much
-     * memory to allocate.
-     */
-    r = card_init_slots(card);
-    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
-    {
-        return r;
-    }
-    if (r != CSR_RESULT_SUCCESS)
-    {
-        unifi_error(card->ospriv, "Init slots failed: %d\n", r);
-        return r;
-    }
-
-    unifi_trace(card->ospriv, UDBG2, "Sending first UniFi interrupt\n");
-
-    r = unifi_set_host_state(card, UNIFI_HOST_STATE_AWAKE);
-    if (r != CSR_RESULT_SUCCESS)
-    {
-        return r;
-    }
-
-    /* Enable the SDIO interrupts now that the f/w is running. */
-    csrResult = CsrSdioInterruptEnable(card->sdio_if);
-    if (csrResult == CSR_SDIO_RESULT_NO_DEVICE)
-    {
-        return CSR_WIFI_HIP_RESULT_NO_DEVICE;
-    }
-
-    /* Signal the UniFi to start handling messages */
-    r = CardGenInt(card);
-    if (r != CSR_RESULT_SUCCESS)
-    {
-        return r;
-    }
-
-    return CSR_RESULT_SUCCESS;
-} /* unifi_hip_init() */
-
-
-/*
- * ---------------------------------------------------------------------------
- *  _build_sdio_config_data
- *
- *      Unpack the SDIO configuration information from a buffer read from
- *      UniFi into a host structure.
- *      The data is byte-swapped for a big-endian host if necessary by the
- *      UNPACK... macros.
- *
- *  Arguments:
- *      card            Pointer to card struct
- *      cfg_data        Destination structure to unpack into.
- *      cfg_data_buf    Source buffer to read from. This should be the raw
- *                      data read from UniFi.
- *
- *  Returns:
- *      None.
- * ---------------------------------------------------------------------------
- */
-static void _build_sdio_config_data(sdio_config_data_t *cfg_data,
-                                    const u8     *cfg_data_buf)
-{
-    s16 offset = 0;
-
-    cfg_data->version = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(cfg_data_buf + offset);
-    offset += SIZEOF_UINT16;
-
-    cfg_data->sdio_ctrl_offset = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(cfg_data_buf + offset);
-    offset += SIZEOF_UINT16;
-
-    cfg_data->fromhost_sigbuf_handle = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(cfg_data_buf + offset);
-    offset += SIZEOF_UINT16;
-
-    cfg_data->tohost_sigbuf_handle = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(cfg_data_buf + offset);
-    offset += SIZEOF_UINT16;
-
-    cfg_data->num_fromhost_sig_frags = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(cfg_data_buf + offset);
-    offset += SIZEOF_UINT16;
-
-    cfg_data->num_tohost_sig_frags = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(cfg_data_buf + offset);
-    offset += SIZEOF_UINT16;
-
-    cfg_data->num_fromhost_data_slots = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(cfg_data_buf + offset);
-    offset += SIZEOF_UINT16;
-
-    cfg_data->num_tohost_data_slots = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(cfg_data_buf + offset);
-    offset += SIZEOF_UINT16;
-
-    cfg_data->data_slot_size = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(cfg_data_buf + offset);
-    offset += SIZEOF_UINT16;
-
-    cfg_data->initialised = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(cfg_data_buf + offset);
-    offset += SIZEOF_UINT16;
-
-    cfg_data->overlay_size = CSR_GET_UINT32_FROM_LITTLE_ENDIAN(cfg_data_buf + offset);
-    offset += SIZEOF_UINT32;
-
-    cfg_data->data_slot_round = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(cfg_data_buf + offset);
-    offset += SIZEOF_UINT16;
-
-    cfg_data->sig_frag_size = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(cfg_data_buf + offset);
-    offset += SIZEOF_UINT16;
-
-    cfg_data->tohost_signal_padding = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(cfg_data_buf + offset);
-} /* _build_sdio_config_data() */
-
-
-/*
- * - Function ----------------------------------------------------------------
- * card_hw_init()
- *
- *      Perform the initialisation procedure described in the UniFi Host
- *      Interface Protocol document (section 3.3.8) and read the run-time
- *      configuration information from the UniFi. This is stuff like number
- *      of bulk data slots etc.
- *
- *      The card enumeration and SD initialisation has already been done by
- *      the SDIO library, see card_sdio_init().
- *
- *      The initialisation is done when firmware is ready, i.e. this may need
- *      to be called after a f/w download operation.
- *
- *      The initialisation procedure goes like this:
- *       - Wait for UniFi to start-up by polling SHARED_MAILBOX1
- *       - Find the symbol table and look up SLT_SDIO_SLOT_CONFIG
- *       - Read the config structure
- *       - Check the "SDIO initialised" flag, if not zero do a h/w reset and
- *         start again
- *       - Decide the number of bulk data slots to allocate, allocate them and
- *         set "SDIO initialised" flag (and generate an interrupt) to say so.
- *
- * Arguments:
- *      card        Pointer to card struct
- *
- * Returns:
- *      CSR_RESULT_SUCEESS on success,
- *      a CSR error code on failure
- *
- * Notes:
- *      All data in the f/w is stored in a little endian format, without any
- *      padding bytes. Every read from this memory has to be transformed in
- *      host (cpu specific) format, before it is stored in driver's parameters
- *      or/and structures. Athough unifi_card_read16() and unifi_read32() do perform
- *      the conversion internally, unifi_readn() does not.
- * ---------------------------------------------------------------------------
- */
-static CsrResult card_hw_init(card_t *card)
-{
-    u32 slut_address;
-    u16 initialised;
-    u16 finger_print;
-    symbol_t slut;
-    sdio_config_data_t *cfg_data;
-    u8 cfg_data_buf[SDIO_CONFIG_DATA_SIZE];
-    CsrResult r;
-    void *dlpriv;
-    s16 major, minor;
-    s16 search_4slut_again;
-    CsrResult csrResult;
-
-    /*
-     * The device revision from the TPLMID_MANF and TPLMID_CARD fields
-     * of the CIS are available as
-     *   card->sdio_if->pDevice->ManfID
-     *   card->sdio_if->pDevice->AppID
-     */
-
-    /*
-     * Run in a loop so we can patch.
-     */
-    do
-    {
-        /* Reset these each time around the loop. */
-        search_4slut_again = 0;
-        cfg_data = NULL;
-
-        r = card_wait_for_firmware_to_start(card, &slut_address);
-        if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
-        {
-            return r;
-        }
-        if (r != CSR_RESULT_SUCCESS)
-        {
-            unifi_error(card->ospriv, "Firmware hasn't started\n");
-            return r;
-        }
-        unifi_trace(card->ospriv, UDBG4, "SLUT addr 0x%lX\n", slut_address);
-
-        /*
-         * Firmware has started, but doesn't know full clock configuration yet
-         * as some of the information may be in the MIB. Therefore we set an
-         * initial SDIO clock speed, faster than UNIFI_SDIO_CLOCK_SAFE_HZ, for
-         * the patch download and subsequent firmware initialisation, and
-         * full speed UNIFI_SDIO_CLOCK_MAX_HZ will be set once the f/w tells us
-         * that it is ready.
-         */
-        csrResult = CsrSdioMaxBusClockFrequencySet(card->sdio_if, UNIFI_SDIO_CLOCK_INIT_HZ);
-        if (csrResult != CSR_RESULT_SUCCESS)
-        {
-            r = ConvertCsrSdioToCsrHipResult(card, csrResult);
-            return r;
-        }
-        card->sdio_clock_speed = UNIFI_SDIO_CLOCK_INIT_HZ;
-
-        /*
-         * Check the SLUT fingerprint.
-         * The slut_address is a generic pointer so we must use unifi_card_read16().
-         */
-        unifi_trace(card->ospriv, UDBG4, "Looking for SLUT finger print\n");
-        finger_print = 0;
-        r = unifi_card_read16(card, slut_address, &finger_print);
-        if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
-        {
-            return r;
-        }
-        if (r != CSR_RESULT_SUCCESS)
-        {
-            unifi_error(card->ospriv, "Failed to read SLUT finger print\n");
-            return r;
-        }
-
-        if (finger_print != SLUT_FINGERPRINT)
-        {
-            unifi_error(card->ospriv, "Failed to find Symbol lookup table fingerprint\n");
-            return CSR_RESULT_FAILURE;
-        }
-
-        /* Symbol table starts imedately after the fingerprint */
-        slut_address += 2;
-
-        /* Search the table until either the end marker is found, or the
-         * loading of patch firmware invalidates the current table.
-         */
-        while (!search_4slut_again)
-        {
-            u16 s;
-            u32 l;
-
-            r = unifi_card_read16(card, slut_address, &s);
-            if (r != CSR_RESULT_SUCCESS)
-            {
-                return r;
-            }
-            slut_address += 2;
-
-            if (s == CSR_SLT_END)
-            {
-                unifi_trace(card->ospriv, UDBG3, "  found CSR_SLT_END\n");
-                break;
-            }
-
-            r = unifi_read32(card, slut_address, &l);
-            if (r != CSR_RESULT_SUCCESS)
-            {
-                return r;
-            }
-            slut_address += 4;
-
-            slut.id = s;
-            slut.obj = l;
-
-            unifi_trace(card->ospriv, UDBG3, "  found SLUT id %02d.%08lx\n", slut.id, slut.obj);
-            switch (slut.id)
-            {
-                case CSR_SLT_SDIO_SLOT_CONFIG:
-                    cfg_data = &card->config_data;
-                    /*
-                     * unifi_card_readn reads n bytes from the card, where data is stored
-                     * in a little endian format, without any padding bytes. So, we
-                     * can not just pass the cfg_data pointer or use the
-                     * sizeof(sdio_config_data_t) since the structure in the host can
-                     * be big endian formatted or have padding bytes for alignment.
-                     * We use a char buffer to read the data from the card.
-                     */
-                    r = unifi_card_readn(card, slut.obj, cfg_data_buf, SDIO_CONFIG_DATA_SIZE);
-                    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
-                    {
-                        return r;
-                    }
-                    if (r != CSR_RESULT_SUCCESS)
-                    {
-                        unifi_error(card->ospriv, "Failed to read config data\n");
-                        return r;
-                    }
-                    /* .. and then we copy the data to the host structure */
-                    _build_sdio_config_data(cfg_data, cfg_data_buf);
-
-                    /* Make sure the from host data slots are what we expect
-                        we reserve 2 for commands and there should be at least
-                        1 left for each access category */
-                    if ((cfg_data->num_fromhost_data_slots < UNIFI_RESERVED_COMMAND_SLOTS)
-                        || (cfg_data->num_fromhost_data_slots - UNIFI_RESERVED_COMMAND_SLOTS) / UNIFI_NO_OF_TX_QS == 0)
-                    {
-                        unifi_error(card->ospriv, "From host data slots %d\n", cfg_data->num_fromhost_data_slots);
-                        unifi_error(card->ospriv, "need to be (queues * x + 2) (UNIFI_RESERVED_COMMAND_SLOTS for commands)\n");
-                        return CSR_RESULT_FAILURE;
-                    }
-
-                    /* Configure SDIO to-block-size padding */
-                    if (card->sdio_io_block_pad)
-                    {
-                    /*
-                     * Firmware limits the maximum padding size via data_slot_round.
-                     * Therefore when padding to whole block sizes, the block size
-                     * must be configured correctly by adjusting CSR_WIFI_HIP_SDIO_BLOCK_SIZE.
-                     */
-                        if (cfg_data->data_slot_round < card->sdio_io_block_size)
-                        {
-                            unifi_error(card->ospriv,
-                                        "Configuration error: Block size of %d exceeds f/w data_slot_round of %d\n",
-                                        card->sdio_io_block_size, cfg_data->data_slot_round);
-                            return CSR_WIFI_HIP_RESULT_INVALID_VALUE;
-                        }
-
-                        /*
-                         * To force the To-Host signals to be rounded up to the SDIO block
-                         * size, we need to write the To-Host Signal Padding Fragments
-                         * field of the SDIO configuration in UniFi.
-                         */
-                        if ((card->sdio_io_block_size % cfg_data->sig_frag_size) != 0)
-                        {
-                            unifi_error(card->ospriv, "Configuration error: Can not pad to-host signals.\n");
-                            return CSR_WIFI_HIP_RESULT_INVALID_VALUE;
-                        }
-                        cfg_data->tohost_signal_padding = (u16) (card->sdio_io_block_size / cfg_data->sig_frag_size);
-                        unifi_info(card->ospriv, "SDIO block size %d requires %d padding chunks\n",
-                                   card->sdio_io_block_size, cfg_data->tohost_signal_padding);
-                        r = unifi_card_write16(card, slut.obj + SDIO_TO_HOST_SIG_PADDING_OFFSET, cfg_data->tohost_signal_padding);
-                        if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
-                        {
-                            return r;
-                        }
-                        if (r != CSR_RESULT_SUCCESS)
-                        {
-                            unifi_error(card->ospriv, "Failed to write To-Host Signal Padding Fragments\n");
-                            return r;
-                        }
-                    }
-
-                    /* Reconstruct the Generic Pointer address of the
-                     * SDIO Control Data Struct.
-                     */
-                    card->sdio_ctrl_addr = cfg_data->sdio_ctrl_offset | (UNIFI_SH_DMEM << 24);
-                    card->init_flag_addr = slut.obj + SDIO_INIT_FLAG_OFFSET;
-                    break;
-
-                case CSR_SLT_BUILD_ID_NUMBER:
-                {
-                    u32 n;
-                    r = unifi_read32(card, slut.obj, &n);
-                    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
-                    {
-                        return r;
-                    }
-                    if (r != CSR_RESULT_SUCCESS)
-                    {
-                        unifi_error(card->ospriv, "Failed to read build id\n");
-                        return r;
-                    }
-                    card->build_id = n;
-                }
-                break;
-
-                case CSR_SLT_BUILD_ID_STRING:
-                    r = unifi_readnz(card, slut.obj, card->build_id_string,
-                                     sizeof(card->build_id_string));
-                    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
-                    {
-                        return r;
-                    }
-                    if (r != CSR_RESULT_SUCCESS)
-                    {
-                        unifi_error(card->ospriv, "Failed to read build string\n");
-                        return r;
-                    }
-                    break;
-
-                case CSR_SLT_PERSISTENT_STORE_DB:
-                    break;
-
-                case CSR_SLT_BOOT_LOADER_CONTROL:
-
-                    /* This command copies most of the station firmware
-                     * image from ROM into program RAM.  It also clears
-                     * out the zerod data and sets up the initialised
-                     * data. */
-                    r = unifi_do_loader_op(card, slut.obj + 6, UNIFI_BOOT_LOADER_LOAD_STA);
-                    if (r != CSR_RESULT_SUCCESS)
-                    {
-                        unifi_error(card->ospriv, "Failed to write loader load image command\n");
-                        return r;
-                    }
-
-                    dlpriv = unifi_dl_fw_read_start(card, UNIFI_FW_STA);
-
-                    /* dlpriv might be NULL, we still need to do the do_loader_op step. */
-                    if (dlpriv != NULL)
-                    {
-                    /* Download the firmware. */
-                        r = unifi_dl_patch(card, dlpriv, slut.obj);
-
-                    /* Free the firmware file information. */
-                        unifi_fw_read_stop(card->ospriv, dlpriv);
-
-                        if (r != CSR_RESULT_SUCCESS)
-                        {
-                            unifi_error(card->ospriv, "Failed to patch firmware\n");
-                            return r;
-                        }
-                    }
-
-                    /* This command starts the firmware image that we want (the
-                    * station by default) with any patches required applied. */
-                    r = unifi_do_loader_op(card, slut.obj + 6, UNIFI_BOOT_LOADER_RESTART);
-                    if (r != CSR_RESULT_SUCCESS)
-                    {
-                        unifi_error(card->ospriv, "Failed to write loader restart command\n");
-                        return r;
-                    }
-
-                    /* The now running patch f/w defines a new SLUT data structure -
-                     * the current one is no longer valid. We must drop out of the
-                     * processing loop and enumerate the new SLUT (which may appear
-                     * at a different offset).
-                     */
-                    search_4slut_again = 1;
-                    break;
-
-                case CSR_SLT_PANIC_DATA_PHY:
-                    card->panic_data_phy_addr = slut.obj;
-                    break;
-
-                case CSR_SLT_PANIC_DATA_MAC:
-                    card->panic_data_mac_addr = slut.obj;
-                    break;
-
-                default:
-                    /* do nothing */
-                    break;
-            }
-        } /* while */
-    } while (search_4slut_again);
-
-    /* Did we find the Config Data ? */
-    if (cfg_data == NULL)
-    {
-        unifi_error(card->ospriv, "Failed to find SDIO_SLOT_CONFIG Symbol\n");
-        return CSR_RESULT_FAILURE;
-    }
-
-    /*
-     * Has ths card already been initialised?
-     * If so, return an error so we do a h/w reset and start again.
-     */
-    r = unifi_card_read16(card, card->init_flag_addr, &initialised);
-    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
-    {
-        return r;
-    }
-    if (r != CSR_RESULT_SUCCESS)
-    {
-        unifi_error(card->ospriv, "Failed to read init flag at %08lx\n",
-                    card->init_flag_addr);
-        return r;
-    }
-    if (initialised != 0)
-    {
-        return CSR_RESULT_FAILURE;
-    }
-
-
-    /*
-     * Now check the UniFi firmware version
-     */
-    major = (cfg_data->version >> 8) & 0xFF;
-    minor = cfg_data->version & 0xFF;
-    unifi_info(card->ospriv, "UniFi f/w protocol version %d.%d (driver %d.%d)\n",
-               major, minor,
-               UNIFI_HIP_MAJOR_VERSION, UNIFI_HIP_MINOR_VERSION);
-
-    unifi_info(card->ospriv, "Firmware build %u: %s\n",
-               card->build_id, card->build_id_string);
-
-    if (major != UNIFI_HIP_MAJOR_VERSION)
-    {
-        unifi_error(card->ospriv, "UniFi f/w protocol major version (%d) is different from driver (v%d.%d)\n",
-                    major, UNIFI_HIP_MAJOR_VERSION, UNIFI_HIP_MINOR_VERSION);
-#ifndef CSR_WIFI_DISABLE_HIP_VERSION_CHECK
-        return CSR_RESULT_FAILURE;
-#endif
-    }
-    if (minor < UNIFI_HIP_MINOR_VERSION)
-    {
-        unifi_error(card->ospriv, "UniFi f/w protocol version (v%d.%d) is older than minimum required by driver (v%d.%d).\n",
-                    major, minor,
-                    UNIFI_HIP_MAJOR_VERSION, UNIFI_HIP_MINOR_VERSION);
-#ifndef CSR_WIFI_DISABLE_HIP_VERSION_CHECK
-        return CSR_RESULT_FAILURE;
-#endif
-    }
-
-    /* Read panic codes from a previous firmware panic. If the firmware has
-     * not panicked since power was applied (e.g. power-off hard reset)
-     * the stored panic codes will not be updated.
-     */
-    unifi_read_panic(card);
-
-    return CSR_RESULT_SUCCESS;
-} /* card_hw_init() */
-
-
-/*
- * ---------------------------------------------------------------------------
- *  card_wait_for_unifi_to_reset
- *
- *      Waits for a reset to complete by polling the WLAN function enable
- *      bit (which is cleared on reset).
- *
- *  Arguments:
- *      card            Pointer to card struct
- *
- *  Returns:
- *      CSR_RESULT_SUCCESS on success, CSR error code on failure.
- * ---------------------------------------------------------------------------
- */
-static CsrResult card_wait_for_unifi_to_reset(card_t *card)
-{
-    s16 i;
-    CsrResult r;
-    u8 io_enable;
-    CsrResult csrResult;
-
-    r = CSR_RESULT_SUCCESS;
-    for (i = 0; i < MAILBOX2_ATTEMPTS; i++)
-    {
-        unifi_trace(card->ospriv, UDBG1, "waiting for reset to complete, attempt %d\n", i);
-        if (card->chip_id > SDIO_CARD_ID_UNIFI_2)
-        {
-            /* It's quite likely that this read will timeout for the
-             * first few tries - especially if we have reset via
-             * DBG_RESET.
-             */
-#if defined (CSR_WIFI_HIP_DEBUG_OFFLINE) && defined (CSR_WIFI_HIP_SDIO_TRACE)
-            unifi_debug_log_to_buf("m0@%02X=", SDIO_IO_READY);
-#endif
-            csrResult = CsrSdioF0Read8(card->sdio_if, SDIO_IO_READY, &io_enable);
-#if defined (CSR_WIFI_HIP_DEBUG_OFFLINE) && defined (CSR_WIFI_HIP_SDIO_TRACE)
-            if (csrResult != CSR_RESULT_SUCCESS)
-            {
-                unifi_debug_log_to_buf("error=%X\n", csrResult);
-            }
-            else
-            {
-                unifi_debug_log_to_buf("%X\n", io_enable);
-            }
-#endif
-            if (csrResult == CSR_SDIO_RESULT_NO_DEVICE)
-            {
-                return CSR_WIFI_HIP_RESULT_NO_DEVICE;
-            }
-            r = CSR_RESULT_SUCCESS;
-            if (csrResult != CSR_RESULT_SUCCESS)
-            {
-                r = ConvertCsrSdioToCsrHipResult(card, csrResult);
-            }
-        }
-        else
-        {
-            r = sdio_read_f0(card, SDIO_IO_ENABLE, &io_enable);
-        }
-        if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
-        {
-            return r;
-        }
-        if (r == CSR_RESULT_SUCCESS)
-        {
-            u16 mbox2;
-            s16 enabled = io_enable & (1 << card->function);
-
-            if (!enabled)
-            {
-                unifi_trace(card->ospriv, UDBG1,
-                            "Reset complete (function %d is disabled) in ~ %u msecs\n",
-                            card->function, i * MAILBOX2_TIMEOUT);
-
-                /* Enable WLAN function and verify MAILBOX2 is zero'd */
-                csrResult = CsrSdioFunctionEnable(card->sdio_if);
-                if (csrResult != CSR_RESULT_SUCCESS)
-                {
-                    r = ConvertCsrSdioToCsrHipResult(card, csrResult);
-                    unifi_error(card->ospriv, "CsrSdioFunctionEnable failed %d\n", r);
-                    break;
-                }
-            }
-
-            r = unifi_read_direct16(card, ChipHelper_SDIO_HIP_HANDSHAKE(card->helper) * 2, &mbox2);
-            if (r != CSR_RESULT_SUCCESS)
-            {
-                unifi_error(card->ospriv, "read HIP_HANDSHAKE failed %d\n", r);
-                break;
-            }
-            if (mbox2 != 0)
-            {
-                unifi_error(card->ospriv, "MAILBOX2 non-zero after reset (mbox2 = %04x)\n", mbox2);
-                r = CSR_RESULT_FAILURE;
-            }
-            break;
-        }
-        else
-        {
-            if (card->chip_id > SDIO_CARD_ID_UNIFI_2)
-            {
-                /* We ignore read failures for the first few reads,
-                 * they are probably benign. */
-                if (i > MAILBOX2_ATTEMPTS / 4)
-                {
-                    unifi_trace(card->ospriv, UDBG1, "Failed to read CCCR IO Ready register while polling for reset\n");
-                }
-            }
-            else
-            {
-                unifi_trace(card->ospriv, UDBG1, "Failed to read CCCR IO Enable register while polling for reset\n");
-            }
-        }
-        CsrThreadSleep(MAILBOX2_TIMEOUT);
-    }
-
-    if (r == CSR_RESULT_SUCCESS && i == MAILBOX2_ATTEMPTS)
-    {
-        unifi_trace(card->ospriv, UDBG1, "Timeout waiting for UniFi to complete reset\n");
-        r = CSR_RESULT_FAILURE;
-    }
-
-    return r;
-} /* card_wait_for_unifi_to_reset() */
-
-
-/*
- * ---------------------------------------------------------------------------
- *  card_wait_for_unifi_to_disable
- *
- *      Waits for the function to become disabled by polling the
- *      IO_READY bit.
- *
- *  Arguments:
- *      card            Pointer to card struct
- *
- *  Returns:
- *      CSR_RESULT_SUCCESS on success, CSR error code on failure.
- *
- *  Notes: This function can only be used with
- *         card->chip_id > SDIO_CARD_ID_UNIFI_2
- * ---------------------------------------------------------------------------
- */
-static CsrResult card_wait_for_unifi_to_disable(card_t *card)
-{
-    s16 i;
-    CsrResult r;
-    u8 io_enable;
-    CsrResult csrResult;
-
-    if (card->chip_id <= SDIO_CARD_ID_UNIFI_2)
-    {
-        unifi_error(card->ospriv,
-                    "Function reset method not supported for chip_id=%d\n",
-                    card->chip_id);
-        return CSR_RESULT_FAILURE;
-    }
-
-    r = CSR_RESULT_SUCCESS;
-    for (i = 0; i < MAILBOX2_ATTEMPTS; i++)
-    {
-        unifi_trace(card->ospriv, UDBG1, "waiting for disable to complete, attempt %d\n", i);
-
-        /*
-         * It's quite likely that this read will timeout for the
-         * first few tries - especially if we have reset via
-         * DBG_RESET.
-         */
-#if defined (CSR_WIFI_HIP_DEBUG_OFFLINE) && defined (CSR_WIFI_HIP_SDIO_TRACE)
-        unifi_debug_log_to_buf("r0@%02X=", SDIO_IO_READY);
-#endif
-        csrResult = CsrSdioF0Read8(card->sdio_if, SDIO_IO_READY, &io_enable);
-#if defined (CSR_WIFI_HIP_DEBUG_OFFLINE) && defined (CSR_WIFI_HIP_SDIO_TRACE)
-        if (csrResult != CSR_RESULT_SUCCESS)
-        {
-            unifi_debug_log_to_buf("error=%X\n", csrResult);
-        }
-        else
-        {
-            unifi_debug_log_to_buf("%X\n", io_enable);
-        }
-#endif
-        if (csrResult == CSR_SDIO_RESULT_NO_DEVICE)
-        {
-            return CSR_WIFI_HIP_RESULT_NO_DEVICE;
-        }
-        if (csrResult == CSR_RESULT_SUCCESS)
-        {
-            s16 enabled = io_enable & (1 << card->function);
-            r = CSR_RESULT_SUCCESS;
-            if (!enabled)
-            {
-                unifi_trace(card->ospriv, UDBG1,
-                            "Disable complete (function %d is disabled) in ~ %u msecs\n",
-                            card->function, i * MAILBOX2_TIMEOUT);
-
-                break;
-            }
-        }
-        else
-        {
-            /*
-             * We ignore read failures for the first few reads,
-             * they are probably benign.
-             */
-            r = ConvertCsrSdioToCsrHipResult(card, csrResult);
-            if (i > (MAILBOX2_ATTEMPTS / 4))
-            {
-                unifi_trace(card->ospriv, UDBG1,
-                            "Failed to read CCCR IO Ready register while polling for disable\n");
-            }
-        }
-        CsrThreadSleep(MAILBOX2_TIMEOUT);
-    }
-
-    if ((r == CSR_RESULT_SUCCESS) && (i == MAILBOX2_ATTEMPTS))
-    {
-        unifi_trace(card->ospriv, UDBG1, "Timeout waiting for UniFi to complete disable\n");
-        r = CSR_RESULT_FAILURE;
-    }
-
-    return r;
-} /* card_wait_for_unifi_to_reset() */
-
-
-/*
- * ---------------------------------------------------------------------------
- *  card_wait_for_firmware_to_start
- *
- *      Polls the MAILBOX1 register for a non-zero value.
- *      Then reads MAILBOX0 and forms the two values into a 32-bit address
- *      which is returned to the caller.
- *
- *  Arguments:
- *      card            Pointer to card struct
- *      paddr           Pointer to receive the UniFi address formed
- *                      by concatenating MAILBOX1 and MAILBOX0.
- *
- *  Returns:
- *      CSR_RESULT_SUCCESS on success, CSR error code on failure.
- * ---------------------------------------------------------------------------
- */
-CsrResult card_wait_for_firmware_to_start(card_t *card, u32 *paddr)
-{
-    s32 i;
-    u16 mbox0, mbox1;
-    CsrResult r;
-
-    /*
-     * Wait for UniFi to initialise its data structures by polling
-     * the SHARED_MAILBOX1 register.
-     * Experience shows this is typically 120ms.
-     */
-    CsrThreadSleep(MAILBOX1_TIMEOUT);
-
-    mbox1 = 0;
-    unifi_trace(card->ospriv, UDBG1, "waiting for MAILBOX1 to be non-zero...\n");
-    for (i = 0; i < MAILBOX1_ATTEMPTS; i++)
-    {
-        r = unifi_read_direct16(card, ChipHelper_MAILBOX1(card->helper) * 2, &mbox1);
-        if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
-        {
-            return r;
-        }
-        if (r != CSR_RESULT_SUCCESS)
-        {
-            /* These reads can fail if UniFi isn't up yet, so try again */
-            unifi_warning(card->ospriv, "Failed to read UniFi Mailbox1 register\n");
-        }
-
-        if ((r == CSR_RESULT_SUCCESS) && (mbox1 != 0))
-        {
-            unifi_trace(card->ospriv, UDBG1, "MAILBOX1 ready (0x%04X) in %u millisecs\n",
-                        mbox1, i * MAILBOX1_TIMEOUT);
-
-            /* Read the MAILBOX1 again in case we caught the value as it
-             * changed. */
-            r = unifi_read_direct16(card, ChipHelper_MAILBOX1(card->helper) * 2, &mbox1);
-            if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
-            {
-                return r;
-            }
-            if (r != CSR_RESULT_SUCCESS)
-            {
-                unifi_error(card->ospriv, "Failed to read UniFi Mailbox1 register for second time\n");
-                return r;
-            }
-            unifi_trace(card->ospriv, UDBG1, "MAILBOX1 value=0x%04X\n", mbox1);
-
-            break;
-        }
-
-        CsrThreadSleep(MAILBOX1_TIMEOUT);
-        if ((i % 100) == 99)
-        {
-            unifi_trace(card->ospriv, UDBG2, "MAILBOX1 not ready (0x%X), still trying...\n", mbox1);
-        }
-    }
-
-    if ((r == CSR_RESULT_SUCCESS) && (mbox1 == 0))
-    {
-        unifi_trace(card->ospriv, UDBG1, "Timeout waiting for firmware to start, Mailbox1 still 0 after %d ms\n",
-                    MAILBOX1_ATTEMPTS * MAILBOX1_TIMEOUT);
-        return CSR_RESULT_FAILURE;
-    }
-
-
-    /*
-     * Complete the reset handshake by setting MAILBOX2 to 0xFFFF
-     */
-    r = unifi_write_direct16(card, ChipHelper_SDIO_HIP_HANDSHAKE(card->helper) * 2, 0xFFFF);
-    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
-    {
-        return r;
-    }
-    if (r != CSR_RESULT_SUCCESS)
-    {
-        unifi_error(card->ospriv, "Failed to write f/w startup handshake to MAILBOX2\n");
-        return r;
-    }
-
-
-    /*
-     * Read the Symbol Look Up Table (SLUT) offset.
-     * Top 16 bits are in mbox1, read the lower 16 bits from mbox0.
-     */
-    mbox0 = 0;
-    r = unifi_read_direct16(card, ChipHelper_MAILBOX0(card->helper) * 2, &mbox0);
-    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
-    {
-        return r;
-    }
-    if (r != CSR_RESULT_SUCCESS)
-    {
-        unifi_error(card->ospriv, "Failed to read UniFi Mailbox0 register\n");
-        return r;
-    }
-
-    *paddr = (((u32)mbox1 << 16) | mbox0);
-
-    return CSR_RESULT_SUCCESS;
-} /* card_wait_for_firmware_to_start() */
-
-
-/*
- * ---------------------------------------------------------------------------
- *  unifi_capture_panic
- *
- *      Attempt to capture panic codes from the firmware. This may involve
- *      warm reset of the chip to regain access following a watchdog reset.
- *
- *  Arguments:
- *      card            Pointer to card struct
- *
- *  Returns:
- *      CSR_RESULT_SUCCESS if panic codes were captured, or none available
- *      CSR_RESULT_FAILURE if the driver could not access function 1
- * ---------------------------------------------------------------------------
- */
-CsrResult unifi_capture_panic(card_t *card)
-{
-
-    /* The firmware must have previously initialised to read the panic addresses
-     * from the SLUT
-     */
-    if (!card->panic_data_phy_addr || !card->panic_data_mac_addr)
-    {
-        return CSR_RESULT_SUCCESS;
-    }
-
-    /* Ensure we can access function 1 following a panic/watchdog reset */
-    if (card_access_panic(card) == CSR_RESULT_SUCCESS)
-    {
-        /* Read the panic codes */
-        unifi_read_panic(card);
-    }
-    else
-    {
-        unifi_info(card->ospriv, "Unable to read panic codes");
-    }
-
-    return CSR_RESULT_SUCCESS;
-}
-
-
-/*
- * ---------------------------------------------------------------------------
- *  card_access_panic
- *      Attempt to read the WLAN SDIO function in order to read panic codes
- *      and perform various reset steps to regain access if the read fails.
- *
- *  Arguments:
- *      card            Pointer to card struct
- *
- *  Returns:
- *      CSR_RESULT_SUCCESS if panic codes can be read
- *      CSR error code if panic codes can not be read
- * ---------------------------------------------------------------------------
- */
-static CsrResult card_access_panic(card_t *card)
-{
-    u16 data_u16 = 0;
-    s32 i;
-    CsrResult r, sr;
-
-    /* A chip version of zero means that the version never got successfully read
-     * during reset. In this case give up because it will not be possible to
-     * verify the chip version.
-     */
-    if (!card->chip_version)
-    {
-        unifi_info(card->ospriv, "Unknown chip version\n");
-        return CSR_RESULT_FAILURE;
-    }
-
-    /* Ensure chip is awake or access to function 1 will fail */
-    r = unifi_set_host_state(card, UNIFI_HOST_STATE_AWAKE);
-    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
-    {
-        return r;
-    }
-    if (r != CSR_RESULT_SUCCESS)
-    {
-        unifi_error(card->ospriv, "unifi_set_host_state() failed %d\n", r);
-        return CSR_RESULT_FAILURE; /* Card is probably unpowered */
-    }
-    CsrThreadSleep(20);
-
-    for (i = 0; i < 3; i++)
-    {
-        sr = CsrSdioRead16(card->sdio_if, CHIP_HELPER_UNIFI_GBL_CHIP_VERSION * 2, &data_u16);
-        if (sr != CSR_RESULT_SUCCESS || data_u16 != card->chip_version)
-        {
-            unifi_info(card->ospriv, "Failed to read valid chip version sr=%d (0x%04x want 0x%04x) try %d\n",
-                       sr, data_u16, card->chip_version, i);
-
-            /* Set clock speed low */
-            sr = CsrSdioMaxBusClockFrequencySet(card->sdio_if, UNIFI_SDIO_CLOCK_SAFE_HZ);
-            if (sr != CSR_RESULT_SUCCESS)
-            {
-                unifi_error(card->ospriv, "CsrSdioMaxBusClockFrequencySet() failed1 %d\n", sr);
-                r = ConvertCsrSdioToCsrHipResult(card, sr);
-            }
-            card->sdio_clock_speed = UNIFI_SDIO_CLOCK_SAFE_HZ;
-
-            /* First try re-enabling function in case a f/w watchdog reset disabled it */
-            if (i == 0)
-            {
-                unifi_info(card->ospriv, "Try function enable\n");
-                sr = CsrSdioFunctionEnable(card->sdio_if);
-                if (sr != CSR_RESULT_SUCCESS)
-                {
-                    r = ConvertCsrSdioToCsrHipResult(card, sr);
-                    unifi_error(card->ospriv, "CsrSdioFunctionEnable failed %d (HIP %d)\n", sr, r);
-                }
-                continue;
-            }
-
-            /* Second try, set awake */
-            unifi_info(card->ospriv, "Try set awake\n");
-
-            /* Ensure chip is awake */
-            r = unifi_set_host_state(card, UNIFI_HOST_STATE_AWAKE);
-            if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
-            {
-                return r;
-            }
-            if (r != CSR_RESULT_SUCCESS)
-            {
-                unifi_error(card->ospriv, "unifi_set_host_state() failed2 %d\n", r);
-            }
-
-            /* Set clock speed low in case setting the host state raised it, which
-             * would only happen if host state was previously TORPID
-             */
-            sr = CsrSdioMaxBusClockFrequencySet(card->sdio_if, UNIFI_SDIO_CLOCK_SAFE_HZ);
-            if (sr != CSR_RESULT_SUCCESS)
-            {
-                unifi_error(card->ospriv, "CsrSdioMaxBusClockFrequencySet() failed2 %d\n", sr);
-            }
-            card->sdio_clock_speed = UNIFI_SDIO_CLOCK_SAFE_HZ;
-
-            if (i == 1)
-            {
-                continue;
-            }
-
-            /* Perform a s/w reset to preserve as much as the card state as possible,
-             * (mainly the preserve RAM). The context will be lost for coredump - but as we
-             * were unable to access the WLAN function for panic, the coredump would have
-             * also failed without a reset.
-             */
-            unifi_info(card->ospriv, "Try s/w reset\n");
-
-            r = unifi_card_hard_reset(card);
-            if (r != CSR_RESULT_SUCCESS)
-            {
-                unifi_error(card->ospriv, "unifi_card_hard_reset() failed %d\n", r);
-            }
-        }
-        else
-        {
-            if (i > 0)
-            {
-                unifi_info(card->ospriv, "Read chip version 0x%x after %d retries\n", data_u16, i);
-            }
-            break;
-        }
-    }
-
-    r = ConvertCsrSdioToCsrHipResult(card, sr);
-    return r;
-}
-
-
-/*
- * ---------------------------------------------------------------------------
- *  unifi_read_panic
- *      Reads, saves and prints panic codes stored by the firmware in UniFi's
- *      preserve RAM by the last panic that occurred since chip was powered.
- *      Nothing is saved if the panic codes are read as zero.
- *
- *  Arguments:
- *      card            Pointer to card struct
- *
- *  Returns:
- * ---------------------------------------------------------------------------
- */
-void unifi_read_panic(card_t *card)
-{
-    CsrResult r;
-    u16 p_code, p_arg;
-
-    /* The firmware must have previously initialised to read the panic addresses
-     * from the SLUT
-     */
-    if (!card->panic_data_phy_addr || !card->panic_data_mac_addr)
-    {
-        return;
-    }
-
-    /* Get the panic data from PHY */
-    r = unifi_card_read16(card, card->panic_data_phy_addr, &p_code);
-    if (r != CSR_RESULT_SUCCESS)
-    {
-        unifi_error(card->ospriv, "capture_panic: unifi_read16 %08x failed %d\n", card->panic_data_phy_addr, r);
-        p_code = 0;
-    }
-    if (p_code)
-    {
-        r = unifi_card_read16(card, card->panic_data_phy_addr + 2, &p_arg);
-        if (r != CSR_RESULT_SUCCESS)
-        {
-            unifi_error(card->ospriv, "capture_panic: unifi_read16 %08x failed %d\n", card->panic_data_phy_addr + 2, r);
-        }
-        unifi_error(card->ospriv, "Last UniFi PHY PANIC %04x arg %04x\n", p_code, p_arg);
-        card->last_phy_panic_code = p_code;
-        card->last_phy_panic_arg = p_arg;
-    }
-
-    /* Get the panic data from MAC */
-    r = unifi_card_read16(card, card->panic_data_mac_addr, &p_code);
-    if (r != CSR_RESULT_SUCCESS)
-    {
-        unifi_error(card->ospriv, "capture_panic: unifi_read16 %08x failed %d\n", card->panic_data_mac_addr, r);
-        p_code = 0;
-    }
-    if (p_code)
-    {
-        r = unifi_card_read16(card, card->panic_data_mac_addr + 2, &p_arg);
-        if (r != CSR_RESULT_SUCCESS)
-        {
-            unifi_error(card->ospriv, "capture_panic: unifi_read16 %08x failed %d\n", card->panic_data_mac_addr + 2, r);
-        }
-        unifi_error(card->ospriv, "Last UniFi MAC PANIC %04x arg %04x\n", p_code, p_arg);
-        card->last_mac_panic_code = p_code;
-        card->last_mac_panic_arg = p_arg;
-    }
-
-}
-
-
-/*
- * ---------------------------------------------------------------------------
- *  card_allocate_memory_resources
- *
- *      Allocates memory for the from-host, to-host bulk data slots,
- *      soft queue buffers and bulk data buffers.
- *
- *  Arguments:
- *      card            Pointer to card struct
- *
- *  Returns:
- *      CSR_RESULT_SUCCESS on success, CSR error code on failure.
- * ---------------------------------------------------------------------------
- */
-static CsrResult card_allocate_memory_resources(card_t *card)
-{
-    s16 n, i, k, r;
-    sdio_config_data_t *cfg_data;
-
-    /* Reset any state carried forward from a previous life */
-    card->fh_command_queue.q_rd_ptr = 0;
-    card->fh_command_queue.q_wr_ptr = 0;
-    (void)scnprintf(card->fh_command_queue.name, UNIFI_QUEUE_NAME_MAX_LENGTH,
-                      "fh_cmd_q");
-    for (i = 0; i < UNIFI_NO_OF_TX_QS; i++)
-    {
-        card->fh_traffic_queue[i].q_rd_ptr = 0;
-        card->fh_traffic_queue[i].q_wr_ptr = 0;
-        (void)scnprintf(card->fh_traffic_queue[i].name,
-                          UNIFI_QUEUE_NAME_MAX_LENGTH, "fh_data_q%d", i);
-    }
-#ifndef CSR_WIFI_HIP_TA_DISABLE
-    unifi_ta_sampling_init(card);
-#endif
-    /* Convenience short-cut */
-    cfg_data = &card->config_data;
-
-    /*
-     * Allocate memory for the from-host and to-host signal buffers.
-     */
-    card->fh_buffer.buf = kmalloc(UNIFI_FH_BUF_SIZE, GFP_KERNEL);
-    if (card->fh_buffer.buf == NULL)
-    {
-        unifi_error(card->ospriv, "Failed to allocate memory for F-H signals\n");
-        return CSR_WIFI_HIP_RESULT_NO_MEMORY;
-    }
-    card->fh_buffer.bufsize = UNIFI_FH_BUF_SIZE;
-    card->fh_buffer.ptr = card->fh_buffer.buf;
-    card->fh_buffer.count = 0;
-
-    card->th_buffer.buf = kmalloc(UNIFI_FH_BUF_SIZE, GFP_KERNEL);
-    if (card->th_buffer.buf == NULL)
-    {
-        unifi_error(card->ospriv, "Failed to allocate memory for T-H signals\n");
-        return CSR_WIFI_HIP_RESULT_NO_MEMORY;
-    }
-    card->th_buffer.bufsize = UNIFI_FH_BUF_SIZE;
-    card->th_buffer.ptr = card->th_buffer.buf;
-    card->th_buffer.count = 0;
-
-
-    /*
-     * Allocate memory for the from-host and to-host bulk data slots.
-     * This is done as separate kmallocs because lots of smaller
-     * allocations are more likely to succeed than one huge one.
-     */
-
-    /* Allocate memory for the array of pointers */
-    n = cfg_data->num_fromhost_data_slots;
-
-    unifi_trace(card->ospriv, UDBG3, "Alloc from-host resources, %d slots.\n", n);
-    card->from_host_data = kmalloc(n * sizeof(slot_desc_t), GFP_KERNEL);
-    if (card->from_host_data == NULL)
-    {
-        unifi_error(card->ospriv, "Failed to allocate memory for F-H bulk data array\n");
-        return CSR_WIFI_HIP_RESULT_NO_MEMORY;
-    }
-
-    /* Initialise from-host bulk data slots */
-    for (i = 0; i < n; i++)
-    {
-        UNIFI_INIT_BULK_DATA(&card->from_host_data[i].bd);
-    }
-
-    /* Allocate memory for the array used for slot host tag mapping */
-    card->fh_slot_host_tag_record = kmalloc(n * sizeof(u32), GFP_KERNEL);
-
-    if (card->fh_slot_host_tag_record == NULL)
-    {
-        unifi_error(card->ospriv, "Failed to allocate memory for F-H slot host tag mapping array\n");
-        return CSR_WIFI_HIP_RESULT_NO_MEMORY;
-    }
-
-    /* Initialise host tag entries for from-host bulk data slots */
-    for (i = 0; i < n; i++)
-    {
-        card->fh_slot_host_tag_record[i] = CSR_WIFI_HIP_RESERVED_HOST_TAG;
-    }
-
-
-    /* Allocate memory for the array of pointers */
-    n = cfg_data->num_tohost_data_slots;
-
-    unifi_trace(card->ospriv, UDBG3, "Alloc to-host resources, %d slots.\n", n);
-    card->to_host_data = kmalloc(n * sizeof(bulk_data_desc_t), GFP_KERNEL);
-    if (card->to_host_data == NULL)
-    {
-        unifi_error(card->ospriv, "Failed to allocate memory for T-H bulk data array\n");
-        return CSR_WIFI_HIP_RESULT_NO_MEMORY;
-    }
-
-    /* Initialise to-host bulk data slots */
-    for (i = 0; i < n; i++)
-    {
-        UNIFI_INIT_BULK_DATA(&card->to_host_data[i]);
-    }
-
-    /*
-     * Initialise buffers for soft Q
-     */
-    for (i = 0; i < UNIFI_SOFT_COMMAND_Q_LENGTH; i++)
-    {
-        for (r = 0; r < UNIFI_MAX_DATA_REFERENCES; r++)
-        {
-            UNIFI_INIT_BULK_DATA(&card->fh_command_q_body[i].bulkdata[r]);
-        }
-    }
-
-    for (k = 0; k < UNIFI_NO_OF_TX_QS; k++)
-    {
-        for (i = 0; i < UNIFI_SOFT_TRAFFIC_Q_LENGTH; i++)
-        {
-            for (r = 0; r < UNIFI_MAX_DATA_REFERENCES; r++)
-            {
-                UNIFI_INIT_BULK_DATA(&card->fh_traffic_q_body[k][i].bulkdata[r]);
-            }
-        }
-    }
-
-    card->memory_resources_allocated = 1;
-
-    return CSR_RESULT_SUCCESS;
-} /* card_allocate_memory_resources() */
-
-
-/*
- * ---------------------------------------------------------------------------
- *  unifi_free_bulk_data
- *
- *      Free the data associated to a bulk data structure.
- *
- *  Arguments:
- *      card            Pointer to card struct
- *      bulk_data_slot  Pointer to bulk data structure
- *
- *  Returns:
- *      None.
- *
- * ---------------------------------------------------------------------------
- */
-static void unifi_free_bulk_data(card_t *card, bulk_data_desc_t *bulk_data_slot)
-{
-    if (bulk_data_slot->data_length != 0)
-    {
-        unifi_net_data_free(card->ospriv, bulk_data_slot);
-    }
-} /* unifi_free_bulk_data() */
-
-
-/*
- * ---------------------------------------------------------------------------
- *  card_free_memory_resources
- *
- *      Frees memory allocated for the from-host, to-host bulk data slots,
- *      soft queue buffers and bulk data buffers.
- *
- *  Arguments:
- *      card            Pointer to card struct
- *
- *  Returns:
- *      None.
- * ---------------------------------------------------------------------------
- */
-static void card_free_memory_resources(card_t *card)
-{
-
-    unifi_trace(card->ospriv, UDBG1, "Freeing card memory resources.\n");
-
-    /* Clear our internal queues */
-    unifi_cancel_pending_signals(card);
-
-
-    kfree(card->to_host_data);
-    card->to_host_data = NULL;
-
-    kfree(card->from_host_data);
-    card->from_host_data = NULL;
-
-    /* free the memory for slot host tag mapping array */
-    kfree(card->fh_slot_host_tag_record);
-    card->fh_slot_host_tag_record = NULL;
-
-    kfree(card->fh_buffer.buf);
-    card->fh_buffer.ptr = card->fh_buffer.buf = NULL;
-    card->fh_buffer.bufsize = 0;
-    card->fh_buffer.count = 0;
-
-    kfree(card->th_buffer.buf);
-    card->th_buffer.ptr = card->th_buffer.buf = NULL;
-    card->th_buffer.bufsize = 0;
-    card->th_buffer.count = 0;
-
-
-    card->memory_resources_allocated = 0;
-
-} /* card_free_memory_resources() */
-
-
-static void card_init_soft_queues(card_t *card)
-{
-    s16 i;
-
-    unifi_trace(card->ospriv, UDBG1, "Initialising internal signal queues.\n");
-    /* Reset any state carried forward from a previous life */
-    card->fh_command_queue.q_rd_ptr = 0;
-    card->fh_command_queue.q_wr_ptr = 0;
-    (void)scnprintf(card->fh_command_queue.name, UNIFI_QUEUE_NAME_MAX_LENGTH,
-                      "fh_cmd_q");
-    for (i = 0; i < UNIFI_NO_OF_TX_QS; i++)
-    {
-        card->fh_traffic_queue[i].q_rd_ptr = 0;
-        card->fh_traffic_queue[i].q_wr_ptr = 0;
-        (void)scnprintf(card->fh_traffic_queue[i].name,
-                          UNIFI_QUEUE_NAME_MAX_LENGTH, "fh_data_q%d", i);
-    }
-#ifndef CSR_WIFI_HIP_TA_DISABLE
-    unifi_ta_sampling_init(card);
-#endif
-}
-
-
-/*
- * ---------------------------------------------------------------------------
- *  unifi_cancel_pending_signals
- *
- *      Free the signals and associated bulk data, pending in the core.
- *
- *  Arguments:
- *      card        Pointer to card struct
- *
- *  Returns:
- *      None.
- * ---------------------------------------------------------------------------
- */
-void unifi_cancel_pending_signals(card_t *card)
-{
-    s16 i, n, r;
-
-    unifi_trace(card->ospriv, UDBG1, "Canceling pending signals.\n");
-
-    if (card->to_host_data)
-    {
-        /*
-         * Free any bulk data buffers allocated for the t-h slots
-         * This will clear all buffers that did not make it to
-         * unifi_receive_event() before cancel was request.
-         */
-        n = card->config_data.num_tohost_data_slots;
-        unifi_trace(card->ospriv, UDBG3, "Freeing to-host resources, %d slots.\n", n);
-        for (i = 0; i < n; i++)
-        {
-            unifi_free_bulk_data(card, &card->to_host_data[i]);
-        }
-    }
-
-    /*
-     * If any of the from-host bulk data has reached the card->from_host_data
-     * but not UniFi, we need to free the buffers here.
-     */
-    if (card->from_host_data)
-    {
-        /* Free any bulk data buffers allocated for the f-h slots */
-        n = card->config_data.num_fromhost_data_slots;
-        unifi_trace(card->ospriv, UDBG3, "Freeing from-host resources, %d slots.\n", n);
-        for (i = 0; i < n; i++)
-        {
-            unifi_free_bulk_data(card, &card->from_host_data[i].bd);
-        }
-
-        for (i = 0; i < UNIFI_NO_OF_TX_QS; i++)
-        {
-            card->dynamic_slot_data.from_host_used_slots[i] = 0;
-            card->dynamic_slot_data.from_host_max_slots[i] = 0;
-            card->dynamic_slot_data.from_host_reserved_slots[i] = 0;
-        }
-    }
-
-    /*
-     * Free any bulk data buffers allocated in the soft queues.
-     * This covers the case where a bulk data pointer has reached the soft queue
-     * but not the card->from_host_data.
-     */
-    unifi_trace(card->ospriv, UDBG3, "Freeing cmd q resources.\n");
-    for (i = 0; i < UNIFI_SOFT_COMMAND_Q_LENGTH; i++)
-    {
-        for (r = 0; r < UNIFI_MAX_DATA_REFERENCES; r++)
-        {
-            unifi_free_bulk_data(card, &card->fh_command_q_body[i].bulkdata[r]);
-        }
-    }
-
-    unifi_trace(card->ospriv, UDBG3, "Freeing traffic q resources.\n");
-    for (n = 0; n < UNIFI_NO_OF_TX_QS; n++)
-    {
-        for (i = 0; i < UNIFI_SOFT_TRAFFIC_Q_LENGTH; i++)
-        {
-            for (r = 0; r < UNIFI_MAX_DATA_REFERENCES; r++)
-            {
-                unifi_free_bulk_data(card, &card->fh_traffic_q_body[n][i].bulkdata[r]);
-            }
-        }
-    }
-
-    card_init_soft_queues(card);
-
-} /* unifi_cancel_pending_signals() */
-
-
-/*
- * ---------------------------------------------------------------------------
- *  unifi_free_card
- *
- *      Free the memory allocated for the card structure and buffers.
- *
- *  Notes:
- *      The porting layer is responsible for freeing any mini-coredump buffers
- *      allocated when it called unifi_coredump_init(), by calling
- *      unifi_coredump_free() before calling this function.
- *
- *  Arguments:
- *      card        Pointer to card struct
- *
- *  Returns:
- *      None.
- * ---------------------------------------------------------------------------
- */
-void unifi_free_card(card_t *card)
-{
-#ifdef CSR_PRE_ALLOC_NET_DATA
-    prealloc_netdata_free(card);
-#endif
-    /* Free any memory allocated. */
-    card_free_memory_resources(card);
-
-    /* Warn if caller didn't free coredump buffers */
-    if (card->dump_buf)
-    {
-        unifi_error(card->ospriv, "Caller should call unifi_coredump_free()\n");
-        unifi_coredump_free(card); /* free anyway to prevent memory leak */
-    }
-
-    kfree(card);
-
-} /* unifi_free_card() */
-
-
-/*
- * ---------------------------------------------------------------------------
- *  card_init_slots
- *
- *      Allocate memory for host-side slot data and signal queues.
- *
- * Arguments:
- *      card            Pointer to card object
- *
- * Returns:
- *      CSR error code.
- * ---------------------------------------------------------------------------
- */
-static CsrResult card_init_slots(card_t *card)
-{
-    CsrResult r;
-    u8 i;
-
-    /* Allocate the buffers we need, only once. */
-    if (card->memory_resources_allocated == 1)
-    {
-        card_free_memory_resources(card);
-    }
-    else
-    {
-        /* Initialise our internal command and traffic queues */
-        card_init_soft_queues(card);
-    }
-
-    r = card_allocate_memory_resources(card);
-    if (r != CSR_RESULT_SUCCESS)
-    {
-        unifi_error(card->ospriv, "Failed to allocate card memory resources.\n");
-        card_free_memory_resources(card);
-        return r;
-    }
-
-    if (card->sdio_ctrl_addr == 0)
-    {
-        unifi_error(card->ospriv, "Failed to find config struct!\n");
-        return CSR_WIFI_HIP_RESULT_INVALID_VALUE;
-    }
-
-    /*
-     * Set initial counts.
-     */
-
-    card->from_host_data_head = 0;
-
-    /* Get initial signal counts from UniFi, in case it has not been reset. */
-    {
-        u16 s;
-
-        /* Get the from-host-signals-written count */
-        r = unifi_card_read16(card, card->sdio_ctrl_addr + 0, &s);
-        if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
-        {
-            return r;
-        }
-        if (r != CSR_RESULT_SUCCESS)
-        {
-            unifi_error(card->ospriv, "Failed to read from-host sig written count\n");
-            return r;
-        }
-        card->from_host_signals_w = (s16)s;
-
-        /* Get the to-host-signals-written count */
-        r = unifi_card_read16(card, card->sdio_ctrl_addr + 6, &s);
-        if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
-        {
-            return r;
-        }
-        if (r != CSR_RESULT_SUCCESS)
-        {
-            unifi_error(card->ospriv, "Failed to read to-host sig read count\n");
-            return r;
-        }
-        card->to_host_signals_r = (s16)s;
-    }
-
-    /* Set Initialised flag. */
-    r = unifi_card_write16(card, card->init_flag_addr, 0x0001);
-    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
-    {
-        return r;
-    }
-    if (r != CSR_RESULT_SUCCESS)
-    {
-        unifi_error(card->ospriv, "Failed to write initialised flag\n");
-        return r;
-    }
-
-    /* Dynamic queue reservation */
-    memset(&card->dynamic_slot_data, 0, sizeof(card_dynamic_slot_t));
-
-    for (i = 0; i < UNIFI_NO_OF_TX_QS; i++)
-    {
-        card->dynamic_slot_data.from_host_max_slots[i] = card->config_data.num_fromhost_data_slots -
-                                                         UNIFI_RESERVED_COMMAND_SLOTS;
-        card->dynamic_slot_data.queue_stable[i] = FALSE;
-    }
-
-    card->dynamic_slot_data.packets_interval = UNIFI_PACKETS_INTERVAL;
-
-    return CSR_RESULT_SUCCESS;
-} /* card_init_slots() */
-
-
-/*
- * ---------------------------------------------------------------------------
- *  unifi_set_udi_hook
- *
- *      Registers the udi hook that reports the sent signals to the core.
- *
- *  Arguments:
- *      card            Pointer to the card context struct
- *      udi_fn          Pointer to the callback function.
- *
- *  Returns:
- *      CSR_WIFI_HIP_RESULT_INVALID_VALUE if the card pointer is invalid,
- *      CSR_RESULT_SUCCESS on success.
- * ---------------------------------------------------------------------------
- */
-CsrResult unifi_set_udi_hook(card_t *card, udi_func_t udi_fn)
-{
-    if (card == NULL)
-    {
-        return CSR_WIFI_HIP_RESULT_INVALID_VALUE;
-    }
-
-    if (card->udi_hook == NULL)
-    {
-        card->udi_hook = udi_fn;
-    }
-
-    return CSR_RESULT_SUCCESS;
-} /* unifi_set_udi_hook() */
-
-
-/*
- * ---------------------------------------------------------------------------
- *  unifi_remove_udi_hook
- *
- *      Removes the udi hook that reports the sent signals from the core.
- *
- *  Arguments:
- *      card            Pointer to the card context struct
- *      udi_fn          Pointer to the callback function.
- *
- *  Returns:
- *      CSR_WIFI_HIP_RESULT_INVALID_VALUE if the card pointer is invalid,
- *      CSR_RESULT_SUCCESS on success.
- * ---------------------------------------------------------------------------
- */
-CsrResult unifi_remove_udi_hook(card_t *card, udi_func_t udi_fn)
-{
-    if (card == NULL)
-    {
-        return CSR_WIFI_HIP_RESULT_INVALID_VALUE;
-    }
-
-    if (card->udi_hook == udi_fn)
-    {
-        card->udi_hook = NULL;
-    }
-
-    return CSR_RESULT_SUCCESS;
-} /* unifi_remove_udi_hook() */
-
-
-static void CardReassignDynamicReservation(card_t *card)
-{
-    u8 i;
-
-    unifi_trace(card->ospriv, UDBG5, "Packets Txed %d %d %d %d\n",
-                card->dynamic_slot_data.packets_txed[0],
-                card->dynamic_slot_data.packets_txed[1],
-                card->dynamic_slot_data.packets_txed[2],
-                card->dynamic_slot_data.packets_txed[3]);
-
-    /* Clear reservation and recalculate max slots */
-    for (i = 0; i < UNIFI_NO_OF_TX_QS; i++)
-    {
-        card->dynamic_slot_data.queue_stable[i] = FALSE;
-        card->dynamic_slot_data.from_host_reserved_slots[i] = 0;
-        card->dynamic_slot_data.from_host_max_slots[i] = card->config_data.num_fromhost_data_slots -
-                                                         UNIFI_RESERVED_COMMAND_SLOTS;
-        card->dynamic_slot_data.packets_txed[i] = 0;
-
-        unifi_trace(card->ospriv, UDBG5, "CardReassignDynamicReservation: queue %d reserved %d Max %d\n", i,
-                    card->dynamic_slot_data.from_host_reserved_slots[i],
-                    card->dynamic_slot_data.from_host_max_slots[i]);
-    }
-
-    card->dynamic_slot_data.total_packets_txed = 0;
-}
-
-
-/* Algorithm to dynamically reserve slots. The logic is based mainly on the outstanding queue
- * length. Slots are reserved for particular queues during an interval and cleared after the interval.
- * Each queue has three associated variables.. a) used slots - the number of slots currently occupied
- * by the queue b) reserved slots - number of slots reserved specifically for the queue c) max slots - total
- * slots that this queue can actually use (may be higher than reserved slots and is dependent on reserved slots
- * for other queues).
- * This function is called when there are no slots available for a queue. It checks to see if there are enough
- * unreserved slots sufficient for this request. If available these slots are reserved for the queue.
- * If there are not enough unreserved slots, a fair share for each queue is calculated based on the total slots
- * and the number of active queues (any queue with existing reservation is considered active). Queues needing
- * less than their fair share are allowed to have the previously reserved slots. The remaining slots are
- * distributed evenly among queues that need more than the fair share
- *
- * A better scheme would take current bandwidth per AC into consideration when reserving slots. An
- * implementation scheme could consider the relative time/service period for slots in an AC. If the firmware
- * services other ACs faster than a particular AC (packets wait in the slots longer) then it is fair to reserve
- * less slots for the AC
- */
-static void CardCheckDynamicReservation(card_t *card, unifi_TrafficQueue queue)
-{
-    u16 q_len, active_queues = 0, excess_queue_slots, div_extra_slots,
-              queue_fair_share, reserved_slots = 0, q, excess_need_queues = 0, unmovable_slots = 0;
-    s32 i;
-    q_t *sigq;
-    u16 num_data_slots = card->config_data.num_fromhost_data_slots - UNIFI_RESERVED_COMMAND_SLOTS;
-
-    /* Calculate the pending queue length */
-    sigq = &card->fh_traffic_queue[queue];
-    q_len = CSR_WIFI_HIP_Q_SLOTS_USED(sigq);
-
-    if (q_len <= card->dynamic_slot_data.from_host_reserved_slots[queue])
-    {
-        unifi_trace(card->ospriv, UDBG5, "queue %d q_len %d already has that many reserved slots, exiting\n", queue, q_len);
-        return;
-    }
-
-    /* Upper limit */
-    if (q_len > num_data_slots)
-    {
-        q_len = num_data_slots;
-    }
-
-    for (i = 0; i < UNIFI_NO_OF_TX_QS; i++)
-    {
-        if (i != (s32)queue)
-        {
-            reserved_slots += card->dynamic_slot_data.from_host_reserved_slots[i];
-        }
-        if ((i == (s32)queue) || (card->dynamic_slot_data.from_host_reserved_slots[i] > 0))
-        {
-            active_queues++;
-        }
-    }
-
-    unifi_trace(card->ospriv, UDBG5, "CardCheckDynamicReservation: queue %d q_len %d\n", queue, q_len);
-    unifi_trace(card->ospriv, UDBG5, "Active queues %d reserved slots on other queues %d\n",
-                active_queues, reserved_slots);
-
-    if (reserved_slots + q_len <= num_data_slots)
-    {
-        card->dynamic_slot_data.from_host_reserved_slots[queue] = q_len;
-        if (q_len == num_data_slots)
-        {
-            /* This is the common case when just 1 stream is going */
-            card->dynamic_slot_data.queue_stable[queue] = TRUE;
-        }
-    }
-    else
-    {
-        queue_fair_share = num_data_slots / active_queues;
-        unifi_trace(card->ospriv, UDBG5, "queue fair share %d\n", queue_fair_share);
-
-        /* Evenly distribute slots among active queues */
-        /* Find out the queues that need excess of fair share. Also find slots allocated
-         * to queues less than their fair share, these slots cannot be reallocated (unmovable slots) */
-
-        card->dynamic_slot_data.from_host_reserved_slots[queue] = q_len;
-
-        for (i = 0; i < UNIFI_NO_OF_TX_QS; i++)
-        {
-            if (card->dynamic_slot_data.from_host_reserved_slots[i] > queue_fair_share)
-            {
-                excess_need_queues++;
-            }
-            else
-            {
-                unmovable_slots += card->dynamic_slot_data.from_host_reserved_slots[i];
-            }
-        }
-
-        unifi_trace(card->ospriv, UDBG5, "Excess need queues %d\n", excess_need_queues);
-
-        /* Now find the slots per excess demand queue */
-        excess_queue_slots = (num_data_slots - unmovable_slots) / excess_need_queues;
-        div_extra_slots = (num_data_slots - unmovable_slots) - excess_queue_slots * excess_need_queues;
-        for (i = UNIFI_NO_OF_TX_QS - 1; i >= 0; i--)
-        {
-            if (card->dynamic_slot_data.from_host_reserved_slots[i] > excess_queue_slots)
-            {
-                card->dynamic_slot_data.from_host_reserved_slots[i] = excess_queue_slots;
-                if (div_extra_slots > 0)
-                {
-                    card->dynamic_slot_data.from_host_reserved_slots[i]++;
-                    div_extra_slots--;
-                }
-                /* No more slots will be allocated to this queue during the current interval */
-                card->dynamic_slot_data.queue_stable[i] = TRUE;
-                unifi_trace(card->ospriv, UDBG5, "queue stable %d\n", i);
-            }
-        }
-    }
-
-    /* Redistribute max slots */
-    for (i = 0; i < UNIFI_NO_OF_TX_QS; i++)
-    {
-        reserved_slots = 0;
-        for (q = 0; q < UNIFI_NO_OF_TX_QS; q++)
-        {
-            if (i != q)
-            {
-                reserved_slots += card->dynamic_slot_data.from_host_reserved_slots[q];
-            }
-        }
-
-        card->dynamic_slot_data.from_host_max_slots[i] = num_data_slots - reserved_slots;
-        unifi_trace(card->ospriv, UDBG5, "queue %d reserved %d Max %d\n", i,
-                    card->dynamic_slot_data.from_host_reserved_slots[i],
-                    card->dynamic_slot_data.from_host_max_slots[i]);
-    }
-
-}
-
-
-/*
- * ---------------------------------------------------------------------------
- *  CardClearFromHostDataSlot
- *
- *      Clear a the given data slot, making it available again.
- *
- *  Arguments:
- *      card            Pointer to Card object
- *      slot            Index of the signal slot to clear.
- *
- *  Returns:
- *      None.
- * ---------------------------------------------------------------------------
- */
-void CardClearFromHostDataSlot(card_t *card, const s16 slot)
-{
-    u8 queue = card->from_host_data[slot].queue;
-    const void *os_data_ptr = card->from_host_data[slot].bd.os_data_ptr;
-
-    if (card->from_host_data[slot].bd.data_length == 0)
-    {
-        unifi_warning(card->ospriv,
-                      "Surprise: request to clear an already free FH data slot: %d\n",
-                      slot);
-        return;
-    }
-
-    if (os_data_ptr == NULL)
-    {
-        unifi_warning(card->ospriv,
-                      "Clearing FH data slot %d: has null payload, len=%d\n",
-                      slot, card->from_host_data[slot].bd.data_length);
-    }
-
-    /* Free card->from_host_data[slot].bd.os_net_ptr here. */
-    /* Mark slot as free by setting length to 0. */
-    unifi_free_bulk_data(card, &card->from_host_data[slot].bd);
-    if (queue < UNIFI_NO_OF_TX_QS)
-    {
-        if (card->dynamic_slot_data.from_host_used_slots[queue] == 0)
-        {
-            unifi_error(card->ospriv, "Goofed up used slots q = %d used slots = %d\n",
-                        queue,
-                        card->dynamic_slot_data.from_host_used_slots[queue]);
-        }
-        else
-        {
-            card->dynamic_slot_data.from_host_used_slots[queue]--;
-        }
-        card->dynamic_slot_data.packets_txed[queue]++;
-        card->dynamic_slot_data.total_packets_txed++;
-        if (card->dynamic_slot_data.total_packets_txed >= card->dynamic_slot_data.packets_interval)
-        {
-            CardReassignDynamicReservation(card);
-        }
-    }
-
-    unifi_trace(card->ospriv, UDBG4, "CardClearFromHostDataSlot: slot %d recycled %p\n", slot, os_data_ptr);
-
-} /* CardClearFromHostDataSlot() */
-
-
-#ifdef CSR_WIFI_REQUEUE_PACKET_TO_HAL
-/*
- * ---------------------------------------------------------------------------
- *  CardClearFromHostDataSlotWithoutFreeingBulkData
- *
- *      Clear the given data slot with out freeing the bulk data.
- *
- *  Arguments:
- *      card            Pointer to Card object
- *      slot            Index of the signal slot to clear.
- *
- *  Returns:
- *      None.
- * ---------------------------------------------------------------------------
- */
-void CardClearFromHostDataSlotWithoutFreeingBulkData(card_t *card, const s16 slot)
-{
-    u8 queue = card->from_host_data[slot].queue;
-
-    /* Initialise the from_host data slot so it can be re-used,
-     * Set length field in from_host_data array to 0.
-     */
-    UNIFI_INIT_BULK_DATA(&card->from_host_data[slot].bd);
-
-    queue = card->from_host_data[slot].queue;
-
-    if (queue < UNIFI_NO_OF_TX_QS)
-    {
-        if (card->dynamic_slot_data.from_host_used_slots[queue] == 0)
-        {
-            unifi_error(card->ospriv, "Goofed up used slots q = %d used slots = %d\n",
-                        queue,
-                        card->dynamic_slot_data.from_host_used_slots[queue]);
-        }
-        else
-        {
-            card->dynamic_slot_data.from_host_used_slots[queue]--;
-        }
-        card->dynamic_slot_data.packets_txed[queue]++;
-        card->dynamic_slot_data.total_packets_txed++;
-        if (card->dynamic_slot_data.total_packets_txed >=
-            card->dynamic_slot_data.packets_interval)
-        {
-            CardReassignDynamicReservation(card);
-        }
-    }
-} /* CardClearFromHostDataSlotWithoutFreeingBulkData() */
-
-
-#endif
-
-u16 CardGetDataSlotSize(card_t *card)
-{
-    return card->config_data.data_slot_size;
-} /* CardGetDataSlotSize() */
-
-
-/*
- * ---------------------------------------------------------------------------
- *  CardGetFreeFromHostDataSlots
- *
- *      Retrieve the number of from-host bulk data slots available.
- *
- *  Arguments:
- *      card            Pointer to the card context struct
- *
- *  Returns:
- *      Number of free from-host bulk data slots.
- * ---------------------------------------------------------------------------
- */
-u16 CardGetFreeFromHostDataSlots(card_t *card)
-{
-    u16 i, n = 0;
-
-    /* First two slots reserved for MLME */
-    for (i = 0; i < card->config_data.num_fromhost_data_slots; i++)
-    {
-        if (card->from_host_data[i].bd.data_length == 0)
-        {
-            /* Free slot */
-            n++;
-        }
-    }
-
-    return n;
-} /* CardGetFreeFromHostDataSlots() */
-
-
-/*
- * ---------------------------------------------------------------------------
- *  CardAreAllFromHostDataSlotsEmpty
- *
- *      Returns the state of from-host bulk data slots.
- *
- *  Arguments:
- *      card            Pointer to the card context struct
- *
- *  Returns:
- *      1       The from-host bulk data slots are all empty (available).
- *      0       Some or all the from-host bulk data slots are in use.
- * ---------------------------------------------------------------------------
- */
-u16 CardAreAllFromHostDataSlotsEmpty(card_t *card)
-{
-    u16 i;
-
-    for (i = 0; i < card->config_data.num_fromhost_data_slots; i++)
-    {
-        if (card->from_host_data[i].bd.data_length != 0)
-        {
-            return 0;
-        }
-    }
-
-    return 1;
-} /* CardGetFreeFromHostDataSlots() */
-
-
-static CsrResult unifi_identify_hw(card_t *card)
-{
-
-    card->chip_id = card->sdio_if->sdioId.cardId;
-    card->function = card->sdio_if->sdioId.sdioFunction;
-    card->sdio_io_block_size = card->sdio_if->blockSize;
-
-    /* If SDIO controller doesn't support byte mode CMD53, pad transfers to block sizes */
-    card->sdio_io_block_pad = (card->sdio_if->features & CSR_SDIO_FEATURE_BYTE_MODE)?FALSE : TRUE;
-
-    /*
-     * Setup the chip helper so that we can access the registers (and
-     * also tell what sub-type of HIP we should use).
-     */
-    card->helper = ChipHelper_GetVersionSdio((u8)card->chip_id);
-    if (!card->helper)
-    {
-        unifi_error(card->ospriv, "Null ChipHelper\n");
-    }
-
-    unifi_info(card->ospriv, "Chip ID 0x%02X  Function %u  Block Size %u  Name %s(%s)\n",
-               card->chip_id, card->function, card->sdio_io_block_size,
-               ChipHelper_MarketingName(card->helper),
-               ChipHelper_FriendlyName(card->helper));
-
-    return CSR_RESULT_SUCCESS;
-} /* unifi_identify_hw() */
-
-
-static CsrResult unifi_prepare_hw(card_t *card)
-{
-    CsrResult r;
-    CsrResult csrResult;
-    enum unifi_host_state old_state = card->host_state;
-
-    r = unifi_identify_hw(card);
-    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
-    {
-        return r;
-    }
-    if (r != CSR_RESULT_SUCCESS)
-    {
-        unifi_error(card->ospriv, "Failed to identify hw\n");
-        return r;
-    }
-
-    unifi_trace(card->ospriv, UDBG1,
-                "%s mode SDIO\n", card->sdio_io_block_pad?"Block" : "Byte");
-    /*
-     * Chip must be a awake or blocks that are asleep may not get
-     * reset.  We can only do this after we have read the chip_id.
-     */
-    r = unifi_set_host_state(card, UNIFI_HOST_STATE_AWAKE);
-    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
-    {
-        return r;
-    }
-
-    if (old_state == UNIFI_HOST_STATE_TORPID)
-    {
-        /* Ensure the initial clock rate is set; if a reset occurred when the chip was
-         * TORPID, unifi_set_host_state() may have raised it to MAX.
-         */
-        csrResult = CsrSdioMaxBusClockFrequencySet(card->sdio_if, UNIFI_SDIO_CLOCK_INIT_HZ);
-        if (csrResult != CSR_RESULT_SUCCESS)
-        {
-            r = ConvertCsrSdioToCsrHipResult(card, csrResult);
-            return r;
-        }
-        card->sdio_clock_speed = UNIFI_SDIO_CLOCK_INIT_HZ;
-    }
-
-    /*
-     * The WLAN function must be enabled to access MAILBOX2 and DEBUG_RST
-     * registers.
-     */
-    csrResult = CsrSdioFunctionEnable(card->sdio_if);
-    if (csrResult == CSR_SDIO_RESULT_NO_DEVICE)
-    {
-        return CSR_WIFI_HIP_RESULT_NO_DEVICE;
-    }
-    if (csrResult != CSR_RESULT_SUCCESS)
-    {
-        r = ConvertCsrSdioToCsrHipResult(card, csrResult);
-        /* Can't enable WLAN function. Try resetting the SDIO block. */
-        unifi_error(card->ospriv, "Failed to re-enable function %d.\n", card->function);
-        return r;
-    }
-
-    /*
-     * Poke some registers to make sure the PLL has started,
-     * otherwise memory accesses are likely to fail.
-     */
-    bootstrap_chip_hw(card);
-
-    /* Try to read the chip version from register. */
-    r = unifi_read_chip_version(card);
-    if (r != CSR_RESULT_SUCCESS)
-    {
-        return r;
-    }
-
-    return CSR_RESULT_SUCCESS;
-} /* unifi_prepare_hw() */
-
-
-static CsrResult unifi_read_chip_version(card_t *card)
-{
-    u32 gbl_chip_version;
-    CsrResult r;
-    u16 ver;
-
-    gbl_chip_version = ChipHelper_GBL_CHIP_VERSION(card->helper);
-
-    /* Try to read the chip version from register. */
-    if (gbl_chip_version != 0)
-    {
-        r = unifi_read_direct16(card, gbl_chip_version * 2, &ver);
-        if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
-        {
-            return r;
-        }
-        if (r != CSR_RESULT_SUCCESS)
-        {
-            unifi_error(card->ospriv, "Failed to read GBL_CHIP_VERSION\n");
-            return r;
-        }
-        card->chip_version = ver;
-    }
-    else
-    {
-        unifi_info(card->ospriv, "Unknown Chip ID, cannot locate GBL_CHIP_VERSION\n");
-        r = CSR_RESULT_FAILURE;
-    }
-
-    unifi_info(card->ospriv, "Chip Version 0x%04X\n", card->chip_version);
-
-    return r;
-} /* unifi_read_chip_version() */
-
-
-/*
- * ---------------------------------------------------------------------------
- *  unifi_reset_hardware
- *
- *      Execute the UniFi reset sequence.
- *
- *      Note: This may fail if the chip is going TORPID so retry at
- *      least once.
- *
- *  Arguments:
- *      card - pointer to card context structure
- *
- *  Returns:
- *      CSR_RESULT_SUCCESS on success, CSR error otherwise.
- *
- *  Notes:
- *      Some platforms (e.g. Windows Vista) do not allow access to registers
- *      that are necessary for a software soft reset.
- * ---------------------------------------------------------------------------
- */
-static CsrResult unifi_reset_hardware(card_t *card)
-{
-    CsrResult r;
-    u16 new_block_size = UNIFI_IO_BLOCK_SIZE;
-    CsrResult csrResult;
-
-    /* Errors returned by unifi_prepare_hw() are not critical at this point */
-    r = unifi_prepare_hw(card);
-    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
-    {
-        return r;
-    }
-
-    /* First try SDIO controller reset, which may power cycle the UniFi, assert
-     * its reset line, or not be implemented depending on the platform.
-     */
-    unifi_info(card->ospriv, "Calling CsrSdioHardReset\n");
-    csrResult = CsrSdioHardReset(card->sdio_if);
-    if (csrResult == CSR_RESULT_SUCCESS)
-    {
-        unifi_info(card->ospriv, "CsrSdioHardReset succeeded on resetting UniFi\n");
-        r = unifi_prepare_hw(card);
-        if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
-        {
-            return r;
-        }
-        if (r != CSR_RESULT_SUCCESS)
-        {
-            unifi_error(card->ospriv, "unifi_prepare_hw failed after hard reset\n");
-            return r;
-        }
-    }
-    else if (csrResult == CSR_SDIO_RESULT_NO_DEVICE)
-    {
-        return CSR_WIFI_HIP_RESULT_NO_DEVICE;
-    }
-    else
-    {
-        /* Falling back to software hard reset methods */
-        unifi_info(card->ospriv, "Falling back to software hard reset\n");
-        r = unifi_card_hard_reset(card);
-        if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
-        {
-            return r;
-        }
-        if (r != CSR_RESULT_SUCCESS)
-        {
-            unifi_error(card->ospriv, "software hard reset failed\n");
-            return r;
-        }
-
-        /* If we fell back to unifi_card_hard_reset() methods, chip version may
-         * not have been read. (Note in the unlikely event that it is zero,
-         * it will be harmlessly read again)
-         */
-        if (card->chip_version == 0)
-        {
-            r = unifi_read_chip_version(card);
-            if (r != CSR_RESULT_SUCCESS)
-            {
-                return r;
-            }
-        }
-    }
-
-#ifdef CSR_WIFI_HIP_SDIO_BLOCK_SIZE
-    new_block_size = CSR_WIFI_HIP_SDIO_BLOCK_SIZE;
-#endif
-
-    /* After hard reset, we need to restore the SDIO block size */
-    csrResult = CsrSdioBlockSizeSet(card->sdio_if, new_block_size);
-    r = ConvertCsrSdioToCsrHipResult(card, csrResult);
-
-    /* Warn if a different block size was achieved by the transport */
-    if (card->sdio_if->blockSize != new_block_size)
-    {
-        unifi_info(card->ospriv,
-                   "Actually got block size %d\n", card->sdio_if->blockSize);
-    }
-
-    /* sdio_io_block_size always needs be updated from the achieved block size,
-     * as it is used by the OS layer to allocate memory in unifi_net_malloc().
-     * Controllers which don't support block mode (e.g. CSPI) will report a
-     * block size of zero.
-     */
-    if (card->sdio_if->blockSize == 0)
-    {
-        unifi_info(card->ospriv, "Block size 0, block mode not available\n");
-
-        /* Set sdio_io_block_size to 1 so that unifi_net_data_malloc() has a
-         * sensible rounding value. Elsewhere padding will already be
-         * disabled because the controller supports byte mode.
-         */
-        card->sdio_io_block_size = 1;
-
-        /* Controller features must declare support for byte mode */
-        if (!(card->sdio_if->features & CSR_SDIO_FEATURE_BYTE_MODE))
-        {
-            unifi_error(card->ospriv, "Requires byte mode\n");
-            r = CSR_WIFI_HIP_RESULT_INVALID_VALUE;
-        }
-    }
-    else
-    {
-        /* Padding will be enabled if CSR_SDIO_FEATURE_BYTE_MODE isn't set */
-        card->sdio_io_block_size = card->sdio_if->blockSize;
-    }
-
-
-    return r;
-} /* unifi_reset_hardware() */
-
-
-/*
- * ---------------------------------------------------------------------------
- *  card_reset_method_io_enable
- *
- *      Issue a hard reset to the hw writing the IO_ENABLE.
- *
- *  Arguments:
- *      card            Pointer to Card object
- *
- *  Returns:
- *      0 on success,
- *      CSR_WIFI_HIP_RESULT_NO_DEVICE   if the card was ejected
- *      CSR_RESULT_FAILURE         if an SDIO error occurred or if a response
- *                                 was not seen in the expected time
- * ---------------------------------------------------------------------------
- */
-static CsrResult card_reset_method_io_enable(card_t *card)
-{
-    CsrResult r;
-    CsrResult csrResult;
-
-    /*
-     * This resets only function 1, so should be used in
-     * preference to the method below (CSR_FUNC_EN)
-     */
-    unifi_trace(card->ospriv, UDBG1, "Hard reset (IO_ENABLE)\n");
-
-    csrResult = CsrSdioFunctionDisable(card->sdio_if);
-    if (csrResult == CSR_SDIO_RESULT_NO_DEVICE)
-    {
-        return CSR_WIFI_HIP_RESULT_NO_DEVICE;
-    }
-    if (csrResult != CSR_RESULT_SUCCESS)
-    {
-        r = ConvertCsrSdioToCsrHipResult(card, csrResult);
-        unifi_warning(card->ospriv, "SDIO error writing IO_ENABLE: %d\n", r);
-    }
-    else
-    {
-        /* Delay here to let the reset take affect. */
-        CsrThreadSleep(RESET_SETTLE_DELAY);
-
-        r = card_wait_for_unifi_to_disable(card);
-        if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
-        {
-            return r;
-        }
-
-        if (r == CSR_RESULT_SUCCESS)
-        {
-            r = card_wait_for_unifi_to_reset(card);
-            if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
-            {
-                return r;
-            }
-        }
-    }
-
-    if (r != CSR_RESULT_SUCCESS)
-    {
-        unifi_trace(card->ospriv, UDBG1, "Hard reset (CSR_FUNC_EN)\n");
-
-        r = sdio_write_f0(card, SDIO_CSR_FUNC_EN, 0);
-        if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
-        {
-            return r;
-        }
-        if (r != CSR_RESULT_SUCCESS)
-        {
-            unifi_warning(card->ospriv, "SDIO error writing SDIO_CSR_FUNC_EN: %d\n", r);
-            return r;
-        }
-        else
-        {
-            /* Delay here to let the reset take affect. */
-            CsrThreadSleep(RESET_SETTLE_DELAY);
-
-            r = card_wait_for_unifi_to_reset(card);
-            if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
-            {
-                return r;
-            }
-        }
-    }
-
-    if (r != CSR_RESULT_SUCCESS)
-    {
-        unifi_warning(card->ospriv, "card_reset_method_io_enable failed to reset UniFi\n");
-    }
-
-    return r;
-} /* card_reset_method_io_enable() */
-
-
-/*
- * ---------------------------------------------------------------------------
- *  card_reset_method_dbg_reset
- *
- *      Issue a hard reset to the hw writing the DBG_RESET.
- *
- *  Arguments:
- *      card            Pointer to Card object
- *
- *  Returns:
- *      CSR_RESULT_SUCCESS         on success,
- *      CSR_WIFI_HIP_RESULT_NO_DEVICE   if the card was ejected
- *      CSR_RESULT_FAILURE         if an SDIO error occurred or if a response
- *                                 was not seen in the expected time
- * ---------------------------------------------------------------------------
- */
-static CsrResult card_reset_method_dbg_reset(card_t *card)
-{
-    CsrResult r;
-
-    /*
-     * Prepare UniFi for h/w reset
-     */
-    if (card->host_state == UNIFI_HOST_STATE_TORPID)
-    {
-        r = unifi_set_host_state(card, UNIFI_HOST_STATE_DROWSY);
-        if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
-        {
-            return r;
-        }
-        if (r != CSR_RESULT_SUCCESS)
-        {
-            unifi_error(card->ospriv, "Failed to set UNIFI_HOST_STATE_DROWSY\n");
-            return r;
-        }
-        CsrThreadSleep(5);
-    }
-
-    r = unifi_card_stop_processor(card, UNIFI_PROC_BOTH);
-    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
-    {
-        return r;
-    }
-    if (r != CSR_RESULT_SUCCESS)
-    {
-        unifi_error(card->ospriv, "Can't stop processors\n");
-        return r;
-    }
-
-    unifi_trace(card->ospriv, UDBG1, "Hard reset (DBG_RESET)\n");
-
-    /*
-     * This register write may fail. The debug reset resets
-     * parts of the Function 0 sections of the chip, and
-     * therefore the response cannot be sent back to the host.
-     */
-    r = unifi_write_direct_8_or_16(card, ChipHelper_DBG_RESET(card->helper) * 2, 1);
-    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
-    {
-        return r;
-    }
-    if (r != CSR_RESULT_SUCCESS)
-    {
-        unifi_warning(card->ospriv, "SDIO error writing DBG_RESET: %d\n", r);
-        return r;
-    }
-
-    /* Delay here to let the reset take affect. */
-    CsrThreadSleep(RESET_SETTLE_DELAY);
-
-    r = card_wait_for_unifi_to_reset(card);
-    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
-    {
-        return r;
-    }
-    if (r != CSR_RESULT_SUCCESS)
-    {
-        unifi_warning(card->ospriv, "card_reset_method_dbg_reset failed to reset UniFi\n");
-    }
-
-    return r;
-} /* card_reset_method_dbg_reset() */
-
-
-/*
- * ---------------------------------------------------------------------------
- *  unifi_card_hard_reset
- *
- *      Issue reset to hardware, by writing to registers on the card.
- *      Power to the card is preserved.
- *
- *  Arguments:
- *      card            Pointer to Card object
- *
- *  Returns:
- *      CSR_RESULT_SUCCESS         on success,
- *      CSR_WIFI_HIP_RESULT_NO_DEVICE   if the card was ejected
- *      CSR_RESULT_FAILURE         if an SDIO error occurred or if a response
- *                                 was not seen in the expected time
- * ---------------------------------------------------------------------------
- */
-CsrResult unifi_card_hard_reset(card_t *card)
-{
-    CsrResult r;
-    const struct chip_helper_reset_values *init_data;
-    u32 chunks;
-
-    /* Clear cache of page registers */
-    card->proc_select = (u32)(-1);
-    card->dmem_page = (u32)(-1);
-    card->pmem_page = (u32)(-1);
-
-    /*
-     * We need to have a valid card->helper before we use software hard reset.
-     * If unifi_identify_hw() fails to get the card ID, it probably means
-     * that there is no way to talk to the h/w.
-     */
-    r = unifi_identify_hw(card);
-    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
-    {
-        return r;
-    }
-    if (r != CSR_RESULT_SUCCESS)
-    {
-        unifi_error(card->ospriv, "unifi_card_hard_reset failed to identify h/w\n");
-        return r;
-    }
-
-    /* Search for some reset code. */
-    chunks = ChipHelper_HostResetSequence(card->helper, &init_data);
-    if (chunks != 0)
-    {
-        unifi_error(card->ospriv,
-                    "Hard reset (Code download) is unsupported\n");
-
-        return CSR_RESULT_FAILURE;
-    }
-
-    if (card->chip_id > SDIO_CARD_ID_UNIFI_2)
-    {
-        /* The HIP spec considers this a bus-specific reset.
-         * This resets only function 1, so should be used in
-         * preference to the method below (CSR_FUNC_EN)
-         * If this method fails, it means that the f/w is probably
-         * not running. In this case, try the DBG_RESET method.
-         */
-        r = card_reset_method_io_enable(card);
-        if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
-        {
-            return r;
-        }
-        if (r == CSR_RESULT_SUCCESS)
-        {
-            return r;
-        }
-    }
-
-    /* Software hard reset */
-    r = card_reset_method_dbg_reset(card);
-
-    return r;
-} /* unifi_card_hard_reset() */
-
-
-/*
- * ---------------------------------------------------------------------------
- *
- *  CardGenInt
- *
- *      Prod the card.
- *      This function causes an internal interrupt to be raised in the
- *      UniFi chip. It is used to signal the firmware that some action has
- *      been completed.
- *      The UniFi Host Interface asks that the value used increments for
- *      debugging purposes.
- *
- *  Arguments:
- *      card            Pointer to Card object
- *
- *  Returns:
- *      CSR_RESULT_SUCCESS         on success,
- *      CSR_WIFI_HIP_RESULT_NO_DEVICE   if the card was ejected
- *      CSR_RESULT_FAILURE         if an SDIO error occurred or if a response
- *                                 was not seen in the expected time
- * ---------------------------------------------------------------------------
- */
-CsrResult CardGenInt(card_t *card)
-{
-    CsrResult r;
-
-    if (card->chip_id > SDIO_CARD_ID_UNIFI_2)
-    {
-        r = sdio_write_f0(card, SDIO_CSR_FROM_HOST_SCRATCH0,
-                          (u8)card->unifi_interrupt_seq);
-    }
-    else
-    {
-        r = unifi_write_direct_8_or_16(card,
-                                       ChipHelper_SHARED_IO_INTERRUPT(card->helper) * 2,
-                                       (u8)card->unifi_interrupt_seq);
-    }
-    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
-    {
-        return r;
-    }
-    if (r != CSR_RESULT_SUCCESS)
-    {
-        unifi_error(card->ospriv, "SDIO error writing UNIFI_SHARED_IO_INTERRUPT: %d\n", r);
-        return r;
-    }
-
-    card->unifi_interrupt_seq++;
-
-    return CSR_RESULT_SUCCESS;
-} /* CardGenInt() */
-
-
-/*
- * ---------------------------------------------------------------------------
- *  CardEnableInt
- *
- *      Enable the outgoing SDIO interrupt from UniFi to the host.
- *
- *  Arguments:
- *      card            Pointer to Card object
- *
- *  Returns:
- *      CSR_RESULT_SUCCESS            on success,
- *      CSR_WIFI_HIP_RESULT_NO_DEVICE      if the card was ejected
- *      CSR_RESULT_FAILURE            if an SDIO error occurred,
- * ---------------------------------------------------------------------------
- */
-CsrResult CardEnableInt(card_t *card)
-{
-    CsrResult r;
-    u8 int_enable;
-
-    r = sdio_read_f0(card, SDIO_INT_ENABLE, &int_enable);
-    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
-    {
-        return r;
-    }
-    if (r != CSR_RESULT_SUCCESS)
-    {
-        unifi_error(card->ospriv, "SDIO error reading SDIO_INT_ENABLE\n");
-        return r;
-    }
-
-    int_enable |= (1 << card->function) | UNIFI_SD_INT_ENABLE_IENM;
-
-    r = sdio_write_f0(card, SDIO_INT_ENABLE, int_enable);
-    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
-    {
-        return r;
-    }
-    if (r != CSR_RESULT_SUCCESS)
-    {
-        unifi_error(card->ospriv, "SDIO error writing SDIO_INT_ENABLE\n");
-        return r;
-    }
-
-    return CSR_RESULT_SUCCESS;
-} /* CardEnableInt() */
-
-
-/*
- * ---------------------------------------------------------------------------
- *  CardDisableInt
- *
- *      Disable the outgoing SDIO interrupt from UniFi to the host.
- *
- *  Arguments:
- *      card            Pointer to Card object
- *
- *  Returns:
- *      CSR_RESULT_SUCCESS            on success,
- *      CSR_WIFI_HIP_RESULT_NO_DEVICE      if the card was ejected
- *      CSR_RESULT_FAILURE            if an SDIO error occurred,
- * ---------------------------------------------------------------------------
- */
-CsrResult CardDisableInt(card_t *card)
-{
-    CsrResult r;
-    u8 int_enable;
-
-    r = sdio_read_f0(card, SDIO_INT_ENABLE, &int_enable);
-    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
-    {
-        return r;
-    }
-    if (r != CSR_RESULT_SUCCESS)
-    {
-        unifi_error(card->ospriv, "SDIO error reading SDIO_INT_ENABLE\n");
-        return r;
-    }
-
-    int_enable &= ~(1 << card->function);
-
-    r = sdio_write_f0(card, SDIO_INT_ENABLE, int_enable);
-    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
-    {
-        return r;
-    }
-    if (r != CSR_RESULT_SUCCESS)
-    {
-        unifi_error(card->ospriv, "SDIO error writing SDIO_INT_ENABLE\n");
-        return r;
-    }
-
-    return CSR_RESULT_SUCCESS;
-} /* CardDisableInt() */
-
-
-/*
- * ---------------------------------------------------------------------------
- *  CardPendingInt
- *
- *      Determine whether UniFi is currently asserting the SDIO interrupt
- *      request.
- *
- *  Arguments:
- *      card            Pointer to Card object
- *      pintr           Pointer to location to write interrupt status,
- *                          TRUE if interrupt pending,
- *                          FALSE if no interrupt pending.
- *  Returns:
- *      CSR_RESULT_SUCCESS            interrupt status read successfully
- *      CSR_WIFI_HIP_RESULT_NO_DEVICE      if the card was ejected
- *      CSR_RESULT_FAILURE            if an SDIO error occurred,
- * ---------------------------------------------------------------------------
- */
-CsrResult CardPendingInt(card_t *card, u8 *pintr)
-{
-    CsrResult r;
-    u8 pending;
-
-    *pintr = FALSE;
-
-    r = sdio_read_f0(card, SDIO_INT_PENDING, &pending);
-    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
-    {
-        return r;
-    }
-    if (r != CSR_RESULT_SUCCESS)
-    {
-        unifi_error(card->ospriv, "SDIO error reading SDIO_INT_PENDING\n");
-        return r;
-    }
-
-    *pintr = (pending & (1 << card->function))?TRUE : FALSE;
-
-    return CSR_RESULT_SUCCESS;
-} /* CardPendingInt() */
-
-
-/*
- * ---------------------------------------------------------------------------
- *  CardClearInt
- *
- *      Clear the UniFi SDIO interrupt request.
- *
- *  Arguments:
- *      card            Pointer to Card object
- *
- *  Returns:
- *      CSR_RESULT_SUCCESS          if pending interrupt was cleared, or no pending interrupt.
- *      CSR_WIFI_HIP_RESULT_NO_DEVICE    if the card was ejected
- *      CSR_RESULT_FAILURE          if an SDIO error occurred,
- * ---------------------------------------------------------------------------
- */
-CsrResult CardClearInt(card_t *card)
-{
-    CsrResult r;
-    u8 intr;
-
-    if (card->chip_id > SDIO_CARD_ID_UNIFI_2)
-    {
-        /* CardPendingInt() sets intr, if there is a pending interrupt */
-        r = CardPendingInt(card, &intr);
-        if (intr == FALSE)
-        {
-            return r;
-        }
-
-        r = sdio_write_f0(card, SDIO_CSR_HOST_INT_CLEAR, 1);
-        if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
-        {
-            return r;
-        }
-        if (r != CSR_RESULT_SUCCESS)
-        {
-            unifi_error(card->ospriv, "SDIO error writing SDIO_CSR_HOST_INT_CLEAR\n");
-        }
-    }
-    else
-    {
-        r = unifi_write_direct_8_or_16(card,
-                                       ChipHelper_SDIO_HOST_INT(card->helper) * 2,
-                                       0);
-        if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
-        {
-            return r;
-        }
-        if (r != CSR_RESULT_SUCCESS)
-        {
-            unifi_error(card->ospriv, "SDIO error writing UNIFI_SDIO_HOST_INT\n");
-        }
-    }
-
-    return r;
-} /* CardClearInt() */
-
-
-/*
- * ---------------------------------------------------------------------------
- *  CardIntEnabled
- *
- *      Determine whether UniFi is currently asserting the SDIO interrupt
- *      request.
- *
- *  Arguments:
- *      card            Pointer to Card object
- *      enabled         Pointer to location to write interrupt enable status,
- *                          TRUE if interrupts enabled,
- *                          FALSE if interupts disabled.
- *
- *  Returns:
- *      CSR_WIFI_HIP_RESULT_NO_DEVICE      if the card was ejected
- *      CSR_RESULT_FAILURE            if an SDIO error occurred,
- * ---------------------------------------------------------------------------
- */
-CsrResult CardIntEnabled(card_t *card, u8 *enabled)
-{
-    CsrResult r;
-    u8 int_enable;
-
-    r = sdio_read_f0(card, SDIO_INT_ENABLE, &int_enable);
-    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
-    {
-        return r;
-    }
-    if (r != CSR_RESULT_SUCCESS)
-    {
-        unifi_error(card->ospriv, "SDIO error reading SDIO_INT_ENABLE\n");
-        return r;
-    }
-
-    *enabled = (int_enable & (1 << card->function))?TRUE : FALSE;
-
-    return CSR_RESULT_SUCCESS;
-} /* CardIntEnabled() */
-
-
-/*
- * ---------------------------------------------------------------------------
- *  CardWriteBulkData
- *      Allocate slot in the pending bulkdata arrays and assign it to a signal's
- *      bulkdata reference. The slot is then ready for UniFi's bulkdata commands
- *      to transfer the data to/from the host.
- *
- *  Arguments:
- *      card            Pointer to Card object
- *      csptr           Pending signal pointer, including bulkdata ref
- *      queue           Traffic queue that this signal is using
- *
- *  Returns:
- *      CSR_RESULT_SUCCESS if a free slot was assigned
- *      CSR_RESULT_FAILURE if no slot was available
- * ---------------------------------------------------------------------------
- */
-CsrResult CardWriteBulkData(card_t *card, card_signal_t *csptr, unifi_TrafficQueue queue)
-{
-    u16 i, slots[UNIFI_MAX_DATA_REFERENCES], j = 0;
-    u8 *packed_sigptr, num_slots_required = 0;
-    bulk_data_desc_t *bulkdata = csptr->bulkdata;
-    s16 h, nslots;
-
-    /* Count the number of slots required */
-    for (i = 0; i < UNIFI_MAX_DATA_REFERENCES; i++)
-    {
-        if (bulkdata[i].data_length != 0)
-        {
-            num_slots_required++;
-        }
-    }
-
-    /* Get the slot numbers */
-    if (num_slots_required != 0)
-    {
-        /* Last 2 slots for MLME */
-        if (queue == UNIFI_TRAFFIC_Q_MLME)
-        {
-            h = card->config_data.num_fromhost_data_slots - UNIFI_RESERVED_COMMAND_SLOTS;
-            for (i = 0; i < card->config_data.num_fromhost_data_slots; i++)
-            {
-                if (card->from_host_data[h].bd.data_length == 0)
-                {
-                    /* Free data slot, claim it */
-                    slots[j++] = h;
-                    if (j == num_slots_required)
-                    {
-                        break;
-                    }
-                }
-
-                if (++h >= card->config_data.num_fromhost_data_slots)
-                {
-                    h = 0;
-                }
-            }
-        }
-        else
-        {
-            if (card->dynamic_slot_data.from_host_used_slots[queue]
-                < card->dynamic_slot_data.from_host_max_slots[queue])
-            {
-                /* Data commands get a free slot only after a few checks */
-                nslots = card->config_data.num_fromhost_data_slots - UNIFI_RESERVED_COMMAND_SLOTS;
-
-                h = card->from_host_data_head;
-
-                for (i = 0; i < nslots; i++)
-                {
-                    if (card->from_host_data[h].bd.data_length == 0)
-                    {
-                        /* Free data slot, claim it */
-                        slots[j++] = h;
-                        if (j == num_slots_required)
-                        {
-                            break;
-                        }
-                    }
-
-                    if (++h >= nslots)
-                    {
-                        h = 0;
-                    }
-                }
-                card->from_host_data_head = h;
-            }
-        }
-
-        /* Required number of slots are not available, bail out */
-        if (j != num_slots_required)
-        {
-            unifi_trace(card->ospriv, UDBG5, "CardWriteBulkData: didn't find free slot/s\n");
-
-            /* If we haven't already reached the stable state we can ask for reservation */
-            if ((queue != UNIFI_TRAFFIC_Q_MLME) && (card->dynamic_slot_data.queue_stable[queue] == FALSE))
-            {
-                CardCheckDynamicReservation(card, queue);
-            }
-
-            for (i = 0; i < card->config_data.num_fromhost_data_slots; i++)
-            {
-                unifi_trace(card->ospriv, UDBG5, "fh data slot %d: %d\n", i, card->from_host_data[i].bd.data_length);
-            }
-            return CSR_RESULT_FAILURE;
-        }
-    }
-
-    packed_sigptr = csptr->sigbuf;
-
-    /* Fill in the slots with data */
-    j = 0;
-    for (i = 0; i < UNIFI_MAX_DATA_REFERENCES; i++)
-    {
-        if (bulkdata[i].data_length == 0)
-        {
-            /* Zero-out the DATAREF in the signal */
-            SET_PACKED_DATAREF_SLOT(packed_sigptr, i, 0);
-            SET_PACKED_DATAREF_LEN(packed_sigptr, i, 0);
-        }
-        else
-        {
-            /*
-             * Fill in the slot number in the SIGNAL structure but
-             * preserve the offset already in there
-             */
-            SET_PACKED_DATAREF_SLOT(packed_sigptr, i, slots[j] | (((u16)packed_sigptr[SIZEOF_SIGNAL_HEADER + (i * SIZEOF_DATAREF) + 1]) << 8));
-            SET_PACKED_DATAREF_LEN(packed_sigptr, i, bulkdata[i].data_length);
-
-            /* Do not copy the data, just store the information to them */
-            card->from_host_data[slots[j]].bd.os_data_ptr = bulkdata[i].os_data_ptr;
-            card->from_host_data[slots[j]].bd.os_net_buf_ptr = bulkdata[i].os_net_buf_ptr;
-            card->from_host_data[slots[j]].bd.data_length = bulkdata[i].data_length;
-            card->from_host_data[slots[j]].bd.net_buf_length = bulkdata[i].net_buf_length;
-            card->from_host_data[slots[j]].queue = queue;
-
-            unifi_trace(card->ospriv, UDBG4, "CardWriteBulkData sig=0x%x, fh slot %d = %p\n",
-                        GET_SIGNAL_ID(packed_sigptr), i, bulkdata[i].os_data_ptr);
-
-            /* Sanity-check that the bulk data desc being assigned to the slot
-             * actually has a payload.
-             */
-            if (!bulkdata[i].os_data_ptr)
-            {
-                unifi_error(card->ospriv, "Assign null os_data_ptr (len=%d) fh slot %d, i=%d, q=%d, sig=0x%x",
-                            bulkdata[i].data_length, slots[j], i, queue, GET_SIGNAL_ID(packed_sigptr));
-            }
-
-            j++;
-            if (queue < UNIFI_NO_OF_TX_QS)
-            {
-                card->dynamic_slot_data.from_host_used_slots[queue]++;
-            }
-        }
-    }
-
-    return CSR_RESULT_SUCCESS;
-} /*  CardWriteBulkData() */
-
-
-/*
- * ---------------------------------------------------------------------------
- *  card_find_data_slot
- *
- *      Dereference references to bulk data slots into pointers to real data.
- *
- *  Arguments:
- *      card            Pointer to the card struct.
- *      slot            Slot number from a signal structure
- *
- *  Returns:
- *      Pointer to entry in bulk_data_slot array.
- * ---------------------------------------------------------------------------
- */
-bulk_data_desc_t* card_find_data_slot(card_t *card, s16 slot)
-{
-    s16 sn;
-    bulk_data_desc_t *bd;
-
-    sn = slot & 0x7FFF;
-
-    /* ?? check sanity of slot number ?? */
-
-    if (slot & SLOT_DIR_TO_HOST)
-    {
-        bd = &card->to_host_data[sn];
-    }
-    else
-    {
-        bd = &card->from_host_data[sn].bd;
-    }
-
-    return bd;
-} /* card_find_data_slot() */
-
-
-/*
- * ---------------------------------------------------------------------------
- *  firmware_present_in_flash
- *
- *      Probe for external Flash that looks like it might contain firmware.
- *
- *      If Flash is not present, reads always return 0x0008.
- *      If Flash is present, but empty, reads return 0xFFFF.
- *      Anything else is considered to be firmware.
- *
- *  Arguments:
- *      card        Pointer to card struct
- *
- *  Returns:
- *      CSR_RESULT_SUCCESS                 firmware is present in ROM or flash
- *      CSR_WIFI_HIP_RESULT_NOT_FOUND      firmware is not present in ROM or flash
- *      CSR_WIFI_HIP_RESULT_NO_DEVICE      if the card was ejected
- *      CSR_RESULT_FAILURE                 if an SDIO error occurred
- * ---------------------------------------------------------------------------
- */
-static CsrResult firmware_present_in_flash(card_t *card)
-{
-    CsrResult r;
-    u16 m1, m5;
-
-    if (ChipHelper_HasRom(card->helper))
-    {
-        return CSR_RESULT_SUCCESS;
-    }
-    if (!ChipHelper_HasFlash(card->helper))
-    {
-        return CSR_WIFI_HIP_RESULT_NOT_FOUND;
-    }
-
-    /*
-     * Examine the Flash locations that are the power-on default reset
-     * vectors of the XAP processors.
-     * These are words 1 and 5 in Flash.
-     */
-    r = unifi_card_read16(card, UNIFI_MAKE_GP(EXT_FLASH, 2), &m1);
-    if (r != CSR_RESULT_SUCCESS)
-    {
-        return r;
-    }
-
-    r = unifi_card_read16(card, UNIFI_MAKE_GP(EXT_FLASH, 10), &m5);
-    if (r != CSR_RESULT_SUCCESS)
-    {
-        return r;
-    }
-
-    /* Check for uninitialised/missing flash */
-    if ((m1 == 0x0008) || (m1 == 0xFFFF) ||
-        (m1 == 0x0004) || (m5 == 0x0004) ||
-        (m5 == 0x0008) || (m5 == 0xFFFF))
-    {
-        return CSR_WIFI_HIP_RESULT_NOT_FOUND;
-    }
-
-    return CSR_RESULT_SUCCESS;
-} /* firmware_present_in_flash() */
-
-
-/*
- * ---------------------------------------------------------------------------
- *  bootstrap_chip_hw
- *
- *      Perform chip specific magic to "Get It Working" TM.  This will
- *      increase speed of PLLs in analogue and maybe enable some
- *      on-chip regulators.
- *
- *  Arguments:
- *      card            Pointer to card struct
- *
- *  Returns:
- *      None.
- * ---------------------------------------------------------------------------
- */
-static void bootstrap_chip_hw(card_t *card)
-{
-    const struct chip_helper_init_values *vals;
-    u32 i, len;
-    void *sdio = card->sdio_if;
-    CsrResult csrResult;
-
-    len = ChipHelper_ClockStartupSequence(card->helper, &vals);
-    if (len != 0)
-    {
-        for (i = 0; i < len; i++)
-        {
-            csrResult = CsrSdioWrite16(sdio, vals[i].addr * 2, vals[i].value);
-            if (csrResult != CSR_RESULT_SUCCESS)
-            {
-                unifi_warning(card->ospriv, "Failed to write bootstrap value %d\n", i);
-                /* Might not be fatal */
-            }
-
-            CsrThreadSleep(1);
-        }
-    }
-} /* bootstrap_chip_hw() */
-
-
-/*
- * ---------------------------------------------------------------------------
- *  unifi_card_stop_processor
- *
- *      Stop the UniFi XAP processors.
- *
- *  Arguments:
- *      card            Pointer to card struct
- *      which           One of UNIFI_PROC_MAC, UNIFI_PROC_PHY, UNIFI_PROC_BOTH
- *
- *  Returns:
- *      CSR_RESULT_SUCCESS if successful, or CSR error code
- * ---------------------------------------------------------------------------
- */
-CsrResult unifi_card_stop_processor(card_t *card, enum unifi_dbg_processors_select which)
-{
-    CsrResult r = CSR_RESULT_SUCCESS;
-    u8 status;
-    s16 retry = 100;
-
-    while (retry--)
-    {
-        /* Select both XAPs */
-        r = unifi_set_proc_select(card, which);
-        if (r != CSR_RESULT_SUCCESS)
-        {
-            break;
-        }
-
-        /* Stop processors */
-        r = unifi_write_direct16(card, ChipHelper_DBG_EMU_CMD(card->helper) * 2, 2);
-        if (r != CSR_RESULT_SUCCESS)
-        {
-            break;
-        }
-
-        /* Read status */
-        r = unifi_read_direct_8_or_16(card,
-                                      ChipHelper_DBG_HOST_STOP_STATUS(card->helper) * 2,
-                                      &status);
-        if (r != CSR_RESULT_SUCCESS)
-        {
-            break;
-        }
-
-        if ((status & 1) == 1)
-        {
-            /* Success! */
-            return CSR_RESULT_SUCCESS;
-        }
-
-        /* Processors didn't stop, try again */
-    }
-
-    if (r != CSR_RESULT_SUCCESS)
-    {
-        /* An SDIO error occurred */
-        unifi_error(card->ospriv, "Failed to stop processors: SDIO error\n");
-    }
-    else
-    {
-        /* If we reach here, we didn't the status in time. */
-        unifi_error(card->ospriv, "Failed to stop processors: timeout waiting for stopped status\n");
-        r = CSR_RESULT_FAILURE;
-    }
-
-    return r;
-} /* unifi_card_stop_processor() */
-
-
-/*
- * ---------------------------------------------------------------------------
- *  card_start_processor
- *
- *      Start the UniFi XAP processors.
- *
- *  Arguments:
- *      card            Pointer to card struct
- *      which           One of UNIFI_PROC_MAC, UNIFI_PROC_PHY, UNIFI_PROC_BOTH
- *
- *  Returns:
- *      CSR_RESULT_SUCCESS or CSR error code
- * ---------------------------------------------------------------------------
- */
-CsrResult card_start_processor(card_t *card, enum unifi_dbg_processors_select which)
-{
-    CsrResult r;
-
-    /* Select both XAPs */
-    r = unifi_set_proc_select(card, which);
-    if (r != CSR_RESULT_SUCCESS)
-    {
-        unifi_error(card->ospriv, "unifi_set_proc_select failed: %d.\n", r);
-        return r;
-    }
-
-
-    r = unifi_write_direct_8_or_16(card,
-                                   ChipHelper_DBG_EMU_CMD(card->helper) * 2, 8);
-    if (r != CSR_RESULT_SUCCESS)
-    {
-        return r;
-    }
-
-    r = unifi_write_direct_8_or_16(card,
-                                   ChipHelper_DBG_EMU_CMD(card->helper) * 2, 0);
-    if (r != CSR_RESULT_SUCCESS)
-    {
-        return r;
-    }
-
-    return CSR_RESULT_SUCCESS;
-} /* card_start_processor() */
-
-
-/*
- * ---------------------------------------------------------------------------
- *  unifi_set_interrupt_mode
- *
- *      Configure the interrupt processing mode used by the HIP
- *
- *  Arguments:
- *      card            Pointer to card struct
- *      mode            Interrupt mode to apply
- *
- *  Returns:
- *      None
- * ---------------------------------------------------------------------------
- */
-void unifi_set_interrupt_mode(card_t *card, u32 mode)
-{
-    if (mode == CSR_WIFI_INTMODE_RUN_BH_ONCE)
-    {
-        unifi_info(card->ospriv, "Scheduled interrupt mode");
-    }
-    card->intmode = mode;
-} /* unifi_set_interrupt_mode() */
-
-
-/*
- * ---------------------------------------------------------------------------
- *  unifi_start_processors
- *
- *      Start all UniFi XAP processors.
- *
- *  Arguments:
- *      card            Pointer to card struct
- *
- *  Returns:
- *      CSR_RESULT_SUCCESS on success, CSR error code on error
- * ---------------------------------------------------------------------------
- */
-CsrResult unifi_start_processors(card_t *card)
-{
-    return card_start_processor(card, UNIFI_PROC_BOTH);
-} /* unifi_start_processors() */
-
-
-/*
- * ---------------------------------------------------------------------------
- *  unifi_request_max_sdio_clock
- *
- *      Requests that the maximum SDIO clock rate is set at the next suitable
- *      opportunity (e.g. when the BH next runs, so as not to interfere with
- *      any current operation).
- *
- *  Arguments:
- *      card            Pointer to card struct
- *
- *  Returns:
- *      None
- * ---------------------------------------------------------------------------
- */
-void unifi_request_max_sdio_clock(card_t *card)
-{
-    card->request_max_clock = 1;
-} /* unifi_request_max_sdio_clock() */
-
-
-/*
- * ---------------------------------------------------------------------------
- *  unifi_set_host_state
- *
- *      Set the host deep-sleep state.
- *
- *      If transitioning to TORPID, the SDIO driver will be notified
- *      that the SD bus will be unused (idle) and conversely, when
- *      transitioning from TORPID that the bus will be used (active).
- *
- *  Arguments:
- *      card            Pointer to card struct
- *      state           New deep-sleep state.
- *
- *  Returns:
- *      CSR_RESULT_SUCCESS            on success
- *      CSR_WIFI_HIP_RESULT_NO_DEVICE      if the card was ejected
- *      CSR_RESULT_FAILURE            if an SDIO error occurred
- *
- *  Notes:
- *      We need to reduce the SDIO clock speed before trying to wake up the
- *      chip. Actually, in the implementation below we reduce the clock speed
- *      not just before we try to wake up the chip, but when we put the chip to
- *      deep sleep. This means that if the f/w wakes up on its' own, we waste
- *      a reduce/increace cycle. However, trying to eliminate this overhead is
- *      proved difficult, as the current state machine in the HIP lib does at
- *      least a CMD52 to disable the interrupts before we configure the host
- *      state.
- * ---------------------------------------------------------------------------
- */
-CsrResult unifi_set_host_state(card_t *card, enum unifi_host_state state)
-{
-    CsrResult r = CSR_RESULT_SUCCESS;
-    CsrResult csrResult;
-    static const char *const states[] = {
-        "AWAKE", "DROWSY", "TORPID"
-    };
-    static const u8 state_csr_host_wakeup[] = {
-        1, 3, 0
-    };
-    static const u8 state_io_abort[] = {
-        0, 2, 3
-    };
-
-    unifi_trace(card->ospriv, UDBG4, "State %s to %s\n",
-                states[card->host_state], states[state]);
-
-    if (card->host_state == UNIFI_HOST_STATE_TORPID)
-    {
-        CsrSdioFunctionActive(card->sdio_if);
-    }
-
-    /* Write the new state to UniFi. */
-    if (card->chip_id > SDIO_CARD_ID_UNIFI_2)
-    {
-        r = sdio_write_f0(card, SDIO_CSR_HOST_WAKEUP,
-                          (u8)((card->function << 4) | state_csr_host_wakeup[state]));
-    }
-    else
-    {
-        r = sdio_write_f0(card, SDIO_IO_ABORT, state_io_abort[state]);
-    }
-
-    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
-    {
-        return r;
-    }
-    if (r != CSR_RESULT_SUCCESS)
-    {
-        unifi_error(card->ospriv, "Failed to write UniFi deep sleep state\n");
-    }
-    else
-    {
-        /*
-         * If the chip was in state TORPID then we can now increase
-         * the maximum bus clock speed.
-         */
-        if (card->host_state == UNIFI_HOST_STATE_TORPID)
-        {
-            csrResult = CsrSdioMaxBusClockFrequencySet(card->sdio_if,
-                                                       UNIFI_SDIO_CLOCK_MAX_HZ);
-            r = ConvertCsrSdioToCsrHipResult(card, csrResult);
-            /* Non-fatal error */
-            if (r != CSR_RESULT_SUCCESS && r != CSR_WIFI_HIP_RESULT_NO_DEVICE)
-            {
-                unifi_warning(card->ospriv,
-                              "Failed to increase the SDIO clock speed\n");
-            }
-            else
-            {
-                card->sdio_clock_speed = UNIFI_SDIO_CLOCK_MAX_HZ;
-            }
-        }
-
-        /*
-         * Cache the current state in the card structure to avoid
-         * unnecessary SDIO reads.
-         */
-        card->host_state = state;
-
-        if (state == UNIFI_HOST_STATE_TORPID)
-        {
-            /*
-             * If the chip is now in state TORPID then we must now decrease
-             * the maximum bus clock speed.
-             */
-            csrResult = CsrSdioMaxBusClockFrequencySet(card->sdio_if,
-                                                       UNIFI_SDIO_CLOCK_SAFE_HZ);
-            r = ConvertCsrSdioToCsrHipResult(card, csrResult);
-            if (r != CSR_RESULT_SUCCESS && r != CSR_WIFI_HIP_RESULT_NO_DEVICE)
-            {
-                unifi_warning(card->ospriv,
-                              "Failed to decrease the SDIO clock speed\n");
-            }
-            else
-            {
-                card->sdio_clock_speed = UNIFI_SDIO_CLOCK_SAFE_HZ;
-            }
-            CsrSdioFunctionIdle(card->sdio_if);
-        }
-    }
-
-    return r;
-} /* unifi_set_host_state() */
-
-
-/*
- * ---------------------------------------------------------------------------
- *  unifi_card_info
- *
- *      Update the card information data structure
- *
- *  Arguments:
- *      card            Pointer to card struct
- *      card_info       Pointer to info structure to update
- *
- *  Returns:
- *      None
- * ---------------------------------------------------------------------------
- */
-void unifi_card_info(card_t *card, card_info_t *card_info)
-{
-    card_info->chip_id = card->chip_id;
-    card_info->chip_version = card->chip_version;
-    card_info->fw_build = card->build_id;
-    card_info->fw_hip_version = card->config_data.version;
-    card_info->sdio_block_size = card->sdio_io_block_size;
-} /* unifi_card_info() */
-
-
-/*
- * ---------------------------------------------------------------------------
- *  unifi_check_io_status
- *
- *      Check UniFi for spontaneous reset and pending interrupt.
- *
- *  Arguments:
- *      card            Pointer to card struct
- *      status          Pointer to location to write chip status:
- *                        0 if UniFi is running, and no interrupt pending
- *                        1 if UniFi has spontaneously reset
- *                        2 if there is a pending interrupt
- *  Returns:
- *      CSR_RESULT_SUCCESS if OK, or CSR error
- * ---------------------------------------------------------------------------
- */
-CsrResult unifi_check_io_status(card_t *card, s32 *status)
-{
-    u8 io_en;
-    CsrResult r;
-    u8 pending;
-
-    *status = 0;
-
-    r = sdio_read_f0(card, SDIO_IO_ENABLE, &io_en);
-    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
-    {
-        return r;
-    }
-    if (r != CSR_RESULT_SUCCESS)
-    {
-        unifi_error(card->ospriv, "Failed to read SDIO_IO_ENABLE to check for spontaneous reset\n");
-        return r;
-    }
-
-    if ((io_en & (1 << card->function)) == 0)
-    {
-        s32 fw_count;
-        *status = 1;
-        unifi_error(card->ospriv, "UniFi has spontaneously reset.\n");
-
-        /*
-         * These reads are very likely to fail. We want to know if the function is really
-         * disabled or the SDIO driver just returns rubbish.
-         */
-        fw_count = unifi_read_shared_count(card, card->sdio_ctrl_addr + 4);
-        if (fw_count < 0)
-        {
-            unifi_error(card->ospriv, "Failed to read to-host sig written count\n");
-        }
-        else
-        {
-            unifi_error(card->ospriv, "thsw: %u (driver thinks is %u)\n",
-                        fw_count, card->to_host_signals_w);
-        }
-        fw_count = unifi_read_shared_count(card, card->sdio_ctrl_addr + 2);
-        if (fw_count < 0)
-        {
-            unifi_error(card->ospriv, "Failed to read from-host sig read count\n");
-        }
-        else
-        {
-            unifi_error(card->ospriv, "fhsr: %u (driver thinks is %u)\n",
-                        fw_count, card->from_host_signals_r);
-        }
-
-        return r;
-    }
-
-    unifi_info(card->ospriv, "UniFi function %d is enabled.\n", card->function);
-
-    /* See if we missed an SDIO interrupt */
-    r = CardPendingInt(card, &pending);
-    if (pending)
-    {
-        unifi_error(card->ospriv, "There is an unhandled pending interrupt.\n");
-        *status = 2;
-        return r;
-    }
-
-    return r;
-} /* unifi_check_io_status() */
-
-
-void unifi_get_hip_qos_info(card_t *card, unifi_HipQosInfo *hipqosinfo)
-{
-    s32 count_fhr;
-    s16 t;
-    u32 occupied_fh;
-
-    q_t *sigq;
-    u16 nslots, i;
-
-    memset(hipqosinfo, 0, sizeof(unifi_HipQosInfo));
-
-    nslots = card->config_data.num_fromhost_data_slots;
-
-    for (i = 0; i < nslots; i++)
-    {
-        if (card->from_host_data[i].bd.data_length == 0)
-        {
-            hipqosinfo->free_fh_bulkdata_slots++;
-        }
-    }
-
-    for (i = 0; i < UNIFI_NO_OF_TX_QS; i++)
-    {
-        sigq = &card->fh_traffic_queue[i];
-        t = sigq->q_wr_ptr - sigq->q_rd_ptr;
-        if (t < 0)
-        {
-            t += sigq->q_length;
-        }
-        hipqosinfo->free_fh_sig_queue_slots[i] = (sigq->q_length - t) - 1;
-    }
-
-    count_fhr = unifi_read_shared_count(card, card->sdio_ctrl_addr + 2);
-    if (count_fhr < 0)
-    {
-        unifi_error(card->ospriv, "Failed to read from-host sig read count - %d\n", count_fhr);
-        hipqosinfo->free_fh_fw_slots = 0xfa;
-        return;
-    }
-
-    occupied_fh = (card->from_host_signals_w - count_fhr) % 128;
-
-    hipqosinfo->free_fh_fw_slots = (u16)(card->config_data.num_fromhost_sig_frags - occupied_fh);
-}
-
-
-
-CsrResult ConvertCsrSdioToCsrHipResult(card_t *card, CsrResult csrResult)
-{
-    CsrResult r = CSR_RESULT_FAILURE;
-
-    switch (csrResult)
-    {
-        case CSR_RESULT_SUCCESS:
-            r = CSR_RESULT_SUCCESS;
-            break;
-        /* Timeout errors */
-        case CSR_SDIO_RESULT_TIMEOUT:
-        /* Integrity errors */
-        case CSR_SDIO_RESULT_CRC_ERROR:
-            r = CSR_RESULT_FAILURE;
-            break;
-        case CSR_SDIO_RESULT_NO_DEVICE:
-            r = CSR_WIFI_HIP_RESULT_NO_DEVICE;
-            break;
-        case CSR_SDIO_RESULT_INVALID_VALUE:
-            r = CSR_WIFI_HIP_RESULT_INVALID_VALUE;
-            break;
-        case CSR_RESULT_FAILURE:
-            r = CSR_RESULT_FAILURE;
-            break;
-        default:
-            unifi_warning(card->ospriv, "Unrecognised csrResult error code: %d\n", csrResult);
-            break;
-    }
-
-    return r;
-} /* ConvertCsrSdioToCsrHipResult() */
-
-
diff -ruN linux-3.10/drivers/tty/serial/Kconfig linux-3.10_patched/drivers/tty/serial/Kconfig
--- linux-3.10/drivers/tty/serial/Kconfig	2013-06-30 22:13:29.000000000 +0000
+++ linux-3.10_patched/drivers/tty/serial/Kconfig	2025-06-14 05:48:04.973173245 +0000
@@ -1484,6 +1484,29 @@
 	  If multiple cards are present, the default limit of 32 ports may
 	  need to be increased.
 
+config SERIAL_QSP_UART
+       tristate "QSP uart/serial support"
+       default y if QSP
+       select SERIAL_CORE
+       help
+         This driver supports the QSP serial/uart.
+
+config SERIAL_QSP_MAXPORTS
+       int "Maximum number of QSP UART ports"
+      depends on SERIAL_QSP_UART
+       default 16
+       help
+        This setting lets you define the maximum number of the QSP
+         UART ports. The usual default varies from board to board, and
+         this setting is a way of catering for that.
+
+config SERIAL_QSP_CONSOLE
+       bool "QSP UART console support"
+       depends on SERIAL_QSP_UART=y
+       select SERIAL_CORE_CONSOLE
+       help
+         Enable a QSP UART port to be the system console.
+
 endmenu
 
 endif # TTY
diff -ruN linux-3.10/drivers/tty/serial/Makefile linux-3.10_patched/drivers/tty/serial/Makefile
--- linux-3.10/drivers/tty/serial/Makefile	2013-06-30 22:13:29.000000000 +0000
+++ linux-3.10_patched/drivers/tty/serial/Makefile	2025-06-14 05:48:04.973173245 +0000
@@ -85,3 +85,4 @@
 obj-$(CONFIG_SERIAL_EFM32_UART) += efm32-uart.o
 obj-$(CONFIG_SERIAL_ARC)	+= arc_uart.o
 obj-$(CONFIG_SERIAL_RP2)	+= rp2.o
+obj-$(CONFIG_SERIAL_QSP_UART)	+= qsp_uart.o
diff -ruN linux-3.10/drivers/tty/serial/qsp_uart.c linux-3.10_patched/drivers/tty/serial/qsp_uart.c
--- linux-3.10/drivers/tty/serial/qsp_uart.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.10_patched/drivers/tty/serial/qsp_uart.c	2025-06-14 05:48:04.973173245 +0000
@@ -0,0 +1,518 @@
+/*
+ * qsp_uart.c -- QSP Serial driver
+ *
+ * Based on altera_uart.c -- Altera UART driver
+ *
+ * (C) Copyright 2012, Ivar Holmqvist <ivarholmqvist@gmail.com>
+ * (C) Copyright 2003-2007, Greg Ungerer <gerg@snapgear.com>
+ * (C) Copyright 2008, Thomas Chou <thomas@wytron.com.tw>
+ * (C) Copyright 2010, Tobias Klauser <tklauser@distanz.ch>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/console.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/serial.h>
+#include <linux/serial_core.h>
+#include <linux/platform_device.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/of.h>
+#include <linux/io.h>
+#include <linux/device.h>
+
+#include <linux/qsp/qsp.h>
+
+#define DRV_NAME "qsp_uart"
+#define SERIAL_QSP_MAJOR 204
+#define SERIAL_QSP_MINOR 16
+
+#define CONFIG_SERIAL_QSP_UART_MAXPORTS 32
+#define QSP_UART_SIZE			32
+
+/* Register offfsets
+ */
+#define ID_REG      0x00
+#define STATUS_REG  0x04
+#define CONTROL_REG 0x08
+#define TXDATA_REG  0x0c
+#define RXDATA_REG  0x10
+
+/* Status register bits
+ */
+#define TX_READY (1<<0)
+#define RX_READY (1<<1)
+
+/* Control register bits
+ */
+#define TX_INT (1<<0)
+#define RX_INT (1<<1)
+
+/*
+ * Local per-uart structure.
+ */
+struct qsp_uart {
+	struct uart_port port;
+	int irq;
+};
+
+static u32 qsp_uart_readl(struct uart_port *port, int reg)
+{
+	return readl(port->membase + (reg << port->regshift));
+}
+
+static void qsp_uart_writel(struct uart_port *port, u32 dat, int reg)
+{
+	writel(dat, port->membase + (reg << port->regshift));
+}
+
+static unsigned int qsp_uart_tx_empty(struct uart_port *port)
+{
+	return (qsp_uart_readl(port, STATUS_REG) & TX_READY) ? TIOCSER_TEMT : 0;
+}
+
+/* No modem control lines
+ */
+static unsigned int qsp_uart_get_mctrl(struct uart_port *port)
+{
+	return TIOCM_CAR | TIOCM_DSR | TIOCM_CTS;
+}
+
+static void qsp_uart_set_mctrl(struct uart_port *port, unsigned int mctrl)
+{
+}
+
+static void qsp_uart_start_tx(struct uart_port *port)
+{
+	u32 pre;
+
+	pre = qsp_uart_readl(port, CONTROL_REG);
+	qsp_uart_writel(port, pre|TX_INT, CONTROL_REG);
+}
+
+static void qsp_uart_stop_tx(struct uart_port *port)
+{
+	u32 pre;
+
+	pre = qsp_uart_readl(port, CONTROL_REG);
+	qsp_uart_writel(port, pre & ~TX_INT, CONTROL_REG);
+}
+
+static void qsp_uart_stop_rx(struct uart_port *port)
+{
+	u32 pre;
+
+	pre = qsp_uart_readl(port, CONTROL_REG);
+	qsp_uart_writel(port, pre & ~RX_INT, CONTROL_REG);
+}
+
+static void qsp_uart_break_ctl(struct uart_port *port, int break_state)
+{
+	dev_dbg(port->dev, "ignoring break_ctl\n");
+}
+
+static void qsp_uart_enable_ms(struct uart_port *port)
+{
+	dev_dbg(port->dev, "ignoring enable_ms\n");
+}
+
+static void qsp_uart_set_termios(struct uart_port *port,
+				    struct ktermios *termios,
+				    struct ktermios *old)
+{
+	unsigned int baud;
+
+	baud = uart_get_baud_rate(port, termios, old, 0, 4000000);
+
+	if (old)
+		tty_termios_copy_hw(termios, old);
+	tty_termios_encode_baud_rate(termios, baud, baud);
+
+	uart_update_timeout(port, termios->c_cflag, baud);
+}
+
+static void qsp_uart_rx_chars(struct qsp_uart *pp)
+{
+	struct uart_port *port = &pp->port;
+	unsigned char ch, flag;
+	unsigned short status;
+
+	while ((status = qsp_uart_readl(port, STATUS_REG)) &
+	       RX_READY) {
+		ch = qsp_uart_readl(port, RXDATA_REG);
+		flag = TTY_NORMAL;
+		port->icount.rx++;
+
+		/* There is no possibility to errors on this HW (i.e framing
+		 * etc) so there's no other icount updates and we always
+		 * return TTY_NORMAL.
+		 */
+
+		if (uart_handle_sysrq_char(port, ch))
+			continue;
+
+		/* RX Ovverun not supported by HW, so we skip passing
+		 * status/mask for that.
+		 */
+		uart_insert_char(port, 0, 0, ch, flag);
+	}
+
+	tty_flip_buffer_push(port->state->port.tty);
+}
+
+static void qsp_uart_tx_chars(struct qsp_uart *pp)
+{
+	struct uart_port *port = &pp->port;
+	struct circ_buf *xmit = &port->state->xmit;
+
+	if (port->x_char) {
+		/* Send special char - probably flow control */
+		qsp_uart_writel(port, port->x_char, TXDATA_REG);
+		port->x_char = 0;
+		port->icount.tx++;
+		return;
+	}
+
+	while (qsp_uart_readl(port, STATUS_REG) &
+	       TX_READY) {
+		if (xmit->head == xmit->tail)
+			break;
+		qsp_uart_writel(port, xmit->buf[xmit->tail],
+		       TXDATA_REG);
+		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+		port->icount.tx++;
+	}
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+		uart_write_wakeup(port);
+
+	if (xmit->head == xmit->tail) {
+		qsp_uart_writel(port,
+				   qsp_uart_readl(port, CONTROL_REG) & ~TX_INT,
+				   CONTROL_REG);
+	}
+}
+
+static irqreturn_t qsp_uart_interrupt(int irq, void *data)
+{
+	struct uart_port *port = data;
+	struct qsp_uart *pp = container_of(port, struct qsp_uart, port);
+	unsigned int isr;
+
+	isr = qsp_uart_readl(port, STATUS_REG) &
+		qsp_uart_readl(port, CONTROL_REG);
+
+	spin_lock(&port->lock);
+	if (isr & RX_READY)
+		qsp_uart_rx_chars(pp);
+	if (isr & TX_READY)
+		qsp_uart_tx_chars(pp);
+	spin_unlock(&port->lock);
+
+	return IRQ_RETVAL(isr);
+}
+
+static void qsp_uart_config_port(struct uart_port *port, int flags)
+{
+	port->type = PORT_QSP_UART;
+
+	/* Clear interrupt mask */
+	qsp_uart_writel(port, 0, CONTROL_REG);
+}
+
+static int qsp_uart_startup(struct uart_port *port)
+{
+	int ret;
+	unsigned long flags;
+	u32 pre;
+
+	dev_dbg(port->dev, "startup\n");
+
+	port->irq = irq_of_parse_and_map(port->dev->of_node,  0);
+	if (!port->irq) {
+		dev_err(port->dev, "IRQ not specified in dtb\n");
+		return -EINVAL;
+	}
+	dev_dbg(port->dev, "got irq %d\n", port->irq);
+
+	ret = request_irq(port->irq, qsp_uart_interrupt, 0,
+			DRV_NAME, port);
+	if (ret) {
+		pr_err(DRV_NAME ": unable to attach Adp UART %d "
+		       "interrupt vector=%d\n", port->line, port->irq);
+		return ret;
+	}
+
+	/* Enable RX interrupts now */
+	spin_lock_irqsave(&port->lock, flags);
+	pre = qsp_uart_readl(port, CONTROL_REG);
+	qsp_uart_writel(port, pre | RX_INT, CONTROL_REG);
+	spin_unlock_irqrestore(&port->lock, flags);
+
+	return 0;
+}
+
+static void qsp_uart_shutdown(struct uart_port *port)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&port->lock, flags);
+
+	/* Disable all interrupts now */
+	qsp_uart_writel(port, 0, CONTROL_REG);
+
+	spin_unlock_irqrestore(&port->lock, flags);
+
+	free_irq(port->irq, port);
+}
+
+static const char *qsp_uart_type(struct uart_port *port)
+{
+	return (port->type == PORT_QSP_UART) ? "QSP UART" : NULL;
+}
+
+static int qsp_uart_request_port(struct uart_port *port)
+{
+	/* Resources taken in probe. */
+	dev_dbg(port->dev, "request port\n");
+	return 0;
+}
+
+static void qsp_uart_release_port(struct uart_port *port)
+{
+	/* Nothing to release... */
+	dev_dbg(port->dev, "release port\n");
+}
+
+static int qsp_uart_verify_port(struct uart_port *port,
+				   struct serial_struct *ser)
+{
+	if ((ser->type != PORT_UNKNOWN) && (ser->type != PORT_QSP_UART))
+		return -EINVAL;
+	return 0;
+}
+
+/* Define the basic serial functions we support.
+ */
+static struct uart_ops qsp_uart_ops = {
+	.tx_empty	= qsp_uart_tx_empty,
+	.get_mctrl	= qsp_uart_get_mctrl,
+	.set_mctrl	= qsp_uart_set_mctrl,
+	.start_tx	= qsp_uart_start_tx,
+	.stop_tx	= qsp_uart_stop_tx,
+	.stop_rx	= qsp_uart_stop_rx,
+	.enable_ms	= qsp_uart_enable_ms,
+	.break_ctl	= qsp_uart_break_ctl,
+	.startup	= qsp_uart_startup,
+	.shutdown	= qsp_uart_shutdown,
+	.set_termios	= qsp_uart_set_termios,
+	.type		= qsp_uart_type,
+	.request_port	= qsp_uart_request_port,
+	.release_port	= qsp_uart_release_port,
+	.config_port	= qsp_uart_config_port,
+	.verify_port	= qsp_uart_verify_port,
+};
+
+static struct qsp_uart qsp_uart_ports[CONFIG_SERIAL_QSP_MAXPORTS];
+
+#if defined(CONFIG_SERIAL_QSP_CONSOLE)
+
+
+static void qsp_uart_console_putc(struct uart_port *port, const char c)
+{
+	while (!(qsp_uart_readl(port, STATUS_REG) &
+		 TX_READY))
+		cpu_relax();
+
+	qsp_uart_writel(port, c, TXDATA_REG);
+}
+
+static void qsp_uart_console_write(struct console *co, const char *s,
+				      unsigned int count)
+{
+	struct uart_port *port = &(qsp_uart_ports + co->index)->port;
+
+	for (; count; count--, s++) {
+		qsp_uart_console_putc(port, *s);
+		if (*s == '\n')
+			qsp_uart_console_putc(port, '\r');
+	}
+}
+
+static int __init qsp_uart_console_setup(struct console *co, char *options)
+{
+	struct uart_port *port;
+	int baud = 115200;
+	int bits = 8;
+	int parity = 'n';
+	int flow = 'n';
+
+	if (co->index < 0 || co->index >= CONFIG_SERIAL_QSP_MAXPORTS)
+		return -EINVAL;
+
+	port = &qsp_uart_ports[co->index].port;
+	if (!port->membase)
+		return -ENODEV;
+
+	if (options)
+		uart_parse_options(options, &baud, &parity, &bits, &flow);
+
+	return uart_set_options(port, co, baud, parity, bits, flow);
+}
+
+static struct uart_driver qsp_uart_driver;
+
+static struct console qsp_uart_console = {
+	.name	= "ttyAM",
+	.write	= qsp_uart_console_write,
+	.device	= uart_console_device,
+	.setup	= qsp_uart_console_setup,
+	.flags	= CON_PRINTBUFFER,
+	.index	= -1,
+	.data	= &qsp_uart_driver,
+};
+
+static int __init qsp_uart_console_init(void)
+{
+	register_console(&qsp_uart_console);
+	return 0;
+}
+
+console_initcall(qsp_uart_console_init);
+
+#define	ALT_UART_KEEP_CONSOLE	(&qsp_uart_console)
+
+#else
+
+#define	ALT_UART_KEEP_CONSOLE	NULL
+
+#endif /* CONFIG_ALT_UART_KEEP_CONSOLE */
+
+/* Define the qsp_uart UART driver structure.
+ */
+static struct uart_driver qsp_uart_driver = {
+	.owner		= THIS_MODULE,
+	.driver_name	= DRV_NAME,
+	.dev_name	= "ttyAM",
+	.major		= SERIAL_QSP_MAJOR,
+	.minor		= SERIAL_QSP_MINOR,
+	.nr		= CONFIG_SERIAL_QSP_MAXPORTS,
+	.cons		= ALT_UART_KEEP_CONSOLE,
+};
+
+static int qsp_uart_probe(struct platform_device *pdev)
+{
+	struct resource res;
+	struct uart_port *port;
+	int i = pdev->id;
+	u32 id;
+
+	dev_dbg(&pdev->dev, "probe %d\n", i);
+	/* if id is -1 scan for a free id and use that one */
+	if (i == -1) {
+		for (i = 0; i < CONFIG_SERIAL_QSP_MAXPORTS; i++)
+			if (qsp_uart_ports[i].port.membase == 0)
+				break;
+	}
+
+	if (i < 0 || i >= CONFIG_SERIAL_QSP_MAXPORTS)
+		return -EINVAL;
+
+	dev_dbg(&pdev->dev, "using index %d\n", i);
+	port = &qsp_uart_ports[i].port;
+
+	port->membase = of_iomap(pdev->dev.of_node, 0);
+	port->irq = irq_of_parse_and_map(pdev->dev.of_node,  0);
+	port->line = i;
+	port->type = PORT_QSP_UART;
+	port->iotype = SERIAL_IO_MEM;
+	port->fifosize = 1;
+	port->ops = &qsp_uart_ops;
+	port->flags = UPF_BOOT_AUTOCONF;
+	port->dev = &pdev->dev;
+	dev_set_drvdata(&pdev->dev, port);
+
+	/* Get phys addr of membase as well,
+	 * for pretty print out by serial_core.c */
+	of_address_to_resource(pdev->dev.of_node, 0, &res);
+	port->mapbase = res.start;
+
+	id = qsp_uart_readl(port, 0);
+	dev_dbg(&pdev->dev, "id %08x\n", id);
+	if (id != QSP_SERIAL_ID_VAL)
+		return -ENODEV;
+
+	uart_add_one_port(&qsp_uart_driver, port);
+	dev_dbg(&pdev->dev, "one port added\n");
+	return 0;
+}
+
+static int qsp_uart_remove(struct platform_device *pdev)
+{
+	struct uart_port *port = dev_get_drvdata(&pdev->dev);
+
+	if (port) {
+		uart_remove_one_port(&qsp_uart_driver, port);
+		dev_set_drvdata(&pdev->dev, NULL);
+		port->mapbase = 0;
+	}
+
+	return 0;
+}
+
+static struct of_device_id qsp_uart_match[] = {
+	{ .compatible = "qsp-serial" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, qsp_uart_match);
+
+static struct platform_driver qsp_uart_platform_driver = {
+	.probe	= qsp_uart_probe,
+	.remove	= qsp_uart_remove,
+	.driver	= {
+		.name		= DRV_NAME,
+		.owner		= THIS_MODULE,
+		.of_match_table	= of_match_ptr(qsp_uart_match),
+	},
+};
+
+static int __init qsp_uart_init(void)
+{
+	int rc;
+	rc = uart_register_driver(&qsp_uart_driver);
+	if (rc) {
+		pr_err(DRV_NAME "Failed to register uart driver.\n");
+		return rc;
+	}
+
+	rc = platform_driver_register(&qsp_uart_platform_driver);
+	if (rc) {
+		pr_err(DRV_NAME "Failed to register platform driver.\n");
+		uart_unregister_driver(&qsp_uart_driver);
+	}
+	return rc;
+}
+
+static void __exit qsp_uart_exit(void)
+{
+	platform_driver_unregister(&qsp_uart_platform_driver);
+	uart_unregister_driver(&qsp_uart_driver);
+}
+
+module_init(qsp_uart_init);
+module_exit(qsp_uart_exit);
+
+MODULE_DESCRIPTION("QSP UART driver");
+MODULE_AUTHOR("Ivar Holmqvist <ivarholmqvist@gmail.com>");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:" DRV_NAME);
+MODULE_ALIAS_CHARDEV_MAJOR(SERIAL_QSP_MAJOR);
diff -ruN linux-3.10/include/linux/qsp/qsp_clk.h linux-3.10_patched/include/linux/qsp/qsp_clk.h
--- linux-3.10/include/linux/qsp/qsp_clk.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.10_patched/include/linux/qsp/qsp_clk.h	2025-06-14 05:48:04.977173245 +0000
@@ -0,0 +1,27 @@
+/*
+ *  Copyright 2012 Wind River, Inc
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef __LINUX_QSP_CLK_H
+#define __LINUX_QSP_CLK_H
+
+#include <linux/clocksource.h>
+
+void qsp_timer_init_one(int irq, void __iomem *base);
+cycle_t qsp_read(struct clocksource *cs);
+
+#endif /* __LINUX_QSP_PIC_H */
diff -ruN linux-3.10/include/linux/qsp/qsp.h linux-3.10_patched/include/linux/qsp/qsp.h
--- linux-3.10/include/linux/qsp/qsp.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.10_patched/include/linux/qsp/qsp.h	2025-06-14 05:48:04.977173245 +0000
@@ -0,0 +1,49 @@
+/*
+ *  Copyright 2012 Wind River, Inc
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef __LINUX_QSP_H
+#define __LINUX_QSP_H
+
+#define QSP_ID_VAL 0x12340000
+
+#define QSP_PIC_ID_VAL     (QSP_ID_VAL | 0x0001)
+#define QSP_SERIAL_ID_VAL  (QSP_ID_VAL | 0x0002)
+#define QSP_BLK_ID_VAL     (QSP_ID_VAL | 0x0003)
+#define QSP_RTC_ID_VAL     (QSP_ID_VAL | 0x0004)
+#define QSP_LED_ID_VAL     (QSP_ID_VAL | 0x0005)
+#define QSP_NET_ID_VAL     (QSP_ID_VAL | 0x0006)
+#define QSP_TIMER_ID_VAL   (QSP_ID_VAL | 0x0007)
+#define QSP_SYSREGS_ID_VAL (QSP_ID_VAL | 0x0008)
+#define QSP_FLASH_ID_VAL   (QSP_ID_VAL | 0x0009)
+#define QSP_PROBE_ID_VAL   (QSP_ID_VAL | 0x9999)
+
+
+static inline int qsp_device_valid(unsigned char __iomem *addr, int device_id)
+{
+	int id = readl(addr);
+	if (id == QSP_PROBE_ID_VAL) {
+		pr_debug("Device id is probe (%x != %x)\n", id, device_id);
+		return -EINVAL;
+	} else if (id != device_id) {
+		pr_warn("Device id is wrong (%x != %x)\n", id, device_id);
+		return -EINVAL;
+	} else
+		return 0;
+}
+
+#endif /* __LINUX_QSP_H */
diff -ruN linux-3.10/include/linux/qsp/qsp_pic.h linux-3.10_patched/include/linux/qsp/qsp_pic.h
--- linux-3.10/include/linux/qsp/qsp_pic.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.10_patched/include/linux/qsp/qsp_pic.h	2025-06-14 05:48:04.977173245 +0000
@@ -0,0 +1,47 @@
+/*
+ *  Copyright 2012 Wind River, Inc
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef __LINUX_QSP_PIC_H
+#define __LINUX_QSP_PIC_H
+
+void  qsp_pic_init(void);
+unsigned int qsp_pic_get_irq(void);
+
+#ifdef CONFIG_SMP
+void qsp_pic_message_pass(int cpu, int msg);
+void smp_qsp_pic_setup_cpu(int cpu);
+int __init smp_qsp_pic_probe(void);
+void qsp_ipi_eoi(int irq);
+
+#define IPI_BASE 128
+#ifdef CONFIG_ARM
+/* FIXME: */
+// ipi_msg_type for ARM begins from IPI_TIMER = 2 to IPI_CPU_STOP = 6
+// then our IPI_NUM_TYPES needs to be 7. 7 is fine for the irq number limit
+// in pic model
+#define IPI_NUM_TYPES 7
+#else
+#define IPI_NUM_TYPES 4
+#endif
+#define IPI_NR(cpu, type) (IPI_BASE+(cpu)*IPI_NUM_TYPES+type)
+#define IPI_GET_CPU(vipi) (((vipi)-IPI_BASE)/IPI_NUM_TYPES)
+#define IPI_GET_MSG(vipi) (((vipi)-IPI_BASE)%IPI_NUM_TYPES)
+
+#endif
+
+#endif /* __LINUX_QSP_PIC_H */
diff -ruN linux-3.10/include/linux/serial_core.h linux-3.10_patched/include/linux/serial_core.h
--- linux-3.10/include/linux/serial_core.h	2013-06-30 22:13:29.000000000 +0000
+++ linux-3.10_patched/include/linux/serial_core.h	2025-06-14 05:48:04.977173245 +0000
@@ -19,6 +19,7 @@
  */
 #ifndef LINUX_SERIAL_CORE_H
 #define LINUX_SERIAL_CORE_H
+#define PORT_QSP_UART  101
 
 
 #include <linux/compiler.h>
diff -ruN linux-3.10/README linux-3.10_patched/README
--- linux-3.10/README	2013-06-30 22:13:29.000000000 +0000
+++ linux-3.10_patched/README	2025-06-14 05:48:04.977173245 +0000
@@ -1,412 +1,13 @@
-        Linux kernel release 3.x <http://kernel.org/>
-
-These are the release notes for Linux version 3.  Read them carefully,
-as they tell you what this is all about, explain how to install the
-kernel, and what to do if something goes wrong. 
-
-WHAT IS LINUX?
-
-  Linux is a clone of the operating system Unix, written from scratch by
-  Linus Torvalds with assistance from a loosely-knit team of hackers across
-  the Net. It aims towards POSIX and Single UNIX Specification compliance.
-
-  It has all the features you would expect in a modern fully-fledged Unix,
-  including true multitasking, virtual memory, shared libraries, demand
-  loading, shared copy-on-write executables, proper memory management,
-  and multistack networking including IPv4 and IPv6.
-
-  It is distributed under the GNU General Public License - see the
-  accompanying COPYING file for more details. 
-
-ON WHAT HARDWARE DOES IT RUN?
-
-  Although originally developed first for 32-bit x86-based PCs (386 or higher),
-  today Linux also runs on (at least) the Compaq Alpha AXP, Sun SPARC and
-  UltraSPARC, Motorola 68000, PowerPC, PowerPC64, ARM, Hitachi SuperH, Cell,
-  IBM S/390, MIPS, HP PA-RISC, Intel IA-64, DEC VAX, AMD x86-64, AXIS CRIS,
-  Xtensa, Tilera TILE, AVR32 and Renesas M32R architectures.
-
-  Linux is easily portable to most general-purpose 32- or 64-bit architectures
-  as long as they have a paged memory management unit (PMMU) and a port of the
-  GNU C compiler (gcc) (part of The GNU Compiler Collection, GCC). Linux has
-  also been ported to a number of architectures without a PMMU, although
-  functionality is then obviously somewhat limited.
-  Linux has also been ported to itself. You can now run the kernel as a
-  userspace application - this is called UserMode Linux (UML).
-
-DOCUMENTATION:
-
- - There is a lot of documentation available both in electronic form on
-   the Internet and in books, both Linux-specific and pertaining to
-   general UNIX questions.  I'd recommend looking into the documentation
-   subdirectories on any Linux FTP site for the LDP (Linux Documentation
-   Project) books.  This README is not meant to be documentation on the
-   system: there are much better sources available.
-
- - There are various README files in the Documentation/ subdirectory:
-   these typically contain kernel-specific installation notes for some 
-   drivers for example. See Documentation/00-INDEX for a list of what
-   is contained in each file.  Please read the Changes file, as it
-   contains information about the problems, which may result by upgrading
-   your kernel.
-
- - The Documentation/DocBook/ subdirectory contains several guides for
-   kernel developers and users.  These guides can be rendered in a
-   number of formats:  PostScript (.ps), PDF, HTML, & man-pages, among others.
-   After installation, "make psdocs", "make pdfdocs", "make htmldocs",
-   or "make mandocs" will render the documentation in the requested format.
-
-INSTALLING the kernel source:
-
- - If you install the full sources, put the kernel tarball in a
-   directory where you have permissions (eg. your home directory) and
-   unpack it:
-
-     gzip -cd linux-3.X.tar.gz | tar xvf -
-
-   or
-
-     bzip2 -dc linux-3.X.tar.bz2 | tar xvf -
-
-   Replace "X" with the version number of the latest kernel.
-
-   Do NOT use the /usr/src/linux area! This area has a (usually
-   incomplete) set of kernel headers that are used by the library header
-   files.  They should match the library, and not get messed up by
-   whatever the kernel-du-jour happens to be.
-
- - You can also upgrade between 3.x releases by patching.  Patches are
-   distributed in the traditional gzip and the newer bzip2 format.  To
-   install by patching, get all the newer patch files, enter the
-   top level directory of the kernel source (linux-3.X) and execute:
-
-     gzip -cd ../patch-3.x.gz | patch -p1
-
-   or
-
-     bzip2 -dc ../patch-3.x.bz2 | patch -p1
-
-   Replace "x" for all versions bigger than the version "X" of your current
-   source tree, _in_order_, and you should be ok.  You may want to remove
-   the backup files (some-file-name~ or some-file-name.orig), and make sure
-   that there are no failed patches (some-file-name# or some-file-name.rej).
-   If there are, either you or I have made a mistake.
-
-   Unlike patches for the 3.x kernels, patches for the 3.x.y kernels
-   (also known as the -stable kernels) are not incremental but instead apply
-   directly to the base 3.x kernel.  For example, if your base kernel is 3.0
-   and you want to apply the 3.0.3 patch, you must not first apply the 3.0.1
-   and 3.0.2 patches. Similarly, if you are running kernel version 3.0.2 and
-   want to jump to 3.0.3, you must first reverse the 3.0.2 patch (that is,
-   patch -R) _before_ applying the 3.0.3 patch. You can read more on this in
-   Documentation/applying-patches.txt
-
-   Alternatively, the script patch-kernel can be used to automate this
-   process.  It determines the current kernel version and applies any
-   patches found.
-
-     linux/scripts/patch-kernel linux
-
-   The first argument in the command above is the location of the
-   kernel source.  Patches are applied from the current directory, but
-   an alternative directory can be specified as the second argument.
-
- - Make sure you have no stale .o files and dependencies lying around:
-
-     cd linux
-     make mrproper
-
-   You should now have the sources correctly installed.
-
-SOFTWARE REQUIREMENTS
-
-   Compiling and running the 3.x kernels requires up-to-date
-   versions of various software packages.  Consult
-   Documentation/Changes for the minimum version numbers required
-   and how to get updates for these packages.  Beware that using
-   excessively old versions of these packages can cause indirect
-   errors that are very difficult to track down, so don't assume that
-   you can just update packages when obvious problems arise during
-   build or operation.
-
-BUILD directory for the kernel:
-
-   When compiling the kernel, all output files will per default be
-   stored together with the kernel source code.
-   Using the option "make O=output/dir" allow you to specify an alternate
-   place for the output files (including .config).
-   Example:
-
-     kernel source code: /usr/src/linux-3.X
-     build directory:    /home/name/build/kernel
-
-   To configure and build the kernel, use:
-
-     cd /usr/src/linux-3.X
-     make O=/home/name/build/kernel menuconfig
-     make O=/home/name/build/kernel
-     sudo make O=/home/name/build/kernel modules_install install
-
-   Please note: If the 'O=output/dir' option is used, then it must be
-   used for all invocations of make.
-
-CONFIGURING the kernel:
-
-   Do not skip this step even if you are only upgrading one minor
-   version.  New configuration options are added in each release, and
-   odd problems will turn up if the configuration files are not set up
-   as expected.  If you want to carry your existing configuration to a
-   new version with minimal work, use "make oldconfig", which will
-   only ask you for the answers to new questions.
-
- - Alternative configuration commands are:
-
-     "make config"      Plain text interface.
-
-     "make menuconfig"  Text based color menus, radiolists & dialogs.
-
-     "make nconfig"     Enhanced text based color menus.
-
-     "make xconfig"     X windows (Qt) based configuration tool.
-
-     "make gconfig"     X windows (Gtk) based configuration tool.
-
-     "make oldconfig"   Default all questions based on the contents of
-                        your existing ./.config file and asking about
-                        new config symbols.
-
-     "make silentoldconfig"
-                        Like above, but avoids cluttering the screen
-                        with questions already answered.
-                        Additionally updates the dependencies.
-
-     "make olddefconfig"
-                        Like above, but sets new symbols to their default
-                        values without prompting.
-
-     "make defconfig"   Create a ./.config file by using the default
-                        symbol values from either arch/$ARCH/defconfig
-                        or arch/$ARCH/configs/${PLATFORM}_defconfig,
-                        depending on the architecture.
-
-     "make ${PLATFORM}_defconfig"
-                        Create a ./.config file by using the default
-                        symbol values from
-                        arch/$ARCH/configs/${PLATFORM}_defconfig.
-                        Use "make help" to get a list of all available
-                        platforms of your architecture.
-
-     "make allyesconfig"
-                        Create a ./.config file by setting symbol
-                        values to 'y' as much as possible.
-
-     "make allmodconfig"
-                        Create a ./.config file by setting symbol
-                        values to 'm' as much as possible.
-
-     "make allnoconfig" Create a ./.config file by setting symbol
-                        values to 'n' as much as possible.
-
-     "make randconfig"  Create a ./.config file by setting symbol
-                        values to random values.
-
-     "make localmodconfig" Create a config based on current config and
-                           loaded modules (lsmod). Disables any module
-                           option that is not needed for the loaded modules.
-
-                           To create a localmodconfig for another machine,
-                           store the lsmod of that machine into a file
-                           and pass it in as a LSMOD parameter.
-
-                   target$ lsmod > /tmp/mylsmod
-                   target$ scp /tmp/mylsmod host:/tmp
-
-                   host$ make LSMOD=/tmp/mylsmod localmodconfig
-
-                           The above also works when cross compiling.
-
-     "make localyesconfig" Similar to localmodconfig, except it will convert
-                           all module options to built in (=y) options.
-
-   You can find more information on using the Linux kernel config tools
-   in Documentation/kbuild/kconfig.txt.
-
- - NOTES on "make config":
-
-    - Having unnecessary drivers will make the kernel bigger, and can
-      under some circumstances lead to problems: probing for a
-      nonexistent controller card may confuse your other controllers
-
-    - Compiling the kernel with "Processor type" set higher than 386
-      will result in a kernel that does NOT work on a 386.  The
-      kernel will detect this on bootup, and give up.
-
-    - A kernel with math-emulation compiled in will still use the
-      coprocessor if one is present: the math emulation will just
-      never get used in that case.  The kernel will be slightly larger,
-      but will work on different machines regardless of whether they
-      have a math coprocessor or not.
-
-    - The "kernel hacking" configuration details usually result in a
-      bigger or slower kernel (or both), and can even make the kernel
-      less stable by configuring some routines to actively try to
-      break bad code to find kernel problems (kmalloc()).  Thus you
-      should probably answer 'n' to the questions for "development",
-      "experimental", or "debugging" features.
-
-COMPILING the kernel:
-
- - Make sure you have at least gcc 3.2 available.
-   For more information, refer to Documentation/Changes.
-
-   Please note that you can still run a.out user programs with this kernel.
-
- - Do a "make" to create a compressed kernel image. It is also
-   possible to do "make install" if you have lilo installed to suit the
-   kernel makefiles, but you may want to check your particular lilo setup first.
-
-   To do the actual install, you have to be root, but none of the normal
-   build should require that. Don't take the name of root in vain.
-
- - If you configured any of the parts of the kernel as `modules', you
-   will also have to do "make modules_install".
-
- - Verbose kernel compile/build output:
-
-   Normally, the kernel build system runs in a fairly quiet mode (but not
-   totally silent).  However, sometimes you or other kernel developers need
-   to see compile, link, or other commands exactly as they are executed.
-   For this, use "verbose" build mode.  This is done by inserting
-   "V=1" in the "make" command.  E.g.:
-
-     make V=1 all
-
-   To have the build system also tell the reason for the rebuild of each
-   target, use "V=2".  The default is "V=0".
-
- - Keep a backup kernel handy in case something goes wrong.  This is 
-   especially true for the development releases, since each new release
-   contains new code which has not been debugged.  Make sure you keep a
-   backup of the modules corresponding to that kernel, as well.  If you
-   are installing a new kernel with the same version number as your
-   working kernel, make a backup of your modules directory before you
-   do a "make modules_install".
-
-   Alternatively, before compiling, use the kernel config option
-   "LOCALVERSION" to append a unique suffix to the regular kernel version.
-   LOCALVERSION can be set in the "General Setup" menu.
-
- - In order to boot your new kernel, you'll need to copy the kernel
-   image (e.g. .../linux/arch/i386/boot/bzImage after compilation)
-   to the place where your regular bootable kernel is found. 
-
- - Booting a kernel directly from a floppy without the assistance of a
-   bootloader such as LILO, is no longer supported.
-
-   If you boot Linux from the hard drive, chances are you use LILO, which
-   uses the kernel image as specified in the file /etc/lilo.conf.  The
-   kernel image file is usually /vmlinuz, /boot/vmlinuz, /bzImage or
-   /boot/bzImage.  To use the new kernel, save a copy of the old image
-   and copy the new image over the old one.  Then, you MUST RERUN LILO
-   to update the loading map!! If you don't, you won't be able to boot
-   the new kernel image.
-
-   Reinstalling LILO is usually a matter of running /sbin/lilo. 
-   You may wish to edit /etc/lilo.conf to specify an entry for your
-   old kernel image (say, /vmlinux.old) in case the new one does not
-   work.  See the LILO docs for more information. 
-
-   After reinstalling LILO, you should be all set.  Shutdown the system,
-   reboot, and enjoy!
-
-   If you ever need to change the default root device, video mode,
-   ramdisk size, etc.  in the kernel image, use the 'rdev' program (or
-   alternatively the LILO boot options when appropriate).  No need to
-   recompile the kernel to change these parameters. 
-
- - Reboot with the new kernel and enjoy. 
-
-IF SOMETHING GOES WRONG:
-
- - If you have problems that seem to be due to kernel bugs, please check
-   the file MAINTAINERS to see if there is a particular person associated
-   with the part of the kernel that you are having trouble with. If there
-   isn't anyone listed there, then the second best thing is to mail
-   them to me (torvalds@linux-foundation.org), and possibly to any other
-   relevant mailing-list or to the newsgroup.
-
- - In all bug-reports, *please* tell what kernel you are talking about,
-   how to duplicate the problem, and what your setup is (use your common
-   sense).  If the problem is new, tell me so, and if the problem is
-   old, please try to tell me when you first noticed it.
-
- - If the bug results in a message like
-
-     unable to handle kernel paging request at address C0000010
-     Oops: 0002
-     EIP:   0010:XXXXXXXX
-     eax: xxxxxxxx   ebx: xxxxxxxx   ecx: xxxxxxxx   edx: xxxxxxxx
-     esi: xxxxxxxx   edi: xxxxxxxx   ebp: xxxxxxxx
-     ds: xxxx  es: xxxx  fs: xxxx  gs: xxxx
-     Pid: xx, process nr: xx
-     xx xx xx xx xx xx xx xx xx xx
-
-   or similar kernel debugging information on your screen or in your
-   system log, please duplicate it *exactly*.  The dump may look
-   incomprehensible to you, but it does contain information that may
-   help debugging the problem.  The text above the dump is also
-   important: it tells something about why the kernel dumped code (in
-   the above example, it's due to a bad kernel pointer). More information
-   on making sense of the dump is in Documentation/oops-tracing.txt
-
- - If you compiled the kernel with CONFIG_KALLSYMS you can send the dump
-   as is, otherwise you will have to use the "ksymoops" program to make
-   sense of the dump (but compiling with CONFIG_KALLSYMS is usually preferred).
-   This utility can be downloaded from
-   ftp://ftp.<country>.kernel.org/pub/linux/utils/kernel/ksymoops/ .
-   Alternatively, you can do the dump lookup by hand:
-
- - In debugging dumps like the above, it helps enormously if you can
-   look up what the EIP value means.  The hex value as such doesn't help
-   me or anybody else very much: it will depend on your particular
-   kernel setup.  What you should do is take the hex value from the EIP
-   line (ignore the "0010:"), and look it up in the kernel namelist to
-   see which kernel function contains the offending address.
-
-   To find out the kernel function name, you'll need to find the system
-   binary associated with the kernel that exhibited the symptom.  This is
-   the file 'linux/vmlinux'.  To extract the namelist and match it against
-   the EIP from the kernel crash, do:
-
-     nm vmlinux | sort | less
-
-   This will give you a list of kernel addresses sorted in ascending
-   order, from which it is simple to find the function that contains the
-   offending address.  Note that the address given by the kernel
-   debugging messages will not necessarily match exactly with the
-   function addresses (in fact, that is very unlikely), so you can't
-   just 'grep' the list: the list will, however, give you the starting
-   point of each kernel function, so by looking for the function that
-   has a starting address lower than the one you are searching for but
-   is followed by a function with a higher address you will find the one
-   you want.  In fact, it may be a good idea to include a bit of
-   "context" in your problem report, giving a few lines around the
-   interesting one. 
-
-   If you for some reason cannot do the above (you have a pre-compiled
-   kernel image or similar), telling me as much about your setup as
-   possible will help.  Please read the REPORTING-BUGS document for details.
-
- - Alternatively, you can use gdb on a running kernel. (read-only; i.e. you
-   cannot change values or set break points.) To do this, first compile the
-   kernel with -g; edit arch/i386/Makefile appropriately, then do a "make
-   clean". You'll also need to enable CONFIG_PROC_FS (via "make config").
-
-   After you've rebooted with the new kernel, do "gdb vmlinux /proc/kcore".
-   You can now use all the usual gdb commands. The command to look up the
-   point where your system crashed is "l *0xXXXXXXXX". (Replace the XXXes
-   with the EIP value.)
-
-   gdb'ing a non-running kernel currently fails because gdb (wrongly)
-   disregards the starting offset for which the kernel is compiled.
+Linux files for version 3.10 QSP platforms
+These are the files as they are to exist in the build directory after applying the patch.
+The purpose of this directory is to let us create the patch file for use in a rebuild.
+For example, after the linux 3.10 is pulled into the output/build/ directory:
+   cp -aR 3.10_patches /tmp/
+   cp -aR linux-3.10 /tmp
+   cd /tmp
+   cp -aR linux-3.10 linux-3.10_patched
+   cp -aR 3.10_patches/* linux-3.10_patched/
+   diff -ruN linux-3.10 linux-3.10_patched > patch_file.patch
 
+Then the patch_file copied via the qsp_buildroot.sh script so it gets
+applied during the build process.
