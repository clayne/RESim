diff -pNur buildroot.2014.08/board/windriver/qsp_fs_post.sh buildroot/board/windriver/qsp_fs_post.sh
--- buildroot.2014.08/board/windriver/qsp_fs_post.sh	1970-01-01 07:00:00.000000000 +0700
+++ buildroot/board/windriver/qsp_fs_post.sh	2014-12-09 13:19:53.685729699 +0800
@@ -0,0 +1,15 @@
+#/bin/sh
+cd $1
+if [ ! -e host ]; then
+    mkdir host
+fi
+
+grep simicsfs etc/fstab
+if [ $? = 1 ]; then
+    echo "simicsfs	/host	       simicsfs    defaults,noauto	  0	0" >> etc/fstab
+fi
+
+grep qspdc1 etc/fstab
+if [ $? = 1 ]; then
+    echo "/dev/qspdc1	/mnt	       ext2        defaults	  0	0" >> etc/fstab
+fi
diff -pNur buildroot.2014.08/board/windriver/qsp-ppc/linux-0001-simicsfs-Add-simics-hostfs-1.14.patch buildroot/board/windriver/qsp-ppc/linux-0001-simicsfs-Add-simics-hostfs-1.14.patch
--- buildroot.2014.08/board/windriver/qsp-ppc/linux-0001-simicsfs-Add-simics-hostfs-1.14.patch	1970-01-01 07:00:00.000000000 +0700
+++ buildroot/board/windriver/qsp-ppc/linux-0001-simicsfs-Add-simics-hostfs-1.14.patch	2014-12-09 13:19:53.705729700 +0800
@@ -0,0 +1,2223 @@
+From 0f52053b3b3de90039a5c359c37ffe1c3f16644c Mon Sep 17 00:00:00 2001
+From: Ivar Holmqvist <ivarholmqvist@gmail.com>
+Date: Tue, 17 Apr 2012 17:12:54 +0200
+Subject: [PATCH] simicsfs: Add simics hostfs 1.14.
+
+---
+ fs/Kconfig                 |    1 +
+ fs/Makefile                |    1 +
+ fs/simicsfs/Kconfig        |   18 ++
+ fs/simicsfs/Makefile       |   11 +
+ fs/simicsfs/hostfs.h       |  263 ++++++++++++++++
+ fs/simicsfs/hostfs_data.h  |  355 +++++++++++++++++++++
+ fs/simicsfs/hostfs_dir.c   |   77 +++++
+ fs/simicsfs/hostfs_file.c  |  150 +++++++++
+ fs/simicsfs/hostfs_host.c  |  163 ++++++++++
+ fs/simicsfs/hostfs_inode.c |  748 ++++++++++++++++++++++++++++++++++++++++++++
+ fs/simicsfs/hostfs_linux.h |  143 +++++++++
+ fs/simicsfs/hostfs_super.c |  191 +++++++++++
+ 12 files changed, 2121 insertions(+)
+
+diff --git a/fs/Kconfig b/fs/Kconfig
+index f95ae3a..2a67f5d 100644
+--- a/fs/Kconfig
++++ b/fs/Kconfig
+@@ -220,6 +220,7 @@ source "fs/pstore/Kconfig"
+ source "fs/sysv/Kconfig"
+ source "fs/ufs/Kconfig"
+ source "fs/exofs/Kconfig"
++source "fs/simicsfs/Kconfig"
+ 
+ endif # MISC_FILESYSTEMS
+ 
+diff --git a/fs/Makefile b/fs/Makefile
+index 2fb9779..a9b00d8 100644
+--- a/fs/Makefile
++++ b/fs/Makefile
+@@ -125,3 +125,4 @@ obj-$(CONFIG_GFS2_FS)           += gfs2/
+ obj-y				+= exofs/ # Multiple modules
+ obj-$(CONFIG_CEPH_FS)		+= ceph/
+ obj-$(CONFIG_PSTORE)		+= pstore/
++obj-$(CONFIG_SIMICSFS)		+= simicsfs/
+diff --git a/fs/simicsfs/Kconfig b/fs/simicsfs/Kconfig
+new file mode 100644
+index 0000000..801ba83
+--- /dev/null
++++ b/fs/simicsfs/Kconfig
+@@ -0,0 +1,18 @@
++config SIMICSFS
++       tristate "Simics hostfs"
++       help
++          This filesystem allows Simics to acces the host filesystem.
++
++          To compile this file system support as a module, choose M here. The
++          module will be called simicsfs.
++
++          If unsure, say N.
++
++config SIMICSFS_ADDRESS
++       string "SimicsFS physical address"
++       depends on SIMICSFS
++       help
++          The default address at which the Simics hostfs module is mapped.
++          Can be overriden by setting the phys_addr module parameter.
++
++          If you are not sure, leave it blank.
+diff --git a/fs/simicsfs/Makefile b/fs/simicsfs/Makefile
+new file mode 100644
+index 0000000..d1168f7
+--- /dev/null
++++ b/fs/simicsfs/Makefile
+@@ -0,0 +1,11 @@
++#
++# Makefile for Simics hostfs
++
++ifeq (,$(CONFIG_SIMICSFS))
++CONFIG_SIMICSFS=m
++endif
++
++obj-$(CONFIG_SIMICSFS) += simicsfs.o
++
++simicsfs-objs := hostfs_inode.o hostfs_super.o hostfs_dir.o hostfs_file.o \
++	hostfs_host.o
+diff --git a/fs/simicsfs/hostfs.h b/fs/simicsfs/hostfs.h
+new file mode 100644
+index 0000000..a60f855
+--- /dev/null
++++ b/fs/simicsfs/hostfs.h
+@@ -0,0 +1,263 @@
++/*
++   hostfs for Linux
++   Copyright 2001-2006 Virtutech AB
++
++   This program is free software; you can redistribute it and/or modify
++   it under the terms of the GNU General Public License as published by
++   the Free Software Foundation; either version 2 of the License, or
++   (at your option) any later version.
++
++   This program is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
++   NON INFRINGEMENT.  See the GNU General Public License for more details.
++
++   You should have received a copy of the GNU General Public License
++   along with this program; if not, write to the Free Software
++   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
++*/
++
++#ifndef _HOST_FS_H
++#define _HOST_FS_H
++
++#define HOSTFS_VERSION 1
++#define HOSTFS_SUBVERSION 14 /* update before release, reset to 99 when done */
++
++#if defined(__powerpc__)
++ #define HOSTFS_DEV    0xff660000
++#elif defined(__arm__)
++ #define HOSTFS_DEV    0x50000000
++#elif defined(__mips__)
++ #define HOSTFS_DEV    0x1c000000
++#else
++ #define HOSTFS_DEV    0xffe81000
++#endif
++
++#define HOSTFS_MAGIC 0x66685456 		/* "VThf" */
++
++#define DATA_BUF_LEN        1040
++#define HOSTFS_FILENAME_LEN  512
++#define DEBUG_LEN           1024
++#define XFER_DATA_WORDS      256 /* 1024/4 */
++
++#define SYMBOL_TO_STRING2(n) #n
++#define SYMBOL_TO_STRING(n) SYMBOL_TO_STRING2(n)
++
++/* used on target */
++#define DPRINTF_0 printk
++#define DPRINTF_1 if (hostfs_debug >= 1) printf
++#define DPRINTF_2 if (hostfs_debug >= 2) printf
++
++enum {
++        HF_FREAD   = 0x01,
++        HF_FWRITE  = 0x02,
++        HF_FNDELAY = 0x04,
++        HF_FAPPEND = 0x08,
++        HF_FSYNC   = 0x10
++};
++
++/* identifies a host file for the filesystem */
++typedef uint host_node_t;
++
++/* only in target part */
++extern dev_t hostfs_dev;
++extern int hostfs_debug;
++
++struct hf_node;
++typedef struct hf_node hf_node_t;
++
++typedef enum host_func {
++        hf_VfsStat,
++        hf_Root,
++        hf_GetAttr,
++        hf_SetAttr,
++        hf_Open,
++        hf_Close,
++        hf_Readdir,
++        hf_Lookup,
++        hf_Seek,
++        hf_Read,
++        hf_Write,
++        hf_Create,
++        hf_Remove,
++        hf_MkDir,
++        hf_Parent,
++        hf_Rename,
++        hf_Link,
++        hf_Symlink,
++        hf_Readlink,
++        hf_Debug,
++        hf_Handshake,
++        hf_Unmount,
++        hf_Functions
++} host_func_t;
++
++typedef struct host_funcs {
++        host_func_t func;
++        const char *name;
++        int out;
++        int in;
++        int ie_out;
++        int ie_in;
++} host_funcs_t;
++
++/*********
++ *
++ *IMPORTANT:
++ * If you change the parameters make sure the ie_out and ie_in are still
++ * correct. They signal the first entry to do endian conversion on.
++ * -1 is no conversion at all.
++ *
++ */
++
++struct hf_common_data {
++        uint sys_error;
++};
++
++struct hf_hnode_data {
++        uint sys_error;
++        uint hnode;
++        uint type;
++};
++
++struct hf_vfsstat_data {
++        uint bsize;
++        uint frsize;
++        uint blocks;
++        uint bfree;
++        uint bavail;
++        uint files;
++        uint ffree;
++        uint favail;
++};
++
++struct hf_getattr_data {
++        uint sys_error;
++        uint mode;      /* access mode */
++        uint uid;       /* user id */
++        uint gid;       /* group id */
++        uint link;      /* number of references */
++        uint size_hi;   /* file size */
++        uint size_lo;   
++        uint atime_hi;  /* access time */
++        uint atime_lo;  
++        uint mtime_hi;  /* modification time */
++        uint mtime_lo;  
++        uint ctime_hi;  /* creation time */
++        uint ctime_lo;  
++        uint blksize;   /* fundamental block size */
++        uint blocks_hi; /* blocks allocated */
++        uint blocks_lo; 
++};
++
++struct hf_setattr_data {
++        uint set_atime;
++        uint set_mtime;
++        uint set_mode;
++        uint set_uid;
++        uint set_gid;
++        uint atime_hi;  /* access time */
++        uint atime_lo;  
++        uint mtime_hi;  /* modification time */
++        uint mtime_lo;
++        uint mode;
++        uint uid;
++        uint gid;
++        uint set_size;
++        uint size_hi;
++        uint size_lo;
++};
++
++struct hf_setattr_data_v0 {
++        uint set_atime;
++        uint set_mtime;
++        uint set_mode;
++        uint set_uid;
++        uint set_gid;
++        uint atime_hi;  /* access time */
++        uint atime_lo;  
++        uint mtime_hi;  /* modification time */
++        uint mtime_lo;
++        uint mode;
++        uint uid;
++        uint gid;
++};
++
++struct hf_readdir_data {
++        uint sys_error;
++        host_node_t hnode;
++        char filename[HOSTFS_FILENAME_LEN];
++};
++
++struct hf_readlink_data {
++        uint sys_error;
++        char filename[HOSTFS_FILENAME_LEN];
++};
++
++struct hf_lookup_data {
++        char filename[HOSTFS_FILENAME_LEN];
++};
++
++struct hf_remove_data {
++        char filename[HOSTFS_FILENAME_LEN];
++};
++
++struct hf_rename_data {
++        uint new_hnode;
++        char old_name[HOSTFS_FILENAME_LEN];
++        char new_name[HOSTFS_FILENAME_LEN];
++};
++
++struct hf_create_data {
++        uint excl;
++        uint trunc;
++        uint mode;
++        char filename[HOSTFS_FILENAME_LEN];
++};
++
++struct hf_mkdir_data {
++        uint mode;
++        char dirname[HOSTFS_FILENAME_LEN];
++};
++
++struct hf_seek_data {
++        uint off_hi;
++        uint off_lo;
++};
++
++struct hf_read_data {
++        uint sys_error;
++        uint size;
++        uint data[XFER_DATA_WORDS]; /* max 480 bytes of data */
++};
++
++struct hf_write_data {
++        uint size;
++        uint append;
++        uint data[XFER_DATA_WORDS]; /* max 480 bytes of data */
++};
++
++struct hf_link_data {
++        uint hnode;
++        char link[HOSTFS_FILENAME_LEN];
++};
++
++struct hf_symlink_data {
++        char target[HOSTFS_FILENAME_LEN];
++        char link[HOSTFS_FILENAME_LEN];
++};
++
++struct hf_debug_data {
++        char string[DEBUG_LEN];
++};
++
++struct hf_handshake_data {
++        uint version;
++};
++
++struct hf_handshake_reply_data {
++        uint sys_error;
++        uint magic;
++};
++
++#endif /* _HOST_FS_H */
+diff --git a/fs/simicsfs/hostfs_data.h b/fs/simicsfs/hostfs_data.h
+new file mode 100644
+index 0000000..1e69558
+--- /dev/null
++++ b/fs/simicsfs/hostfs_data.h
+@@ -0,0 +1,355 @@
++/*
++   hostfs for Linux
++   Copyright 2001 - 2006 Virtutech AB
++
++   This program is free software; you can redistribute it and/or modify
++   it under the terms of the GNU General Public License as published by
++   the Free Software Foundation; either version 2 of the License, or
++   (at your option) any later version.
++
++   This program is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
++   NON INFRINGEMENT.  See the GNU General Public License for more details.
++
++   You should have received a copy of the GNU General Public License
++   along with this program; if not, write to the Free Software
++   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
++*/
++
++#ifndef _HOST_FS_DATA_H
++#define _HOST_FS_DATA_H
++
++/* WARNING: Only include once. Contains definitions */
++
++/* when transferring data the following protocol is used:
++ *
++ *   to host:  4 byte  function
++ *   to host:  4 bytes hnode
++ *   to host:  X bytes out data (defined by fkn_len[fkn].out)
++ * from host:  X bytes in data  (defined by fkn_len[fkn].in)  ( X > 0 !!! )
++ *
++ */
++
++static host_funcs_t host_funcs[] = {
++        { hf_VfsStat,
++          "VfsStat",
++          0,
++          sizeof(struct hf_vfsstat_data) >> 2,
++          -1,
++          -1 },
++
++        { hf_Root,
++          "Root",
++          0,
++          sizeof(struct hf_hnode_data) >> 2,
++          -1,
++          -1 },
++
++        { hf_GetAttr,
++          "GetAttr",
++          0,
++          sizeof(struct hf_getattr_data) >> 2,
++          -1,
++          -1 },
++
++        { hf_SetAttr,
++          "SetAttr",
++          sizeof(struct hf_setattr_data) >> 2,
++          sizeof(struct hf_common_data) >> 2,
++          -1,
++          -1 },
++
++        { hf_Open,
++          "Open",
++          1,
++          sizeof(struct hf_common_data) >> 2,
++          -1,
++          -1 },
++
++        { hf_Close,
++          "Close",
++          0,
++          1,
++          -1,
++          -1 },
++
++        { hf_Readdir,
++          "Readdir",
++          1,
++          sizeof(struct hf_readdir_data) >> 2,
++          -1,
++          2 },
++
++        { hf_Lookup,
++          "Lookup",
++          sizeof(struct hf_lookup_data),
++          sizeof(struct hf_hnode_data) >> 2,
++          0,
++          -1 },
++
++        { hf_Seek,
++          "Seek",
++          sizeof(struct hf_seek_data) >> 2,
++          sizeof(struct hf_common_data) >> 2,
++          -1,
++          -1 },
++
++        { hf_Read,
++          "Read",
++          1,
++          sizeof(struct hf_read_data) >> 2,
++          -1,
++          2 },
++
++        { hf_Write,
++          "Write",
++          sizeof(struct hf_write_data) >> 2,
++          sizeof(struct hf_common_data) >> 2,
++          2,
++          -1 },
++
++        { hf_Create,
++          "Create",
++          sizeof(struct hf_create_data) >> 2,
++          sizeof(struct hf_hnode_data) >> 2,
++          3,
++          -1 },
++
++        { hf_Remove,
++          "Remove",
++          sizeof(struct hf_remove_data) >> 2,
++          sizeof(struct hf_common_data) >> 2,
++          0,
++          -1 },
++
++        { hf_MkDir,
++          "MkDir",
++          sizeof(struct hf_mkdir_data) >> 2,
++          sizeof(struct hf_hnode_data) >> 2,
++          1,
++          -1 },
++
++        { hf_Parent,
++          "Parent",
++          0,
++          sizeof(struct hf_hnode_data) >> 2,
++          -1,
++          -1 },
++
++        { hf_Rename,
++          "Rename",
++          sizeof(struct hf_rename_data) >> 2,
++          sizeof(struct hf_common_data) >> 2,
++          1,
++          -1 },
++
++        { hf_Link,
++          "Link",
++          sizeof(struct hf_link_data) >> 2,
++          sizeof(struct hf_common_data) >> 2,
++          1,
++          -1 },
++
++        { hf_Symlink,
++          "Symlink",
++          sizeof(struct hf_symlink_data) >> 2,
++          sizeof(struct hf_common_data) >> 2,
++          0,
++          -1 },
++
++        { hf_Readlink,
++          "Readlink",
++          0,
++          sizeof(struct hf_readlink_data) >> 2,
++          -1,
++          1},
++
++        { hf_Debug,
++          "Debug",
++          sizeof(struct hf_debug_data) >> 2,
++          1,
++          0,
++          -1 },
++
++        { hf_Handshake,
++          "Handshake",
++          sizeof(struct hf_handshake_data) >> 2,
++          sizeof(struct hf_handshake_reply_data) >> 2,
++          -1,
++          -1 },
++
++        { hf_Unmount,
++          "Unmount",
++          0,
++          sizeof(struct hf_common_data) >> 2,
++          -1,
++          -1 }
++};
++
++typedef int check_enough_host_funcs[sizeof(host_funcs) / sizeof(host_funcs[0])
++                                    == hf_Functions ? 1 : -1];
++
++#if defined(HOSTFS_HOST)
++static host_funcs_t host_funcs_v0[] = {
++        { hf_VfsStat,
++          "VfsStat",
++          0,
++          sizeof(struct hf_vfsstat_data) >> 2,
++          -1,
++          -1 },
++
++        { hf_Root,
++          "Root",
++          0,
++          sizeof(struct hf_hnode_data) >> 2,
++          -1,
++          -1 },
++
++        { hf_GetAttr,
++          "GetAttr",
++          0,
++          sizeof(struct hf_getattr_data) >> 2,
++          -1,
++          -1 },
++
++        { hf_SetAttr,
++          "SetAttr",
++          sizeof(struct hf_setattr_data_v0) >> 2,
++          sizeof(struct hf_common_data) >> 2,
++          -1,
++          -1 },
++
++        { hf_Open,
++          "Open",
++          1,
++          sizeof(struct hf_common_data) >> 2,
++          -1,
++          -1 },
++
++        { hf_Close,
++          "Close",
++          0,
++          1,
++          -1,
++          -1 },
++
++        { hf_Readdir,
++          "Readdir",
++          1,
++          sizeof(struct hf_readdir_data) >> 2,
++          -1,
++          2 },
++
++        { hf_Lookup,
++          "Lookup",
++          sizeof(struct hf_lookup_data),
++          sizeof(struct hf_hnode_data) >> 2,
++          0,
++          -1 },
++
++        { hf_Seek,
++          "Seek",
++          sizeof(struct hf_seek_data) >> 2,
++          sizeof(struct hf_common_data) >> 2,
++          -1,
++          -1 },
++
++        { hf_Read,
++          "Read",
++          1,
++          sizeof(struct hf_read_data) >> 2,
++          -1,
++          2 },
++
++        { hf_Write,
++          "Write",
++          sizeof(struct hf_write_data) >> 2,
++          sizeof(struct hf_common_data) >> 2,
++          2,
++          -1 },
++
++        { hf_Create,
++          "Create",
++          sizeof(struct hf_create_data) >> 2,
++          sizeof(struct hf_hnode_data) >> 2,
++          3,
++          -1 },
++
++        { hf_Remove,
++          "Remove",
++          sizeof(struct hf_remove_data) >> 2,
++          sizeof(struct hf_common_data) >> 2,
++          0,
++          -1 },
++
++        { hf_MkDir,
++          "MkDir",
++          sizeof(struct hf_mkdir_data) >> 2,
++          sizeof(struct hf_hnode_data) >> 2,
++          1,
++          -1 },
++
++        { hf_Parent,
++          "Parent",
++          0,
++          sizeof(struct hf_hnode_data) >> 2,
++          -1,
++          -1 },
++
++        { hf_Rename,
++          "Rename",
++          sizeof(struct hf_rename_data) >> 2,
++          sizeof(struct hf_common_data) >> 2,
++          1,
++          -1 },
++
++        { hf_Link,
++          "Link",
++          sizeof(struct hf_link_data) >> 2,
++          sizeof(struct hf_common_data) >> 2,
++          1,
++          -1 },
++
++        { hf_Symlink,
++          "Symlink",
++          sizeof(struct hf_symlink_data) >> 2,
++          sizeof(struct hf_common_data) >> 2,
++          0,
++          -1 },
++
++        { hf_Readlink,
++          "Readlink",
++          0,
++          sizeof(struct hf_readlink_data) >> 2,
++          -1,
++          1},
++
++        { hf_Debug,
++          "Debug",
++          sizeof(struct hf_debug_data) >> 2,
++          1,
++          0,
++          -1 },
++
++        { hf_Handshake,
++          "Handshake",
++          sizeof(struct hf_handshake_data) >> 2,
++          sizeof (struct hf_handshake_reply_data) >> 2,
++          -1,
++          -1 },
++
++        { hf_Unmount,
++          "Unmount",
++          0,
++          0,
++          -1,
++          -1 }
++};
++
++typedef int check_enough_host_funcs_v0[
++                    sizeof(host_funcs_v0) / sizeof(host_funcs_v0[0])
++                    == hf_Functions ? 1 : -1];
++#endif /* HOSTFS_HOST */
++
++#endif /* _HOST_FS_DATA */
+diff --git a/fs/simicsfs/hostfs_dir.c b/fs/simicsfs/hostfs_dir.c
+new file mode 100644
+index 0000000..de47668
+--- /dev/null
++++ b/fs/simicsfs/hostfs_dir.c
+@@ -0,0 +1,77 @@
++/*
++   hostfs for Linux
++   Copyright 2001 - 2006 Virtutech AB
++   Copyright 2001 SuSE
++
++   This program is free software; you can redistribute it and/or modify
++   it under the terms of the GNU General Public License as published by
++   the Free Software Foundation; either version 2 of the License, or
++   (at your option) any later version.
++
++   This program is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
++   NON INFRINGEMENT.  See the GNU General Public License for more details.
++
++   You should have received a copy of the GNU General Public License
++   along with this program; if not, write to the Free Software
++   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
++
++   $Id: hostfs_dir.c,v 1.3 2006/03/31 10:25:53 am Exp $
++*/
++
++#include "hostfs_linux.h"
++
++static int
++hostfs_fo_readdir(struct file *file, void *buf, filldir_t fill)
++{
++#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
++        struct dentry *dentry = file->f_path.dentry;
++#else
++        struct dentry *dentry = file->f_dentry;
++#endif
++        struct inode *inode = dentry->d_inode;
++        struct hf_readdir_data data;
++        uint offset = file->f_pos;
++
++/*          DPRINT1(DEVICE_NAME " hostfs_fo_readdir("); */
++/*          DPRINTFILE1(file); */
++/*          DPRINT1(", %p, %p)\n", buf, fill); */
++/*          DPRINT1("   file->fpos == %ld\n", (long)file->f_pos); */
++
++        get_host_data(hf_Readdir, inode->i_ino, &offset, &data);
++        while (data.hnode) {
++                int res;
++                NTOHSWAP(data.filename);
++                if ((res = fill(buf, data.filename, strlen(data.filename),
++                                offset, data.hnode, DT_UNKNOWN))) {
++                        return 0;
++                }
++                file->f_pos = ++offset;
++                get_host_data(hf_Readdir, inode->i_ino, &offset, &data);
++        }
++        return 0;
++}
++
++static ssize_t
++hostfs_fo_dir_read(struct file *file, char *buf, size_t len, loff_t *off)
++{
++/*          DPRINT1(DEVICE_NAME " hostfs_fo_dir_read()\n"); */
++        return -EISDIR;
++}
++
++
++static int
++hostfs_dir_release(struct inode *inode, struct file *file)
++{
++        uint dummy;
++        get_host_data(hf_Close, inode->i_ino, NULL, &dummy);
++        return 0;
++}
++
++
++struct file_operations hostfs_file_dirops = {
++        read: hostfs_fo_dir_read,
++        readdir: hostfs_fo_readdir,
++	release: hostfs_dir_release,
++};
+diff --git a/fs/simicsfs/hostfs_file.c b/fs/simicsfs/hostfs_file.c
+new file mode 100644
+index 0000000..01d25d1
+--- /dev/null
++++ b/fs/simicsfs/hostfs_file.c
+@@ -0,0 +1,150 @@
++
++/*
++   hostfs for Linux
++   Copyright 2001 - 2006 Virtutech AB
++   Copyright 2001 SuSE
++
++   This program is free software; you can redistribute it and/or modify
++   it under the terms of the GNU General Public License as published by
++   the Free Software Foundation; either version 2 of the License, or
++   (at your option) any later version.
++
++   This program is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
++   NON INFRINGEMENT.  See the GNU General Public License for more details.
++
++   You should have received a copy of the GNU General Public License
++   along with this program; if not, write to the Free Software
++   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
++
++   $Id: hostfs_file.c,v 1.3 2006/03/31 10:25:53 am Exp $
++*/
++
++#include "hostfs_linux.h"
++
++static int
++hostfs_fo_open(struct inode *inode, struct file *file)
++{
++        struct hf_common_data idata;
++        uint oflag = 0, flag = file->f_flags;
++
++        DPRINT1("hostfs_fo_open %ld flags %x\n", inode->i_ino, file->f_flags);
++
++        switch (flag & O_ACCMODE) {
++        case O_RDONLY:
++                oflag = HF_FREAD;
++                break;
++        case O_RDWR:
++                oflag = HF_FREAD; 
++                /* fallthrough */
++        case O_WRONLY:
++                oflag |= HF_FWRITE;
++                break;
++        default:
++                return -EINVAL;
++        }
++
++        get_host_data(hf_Open, inode->i_ino, &oflag, &idata);
++
++        if (idata.sys_error)
++                return -idata.sys_error;
++
++        return 0;
++}
++
++static int
++hostfs_fo_release(struct inode *inode, struct file *file)
++{
++        uint dummy;
++
++        /* DPRINT1("hostfs_fo_release %ld fcount %d icount %d\n",
++        	(long)inode->i_ino, atomic_read(&file->f_count),
++        	atomic_read(&inode->i_count)); */
++
++        get_host_data(hf_Close, inode->i_ino, NULL, &dummy);
++        return 0;
++}
++
++static ssize_t
++hostfs_read(struct file *file, char *buf, size_t len, loff_t *ppos)
++{
++        DPRINT1("hostfs: hostfs_read %ld\n", file->f_dentry->d_inode->i_ino);
++        if (!hostfs_revalidate_inode(file->f_dentry->d_inode))
++                return 0;
++#if defined(KERNEL_2_6)
++        return do_sync_read(file, buf, len, ppos);
++#else
++        return generic_file_read(file, buf, len, ppos);
++#endif
++}
++
++static ssize_t
++hostfs_write(struct file *file, const char *buf, size_t len, loff_t *ppos)
++{
++        DPRINT1("hostfs: hostfs_write %ld\n", file->f_dentry->d_inode->i_ino);
++        if (!hostfs_revalidate_inode(file->f_dentry->d_inode))
++                return 0;
++#if defined(KERNEL_2_6)
++        return do_sync_write(file, buf, len, ppos);
++#else
++        return generic_file_write(file, buf, len, ppos);
++#endif
++}
++
++#if defined(KERNEL_2_6)
++ #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19)
++static ssize_t
++hostfs_aio_read(struct kiocb *kiocb, const struct iovec *iovec,
++                unsigned long len, loff_t ofs)
++ #else
++static ssize_t
++hostfs_aio_read(struct kiocb *kiocb, char *buf, size_t len, loff_t ppos)
++ #endif
++{
++        DPRINT1("hostfs: hostfs_aio_read %ld\n",
++                kiocb->ki_filp->f_dentry->d_inode->i_ino);
++        if (!hostfs_revalidate_inode(kiocb->ki_filp->f_dentry->d_inode))
++                return 0;
++        #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19)
++                return generic_file_aio_read(kiocb, iovec, len, ofs);
++        #else
++                return generic_file_aio_read(kiocb, buf, len, ppos);
++        #endif
++}
++
++ #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19)
++static ssize_t
++hostfs_aio_write(struct kiocb *kiocb, const struct iovec *iovec,
++                 unsigned long len, loff_t ofs)
++ #else
++static ssize_t
++hostfs_aio_write(struct kiocb *kiocb, const char *buf, size_t len, loff_t ppos)
++ #endif
++{
++        DPRINT1("hostfs: hostfs_aio_write %ld\n",
++                kiocb->ki_filp->f_dentry->d_inode->i_ino);
++        if (!hostfs_revalidate_inode(kiocb->ki_filp->f_dentry->d_inode))
++                return 0;
++        #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19)
++                return generic_file_aio_write(kiocb, iovec, len, ofs);
++        #else
++                return generic_file_aio_write(kiocb, buf, len, ppos);
++        #endif
++}
++#endif
++
++struct file_operations hostfs_file_fops = {
++#if defined(KERNEL_2_6)
++        read: hostfs_read,
++        write: hostfs_write,
++        aio_read: hostfs_aio_read,
++        aio_write: hostfs_aio_write,
++#else
++        read: hostfs_read,
++        write: hostfs_write,
++#endif
++        mmap: generic_file_mmap,
++        open: hostfs_fo_open,
++	release: hostfs_fo_release,
++};
+diff --git a/fs/simicsfs/hostfs_host.c b/fs/simicsfs/hostfs_host.c
+new file mode 100644
+index 0000000..5aea029
+--- /dev/null
++++ b/fs/simicsfs/hostfs_host.c
+@@ -0,0 +1,163 @@
++/*
++   hostfs for Linux
++   Copyright 2001 - 2006 Virtutech AB
++   Copyright 2001 SuSE
++
++   This program is free software; you can redistribute it and/or modify
++   it under the terms of the GNU General Public License as published by
++   the Free Software Foundation; either version 2 of the License, or
++   (at your option) any later version.
++
++   This program is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
++   NON INFRINGEMENT.  See the GNU General Public License for more details.
++
++   You should have received a copy of the GNU General Public License
++   along with this program; if not, write to the Free Software
++   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
++
++   $Id: hostfs_host.c,v 1.8 2006/03/31 14:56:52 ekloef Exp $
++*/
++
++
++#include "hostfs_linux.h"
++
++#if !defined(__sparc_v9__)
++static volatile void *hostfs_dev_data;
++#endif
++
++static void
++write_value(uint value)
++{
++#if defined(__sparc_v9__)
++        asm volatile ("wr %0, 0, %%asr31" :: "r"(value));
++#else
++        writel(value, hostfs_dev_data);
++#endif
++}
++
++static uint
++read_value(void)
++{
++        uint value;
++#if defined(__sparc_v9__)
++        asm volatile ("rd %%asr31, %0" : "=r" (value));
++#else
++        value = readl(hostfs_dev_data);
++#endif
++        return value;
++}
++
++static void
++data_to_host(uint *data, int len)
++{
++        int i;
++
++        for (i = 0; i < len; i++)
++                write_value(data[i]);
++}
++
++static void
++data_from_host(uint *data, int len)
++{
++        int i;
++
++        for (i = 0; i < len; i++) 
++                data[i] = read_value();
++}
++
++spinlock_t get_host_data_lock;
++spinlock_t hostfs_position_lock;
++
++
++int
++get_host_data(host_func_t func, host_node_t hnode, void *in_buf, void *out_buf)
++{
++        uint data;
++
++        if (func != host_funcs[func].func)
++                printk(DEVICE_NAME " INTERNAL ERROR: host_funcs_t != func\n");
++
++        spin_lock(&get_host_data_lock);
++
++        data = func;
++        data_to_host(&data, 1);
++        data_to_host(&hnode, 1);
++        data_to_host(in_buf, host_funcs[func].out);
++        data_from_host(out_buf, host_funcs[func].in);
++
++        spin_unlock(&get_host_data_lock);
++
++        return 0;
++}
++
++
++/* internal function */
++int
++hf_do_seek(ino_t inode, loff_t off)
++{
++        struct hf_seek_data odata;
++        struct hf_common_data idata;
++
++        SET_HI_LO(odata.off, off);
++        get_host_data(hf_Seek, inode, &odata, &idata);
++        return idata.sys_error;
++}
++
++
++/*
++ * Dynamic configuration support.
++ * You can specify simicsfs.phys_addr=0xff00ff00 on the kernel command line, or
++ * insmod simicsfs phys_addr=0xff00ff00
++ */
++
++#ifdef KERNEL_2_6
++# include <linux/moduleparam.h>
++
++#ifdef CONFIG_SIMICSFS_ADDRESS
++static char *phys_addr = CONFIG_SIMICSFS_ADDRESS;
++#else
++static char *phys_addr;
++#endif
++
++module_param(phys_addr, charp, 0);
++MODULE_PARM_DESC(phys_addr, "Physical address where simicsfs is mapped.");
++
++#endif
++
++int
++init_host_fs(void)
++{
++        unsigned long long hostfs_dev = HOSTFS_DEV;
++
++#ifdef KERNEL_2_6
++        if (phys_addr && strcmp(phys_addr, "") != 0)
++                hostfs_dev = simple_strtoull(phys_addr, NULL, 0);
++#endif
++
++#if defined(__alpha)
++        hostfs_dev_data = (void *)phys_to_virt(hostfs_dev);
++#elif defined(__i386) || defined(__x86_64__) || defined(__ia64) \
++        || defined(__powerpc__) || defined(__arm__) || defined(__mips__) \
++        || defined(__m68k__)
++# ifdef CONFIG_440
++	hostfs_dev_data = (void *)ioremap64(hostfs_dev, 16);
++# else
++	hostfs_dev_data = (void *)ioremap(hostfs_dev, 16);
++# endif
++	if (!hostfs_dev_data) {
++		printk("hostfs: cannot map 0x%08llx\n", hostfs_dev);
++		return -EIO;
++	}
++	printk(KERN_INFO "Mapping hostfs from p:%08llx to %p\n",
++               hostfs_dev, hostfs_dev_data);
++#elif defined(__sparc_v9__)
++#else
++#error "No device mapping for this architecture"
++#endif
++
++        spin_lock_init(&get_host_data_lock);
++        spin_lock_init(&hostfs_position_lock);
++	return 0;
++}
+diff --git a/fs/simicsfs/hostfs_inode.c b/fs/simicsfs/hostfs_inode.c
+new file mode 100644
+index 0000000..6e97c9c
+--- /dev/null
++++ b/fs/simicsfs/hostfs_inode.c
+@@ -0,0 +1,748 @@
++/*
++   hostfs for Linux
++   Copyright 2001 - 2006 Virtutech AB
++   Copyright 2001 SuSE
++
++   This program is free software; you can redistribute it and/or modify
++   it under the terms of the GNU General Public License as published by
++   the Free Software Foundation; either version 2 of the License, or
++   (at your option) any later version.
++
++   This program is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
++   NON INFRINGEMENT.  See the GNU General Public License for more details.
++
++   You should have received a copy of the GNU General Public License
++   along with this program; if not, write to the Free Software
++   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
++
++   $Id: hostfs_inode.c,v 1.5 2006/03/31 10:25:53 am Exp $
++*/
++
++#include "hostfs_linux.h"
++#include <linux/slab.h>		/* for kmalloc/kfree */
++
++
++static struct address_space_operations hostfs_file_aops;
++static struct inode_operations hostfs_symlink_iops, hostfs_dir_iops;
++
++static struct inode_operations hostfs_file_iops;
++
++int
++hostfs_revalidate_inode(struct inode *inode)
++{
++#ifdef KERNEL_2_6
++        struct inode updated_inode = *inode;
++
++        DPRINT1("hostfs_revalidate %ld\n", (long)inode->i_ino);
++
++        hostfs_read_inode(&updated_inode);
++
++        if (memcmp(&updated_inode, inode, sizeof(updated_inode)) != 0) {
++                DPRINT1("hostfs: inode changed, flushing pages\n");
++                memcpy(inode, &updated_inode, sizeof updated_inode);
++
++                /* TODO: can we do a better guess when to invalidate pages and
++                   when not to? */
++                invalidate_inode_pages2(inode->i_mapping);
++        } else {
++                DPRINT1("hostfs: inode not changed\n");
++        }
++#endif  /* KERNEL_2_6 */
++        return 1;
++}
++
++#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
++struct inode *
++hostfs_iget(struct super_block *sb, unsigned long ino)
++{
++        struct inode *inode;
++
++        inode = iget_locked(sb, ino);
++        if (!inode)
++                return ERR_PTR(-ENOMEM);
++        if (!(inode->i_state & I_NEW))
++                return inode;
++
++        hostfs_read_inode(inode);
++
++        unlock_new_inode(inode);
++        return inode;
++}
++#endif
++
++void
++hostfs_read_inode(struct inode *inode)
++{
++        struct hf_getattr_data data;
++        uint mask;
++
++        get_host_data(hf_GetAttr, inode->i_ino, &mask, &data);
++        if (data.sys_error) {
++                printk(DEVICE_NAME "get_host_data(hf_GetAttr, %ld, ...) "
++                       "had an error\n", inode->i_ino);
++                return;
++        }
++
++        DPRINT1("hostfs_read_inode(%ld) flags %lx\n", inode->i_ino,
++                (long)inode->i_flags);
++
++        inode->i_flags = 0;
++        inode->i_mode = data.mode;
++        inode->i_uid = data.uid;
++        inode->i_gid = data.gid;
++#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,2,0)
++        set_nlink(inode, data.link);
++#else
++        inode->i_nlink = data.link;
++#endif
++        GET_HI_LO(inode->i_size,  data.size);
++#ifndef KERNEL_2_6
++        GET_HI_LO(inode->i_atime, data.atime);
++        GET_HI_LO(inode->i_mtime, data.mtime);
++        GET_HI_LO(inode->i_ctime, data.ctime);
++#else /* KERNEL_2_6 */
++        GET_HI_LO(inode->i_atime.tv_sec, data.atime);
++        GET_HI_LO(inode->i_mtime.tv_sec, data.mtime);
++        GET_HI_LO(inode->i_ctime.tv_sec, data.ctime);
++        inode->i_atime.tv_nsec = 0;
++        inode->i_mtime.tv_nsec = 0;
++        inode->i_ctime.tv_nsec = 0;
++#endif /* KERNEL_2_6 */
++        #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
++                /* blksize field completely removed in 2.6.19 */
++                inode->i_blksize = data.blksize;
++        #endif
++        GET_HI_LO(inode->i_blocks, data.blocks);
++
++        if (S_ISLNK(inode->i_mode)) {
++                inode->i_op = &hostfs_symlink_iops;
++        } else if (S_ISDIR(inode->i_mode)) {
++                inode->i_op = &hostfs_dir_iops;
++		inode->i_fop = &hostfs_file_dirops;
++        } else {
++		inode->i_fop = &hostfs_file_fops;
++		inode->i_op = &hostfs_file_iops;
++                inode->i_mapping->a_ops = &hostfs_file_aops;
++        }
++}
++
++#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34)
++int hostfs_write_inode(struct inode *inode, struct writeback_control *wbc)
++#else
++#  ifdef KERNEL_2_6
++int hostfs_write_inode(struct inode *inode, int sync)
++#  else
++void hostfs_write_inode(struct inode *inode, int sync)
++#  endif
++#endif
++{
++        /*
++         * it might be pointless to implement this function since
++         * supposedly all changes will have been updated by
++         * notify_change anyway, but I'm sure it can't hurt
++         */
++
++        struct hf_setattr_data odata;
++        struct hf_common_data idata;
++
++        DPRINT1(DEVICE_NAME " hostfs_write_inode(%ld)\n", inode->i_ino);
++
++        memset(&odata, 0, sizeof odata);
++        odata.set_atime = 1;
++#ifndef KERNEL_2_6
++        SET_HI_LO(odata.atime, inode->i_atime);
++        SET_HI_LO(odata.mtime, inode->i_mtime);
++#else /* KERNEL_2_6 */
++        SET_HI_LO(odata.atime, inode->i_atime.tv_sec);
++        SET_HI_LO(odata.mtime, inode->i_mtime.tv_sec);
++#endif /* KERNEL_2_6 */
++        odata.set_mtime = 1;
++        odata.set_mode = 1;
++        odata.mode = inode->i_mode;
++        odata.set_uid = 1;
++        odata.uid = inode->i_uid;
++        odata.set_gid = 1;
++        odata.gid = inode->i_gid;
++        get_host_data(hf_SetAttr, inode->i_ino, &odata, &idata);
++#ifdef KERNEL_2_6
++        return 0;
++#endif
++}
++
++static int
++hostfs_setattr(struct dentry *dentry, struct iattr *iattr)
++{
++        struct hf_setattr_data odata;
++        struct hf_common_data idata;
++        struct inode *inode = dentry->d_inode;
++        int error;
++#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36)
++        int setsize = 0;
++#endif
++
++        DPRINT1(DEVICE_NAME " hostfs_notify_change(%ld, 0x%lx)\n",
++                inode->i_ino, (long)iattr->ia_valid);
++
++        if ((error = inode_change_ok(inode, iattr)))
++            return error;
++
++        memset(&odata, 0, sizeof odata);
++        if (iattr->ia_valid & ATTR_ATIME) {
++            odata.set_atime = 1;
++#ifndef KERNEL_2_6
++            SET_HI_LO(odata.atime, iattr->ia_atime);
++#else /* KERNEL_2_6 */
++            SET_HI_LO(odata.atime, iattr->ia_atime.tv_sec);
++#endif /* KERNEL_2_6 */
++        }
++        if (iattr->ia_valid & ATTR_MTIME) {
++            odata.set_mtime = 1;
++#ifndef KERNEL_2_6
++            SET_HI_LO(odata.mtime, iattr->ia_mtime);
++#else /* KERNEL_2_6 */
++            SET_HI_LO(odata.mtime, iattr->ia_mtime.tv_sec);
++#endif /* KERNEL_2_6 */
++        }
++        if (iattr->ia_valid & ATTR_MODE) {
++            odata.set_mode = 1;
++            odata.mode = iattr->ia_mode;
++        }
++        if (iattr->ia_valid & ATTR_UID) {
++            odata.set_uid = 1;
++            odata.uid = iattr->ia_uid;
++        }
++        if (iattr->ia_valid & ATTR_GID) {
++            odata.set_gid = 1;
++            odata.gid = iattr->ia_gid;
++        }
++#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36)
++        if (iattr->ia_valid & ATTR_SIZE && iattr->ia_size != inode->i_size) {
++            setsize = 1;
++            odata.set_size = 1;
++            SET_HI_LO(odata.size, iattr->ia_size);
++        }
++#endif
++        get_host_data(hf_SetAttr, inode->i_ino, &odata, &idata);
++
++        DPRINT1("         hf_SetAttr returned %d\n", idata.sys_error);
++
++        if (idata.sys_error)
++            return -idata.sys_error;
++
++#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36)
++        if (setsize)
++            truncate_setsize(inode, iattr->ia_size);
++        setattr_copy(inode, iattr);
++        mark_inode_dirty(inode);
++        return 0;
++#else
++        return inode_setattr(inode, iattr);
++#endif
++}
++
++#ifdef KERNEL_2_6
++static int
++hostfs_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)
++{
++        DPRINT1("hostfs: getattr\n");
++        if (!hostfs_revalidate_inode(dentry->d_inode))
++                return 0;
++        generic_fillattr(dentry->d_inode, stat);
++        return 0;
++}
++#endif
++
++#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,28)
++static int
++hostfs_write_begin(struct file *file, struct address_space *mapping,
++                   loff_t pos, unsigned len, unsigned flags,
++                   struct page **pagep, void **fsdata)
++{
++        pgoff_t index = pos >> PAGE_CACHE_SHIFT;
++        struct page *page = grab_cache_page_write_begin(mapping, index, flags);
++
++        *pagep = page;
++        if (page == NULL)
++                return -ENOMEM;
++
++        return 0;
++}
++#else
++static int
++hostfs_prepare_write(struct file *file, struct page *page, unsigned offset,
++                     unsigned to)
++{
++	return 0;
++}
++#endif
++
++static int
++hostfs_do_writepage(struct inode *inode, struct page *page, unsigned from,
++                    unsigned to)
++{
++	int offset = (page->index << PAGE_CACHE_SHIFT) + from;
++	unsigned bytes = to - from;
++	unsigned long int address = (unsigned long)page_address(page) + from;
++	uint ino = inode->i_ino;
++	int res;
++        struct hf_write_data *odata;
++
++	if (page->index > (0x7fffffff/PAGE_CACHE_SIZE)-1)
++		return -EFBIG;
++
++        /* It is risky to allocate the write buffer on the stack since we
++           have limited stack space */
++        odata = kmalloc(sizeof *odata, GFP_KERNEL);
++
++        if (!odata)
++                return -ENOMEM;
++
++        spin_lock(&hostfs_position_lock);
++
++        DPRINT1("hostfs_do_writepage: offset:%u bytes:%u address:%lx\n",
++                offset, bytes, address);
++
++        hf_do_seek(ino, offset);
++
++	res = 0;
++        while (bytes > 0) {
++                struct hf_common_data idata;
++                uint cnt = MIN(bytes, XFER_DATA_WORDS * 4);
++                odata->append = 0;
++                odata->size = cnt;
++                memcpy(odata->data, (char *)address, cnt);
++                HTONSWAP(odata->data);
++                get_host_data(hf_Write, ino, odata, &idata);
++                if (idata.sys_error) {
++                        res = -idata.sys_error;
++                        DPRINT1(DEVICE_NAME " failed with errcode %d\n", res);
++                        SetPageError(page);
++			ClearPageUptodate(page);
++                        goto got_error;
++                }
++                address += cnt;
++                bytes -= cnt;
++		res += cnt;
++        }
++        DPRINT1(DEVICE_NAME "wrote %d bytes\n", (int)res);
++
++	SetPageUptodate(page);
++
++ got_error:
++        kfree(odata);
++        spin_unlock(&hostfs_position_lock);
++
++        return res;
++}
++
++static int
++#ifndef KERNEL_2_6
++hostfs_writepage(struct page *page)
++#else /* KERNEL_2_6 */
++hostfs_writepage(struct page *page, struct writeback_control *wbc)
++#endif /* KERNEL_2_6 */
++{
++	struct inode *inode = page->mapping->host;
++	int err = -EIO;
++	int bytes = PAGE_CACHE_SIZE;
++	unsigned long end_index = inode->i_size >> PAGE_CACHE_SHIFT;
++	if (page->index <= end_index) {
++		if (page->index == end_index)
++			bytes = inode->i_size & (PAGE_CACHE_SIZE-1);
++		kmap(page);
++		err = hostfs_do_writepage(inode, page, 0, bytes);
++		kunmap(page);
++	}
++#ifndef KERNEL_2_6
++	UnlockPage(page);
++#else /* KERNEL_2_6 */
++ #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
++        unlock_page(page);
++ #else
++	ClearPageLocked(page);
++ #endif
++#endif /* KERNEL_2_6 */
++	return err;
++}
++
++#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,28)
++static int
++hostfs_write_end(struct file *file, struct address_space *mapping,
++                 loff_t pos, unsigned len, unsigned copied,
++                 struct page *page, void *fsdata)
++{
++        unsigned from = pos & (PAGE_CACHE_SIZE - 1);
++        unsigned to = from + copied;
++
++	struct inode *inode = mapping->host;
++	int err;
++
++        kmap(page);
++	err = hostfs_do_writepage(inode, page, from, to);
++
++	if (err >= 0) {
++		loff_t s = ((page->index) << PAGE_CACHE_SHIFT) + to;
++		if (s > inode->i_size) {
++			inode->i_size = s;
++                }
++	}
++
++	kunmap(page);
++
++        unlock_page(page);
++        page_cache_release(page);
++	return err;
++}
++
++#else
++
++static int
++hostfs_commit_write(struct file *file, struct page *page, unsigned from,
++                    unsigned to)
++{
++	struct inode *inode = page->mapping->host;
++	int err;
++
++        kmap(page);
++	err = hostfs_do_writepage(inode, page, from, to);
++	kunmap(page);
++
++	if (err < 0)
++		return err;
++
++	{
++		loff_t s = ((page->index) << PAGE_CACHE_SHIFT) + to;
++		if (s > inode->i_size)
++			inode->i_size = s;
++	}
++	return 0;
++}
++#endif
++
++static int
++hostfs_inode_readpage(struct file *file, struct page *page)
++{
++        char *address;
++#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
++        struct inode *inode = file->f_path.dentry->d_inode;
++#else
++        struct inode *inode = file->f_dentry->d_inode;
++#endif
++        uint count = PAGE_CACHE_SIZE;
++        int err;
++        struct hf_read_data *data;
++
++	if (page->index > (0xffffffff/PAGE_CACHE_SIZE)-1)
++		return -EFBIG;
++
++        data = kmalloc(sizeof *data, GFP_KERNEL);
++        if (!data)
++                return -ENOMEM;
++
++	ClearPageError(page);
++        count = PAGE_SIZE;
++
++/*          DPRINT1("readpage seek %ld\n", (long)page->offset); */
++
++	address = kmap(page);
++
++        spin_lock(&hostfs_position_lock);
++
++        if ((err = hf_do_seek(inode->i_ino,
++                              page->index << PAGE_CACHE_SHIFT))) {
++                err = -err;
++                goto out_error;
++        }
++
++        while (count > 0) {
++                uint to_read = MIN(count, XFER_DATA_WORDS * 4);
++
++                get_host_data(hf_Read, inode->i_ino, &to_read, data);
++                if (data->sys_error) {
++                        err = -data->sys_error;
++                        goto out_error;
++                }
++
++/*              DPRINT1("readpage count %d out of %d\n", data.size, count); */
++
++		if (!data->size) {
++			memset(address,0,count);
++			break;
++		}
++
++                NTOHSWAP(data->data);
++
++                memcpy(address, data->data, data->size);
++
++
++                address += data->size;
++                count -= data->size;
++        }
++
++        err = 0;
++        spin_unlock(&hostfs_position_lock);
++
++	SetPageUptodate(page);
++out_error:
++        kfree(data);
++
++        if (err)
++                SetPageError(page);
++#ifndef KERNEL_2_6
++        UnlockPage(page);
++#else /* KERNEL_2_6 */
++ #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
++        unlock_page(page);
++ #else
++	ClearPageLocked(page);
++ #endif
++#endif /* KERNEL_2_6 */
++        kunmap(page);
++
++/*          DPRINT1("postuse %ld\n", (long)atomic_read(&page->count)); */
++
++        return err;
++}
++
++static int
++hostfs_inode_readlink(struct dentry *dentry, char *buf, int size)
++{
++	struct hf_readlink_data data;
++
++	get_host_data(hf_Readlink, dentry->d_inode->i_ino, NULL, &data);
++	if (data.sys_error)
++		return -data.sys_error;
++	NTOHSWAP(data.filename);
++	return vfs_readlink(dentry, buf, size, data.filename);
++}
++
++#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,13)
++static void *
++#else
++static int
++#endif
++hostfs_inode_follow_link(struct dentry *dentry, struct nameidata *nd)
++{
++/*       DPRINT1("hostfs_inode_follow_link ino %ld %ld %d\n",
++                 base->d_inode->i_ino, dentry->d_inode->i_ino, follow); */
++	struct hf_readlink_data data;
++	char *name;
++        int ret_val;
++
++	get_host_data(hf_Readlink, dentry->d_inode->i_ino, NULL, &data);
++	if (data.sys_error)
++		name = ERR_PTR(-data.sys_error);
++	else {
++		name = data.filename;
++		NTOHSWAP(data.filename);
++	}
++
++        ret_val = vfs_follow_link(nd, data.filename);
++
++#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,13)
++        return ERR_PTR(ret_val);
++#else
++        return ret_val;
++#endif
++}
++
++static struct dentry *
++#ifndef KERNEL_2_6
++hostfs_inode_lookup(struct inode *dir, struct dentry *dentry)
++#else /* KERNEL_2_6 */
++hostfs_inode_lookup(struct inode *dir, struct dentry *dentry,
++                    struct nameidata *name_data)
++#endif /* KERNEL_2_6 */
++{
++        struct hf_lookup_data odata;
++        struct hf_hnode_data idata;
++        struct inode *inode;
++
++/*          DPRINT1("hostfs_inode_lookup(%ld, dent %p = %s)\n", dir->i_ino, dentry, dentry->d_name.name); */
++
++	/* protect lots of stupid strcpy()s */
++	if (dentry->d_name.len > HOSTFS_FILENAME_LEN-1)
++		return ERR_PTR(-ENAMETOOLONG);
++
++	memcpy(odata.filename, dentry->d_name.name, dentry->d_name.len);
++	odata.filename[dentry->d_name.len] = 0;
++	HTONSWAP(odata.filename);
++	get_host_data(hf_Lookup, dir->i_ino, &odata, &idata);
++ 
++        if (idata.sys_error) {
++                if (idata.sys_error != ENOENT)
++                        return ERR_PTR(-idata.sys_error);
++                inode = NULL;
++        } else {
++                #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
++                        inode = hostfs_iget(dir->i_sb, idata.hnode);
++                #else
++                        inode = iget(dir->i_sb, idata.hnode);
++                #endif
++        }
++
++        d_add(dentry, inode);
++
++        return ERR_PTR(0);
++}
++
++static int
++hostfs_inode_mkdir(struct inode *dir, struct dentry *dentry, int mode)
++{
++        struct hf_mkdir_data odata;
++        struct hf_hnode_data idata;
++        struct inode *inode;
++
++        DPRINT1("hostfs_inode_mkdir()\n");
++
++        odata.mode = mode;
++        strcpy(odata.dirname, dentry->d_name.name);
++        HTONSWAP(odata.dirname);
++
++        get_host_data(hf_MkDir, dir->i_ino, &odata, &idata);
++        if (idata.sys_error)
++                return -idata.sys_error;;
++
++        #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
++                inode = hostfs_iget(dir->i_sb, idata.hnode);
++        #else
++                inode = iget(dir->i_sb, idata.hnode);
++                hostfs_read_inode(inode);
++        #endif
++        mark_inode_dirty(inode);
++        d_instantiate(dentry, inode);
++
++        return 0;
++}
++
++static int
++hostfs_inode_rmdir(struct inode *dir, struct dentry *dentry)
++{
++        struct hf_remove_data odata;
++        struct hf_common_data idata;
++
++        DPRINT1("hostfs_inode_rmdir()\n");
++
++        strcpy(odata.filename, dentry->d_name.name);
++        HTONSWAP(odata.filename);
++        get_host_data(hf_Remove, dir->i_ino, &odata, &idata);
++        mark_inode_dirty(dir);
++
++        return -idata.sys_error;
++}
++
++static int
++#ifndef KERNEL_2_6
++hostfs_inode_create(struct inode *dir, struct dentry *dentry, int mode)
++#else /* KERNEL_2_6 */
++hostfs_inode_create(struct inode *dir, struct dentry *dentry, int mode,
++                    struct nameidata *name_data)
++#endif /* KERNEL_2_6 */
++{
++        struct hf_create_data odata;
++        struct hf_hnode_data idata;
++        struct inode *inode;
++
++        DPRINT1("hostfs_inode_create(%ld, mode = %d)\n", dir->i_ino, mode);
++
++        odata.mode = mode & S_IALLUGO;
++        odata.excl = 0;
++        odata.trunc = 0;
++        strncpy(odata.filename, dentry->d_name.name, sizeof(odata.filename));
++        HTONSWAP(odata.filename);
++
++        get_host_data(hf_Create, dir->i_ino, &odata, &idata);
++
++        if (idata.sys_error) {
++                return -idata.sys_error;
++        }
++
++        #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
++                inode = hostfs_iget(dir->i_sb, idata.hnode);
++        #else
++                inode = iget(dir->i_sb, idata.hnode);
++                hostfs_read_inode(inode);
++        #endif
++        DPRINT1("    read inode mode 0%o  uid %d\n", inode->i_mode,
++                inode->i_uid);
++        mark_inode_dirty(inode);
++        d_instantiate(dentry, inode);
++
++        return 0;
++}
++
++#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,36)
++static void
++hostfs_inode_truncate(struct inode *inode)
++{
++        struct hf_setattr_data odata;
++        struct hf_common_data idata;
++
++        DPRINT1("hostfs_inode_truncate(inode = %ld)\n", inode->i_ino);
++
++        memset(&odata, 0, sizeof odata);
++        odata.set_size = 1;
++        SET_HI_LO(odata.size, inode->i_size);
++        get_host_data(hf_SetAttr, inode->i_ino, &odata, &idata);
++
++        if (idata.sys_error) {
++                printk("[hostfs] call to truncate() failed with error %d!\n",
++                       idata.sys_error);
++        }
++}
++#endif
++
++static int
++hostfs_unlink(struct inode *dir, struct dentry *dentry)
++{
++        struct hf_remove_data odata;
++        struct hf_common_data idata;
++
++        DPRINT1("hostfs_unlink(dir = %ld, dentry = %s)\n", dir->i_ino,
++                dentry->d_name.name);
++
++        strcpy(odata.filename, dentry->d_name.name);
++        HTONSWAP(odata.filename);
++        get_host_data(hf_Remove, dir->i_ino, &odata, &idata);
++
++        return -idata.sys_error;
++}
++
++static struct inode_operations hostfs_dir_iops = {
++        create: hostfs_inode_create,
++        lookup: hostfs_inode_lookup,
++        unlink: hostfs_unlink,
++        mkdir: hostfs_inode_mkdir,
++        rmdir: hostfs_inode_rmdir,
++};
++
++static struct inode_operations hostfs_symlink_iops = {
++        readlink: hostfs_inode_readlink,
++        follow_link: hostfs_inode_follow_link,
++};
++
++static struct inode_operations hostfs_file_iops = {
++#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,36)
++        truncate: hostfs_inode_truncate,
++#endif
++	setattr: hostfs_setattr,
++#ifdef KERNEL_2_6
++        getattr: hostfs_getattr,
++#endif
++};
++
++static struct address_space_operations hostfs_file_aops = {
++	readpage: hostfs_inode_readpage,
++#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28)
++        write_begin: hostfs_write_begin,
++        write_end: hostfs_write_end,
++#else
++	prepare_write: hostfs_prepare_write,
++	commit_write: hostfs_commit_write,
++#endif
++	writepage: hostfs_writepage,
++};
++
++MODULE_LICENSE("GPL");
+diff --git a/fs/simicsfs/hostfs_linux.h b/fs/simicsfs/hostfs_linux.h
+new file mode 100644
+index 0000000..951cb34
+--- /dev/null
++++ b/fs/simicsfs/hostfs_linux.h
+@@ -0,0 +1,143 @@
++/*
++   hostfs for Linux
++   Copyright 2001 - 2006 Virtutech AB
++   Copyright 2001 SuSE
++
++   This program is free software; you can redistribute it and/or modify
++   it under the terms of the GNU General Public License as published by
++   the Free Software Foundation; either version 2 of the License, or
++   (at your option) any later version.
++
++   This program is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
++   NON INFRINGEMENT.  See the GNU General Public License for more details.
++
++   You should have received a copy of the GNU General Public License
++   along with this program; if not, write to the Free Software
++   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
++
++   $Id: hostfs_linux.h,v 1.4 2006/03/31 10:25:53 am Exp $
++*/
++
++#ifndef HOSTFS_H
++#define HOSTFS_H 1
++
++#include <linux/version.h>
++
++
++#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
++  /* linux/config.h has been deprecated way before 2.6.19, but has at least
++     worked. Starting with 2.6.19 it does not */
++ #include <linux/config.h>
++#endif
++
++#define DEVICE_NAME "[simicsfs]"
++
++#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,0,0)
++ #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
++   #define KERNEL_2_6
++ #endif
++#else
++ #error "Unsupported kernel version"
++#endif
++
++#include <linux/sched.h>
++#include <linux/version.h>
++#include <linux/module.h>
++#include <linux/kernel.h>
++#include <linux/types.h>
++#include <linux/pagemap.h>
++#include <linux/fs.h>
++#include <linux/unistd.h>
++#include <linux/errno.h>
++#include <asm/io.h>
++#include <linux/init.h>
++
++#ifdef KERNEL_2_6
++ #include <linux/statfs.h>
++#endif /* KERNEL_2_6 */
++
++#define TARGETOS_LINUX
++#include "hostfs.h"
++#include "hostfs_data.h"
++
++#define GET_HI_LO(tgt, src) do {                                          \
++        typedef int check_tgt_size[sizeof (tgt) == 8 || sizeof (tgt) == 4 \
++                                   ? 1 : -1];                             \
++        if (sizeof (tgt) == 4)                                            \
++                tgt = src ## _lo;                                         \
++        else if (sizeof (tgt) == 8) {                                     \
++                tgt = src ## _hi;                                         \
++                tgt <<= 16;                                               \
++                tgt <<= 16;                                               \
++                tgt |= src ## _lo;                                        \
++        } else                                                            \
++                printk("hostfs GET_HI_LO panic, sizeof (" #tgt ") "       \
++                       "in %s:%d == %dn",                                 \
++                       __FILE__, __LINE__, (int)sizeof (tgt));            \
++} while (0)
++
++#define SET_HI_LO(tgt, src) do {                                          \
++        typedef int check_src_size[sizeof (src) == 8 || sizeof (src) == 4 \
++                                   ? 1 : -1];                             \
++        if (sizeof (src) == 4) {                                          \
++                tgt ## _lo = src;                                         \
++                tgt ## _hi = 0;                                           \
++        } else if (sizeof (src) == 8) {                                   \
++                unsigned long long tmp = src;                             \
++                tgt ## _lo = (uint)src;                                   \
++                tgt ## _hi = tmp >> 32;                                   \
++        }                                                                 \
++} while (0)
++
++#define DEBUG_LEVEL 0
++#define HOSTFS_BLOCK_BITS 10
++#define HOSTFS_BLOCK_SIZE (1 << HOSTFS_BLOCK_BITS)
++
++#define HOSTFS_ROOT_INO 1
++
++#define DPRINT1 if (DEBUG_LEVEL >= 1) printk
++#define DPRINTINODE1(inode) do {                        \
++        if (DEBUG_LEVEL >= 1) print_inode(inode);       \
++} while (0)
++
++#define DPRINTFILE1(file) do { } while (0)
++
++#define MIN(a, b) ((a) < (b) ? (a) : (b))
++
++#define NTOHSWAP(field) do {                                            \
++        int __i;                                                        \
++        for (__i = 0; __i < (sizeof (field) + 3) / 4; ++__i) {          \
++                ((uint *)&field)[__i] = ntohl(((uint *)&field)[__i]);   \
++        }                                                               \
++} while(0)
++
++#define HTONSWAP(field) NTOHSWAP(field)
++
++extern struct file_operations hostfs_file_fops;
++extern struct file_operations hostfs_file_dirops;
++
++int hostfs_revalidate_inode(struct inode *inode);
++void hostfs_read_inode(struct inode *inode);
++#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34)
++int hostfs_write_inode(struct inode *inode, struct writeback_control *wbc);
++#else
++#  ifdef KERNEL_2_6
++int hostfs_write_inode(struct inode *inode, int sync);
++#  else
++void hostfs_write_inode(struct inode *inode, int sync);
++#  endif
++#endif
++
++extern spinlock_t get_host_data_lock;
++extern spinlock_t hostfs_position_lock;
++
++
++/* host interface */
++int get_host_data(host_func_t func, host_node_t hnode, void *in_buf,
++		  void *out_buf);
++int hf_do_seek(ino_t inode, loff_t off);
++int init_host_fs(void);
++
++#endif
+diff --git a/fs/simicsfs/hostfs_super.c b/fs/simicsfs/hostfs_super.c
+new file mode 100644
+index 0000000..ec62795
+--- /dev/null
++++ b/fs/simicsfs/hostfs_super.c
+@@ -0,0 +1,191 @@
++/*
++   hostfs for Linux
++   Copyright 2001 - 2006 Virtutech AB
++   Copyright 2001 SuSE
++
++   This program is free software; you can redistribute it and/or modify
++   it under the terms of the GNU General Public License as published by
++   the Free Software Foundation; either version 2 of the License, or
++   (at your option) any later version.
++
++   This program is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
++   NON INFRINGEMENT.  See the GNU General Public License for more details.
++
++   You should have received a copy of the GNU General Public License
++   along with this program; if not, write to the Free Software
++   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
++
++   $Id: hostfs_super.c,v 1.6 2006/03/31 10:25:53 am Exp $
++*/
++
++
++#include "hostfs_linux.h"
++
++static struct super_operations hostfs_super_ops;
++
++
++static int
++#ifndef KERNEL_2_6
++hostfs_statfs(struct super_block *sb, struct statfs *buf)
++#else /* KERNEL_2_6 */
++ #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 18)
++hostfs_statfs(struct dentry *de, struct kstatfs *buf)
++ #else
++hostfs_statfs(struct super_block *sb, struct kstatfs *buf)
++ #endif
++#endif /* KERNEL_2_6 */
++{
++        struct hf_vfsstat_data data;
++
++        get_host_data(hf_VfsStat, 0, NULL, &data);
++
++        memset(buf, 0, sizeof *buf);
++        buf->f_type = HOSTFS_MAGIC;
++        buf->f_bsize = data.bsize;
++        buf->f_blocks = data.blocks;
++        buf->f_bfree = data.bfree;
++        buf->f_bavail = data.bavail;
++        buf->f_files = data.files;
++        buf->f_ffree = data.ffree;
++        buf->f_namelen = HOSTFS_FILENAME_LEN;
++
++	return 0;
++}
++
++
++#ifndef KERNEL_2_6
++static struct super_block *
++#else /* KERNEL_2_6 */
++static int
++#endif /* KERNEL_2_6 */
++hostfs_read_super(struct super_block *sb, void *data, int silent)
++{
++        struct inode *root_inode;
++        struct hf_handshake_data odata;
++        struct hf_handshake_reply_data idata;
++
++        odata.version = HOSTFS_VERSION;
++        get_host_data(hf_Handshake, 0, &odata, &idata);
++
++        if (idata.sys_error || idata.magic != HOSTFS_MAGIC) {
++                printk(DEVICE_NAME " Handshake with Simics module failed "
++                       "(err=%d, magic=%x/expected %x!\n", idata.sys_error,
++                       idata.magic, HOSTFS_MAGIC);
++                goto out_fail;
++        }
++
++        printk(DEVICE_NAME " mounted\n");
++
++        sb->s_op = &hostfs_super_ops;
++        sb->s_magic = HOSTFS_MAGIC;
++        sb->s_blocksize = HOSTFS_BLOCK_SIZE;
++        sb->s_blocksize_bits = HOSTFS_BLOCK_BITS;
++        root_inode = new_inode(sb);
++        if (!root_inode)
++                goto out_fail;
++        root_inode->i_ino = HOSTFS_ROOT_INO;
++        hostfs_read_inode(root_inode);
++        sb->s_root = d_alloc_root(root_inode);
++        if (!sb->s_root)
++                goto out_no_root;
++
++#ifndef KERNEL_2_6
++        return sb;
++#else /* KERNEL_2_6 */
++        return 0;
++#endif /* KERNEL_2_6 */
++
++ out_no_root:
++        printk(DEVICE_NAME " get root inode failed\n");
++        iput(root_inode);
++
++ out_fail:
++#ifndef KERNEL_2_6
++        return NULL;
++#else /* KERNEL_2_6 */
++        return -EINVAL;
++#endif /* KERNEL_2_6 */
++}
++
++
++static void
++hostfs_put_super(struct super_block *sb)
++{
++        struct hf_common_data idata;
++        get_host_data(hf_Unmount, 0, NULL, &idata);
++}
++
++
++static struct super_operations hostfs_super_ops = {
++#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 25)
++        read_inode: hostfs_read_inode,
++#endif
++        write_inode: hostfs_write_inode,
++        put_super: hostfs_put_super,
++        statfs:   hostfs_statfs,
++};
++
++#ifndef KERNEL_2_6
++static DECLARE_FSTYPE(host_fs_type, "simicsfs", hostfs_read_super, 0);
++#else /* KERNEL_2_6 */
++ #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39)
++static struct dentry *
++hostfs_mount(struct file_system_type *fs_type,
++             int flags, const char *dev_name, void *data)
++{
++        return mount_nodev(fs_type, flags, data, hostfs_read_super);
++}
++ #elif LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 18)
++static int
++hostfs_get_sb(struct file_system_type *fs_type,
++              int flags, const char *dev_name, void *data,
++              struct vfsmount *mnt)
++{
++        return get_sb_nodev(fs_type, flags, data, hostfs_read_super, mnt);
++}
++ #else
++static struct super_block *
++hostfs_get_sb(struct file_system_type *fs_type,
++              int flags, const char *dev_name, void *data)
++{
++	return get_sb_nodev(fs_type, flags, data, hostfs_read_super);
++}
++ #endif
++
++static struct file_system_type host_fs_type = {
++	.owner =	THIS_MODULE,
++	.name =		"simicsfs",
++ #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39)
++	.mount =	hostfs_mount,
++ #else
++	.get_sb =	hostfs_get_sb,
++ #endif
++	.kill_sb =	kill_anon_super,
++};
++
++#endif /* KERNEL_2_6 */
++
++static int
++__init init_hostfs(void)
++{
++        printk(DEVICE_NAME " " SYMBOL_TO_STRING(HOSTFS_VERSION) "."     \
++               SYMBOL_TO_STRING(HOSTFS_SUBVERSION) " loaded\n");
++        init_host_fs();
++        return register_filesystem(&host_fs_type);
++}
++
++static void
++__exit cleanup_hostfs(void)
++{
++        unregister_filesystem(&host_fs_type);
++        printk(DEVICE_NAME " unloaded\n");
++}
++
++#ifndef KERNEL_2_6
++EXPORT_NO_SYMBOLS;
++#endif /* KERNEL_2_6 */
++
++module_init(init_hostfs)
++module_exit(cleanup_hostfs)
+-- 
+1.7.9.5
+
diff -pNur buildroot.2014.08/board/windriver/qsp-ppc/linux-0002-simicsfs-Replace-obsolete-d_alloc_root-with-d_make_r.patch buildroot/board/windriver/qsp-ppc/linux-0002-simicsfs-Replace-obsolete-d_alloc_root-with-d_make_r.patch
--- buildroot.2014.08/board/windriver/qsp-ppc/linux-0002-simicsfs-Replace-obsolete-d_alloc_root-with-d_make_r.patch	1970-01-01 07:00:00.000000000 +0700
+++ buildroot/board/windriver/qsp-ppc/linux-0002-simicsfs-Replace-obsolete-d_alloc_root-with-d_make_r.patch	2014-12-09 13:19:53.705729700 +0800
@@ -0,0 +1,33 @@
+From 1f17346f150219009d148f955d76c161b6e54c36 Mon Sep 17 00:00:00 2001
+From: Ivar Holmqvist <ivarholmqvist@gmail.com>
+Date: Tue, 17 Apr 2012 17:59:15 +0200
+Subject: [PATCH] simicsfs: Replace obsolete d_alloc_root with d_make_root.
+
+---
+ fs/simicsfs/hostfs_super.c |    3 +--
+ 1 file changed, 1 insertion(+), 2 deletions(-)
+
+diff --git a/fs/simicsfs/hostfs_super.c b/fs/simicsfs/hostfs_super.c
+index ec62795..87d613c 100644
+--- a/fs/simicsfs/hostfs_super.c
++++ b/fs/simicsfs/hostfs_super.c
+@@ -87,7 +87,7 @@ hostfs_read_super(struct super_block *sb, void *data, int silent)
+                 goto out_fail;
+         root_inode->i_ino = HOSTFS_ROOT_INO;
+         hostfs_read_inode(root_inode);
+-        sb->s_root = d_alloc_root(root_inode);
++        sb->s_root = d_make_root(root_inode);
+         if (!sb->s_root)
+                 goto out_no_root;
+ 
+@@ -99,7 +99,6 @@ hostfs_read_super(struct super_block *sb, void *data, int silent)
+ 
+  out_no_root:
+         printk(DEVICE_NAME " get root inode failed\n");
+-        iput(root_inode);
+ 
+  out_fail:
+ #ifndef KERNEL_2_6
+-- 
+1.7.9.5
+
diff -pNur buildroot.2014.08/board/windriver/qsp-ppc/linux-0003-simicsfs-Fix-compile-warnings-umode_t-int.patch buildroot/board/windriver/qsp-ppc/linux-0003-simicsfs-Fix-compile-warnings-umode_t-int.patch
--- buildroot.2014.08/board/windriver/qsp-ppc/linux-0003-simicsfs-Fix-compile-warnings-umode_t-int.patch	1970-01-01 07:00:00.000000000 +0700
+++ buildroot/board/windriver/qsp-ppc/linux-0003-simicsfs-Fix-compile-warnings-umode_t-int.patch	2014-12-09 13:19:53.705729700 +0800
@@ -0,0 +1,43 @@
+From 826f0f16c171bd21911bc100943882254efd55ca Mon Sep 17 00:00:00 2001
+From: Ivar Holmqvist <ivarholmqvist@gmail.com>
+Date: Tue, 17 Apr 2012 17:59:52 +0200
+Subject: [PATCH] simicsfs: Fix compile warnings (umode_t - int)
+
+---
+ fs/simicsfs/hostfs_inode.c |   12 ++++++------
+ 1 file changed, 6 insertions(+), 6 deletions(-)
+
+diff --git a/fs/simicsfs/hostfs_inode.c b/fs/simicsfs/hostfs_inode.c
+index 6e97c9c..2d6f935 100644
+--- a/fs/simicsfs/hostfs_inode.c
++++ b/fs/simicsfs/hostfs_inode.c
+@@ -589,7 +589,7 @@ hostfs_inode_lookup(struct inode *dir, struct dentry *dentry,
+ }
+ 
+ static int
+-hostfs_inode_mkdir(struct inode *dir, struct dentry *dentry, int mode)
++hostfs_inode_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)
+ {
+         struct hf_mkdir_data odata;
+         struct hf_hnode_data idata;
+@@ -634,12 +634,12 @@ hostfs_inode_rmdir(struct inode *dir, struct dentry *dentry)
+ }
+ 
+ static int
+-#ifndef KERNEL_2_6
+-hostfs_inode_create(struct inode *dir, struct dentry *dentry, int mode)
+-#else /* KERNEL_2_6 */
+-hostfs_inode_create(struct inode *dir, struct dentry *dentry, int mode,
++#ifndef KERNEL_2_4
++hostfs_inode_create(struct inode *dir, struct dentry *dentry, umode_t mode,
+                     struct nameidata *name_data)
+-#endif /* KERNEL_2_6 */
++#else
++hostfs_inode_create(struct inode *dir, struct dentry *dentry, int mode)
++#endif
+ {
+         struct hf_create_data odata;
+         struct hf_hnode_data idata;
+-- 
+1.7.9.5
+
diff -pNur buildroot.2014.08/board/windriver/qsp-ppc/linux-0004-REVERT-mtdchar-kill-persistently-held-vfsmount.patch buildroot/board/windriver/qsp-ppc/linux-0004-REVERT-mtdchar-kill-persistently-held-vfsmount.patch
--- buildroot.2014.08/board/windriver/qsp-ppc/linux-0004-REVERT-mtdchar-kill-persistently-held-vfsmount.patch	1970-01-01 07:00:00.000000000 +0700
+++ buildroot/board/windriver/qsp-ppc/linux-0004-REVERT-mtdchar-kill-persistently-held-vfsmount.patch	2014-12-09 13:19:53.705729700 +0800
@@ -0,0 +1,158 @@
+From 888ff03fe5c485e837bdea1468bb9bd34ad36b0e Mon Sep 17 00:00:00 2001
+From: Ivar Holmqvist <ivarholmqvist@gmail.com>
+Date: Thu, 31 May 2012 14:32:08 +0200
+Subject: [PATCH] REVERT: mtdchar: kill persistently held vfsmount
+
+This commit reverts patch 00292bbf769620dea923dbd906afd88955f7ea19
+since it breaks the mtd handling. This may be fixed in later kernels as
+it has already been reported to lkml.
+
+Author: Al Viro <viro@zeniv.linux.org.uk>
+Date:   Fri Mar 23 13:47:52 2012 -0400
+
+    mtdchar: kill persistently held vfsmount
+
+    ... and mtdchar_notifier along with it; just have ->drop_inode() that
+    will unconditionally get evict them instead of dances on mtd device
+    removal and use simple_pin_fs() instead of kern_mount()
+
+    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
+---
+ drivers/mtd/mtdchar.c |   53 ++++++++++++++++++++++++++++++++++---------------
+ 1 file changed, 37 insertions(+), 16 deletions(-)
+
+diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
+index f2f482b..9668078 100644
+--- a/drivers/mtd/mtdchar.c
++++ b/drivers/mtd/mtdchar.c
+@@ -39,6 +39,7 @@
+ #include <asm/uaccess.h>
+ 
+ static DEFINE_MUTEX(mtd_mutex);
++static struct vfsmount *mtd_inode_mnt __read_mostly;
+ 
+ /*
+  * Data structure to hold the pointer to the mtd device as well
+@@ -74,9 +75,7 @@ static loff_t mtdchar_lseek(struct file *file, loff_t offset, int orig)
+ 	return -EINVAL;
+ }
+ 
+-static int count;
+-static struct vfsmount *mnt;
+-static struct file_system_type mtd_inodefs_type;
++
+ 
+ static int mtdchar_open(struct inode *inode, struct file *file)
+ {
+@@ -93,10 +92,6 @@ static int mtdchar_open(struct inode *inode, struct file *file)
+ 	if ((file->f_mode & FMODE_WRITE) && (minor & 1))
+ 		return -EACCES;
+ 
+-	ret = simple_pin_fs(&mtd_inodefs_type, &mnt, &count);
+-	if (ret)
+-		return ret;
+-
+ 	mutex_lock(&mtd_mutex);
+ 	mtd = get_mtd_device(NULL, devnum);
+ 
+@@ -110,7 +105,7 @@ static int mtdchar_open(struct inode *inode, struct file *file)
+ 		goto out1;
+ 	}
+ 
+-	mtd_ino = iget_locked(mnt->mnt_sb, devnum);
++	mtd_ino = iget_locked(mtd_inode_mnt->mnt_sb, devnum);
+ 	if (!mtd_ino) {
+ 		ret = -ENOMEM;
+ 		goto out1;
+@@ -146,7 +141,6 @@ out1:
+ 	put_mtd_device(mtd);
+ out:
+ 	mutex_unlock(&mtd_mutex);
+-	simple_release_fs(&mnt, &count);
+ 	return ret;
+ } /* mtdchar_open */
+ 
+@@ -168,7 +162,6 @@ static int mtdchar_close(struct inode *inode, struct file *file)
+ 	put_mtd_device(mtd);
+ 	file->private_data = NULL;
+ 	kfree(mfi);
+-	simple_release_fs(&mnt, &count);
+ 
+ 	return 0;
+ } /* mtdchar_close */
+@@ -1182,15 +1175,10 @@ static const struct file_operations mtd_fops = {
+ #endif
+ };
+ 
+-static const struct super_operations mtd_ops = {
+-	.drop_inode = generic_delete_inode,
+-	.statfs = simple_statfs,
+-};
+-
+ static struct dentry *mtd_inodefs_mount(struct file_system_type *fs_type,
+ 				int flags, const char *dev_name, void *data)
+ {
+-	return mount_pseudo(fs_type, "mtd_inode:", &mtd_ops, NULL, MTD_INODE_FS_MAGIC);
++	return mount_pseudo(fs_type, "mtd_inode:", NULL, NULL, MTD_INODE_FS_MAGIC);
+ }
+ 
+ static struct file_system_type mtd_inodefs_type = {
+@@ -1199,6 +1187,26 @@ static struct file_system_type mtd_inodefs_type = {
+        .kill_sb = kill_anon_super,
+ };
+ 
++static void mtdchar_notify_add(struct mtd_info *mtd)
++{
++}
++
++static void mtdchar_notify_remove(struct mtd_info *mtd)
++{
++	struct inode *mtd_ino = ilookup(mtd_inode_mnt->mnt_sb, mtd->index);
++
++	if (mtd_ino) {
++		/* Destroy the inode if it exists */
++		clear_nlink(mtd_ino);
++		iput(mtd_ino);
++	}
++}
++
++static struct mtd_notifier mtdchar_notifier = {
++	.add = mtdchar_notify_add,
++	.remove = mtdchar_notify_remove,
++};
++
+ static int __init init_mtdchar(void)
+ {
+ 	int ret;
+@@ -1216,8 +1224,19 @@ static int __init init_mtdchar(void)
+ 		pr_notice("Can't register mtd_inodefs filesystem: %d\n", ret);
+ 		goto err_unregister_chdev;
+ 	}
++
++	mtd_inode_mnt = kern_mount(&mtd_inodefs_type);
++	if (IS_ERR(mtd_inode_mnt)) {
++		ret = PTR_ERR(mtd_inode_mnt);
++		pr_notice("Error mounting mtd_inodefs filesystem: %d\n", ret);
++		goto err_unregister_filesystem;
++	}
++	register_mtd_user(&mtdchar_notifier);
++
+ 	return ret;
+ 
++err_unregister_filesystem:
++	unregister_filesystem(&mtd_inodefs_type);
+ err_unregister_chdev:
+ 	__unregister_chrdev(MTD_CHAR_MAJOR, 0, 1 << MINORBITS, "mtd");
+ 	return ret;
+@@ -1225,6 +1244,8 @@ err_unregister_chdev:
+ 
+ static void __exit cleanup_mtdchar(void)
+ {
++	unregister_mtd_user(&mtdchar_notifier);
++	kern_unmount(mtd_inode_mnt);
+ 	unregister_filesystem(&mtd_inodefs_type);
+ 	__unregister_chrdev(MTD_CHAR_MAJOR, 0, 1 << MINORBITS, "mtd");
+ }
+-- 
+1.7.9.5
+
diff -pNur buildroot.2014.08/board/windriver/qsp-ppc/linux-0005-qsp-arm-Disable-effects-of-commit-078c04545ba-THUMBE.patch buildroot/board/windriver/qsp-ppc/linux-0005-qsp-arm-Disable-effects-of-commit-078c04545ba-THUMBE.patch
--- buildroot.2014.08/board/windriver/qsp-ppc/linux-0005-qsp-arm-Disable-effects-of-commit-078c04545ba-THUMBE.patch	1970-01-01 07:00:00.000000000 +0700
+++ buildroot/board/windriver/qsp-ppc/linux-0005-qsp-arm-Disable-effects-of-commit-078c04545ba-THUMBE.patch	2014-12-09 13:19:53.705729700 +0800
@@ -0,0 +1,37 @@
+From 0f8e7b7a7677b6f156f8cf22c8bf4128a6440331 Mon Sep 17 00:00:00 2001
+From: Ivar Holmqvist <ivarholmqvist@gmail.com>
+Date: Thu, 14 Jun 2012 22:51:14 +0200
+Subject: [PATCH] qsp-arm:  Disable effects of commit 078c04545ba (THUMBEE
+ fixes mm/proc_v7.S) since it breaks on simics.
+
+This needs further investigation and has been reported to on the simics forums thread 36613 as it is most likely a simics cpu bug.
+---
+ arch/arm/mm/proc-v7.S |    5 +++++
+ 1 file changed, 5 insertions(+)
+
+diff --git a/arch/arm/mm/proc-v7.S b/arch/arm/mm/proc-v7.S
+index c2e2b66..b90515d 100644
+--- a/arch/arm/mm/proc-v7.S
++++ b/arch/arm/mm/proc-v7.S
+@@ -255,6 +255,10 @@ __v7_setup:
+ 	mcr	p15, 0, r5, c10, c2, 0		@ write PRRR
+ 	mcr	p15, 0, r6, c10, c2, 1		@ write NMRR
+ #endif
++#ifndef CONFIG_QSP
++	/* This breaks on simics.. don't have time to fix the model
++	* now, just disabling it.
++	*/
+ #ifndef CONFIG_ARM_THUMBEE
+ 	mrc	p15, 0, r0, c0, c1, 0		@ read ID_PFR0 for ThumbEE
+ 	and	r0, r0, #(0xf << 12)		@ ThumbEE enabled field
+@@ -267,6 +271,7 @@ __v7_setup:
+ 	mcr	p14, 6, r0, c0, c0, 0		@ stop userspace TEEHBR access
+ 1:
+ #endif
++#endif
+ 	adr	r5, v7_crval
+ 	ldmia	r5, {r5, r6}
+ #ifdef CONFIG_CPU_ENDIAN_BE8
+-- 
+1.7.9.5
+
diff -pNur buildroot.2014.08/board/windriver/qsp-ppc/linux-0006-qsp-ppc-Initial-support-for-qsp-ppc-platform.patch buildroot/board/windriver/qsp-ppc/linux-0006-qsp-ppc-Initial-support-for-qsp-ppc-platform.patch
--- buildroot.2014.08/board/windriver/qsp-ppc/linux-0006-qsp-ppc-Initial-support-for-qsp-ppc-platform.patch	1970-01-01 07:00:00.000000000 +0700
+++ buildroot/board/windriver/qsp-ppc/linux-0006-qsp-ppc-Initial-support-for-qsp-ppc-platform.patch	2014-12-09 13:19:53.705729700 +0800
@@ -0,0 +1,4970 @@
+From a21b6d8207d6d24cb3f3a2be15c8ec78dbf2cc3e Mon Sep 17 00:00:00 2001
+From: Ivar Holmqvist <ivarholmqvist@gmail.com>
+Date: Mon, 16 Jul 2012 16:57:50 +0200
+Subject: [PATCH] qsp-ppc: Initial support for qsp-ppc platform.
+
+---
+ arch/powerpc/Kconfig                  |    3 +-
+ arch/powerpc/boot/dts/qsp.dts         | 3264 +++++++++++++++++++++++++++++++++
+ arch/powerpc/configs/qsp_defconfig    | 1365 ++++++++++++++
+ arch/powerpc/platforms/Kconfig        |    1 +
+ arch/powerpc/platforms/Makefile       |    1 +
+ arch/powerpc/platforms/qsp/Kconfig    |   18 +
+ arch/powerpc/platforms/qsp/Makefile   |    4 +
+ arch/powerpc/platforms/qsp/head_smp.S |   26 +
+ arch/powerpc/platforms/qsp/setup.c    |   68 +
+ arch/powerpc/platforms/qsp/smp.c      |  103 ++
+ arch/powerpc/platforms/qsp/smp.h      |   17 +
+ 11 files changed, 4869 insertions(+), 1 deletion(-)
+
+diff --git a/arch/powerpc/Kconfig b/arch/powerpc/Kconfig
+index feab3ba..3eecd8f 100644
+--- a/arch/powerpc/Kconfig
++++ b/arch/powerpc/Kconfig
+@@ -719,7 +719,8 @@ config PPC_PCI_CHOICE
+ config PCI
+ 	bool "PCI support" if PPC_PCI_CHOICE
+ 	default y if !40x && !CPM2 && !8xx && !PPC_83xx \
+-		&& !PPC_85xx && !PPC_86xx && !GAMECUBE_COMMON
++		&& !PPC_85xx && !PPC_86xx && !GAMECUBE_COMMON \
++		&& !PPC_QSP
+ 	default PCI_PERMEDIA if !4xx && !CPM2 && !8xx
+ 	default PCI_QSPAN if !4xx && !CPM2 && 8xx
+ 	select ARCH_SUPPORTS_MSI
+diff --git a/arch/powerpc/boot/dts/qsp.dts b/arch/powerpc/boot/dts/qsp.dts
+new file mode 100644
+index 0000000..ca396a6
+--- /dev/null
++++ b/arch/powerpc/boot/dts/qsp.dts
+@@ -0,0 +1,3264 @@
++
++/*
++ * Copyright 2012, Wind River
++ *
++ * This file is licensed under
++ * the terms of the GNU General Public License version 2.  This program
++ * is licensed "as is" without any warranty of any kind, whether express
++ * or implied.
++ */
++
++/* This is a fully populated dts file for a QSP PPC board. The
++ * actual number of cpus and devices can controlled from simics
++ * and we expect to silently fail probing of non-existant devices.
++ */
++
++/dts-v1/;
++
++/ {
++	model = "QSP PPC Simple";
++	compatible = "simics,qsp-ppc";
++	#address-cells = <1>;
++	#size-cells = <1>;
++	chosen {
++		bootargs = "rw root=0x6300 console=ttyAM0";
++	};
++
++	cpus {
++		#address-cells = <1>;
++		#size-cells = <0>;
++
++		PowerPC,e600@0 {
++			device_type = "cpu";
++			reg = <0x0>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@1 {
++			device_type = "cpu";
++			reg = <0x1>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@2 {
++			device_type = "cpu";
++			reg = <0x2>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@3 {
++			device_type = "cpu";
++			reg = <0x3>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@4 {
++			device_type = "cpu";
++			reg = <0x4>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@5 {
++			device_type = "cpu";
++			reg = <0x5>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@6 {
++			device_type = "cpu";
++			reg = <0x6>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@7 {
++			device_type = "cpu";
++			reg = <0x7>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@8 {
++			device_type = "cpu";
++			reg = <0x8>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@9 {
++			device_type = "cpu";
++			reg = <0x9>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@10 {
++			device_type = "cpu";
++			reg = <0xa>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@11 {
++			device_type = "cpu";
++			reg = <0xb>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@12 {
++			device_type = "cpu";
++			reg = <0xc>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@13 {
++			device_type = "cpu";
++			reg = <0xd>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@14 {
++			device_type = "cpu";
++			reg = <0xe>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@15 {
++			device_type = "cpu";
++			reg = <0xf>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@16 {
++			device_type = "cpu";
++			reg = <0x10>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@17 {
++			device_type = "cpu";
++			reg = <0x11>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@18 {
++			device_type = "cpu";
++			reg = <0x12>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@19 {
++			device_type = "cpu";
++			reg = <0x13>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@20 {
++			device_type = "cpu";
++			reg = <0x14>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@21 {
++			device_type = "cpu";
++			reg = <0x15>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@22 {
++			device_type = "cpu";
++			reg = <0x16>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@23 {
++			device_type = "cpu";
++			reg = <0x17>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@24 {
++			device_type = "cpu";
++			reg = <0x18>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@25 {
++			device_type = "cpu";
++			reg = <0x19>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@26 {
++			device_type = "cpu";
++			reg = <0x1a>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@27 {
++			device_type = "cpu";
++			reg = <0x1b>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@28 {
++			device_type = "cpu";
++			reg = <0x1c>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@29 {
++			device_type = "cpu";
++			reg = <0x1d>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@30 {
++			device_type = "cpu";
++			reg = <0x1e>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@31 {
++			device_type = "cpu";
++			reg = <0x1f>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@32 {
++			device_type = "cpu";
++			reg = <0x20>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@33 {
++			device_type = "cpu";
++			reg = <0x21>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@34 {
++			device_type = "cpu";
++			reg = <0x22>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@35 {
++			device_type = "cpu";
++			reg = <0x23>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@36 {
++			device_type = "cpu";
++			reg = <0x24>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@37 {
++			device_type = "cpu";
++			reg = <0x25>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@38 {
++			device_type = "cpu";
++			reg = <0x26>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@39 {
++			device_type = "cpu";
++			reg = <0x27>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@40 {
++			device_type = "cpu";
++			reg = <0x28>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@41 {
++			device_type = "cpu";
++			reg = <0x29>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@42 {
++			device_type = "cpu";
++			reg = <0x2a>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@43 {
++			device_type = "cpu";
++			reg = <0x2b>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@44 {
++			device_type = "cpu";
++			reg = <0x2c>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@45 {
++			device_type = "cpu";
++			reg = <0x2d>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@46 {
++			device_type = "cpu";
++			reg = <0x2e>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@47 {
++			device_type = "cpu";
++			reg = <0x2f>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@48 {
++			device_type = "cpu";
++			reg = <0x30>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@49 {
++			device_type = "cpu";
++			reg = <0x31>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@50 {
++			device_type = "cpu";
++			reg = <0x32>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@51 {
++			device_type = "cpu";
++			reg = <0x33>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@52 {
++			device_type = "cpu";
++			reg = <0x34>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@53 {
++			device_type = "cpu";
++			reg = <0x35>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@54 {
++			device_type = "cpu";
++			reg = <0x36>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@55 {
++			device_type = "cpu";
++			reg = <0x37>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@56 {
++			device_type = "cpu";
++			reg = <0x38>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@57 {
++			device_type = "cpu";
++			reg = <0x39>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@58 {
++			device_type = "cpu";
++			reg = <0x3a>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@59 {
++			device_type = "cpu";
++			reg = <0x3b>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@60 {
++			device_type = "cpu";
++			reg = <0x3c>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@61 {
++			device_type = "cpu";
++			reg = <0x3d>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@62 {
++			device_type = "cpu";
++			reg = <0x3e>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@63 {
++			device_type = "cpu";
++			reg = <0x3f>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@64 {
++			device_type = "cpu";
++			reg = <0x40>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@65 {
++			device_type = "cpu";
++			reg = <0x41>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@66 {
++			device_type = "cpu";
++			reg = <0x42>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@67 {
++			device_type = "cpu";
++			reg = <0x43>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@68 {
++			device_type = "cpu";
++			reg = <0x44>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@69 {
++			device_type = "cpu";
++			reg = <0x45>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@70 {
++			device_type = "cpu";
++			reg = <0x46>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@71 {
++			device_type = "cpu";
++			reg = <0x47>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@72 {
++			device_type = "cpu";
++			reg = <0x48>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@73 {
++			device_type = "cpu";
++			reg = <0x49>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@74 {
++			device_type = "cpu";
++			reg = <0x4a>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@75 {
++			device_type = "cpu";
++			reg = <0x4b>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@76 {
++			device_type = "cpu";
++			reg = <0x4c>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@77 {
++			device_type = "cpu";
++			reg = <0x4d>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@78 {
++			device_type = "cpu";
++			reg = <0x4e>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@79 {
++			device_type = "cpu";
++			reg = <0x4f>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@80 {
++			device_type = "cpu";
++			reg = <0x50>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@81 {
++			device_type = "cpu";
++			reg = <0x51>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@82 {
++			device_type = "cpu";
++			reg = <0x52>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@83 {
++			device_type = "cpu";
++			reg = <0x53>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@84 {
++			device_type = "cpu";
++			reg = <0x54>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@85 {
++			device_type = "cpu";
++			reg = <0x55>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@86 {
++			device_type = "cpu";
++			reg = <0x56>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@87 {
++			device_type = "cpu";
++			reg = <0x57>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@88 {
++			device_type = "cpu";
++			reg = <0x58>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@89 {
++			device_type = "cpu";
++			reg = <0x59>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@90 {
++			device_type = "cpu";
++			reg = <0x5a>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@91 {
++			device_type = "cpu";
++			reg = <0x5b>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@92 {
++			device_type = "cpu";
++			reg = <0x5c>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@93 {
++			device_type = "cpu";
++			reg = <0x5d>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@94 {
++			device_type = "cpu";
++			reg = <0x5e>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@95 {
++			device_type = "cpu";
++			reg = <0x5f>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@96 {
++			device_type = "cpu";
++			reg = <0x60>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@97 {
++			device_type = "cpu";
++			reg = <0x61>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@98 {
++			device_type = "cpu";
++			reg = <0x62>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@99 {
++			device_type = "cpu";
++			reg = <0x63>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@100 {
++			device_type = "cpu";
++			reg = <0x64>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@101 {
++			device_type = "cpu";
++			reg = <0x65>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@102 {
++			device_type = "cpu";
++			reg = <0x66>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@103 {
++			device_type = "cpu";
++			reg = <0x67>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@104 {
++			device_type = "cpu";
++			reg = <0x68>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@105 {
++			device_type = "cpu";
++			reg = <0x69>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@106 {
++			device_type = "cpu";
++			reg = <0x6a>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@107 {
++			device_type = "cpu";
++			reg = <0x6b>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@108 {
++			device_type = "cpu";
++			reg = <0x6c>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@109 {
++			device_type = "cpu";
++			reg = <0x6d>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@110 {
++			device_type = "cpu";
++			reg = <0x6e>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@111 {
++			device_type = "cpu";
++			reg = <0x6f>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@112 {
++			device_type = "cpu";
++			reg = <0x70>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@113 {
++			device_type = "cpu";
++			reg = <0x71>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@114 {
++			device_type = "cpu";
++			reg = <0x72>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@115 {
++			device_type = "cpu";
++			reg = <0x73>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@116 {
++			device_type = "cpu";
++			reg = <0x74>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@117 {
++			device_type = "cpu";
++			reg = <0x75>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@118 {
++			device_type = "cpu";
++			reg = <0x76>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@119 {
++			device_type = "cpu";
++			reg = <0x77>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@120 {
++			device_type = "cpu";
++			reg = <0x78>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@121 {
++			device_type = "cpu";
++			reg = <0x79>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@122 {
++			device_type = "cpu";
++			reg = <0x7a>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@123 {
++			device_type = "cpu";
++			reg = <0x7b>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@124 {
++			device_type = "cpu";
++			reg = <0x7c>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@125 {
++			device_type = "cpu";
++			reg = <0x7d>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@126 {
++			device_type = "cpu";
++			reg = <0x7e>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++		PowerPC,e600@127 {
++			device_type = "cpu";
++			reg = <0x7f>;
++			clock-frequency =   <1000000000>;
++			timebase-frequency = <125000000>;
++			bus-frequency = <0>;
++			/* Following required by dtc but not used */
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++		};
++
++	};
++
++	memory {
++		device_type = "memory";
++		reg = <0x0 0x20000000>;
++	};
++
++	soc@0xe0000000 {
++		#address-cells = <2>;
++		#size-cells = <1>;
++		device_type = "soc";
++		compatible = "simple-bus";
++		ranges = <		0 0 0xe0000000 0x1000 //pic0
++		1 0 0xe0001000 0x1000 //sysregs0
++		2 0 0xe0002000 0x1000 //rtc0
++		3 0 0xe0010000 0x1000 //uart0
++		4 0 0xe0011000 0x1000 //uart1
++		5 0 0xe0012000 0x1000 //uart2
++		6 0 0xe0013000 0x1000 //uart3
++		7 0 0xe0014000 0x1000 //uart4
++		8 0 0xe0015000 0x1000 //uart5
++		9 0 0xe0016000 0x1000 //uart6
++		10 0 0xe0017000 0x1000 //uart7
++		11 0 0xe0018000 0x1000 //uart8
++		12 0 0xe0019000 0x1000 //uart9
++		13 0 0xe001a000 0x1000 //uart10
++		14 0 0xe001b000 0x1000 //uart11
++		15 0 0xe001c000 0x1000 //uart12
++		16 0 0xe001d000 0x1000 //uart13
++		17 0 0xe001e000 0x1000 //uart14
++		18 0 0xe001f000 0x1000 //uart15
++		19 0 0xe0020000 0x1000 //timer0
++		20 0 0xe0030000 0x1000 //led0
++		21 0 0xe0031000 0x1000 //led1
++		22 0 0xe0032000 0x1000 //led2
++		23 0 0xe0033000 0x1000 //led3
++		24 0 0xe0034000 0x1000 //led4
++		25 0 0xe0035000 0x1000 //led5
++		26 0 0xe0036000 0x1000 //led6
++		27 0 0xe0037000 0x1000 //led7
++		28 0 0xe0038000 0x1000 //led8
++		29 0 0xe0039000 0x1000 //led9
++		30 0 0xe003a000 0x1000 //led10
++		31 0 0xe003b000 0x1000 //led11
++		32 0 0xe003c000 0x1000 //led12
++		33 0 0xe003d000 0x1000 //led13
++		34 0 0xe003e000 0x1000 //led14
++		35 0 0xe003f000 0x1000 //led15
++		36 0 0xe0040000 0x1000 //mac0
++		37 0 0xe0041000 0x1000 //mac1
++		38 0 0xe0042000 0x1000 //mac2
++		39 0 0xe0043000 0x1000 //mac3
++		40 0 0xe0044000 0x1000 //mac4
++		41 0 0xe0045000 0x1000 //mac5
++		42 0 0xe0046000 0x1000 //mac6
++		43 0 0xe0047000 0x1000 //mac7
++		44 0 0xe0048000 0x1000 //mac8
++		45 0 0xe0049000 0x1000 //mac9
++		46 0 0xe004a000 0x1000 //mac10
++		47 0 0xe004b000 0x1000 //mac11
++		48 0 0xe004c000 0x1000 //mac12
++		49 0 0xe004d000 0x1000 //mac13
++		50 0 0xe004e000 0x1000 //mac14
++		51 0 0xe004f000 0x1000 //mac15
++		52 0 0xe0050000 0x1000 //disk_ctrl0
++		53 0 0xe0051000 0x1000 //disk_ctrl1
++		54 0 0xe0052000 0x1000 //disk_ctrl2
++		55 0 0xe0053000 0x1000 //disk_ctrl3
++		56 0 0xe0054000 0x1000 //disk_ctrl4
++		57 0 0xe0055000 0x1000 //disk_ctrl5
++		58 0 0xe0056000 0x1000 //disk_ctrl6
++		59 0 0xe0057000 0x1000 //disk_ctrl7
++		60 0 0xe0058000 0x1000 //disk_ctrl8
++		61 0 0xe0059000 0x1000 //disk_ctrl9
++		62 0 0xe005a000 0x1000 //disk_ctrl10
++		63 0 0xe005b000 0x1000 //disk_ctrl11
++		64 0 0xe005c000 0x1000 //disk_ctrl12
++		65 0 0xe005d000 0x1000 //disk_ctrl13
++		66 0 0xe005e000 0x1000 //disk_ctrl14
++		67 0 0xe005f000 0x1000 //disk_ctrl15
++>;
++		bus-frequency = <0>;
++
++		PIC: interrupt-controller@0,0 {
++			#interrupt-cells = <2>;
++			cell-index = <0>;
++			device_type = "interrupt-controller";
++			compatible = "qsp-pic";
++			interrupt-controller;
++			reg = <0 0x0 0x1000>;
++		};
++
++		SYSREGS: sysregs {
++
++			device_type = "sysregs";
++			compatible = "qsp,sysregs";
++			reg = <1 0x0 0x1000>;
++		};
++
++		RTC: rtc {
++			device_type = "rtc";
++			compatible = "qsp-rtc";
++			reg = <2 0x0 0x1000>;
++		};
++
++		UART0: qspserial0 {
++			device_type = "serial";
++			compatible = "qsp-serial";
++			reg = <3 0x0 0x1000>;
++			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
++			interrupt-parent = <&PIC>;
++ 			interrupts = <16 0x1>;
++		};
++
++		UART1: qspserial1 {
++			device_type = "serial";
++			compatible = "qsp-serial";
++			reg = <4 0x0 0x1000>;
++			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
++			interrupt-parent = <&PIC>;
++ 			interrupts = <17 0x1>;
++		};
++
++		UART2: qspserial2 {
++			device_type = "serial";
++			compatible = "qsp-serial";
++			reg = <5 0x0 0x1000>;
++			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
++			interrupt-parent = <&PIC>;
++ 			interrupts = <18 0x1>;
++		};
++
++		UART3: qspserial3 {
++			device_type = "serial";
++			compatible = "qsp-serial";
++			reg = <6 0x0 0x1000>;
++			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
++			interrupt-parent = <&PIC>;
++ 			interrupts = <19 0x1>;
++		};
++
++		UART4: qspserial4 {
++			device_type = "serial";
++			compatible = "qsp-serial";
++			reg = <7 0x0 0x1000>;
++			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
++			interrupt-parent = <&PIC>;
++ 			interrupts = <20 0x1>;
++		};
++
++		UART5: qspserial5 {
++			device_type = "serial";
++			compatible = "qsp-serial";
++			reg = <8 0x0 0x1000>;
++			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
++			interrupt-parent = <&PIC>;
++ 			interrupts = <21 0x1>;
++		};
++
++		UART6: qspserial6 {
++			device_type = "serial";
++			compatible = "qsp-serial";
++			reg = <9 0x0 0x1000>;
++			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
++			interrupt-parent = <&PIC>;
++ 			interrupts = <22 0x1>;
++		};
++
++		UART7: qspserial7 {
++			device_type = "serial";
++			compatible = "qsp-serial";
++			reg = <10 0x0 0x1000>;
++			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
++			interrupt-parent = <&PIC>;
++ 			interrupts = <23 0x1>;
++		};
++
++		UART8: qspserial8 {
++			device_type = "serial";
++			compatible = "qsp-serial";
++			reg = <11 0x0 0x1000>;
++			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
++			interrupt-parent = <&PIC>;
++ 			interrupts = <24 0x1>;
++		};
++
++		UART9: qspserial9 {
++			device_type = "serial";
++			compatible = "qsp-serial";
++			reg = <12 0x0 0x1000>;
++			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
++			interrupt-parent = <&PIC>;
++ 			interrupts = <25 0x1>;
++		};
++
++		UART10: qspserial10 {
++			device_type = "serial";
++			compatible = "qsp-serial";
++			reg = <13 0x0 0x1000>;
++			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
++			interrupt-parent = <&PIC>;
++ 			interrupts = <26 0x1>;
++		};
++
++		UART11: qspserial11 {
++			device_type = "serial";
++			compatible = "qsp-serial";
++			reg = <14 0x0 0x1000>;
++			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
++			interrupt-parent = <&PIC>;
++ 			interrupts = <27 0x1>;
++		};
++
++		UART12: qspserial12 {
++			device_type = "serial";
++			compatible = "qsp-serial";
++			reg = <15 0x0 0x1000>;
++			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
++			interrupt-parent = <&PIC>;
++ 			interrupts = <28 0x1>;
++		};
++
++		UART13: qspserial13 {
++			device_type = "serial";
++			compatible = "qsp-serial";
++			reg = <16 0x0 0x1000>;
++			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
++			interrupt-parent = <&PIC>;
++ 			interrupts = <29 0x1>;
++		};
++
++		UART14: qspserial14 {
++			device_type = "serial";
++			compatible = "qsp-serial";
++			reg = <17 0x0 0x1000>;
++			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
++			interrupt-parent = <&PIC>;
++ 			interrupts = <30 0x1>;
++		};
++
++		UART15: qspserial15 {
++			device_type = "serial";
++			compatible = "qsp-serial";
++			reg = <18 0x0 0x1000>;
++			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
++			interrupt-parent = <&PIC>;
++ 			interrupts = <31 0x1>;
++		};
++
++		TIMER0: qsptimer0 {
++			compatible = "qsp,timer";
++			reg = <19 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <32 0x1>;
++		};
++
++		led0 {
++		 	 label = "led0";
++                         compatible = "leds-qsp";
++                         reg = <20 0x0 0x1000>;
++
++		 	 linux,default-trigger = "default-on";
++
++			led0 {
++				label = "power";
++				index = <0>;
++				linux,default-trigger = "default-on";
++			};
++			led01 {
++				label = "heartbeat";
++				index = <1>;
++				linux,default-trigger = "heartbeat";
++			};
++			led02 {
++				label = "timer";
++				index = <2>;
++				//linux,default-trigger = "timer";
++			};
++			led03 {
++				label = "cpu0";
++				index = <3>;
++				//linux,default-trigger = "cpu0";
++			};
++			led04 {
++				label = "cpu1";
++				index = <4>;
++				//linux,default-trigger = "cpu1";
++			};
++			led05 {
++				label = "cpu2";
++				index = <5>;
++				//linux,default-trigger = "cpu2";
++			};
++			led06 {
++				label = "cpu3";
++				index = <6>;
++				//linux,default-trigger = "cpu3";
++			};
++			led07 {
++				label = "led07";
++				index = <7>;
++			};
++			led08 {
++				label = "led08";
++				index = <8>;
++			};
++			led09 {
++				label = "led09";
++				index = <9>;
++			};
++			led10 {
++				label = "led10";
++				index = <10>;
++			};
++			led11 {
++				label = "led11";
++				index = <11>;
++			};
++			led12 {
++				label = "led12";
++				index = <12>;
++			};
++			led13 {
++				label = "led13";
++				index = <13>;
++			};
++			led14 {
++				label = "led14";
++				index = <14>;
++			};
++			led15 {
++				label = "led15";
++				index = <15>;
++			};
++
++		};
++
++		led1 {
++		 	 label = "led1";
++                         compatible = "leds-qsp";
++                         reg = <21 0x0 0x1000>;
++
++		 	 linux,default-trigger = "default-on";
++
++			led0 {
++				label = "power";
++				index = <0>;
++				linux,default-trigger = "default-on";
++			};
++			led01 {
++				label = "heartbeat";
++				index = <1>;
++				linux,default-trigger = "heartbeat";
++			};
++			led02 {
++				label = "timer";
++				index = <2>;
++				//linux,default-trigger = "timer";
++			};
++			led03 {
++				label = "cpu0";
++				index = <3>;
++				//linux,default-trigger = "cpu0";
++			};
++			led04 {
++				label = "cpu1";
++				index = <4>;
++				//linux,default-trigger = "cpu1";
++			};
++			led05 {
++				label = "cpu2";
++				index = <5>;
++				//linux,default-trigger = "cpu2";
++			};
++			led06 {
++				label = "cpu3";
++				index = <6>;
++				//linux,default-trigger = "cpu3";
++			};
++			led07 {
++				label = "led07";
++				index = <7>;
++			};
++			led08 {
++				label = "led08";
++				index = <8>;
++			};
++			led09 {
++				label = "led09";
++				index = <9>;
++			};
++			led10 {
++				label = "led10";
++				index = <10>;
++			};
++			led11 {
++				label = "led11";
++				index = <11>;
++			};
++			led12 {
++				label = "led12";
++				index = <12>;
++			};
++			led13 {
++				label = "led13";
++				index = <13>;
++			};
++			led14 {
++				label = "led14";
++				index = <14>;
++			};
++			led15 {
++				label = "led15";
++				index = <15>;
++			};
++
++		};
++
++		led2 {
++		 	 label = "led2";
++                         compatible = "leds-qsp";
++                         reg = <22 0x0 0x1000>;
++
++		 	 linux,default-trigger = "default-on";
++
++			led0 {
++				label = "power";
++				index = <0>;
++				linux,default-trigger = "default-on";
++			};
++			led01 {
++				label = "heartbeat";
++				index = <1>;
++				linux,default-trigger = "heartbeat";
++			};
++			led02 {
++				label = "timer";
++				index = <2>;
++				//linux,default-trigger = "timer";
++			};
++			led03 {
++				label = "cpu0";
++				index = <3>;
++				//linux,default-trigger = "cpu0";
++			};
++			led04 {
++				label = "cpu1";
++				index = <4>;
++				//linux,default-trigger = "cpu1";
++			};
++			led05 {
++				label = "cpu2";
++				index = <5>;
++				//linux,default-trigger = "cpu2";
++			};
++			led06 {
++				label = "cpu3";
++				index = <6>;
++				//linux,default-trigger = "cpu3";
++			};
++			led07 {
++				label = "led07";
++				index = <7>;
++			};
++			led08 {
++				label = "led08";
++				index = <8>;
++			};
++			led09 {
++				label = "led09";
++				index = <9>;
++			};
++			led10 {
++				label = "led10";
++				index = <10>;
++			};
++			led11 {
++				label = "led11";
++				index = <11>;
++			};
++			led12 {
++				label = "led12";
++				index = <12>;
++			};
++			led13 {
++				label = "led13";
++				index = <13>;
++			};
++			led14 {
++				label = "led14";
++				index = <14>;
++			};
++			led15 {
++				label = "led15";
++				index = <15>;
++			};
++
++		};
++
++		led3 {
++		 	 label = "led3";
++                         compatible = "leds-qsp";
++                         reg = <23 0x0 0x1000>;
++
++		 	 linux,default-trigger = "default-on";
++
++			led0 {
++				label = "power";
++				index = <0>;
++				linux,default-trigger = "default-on";
++			};
++			led01 {
++				label = "heartbeat";
++				index = <1>;
++				linux,default-trigger = "heartbeat";
++			};
++			led02 {
++				label = "timer";
++				index = <2>;
++				//linux,default-trigger = "timer";
++			};
++			led03 {
++				label = "cpu0";
++				index = <3>;
++				//linux,default-trigger = "cpu0";
++			};
++			led04 {
++				label = "cpu1";
++				index = <4>;
++				//linux,default-trigger = "cpu1";
++			};
++			led05 {
++				label = "cpu2";
++				index = <5>;
++				//linux,default-trigger = "cpu2";
++			};
++			led06 {
++				label = "cpu3";
++				index = <6>;
++				//linux,default-trigger = "cpu3";
++			};
++			led07 {
++				label = "led07";
++				index = <7>;
++			};
++			led08 {
++				label = "led08";
++				index = <8>;
++			};
++			led09 {
++				label = "led09";
++				index = <9>;
++			};
++			led10 {
++				label = "led10";
++				index = <10>;
++			};
++			led11 {
++				label = "led11";
++				index = <11>;
++			};
++			led12 {
++				label = "led12";
++				index = <12>;
++			};
++			led13 {
++				label = "led13";
++				index = <13>;
++			};
++			led14 {
++				label = "led14";
++				index = <14>;
++			};
++			led15 {
++				label = "led15";
++				index = <15>;
++			};
++
++		};
++
++		led4 {
++		 	 label = "led4";
++                         compatible = "leds-qsp";
++                         reg = <24 0x0 0x1000>;
++
++		 	 linux,default-trigger = "default-on";
++
++			led0 {
++				label = "power";
++				index = <0>;
++				linux,default-trigger = "default-on";
++			};
++			led01 {
++				label = "heartbeat";
++				index = <1>;
++				linux,default-trigger = "heartbeat";
++			};
++			led02 {
++				label = "timer";
++				index = <2>;
++				//linux,default-trigger = "timer";
++			};
++			led03 {
++				label = "cpu0";
++				index = <3>;
++				//linux,default-trigger = "cpu0";
++			};
++			led04 {
++				label = "cpu1";
++				index = <4>;
++				//linux,default-trigger = "cpu1";
++			};
++			led05 {
++				label = "cpu2";
++				index = <5>;
++				//linux,default-trigger = "cpu2";
++			};
++			led06 {
++				label = "cpu3";
++				index = <6>;
++				//linux,default-trigger = "cpu3";
++			};
++			led07 {
++				label = "led07";
++				index = <7>;
++			};
++			led08 {
++				label = "led08";
++				index = <8>;
++			};
++			led09 {
++				label = "led09";
++				index = <9>;
++			};
++			led10 {
++				label = "led10";
++				index = <10>;
++			};
++			led11 {
++				label = "led11";
++				index = <11>;
++			};
++			led12 {
++				label = "led12";
++				index = <12>;
++			};
++			led13 {
++				label = "led13";
++				index = <13>;
++			};
++			led14 {
++				label = "led14";
++				index = <14>;
++			};
++			led15 {
++				label = "led15";
++				index = <15>;
++			};
++
++		};
++
++		led5 {
++		 	 label = "led5";
++                         compatible = "leds-qsp";
++                         reg = <25 0x0 0x1000>;
++
++		 	 linux,default-trigger = "default-on";
++
++			led0 {
++				label = "power";
++				index = <0>;
++				linux,default-trigger = "default-on";
++			};
++			led01 {
++				label = "heartbeat";
++				index = <1>;
++				linux,default-trigger = "heartbeat";
++			};
++			led02 {
++				label = "timer";
++				index = <2>;
++				//linux,default-trigger = "timer";
++			};
++			led03 {
++				label = "cpu0";
++				index = <3>;
++				//linux,default-trigger = "cpu0";
++			};
++			led04 {
++				label = "cpu1";
++				index = <4>;
++				//linux,default-trigger = "cpu1";
++			};
++			led05 {
++				label = "cpu2";
++				index = <5>;
++				//linux,default-trigger = "cpu2";
++			};
++			led06 {
++				label = "cpu3";
++				index = <6>;
++				//linux,default-trigger = "cpu3";
++			};
++			led07 {
++				label = "led07";
++				index = <7>;
++			};
++			led08 {
++				label = "led08";
++				index = <8>;
++			};
++			led09 {
++				label = "led09";
++				index = <9>;
++			};
++			led10 {
++				label = "led10";
++				index = <10>;
++			};
++			led11 {
++				label = "led11";
++				index = <11>;
++			};
++			led12 {
++				label = "led12";
++				index = <12>;
++			};
++			led13 {
++				label = "led13";
++				index = <13>;
++			};
++			led14 {
++				label = "led14";
++				index = <14>;
++			};
++			led15 {
++				label = "led15";
++				index = <15>;
++			};
++
++		};
++
++		led6 {
++		 	 label = "led6";
++                         compatible = "leds-qsp";
++                         reg = <26 0x0 0x1000>;
++
++		 	 linux,default-trigger = "default-on";
++
++			led0 {
++				label = "power";
++				index = <0>;
++				linux,default-trigger = "default-on";
++			};
++			led01 {
++				label = "heartbeat";
++				index = <1>;
++				linux,default-trigger = "heartbeat";
++			};
++			led02 {
++				label = "timer";
++				index = <2>;
++				//linux,default-trigger = "timer";
++			};
++			led03 {
++				label = "cpu0";
++				index = <3>;
++				//linux,default-trigger = "cpu0";
++			};
++			led04 {
++				label = "cpu1";
++				index = <4>;
++				//linux,default-trigger = "cpu1";
++			};
++			led05 {
++				label = "cpu2";
++				index = <5>;
++				//linux,default-trigger = "cpu2";
++			};
++			led06 {
++				label = "cpu3";
++				index = <6>;
++				//linux,default-trigger = "cpu3";
++			};
++			led07 {
++				label = "led07";
++				index = <7>;
++			};
++			led08 {
++				label = "led08";
++				index = <8>;
++			};
++			led09 {
++				label = "led09";
++				index = <9>;
++			};
++			led10 {
++				label = "led10";
++				index = <10>;
++			};
++			led11 {
++				label = "led11";
++				index = <11>;
++			};
++			led12 {
++				label = "led12";
++				index = <12>;
++			};
++			led13 {
++				label = "led13";
++				index = <13>;
++			};
++			led14 {
++				label = "led14";
++				index = <14>;
++			};
++			led15 {
++				label = "led15";
++				index = <15>;
++			};
++
++		};
++
++		led7 {
++		 	 label = "led7";
++                         compatible = "leds-qsp";
++                         reg = <27 0x0 0x1000>;
++
++		 	 linux,default-trigger = "default-on";
++
++			led0 {
++				label = "power";
++				index = <0>;
++				linux,default-trigger = "default-on";
++			};
++			led01 {
++				label = "heartbeat";
++				index = <1>;
++				linux,default-trigger = "heartbeat";
++			};
++			led02 {
++				label = "timer";
++				index = <2>;
++				//linux,default-trigger = "timer";
++			};
++			led03 {
++				label = "cpu0";
++				index = <3>;
++				//linux,default-trigger = "cpu0";
++			};
++			led04 {
++				label = "cpu1";
++				index = <4>;
++				//linux,default-trigger = "cpu1";
++			};
++			led05 {
++				label = "cpu2";
++				index = <5>;
++				//linux,default-trigger = "cpu2";
++			};
++			led06 {
++				label = "cpu3";
++				index = <6>;
++				//linux,default-trigger = "cpu3";
++			};
++			led07 {
++				label = "led07";
++				index = <7>;
++			};
++			led08 {
++				label = "led08";
++				index = <8>;
++			};
++			led09 {
++				label = "led09";
++				index = <9>;
++			};
++			led10 {
++				label = "led10";
++				index = <10>;
++			};
++			led11 {
++				label = "led11";
++				index = <11>;
++			};
++			led12 {
++				label = "led12";
++				index = <12>;
++			};
++			led13 {
++				label = "led13";
++				index = <13>;
++			};
++			led14 {
++				label = "led14";
++				index = <14>;
++			};
++			led15 {
++				label = "led15";
++				index = <15>;
++			};
++
++		};
++
++		led8 {
++		 	 label = "led8";
++                         compatible = "leds-qsp";
++                         reg = <28 0x0 0x1000>;
++
++		 	 linux,default-trigger = "default-on";
++
++			led0 {
++				label = "power";
++				index = <0>;
++				linux,default-trigger = "default-on";
++			};
++			led01 {
++				label = "heartbeat";
++				index = <1>;
++				linux,default-trigger = "heartbeat";
++			};
++			led02 {
++				label = "timer";
++				index = <2>;
++				//linux,default-trigger = "timer";
++			};
++			led03 {
++				label = "cpu0";
++				index = <3>;
++				//linux,default-trigger = "cpu0";
++			};
++			led04 {
++				label = "cpu1";
++				index = <4>;
++				//linux,default-trigger = "cpu1";
++			};
++			led05 {
++				label = "cpu2";
++				index = <5>;
++				//linux,default-trigger = "cpu2";
++			};
++			led06 {
++				label = "cpu3";
++				index = <6>;
++				//linux,default-trigger = "cpu3";
++			};
++			led07 {
++				label = "led07";
++				index = <7>;
++			};
++			led08 {
++				label = "led08";
++				index = <8>;
++			};
++			led09 {
++				label = "led09";
++				index = <9>;
++			};
++			led10 {
++				label = "led10";
++				index = <10>;
++			};
++			led11 {
++				label = "led11";
++				index = <11>;
++			};
++			led12 {
++				label = "led12";
++				index = <12>;
++			};
++			led13 {
++				label = "led13";
++				index = <13>;
++			};
++			led14 {
++				label = "led14";
++				index = <14>;
++			};
++			led15 {
++				label = "led15";
++				index = <15>;
++			};
++
++		};
++
++		led9 {
++		 	 label = "led9";
++                         compatible = "leds-qsp";
++                         reg = <29 0x0 0x1000>;
++
++		 	 linux,default-trigger = "default-on";
++
++			led0 {
++				label = "power";
++				index = <0>;
++				linux,default-trigger = "default-on";
++			};
++			led01 {
++				label = "heartbeat";
++				index = <1>;
++				linux,default-trigger = "heartbeat";
++			};
++			led02 {
++				label = "timer";
++				index = <2>;
++				//linux,default-trigger = "timer";
++			};
++			led03 {
++				label = "cpu0";
++				index = <3>;
++				//linux,default-trigger = "cpu0";
++			};
++			led04 {
++				label = "cpu1";
++				index = <4>;
++				//linux,default-trigger = "cpu1";
++			};
++			led05 {
++				label = "cpu2";
++				index = <5>;
++				//linux,default-trigger = "cpu2";
++			};
++			led06 {
++				label = "cpu3";
++				index = <6>;
++				//linux,default-trigger = "cpu3";
++			};
++			led07 {
++				label = "led07";
++				index = <7>;
++			};
++			led08 {
++				label = "led08";
++				index = <8>;
++			};
++			led09 {
++				label = "led09";
++				index = <9>;
++			};
++			led10 {
++				label = "led10";
++				index = <10>;
++			};
++			led11 {
++				label = "led11";
++				index = <11>;
++			};
++			led12 {
++				label = "led12";
++				index = <12>;
++			};
++			led13 {
++				label = "led13";
++				index = <13>;
++			};
++			led14 {
++				label = "led14";
++				index = <14>;
++			};
++			led15 {
++				label = "led15";
++				index = <15>;
++			};
++
++		};
++
++		led10 {
++		 	 label = "led10";
++                         compatible = "leds-qsp";
++                         reg = <30 0x0 0x1000>;
++
++		 	 linux,default-trigger = "default-on";
++
++			led0 {
++				label = "power";
++				index = <0>;
++				linux,default-trigger = "default-on";
++			};
++			led01 {
++				label = "heartbeat";
++				index = <1>;
++				linux,default-trigger = "heartbeat";
++			};
++			led02 {
++				label = "timer";
++				index = <2>;
++				//linux,default-trigger = "timer";
++			};
++			led03 {
++				label = "cpu0";
++				index = <3>;
++				//linux,default-trigger = "cpu0";
++			};
++			led04 {
++				label = "cpu1";
++				index = <4>;
++				//linux,default-trigger = "cpu1";
++			};
++			led05 {
++				label = "cpu2";
++				index = <5>;
++				//linux,default-trigger = "cpu2";
++			};
++			led06 {
++				label = "cpu3";
++				index = <6>;
++				//linux,default-trigger = "cpu3";
++			};
++			led07 {
++				label = "led07";
++				index = <7>;
++			};
++			led08 {
++				label = "led08";
++				index = <8>;
++			};
++			led09 {
++				label = "led09";
++				index = <9>;
++			};
++			led10 {
++				label = "led10";
++				index = <10>;
++			};
++			led11 {
++				label = "led11";
++				index = <11>;
++			};
++			led12 {
++				label = "led12";
++				index = <12>;
++			};
++			led13 {
++				label = "led13";
++				index = <13>;
++			};
++			led14 {
++				label = "led14";
++				index = <14>;
++			};
++			led15 {
++				label = "led15";
++				index = <15>;
++			};
++
++		};
++
++		led11 {
++		 	 label = "led11";
++                         compatible = "leds-qsp";
++                         reg = <31 0x0 0x1000>;
++
++		 	 linux,default-trigger = "default-on";
++
++			led0 {
++				label = "power";
++				index = <0>;
++				linux,default-trigger = "default-on";
++			};
++			led01 {
++				label = "heartbeat";
++				index = <1>;
++				linux,default-trigger = "heartbeat";
++			};
++			led02 {
++				label = "timer";
++				index = <2>;
++				//linux,default-trigger = "timer";
++			};
++			led03 {
++				label = "cpu0";
++				index = <3>;
++				//linux,default-trigger = "cpu0";
++			};
++			led04 {
++				label = "cpu1";
++				index = <4>;
++				//linux,default-trigger = "cpu1";
++			};
++			led05 {
++				label = "cpu2";
++				index = <5>;
++				//linux,default-trigger = "cpu2";
++			};
++			led06 {
++				label = "cpu3";
++				index = <6>;
++				//linux,default-trigger = "cpu3";
++			};
++			led07 {
++				label = "led07";
++				index = <7>;
++			};
++			led08 {
++				label = "led08";
++				index = <8>;
++			};
++			led09 {
++				label = "led09";
++				index = <9>;
++			};
++			led10 {
++				label = "led10";
++				index = <10>;
++			};
++			led11 {
++				label = "led11";
++				index = <11>;
++			};
++			led12 {
++				label = "led12";
++				index = <12>;
++			};
++			led13 {
++				label = "led13";
++				index = <13>;
++			};
++			led14 {
++				label = "led14";
++				index = <14>;
++			};
++			led15 {
++				label = "led15";
++				index = <15>;
++			};
++
++		};
++
++		led12 {
++		 	 label = "led12";
++                         compatible = "leds-qsp";
++                         reg = <32 0x0 0x1000>;
++
++		 	 linux,default-trigger = "default-on";
++
++			led0 {
++				label = "power";
++				index = <0>;
++				linux,default-trigger = "default-on";
++			};
++			led01 {
++				label = "heartbeat";
++				index = <1>;
++				linux,default-trigger = "heartbeat";
++			};
++			led02 {
++				label = "timer";
++				index = <2>;
++				//linux,default-trigger = "timer";
++			};
++			led03 {
++				label = "cpu0";
++				index = <3>;
++				//linux,default-trigger = "cpu0";
++			};
++			led04 {
++				label = "cpu1";
++				index = <4>;
++				//linux,default-trigger = "cpu1";
++			};
++			led05 {
++				label = "cpu2";
++				index = <5>;
++				//linux,default-trigger = "cpu2";
++			};
++			led06 {
++				label = "cpu3";
++				index = <6>;
++				//linux,default-trigger = "cpu3";
++			};
++			led07 {
++				label = "led07";
++				index = <7>;
++			};
++			led08 {
++				label = "led08";
++				index = <8>;
++			};
++			led09 {
++				label = "led09";
++				index = <9>;
++			};
++			led10 {
++				label = "led10";
++				index = <10>;
++			};
++			led11 {
++				label = "led11";
++				index = <11>;
++			};
++			led12 {
++				label = "led12";
++				index = <12>;
++			};
++			led13 {
++				label = "led13";
++				index = <13>;
++			};
++			led14 {
++				label = "led14";
++				index = <14>;
++			};
++			led15 {
++				label = "led15";
++				index = <15>;
++			};
++
++		};
++
++		led13 {
++		 	 label = "led13";
++                         compatible = "leds-qsp";
++                         reg = <33 0x0 0x1000>;
++
++		 	 linux,default-trigger = "default-on";
++
++			led0 {
++				label = "power";
++				index = <0>;
++				linux,default-trigger = "default-on";
++			};
++			led01 {
++				label = "heartbeat";
++				index = <1>;
++				linux,default-trigger = "heartbeat";
++			};
++			led02 {
++				label = "timer";
++				index = <2>;
++				//linux,default-trigger = "timer";
++			};
++			led03 {
++				label = "cpu0";
++				index = <3>;
++				//linux,default-trigger = "cpu0";
++			};
++			led04 {
++				label = "cpu1";
++				index = <4>;
++				//linux,default-trigger = "cpu1";
++			};
++			led05 {
++				label = "cpu2";
++				index = <5>;
++				//linux,default-trigger = "cpu2";
++			};
++			led06 {
++				label = "cpu3";
++				index = <6>;
++				//linux,default-trigger = "cpu3";
++			};
++			led07 {
++				label = "led07";
++				index = <7>;
++			};
++			led08 {
++				label = "led08";
++				index = <8>;
++			};
++			led09 {
++				label = "led09";
++				index = <9>;
++			};
++			led10 {
++				label = "led10";
++				index = <10>;
++			};
++			led11 {
++				label = "led11";
++				index = <11>;
++			};
++			led12 {
++				label = "led12";
++				index = <12>;
++			};
++			led13 {
++				label = "led13";
++				index = <13>;
++			};
++			led14 {
++				label = "led14";
++				index = <14>;
++			};
++			led15 {
++				label = "led15";
++				index = <15>;
++			};
++
++		};
++
++		led14 {
++		 	 label = "led14";
++                         compatible = "leds-qsp";
++                         reg = <34 0x0 0x1000>;
++
++		 	 linux,default-trigger = "default-on";
++
++			led0 {
++				label = "power";
++				index = <0>;
++				linux,default-trigger = "default-on";
++			};
++			led01 {
++				label = "heartbeat";
++				index = <1>;
++				linux,default-trigger = "heartbeat";
++			};
++			led02 {
++				label = "timer";
++				index = <2>;
++				//linux,default-trigger = "timer";
++			};
++			led03 {
++				label = "cpu0";
++				index = <3>;
++				//linux,default-trigger = "cpu0";
++			};
++			led04 {
++				label = "cpu1";
++				index = <4>;
++				//linux,default-trigger = "cpu1";
++			};
++			led05 {
++				label = "cpu2";
++				index = <5>;
++				//linux,default-trigger = "cpu2";
++			};
++			led06 {
++				label = "cpu3";
++				index = <6>;
++				//linux,default-trigger = "cpu3";
++			};
++			led07 {
++				label = "led07";
++				index = <7>;
++			};
++			led08 {
++				label = "led08";
++				index = <8>;
++			};
++			led09 {
++				label = "led09";
++				index = <9>;
++			};
++			led10 {
++				label = "led10";
++				index = <10>;
++			};
++			led11 {
++				label = "led11";
++				index = <11>;
++			};
++			led12 {
++				label = "led12";
++				index = <12>;
++			};
++			led13 {
++				label = "led13";
++				index = <13>;
++			};
++			led14 {
++				label = "led14";
++				index = <14>;
++			};
++			led15 {
++				label = "led15";
++				index = <15>;
++			};
++
++		};
++
++		led15 {
++		 	 label = "led15";
++                         compatible = "leds-qsp";
++                         reg = <35 0x0 0x1000>;
++
++		 	 linux,default-trigger = "default-on";
++
++			led0 {
++				label = "power";
++				index = <0>;
++				linux,default-trigger = "default-on";
++			};
++			led01 {
++				label = "heartbeat";
++				index = <1>;
++				linux,default-trigger = "heartbeat";
++			};
++			led02 {
++				label = "timer";
++				index = <2>;
++				//linux,default-trigger = "timer";
++			};
++			led03 {
++				label = "cpu0";
++				index = <3>;
++				//linux,default-trigger = "cpu0";
++			};
++			led04 {
++				label = "cpu1";
++				index = <4>;
++				//linux,default-trigger = "cpu1";
++			};
++			led05 {
++				label = "cpu2";
++				index = <5>;
++				//linux,default-trigger = "cpu2";
++			};
++			led06 {
++				label = "cpu3";
++				index = <6>;
++				//linux,default-trigger = "cpu3";
++			};
++			led07 {
++				label = "led07";
++				index = <7>;
++			};
++			led08 {
++				label = "led08";
++				index = <8>;
++			};
++			led09 {
++				label = "led09";
++				index = <9>;
++			};
++			led10 {
++				label = "led10";
++				index = <10>;
++			};
++			led11 {
++				label = "led11";
++				index = <11>;
++			};
++			led12 {
++				label = "led12";
++				index = <12>;
++			};
++			led13 {
++				label = "led13";
++				index = <13>;
++			};
++			led14 {
++				label = "led14";
++				index = <14>;
++			};
++			led15 {
++				label = "led15";
++				index = <15>;
++			};
++
++		};
++
++		ETH0: eth0 {
++			device_type = "eth";
++			compatible = "qsp-mac";
++			reg = <36 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <64 0x1>;
++
++		};
++
++		ETH1: eth1 {
++			device_type = "eth";
++			compatible = "qsp-mac";
++			reg = <37 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <65 0x1>;
++
++		};
++
++		ETH2: eth2 {
++			device_type = "eth";
++			compatible = "qsp-mac";
++			reg = <38 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <66 0x1>;
++
++		};
++
++		ETH3: eth3 {
++			device_type = "eth";
++			compatible = "qsp-mac";
++			reg = <39 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <67 0x1>;
++
++		};
++
++		ETH4: eth4 {
++			device_type = "eth";
++			compatible = "qsp-mac";
++			reg = <40 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <68 0x1>;
++
++		};
++
++		ETH5: eth5 {
++			device_type = "eth";
++			compatible = "qsp-mac";
++			reg = <41 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <69 0x1>;
++
++		};
++
++		ETH6: eth6 {
++			device_type = "eth";
++			compatible = "qsp-mac";
++			reg = <42 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <70 0x1>;
++
++		};
++
++		ETH7: eth7 {
++			device_type = "eth";
++			compatible = "qsp-mac";
++			reg = <43 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <71 0x1>;
++
++		};
++
++		ETH8: eth8 {
++			device_type = "eth";
++			compatible = "qsp-mac";
++			reg = <44 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <72 0x1>;
++
++		};
++
++		ETH9: eth9 {
++			device_type = "eth";
++			compatible = "qsp-mac";
++			reg = <45 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <73 0x1>;
++
++		};
++
++		ETH10: eth10 {
++			device_type = "eth";
++			compatible = "qsp-mac";
++			reg = <46 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <74 0x1>;
++
++		};
++
++		ETH11: eth11 {
++			device_type = "eth";
++			compatible = "qsp-mac";
++			reg = <47 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <75 0x1>;
++
++		};
++
++		ETH12: eth12 {
++			device_type = "eth";
++			compatible = "qsp-mac";
++			reg = <48 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <76 0x1>;
++
++		};
++
++		ETH13: eth13 {
++			device_type = "eth";
++			compatible = "qsp-mac";
++			reg = <49 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <77 0x1>;
++
++		};
++
++		ETH14: eth14 {
++			device_type = "eth";
++			compatible = "qsp-mac";
++			reg = <50 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <78 0x1>;
++
++		};
++
++		ETH15: eth15 {
++			device_type = "eth";
++			compatible = "qsp-mac";
++			reg = <51 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <79 0x1>;
++
++		};
++
++		DISKCTL0: diskctrl0 {
++			device_type = "disk-controller";
++			compatible = "qsp,disk-controller";
++			reg = <52 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <80 0x1>;
++		};
++
++		DISKCTL1: diskctrl1 {
++			device_type = "disk-controller";
++			compatible = "qsp,disk-controller";
++			reg = <53 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <81 0x1>;
++		};
++
++		DISKCTL2: diskctrl2 {
++			device_type = "disk-controller";
++			compatible = "qsp,disk-controller";
++			reg = <54 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <82 0x1>;
++		};
++
++		DISKCTL3: diskctrl3 {
++			device_type = "disk-controller";
++			compatible = "qsp,disk-controller";
++			reg = <55 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <83 0x1>;
++		};
++
++		DISKCTL4: diskctrl4 {
++			device_type = "disk-controller";
++			compatible = "qsp,disk-controller";
++			reg = <56 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <84 0x1>;
++		};
++
++		DISKCTL5: diskctrl5 {
++			device_type = "disk-controller";
++			compatible = "qsp,disk-controller";
++			reg = <57 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <85 0x1>;
++		};
++
++		DISKCTL6: diskctrl6 {
++			device_type = "disk-controller";
++			compatible = "qsp,disk-controller";
++			reg = <58 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <86 0x1>;
++		};
++
++		DISKCTL7: diskctrl7 {
++			device_type = "disk-controller";
++			compatible = "qsp,disk-controller";
++			reg = <59 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <87 0x1>;
++		};
++
++		DISKCTL8: diskctrl8 {
++			device_type = "disk-controller";
++			compatible = "qsp,disk-controller";
++			reg = <60 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <88 0x1>;
++		};
++
++		DISKCTL9: diskctrl9 {
++			device_type = "disk-controller";
++			compatible = "qsp,disk-controller";
++			reg = <61 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <89 0x1>;
++		};
++
++		DISKCTL10: diskctrl10 {
++			device_type = "disk-controller";
++			compatible = "qsp,disk-controller";
++			reg = <62 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <90 0x1>;
++		};
++
++		DISKCTL11: diskctrl11 {
++			device_type = "disk-controller";
++			compatible = "qsp,disk-controller";
++			reg = <63 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <91 0x1>;
++		};
++
++		DISKCTL12: diskctrl12 {
++			device_type = "disk-controller";
++			compatible = "qsp,disk-controller";
++			reg = <64 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <92 0x1>;
++		};
++
++		DISKCTL13: diskctrl13 {
++			device_type = "disk-controller";
++			compatible = "qsp,disk-controller";
++			reg = <65 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <93 0x1>;
++		};
++
++		DISKCTL14: diskctrl14 {
++			device_type = "disk-controller";
++			compatible = "qsp,disk-controller";
++			reg = <66 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <94 0x1>;
++		};
++
++		DISKCTL15: diskctrl15 {
++			device_type = "disk-controller";
++			compatible = "qsp,disk-controller";
++			reg = <67 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <95 0x1>;
++		};
++
++	};
++};
+diff --git a/arch/powerpc/configs/qsp_defconfig b/arch/powerpc/configs/qsp_defconfig
+new file mode 100644
+index 0000000..3fd8553
+--- /dev/null
++++ b/arch/powerpc/configs/qsp_defconfig
+@@ -0,0 +1,1365 @@
++#
++# Automatically generated file; DO NOT EDIT.
++# Linux/powerpc 3.4.0 Kernel Configuration
++#
++# CONFIG_PPC64 is not set
++
++#
++# Processor support
++#
++CONFIG_PPC_BOOK3S_32=y
++# CONFIG_PPC_85xx is not set
++# CONFIG_PPC_8xx is not set
++# CONFIG_40x is not set
++# CONFIG_44x is not set
++# CONFIG_E200 is not set
++CONFIG_PPC_BOOK3S=y
++CONFIG_6xx=y
++CONFIG_PPC_FPU=y
++# CONFIG_ALTIVEC is not set
++CONFIG_PPC_STD_MMU=y
++CONFIG_PPC_STD_MMU_32=y
++# CONFIG_PPC_MM_SLICES is not set
++CONFIG_PPC_HAVE_PMU_SUPPORT=y
++CONFIG_SMP=y
++CONFIG_NR_CPUS=128
++CONFIG_PPC32=y
++CONFIG_32BIT=y
++CONFIG_WORD_SIZE=32
++# CONFIG_ARCH_PHYS_ADDR_T_64BIT is not set
++# CONFIG_ARCH_DMA_ADDR_T_64BIT is not set
++CONFIG_MMU=y
++CONFIG_GENERIC_CMOS_UPDATE=y
++CONFIG_GENERIC_TIME_VSYSCALL=y
++CONFIG_GENERIC_CLOCKEVENTS=y
++# CONFIG_HAVE_SETUP_PER_CPU_AREA is not set
++# CONFIG_NEED_PER_CPU_EMBED_FIRST_CHUNK is not set
++CONFIG_NR_IRQS=1024
++CONFIG_STACKTRACE_SUPPORT=y
++CONFIG_HAVE_LATENCYTOP_SUPPORT=y
++CONFIG_TRACE_IRQFLAGS_SUPPORT=y
++CONFIG_LOCKDEP_SUPPORT=y
++CONFIG_RWSEM_XCHGADD_ALGORITHM=y
++CONFIG_ARCH_HAS_ILOG2_U32=y
++CONFIG_ARCH_HAS_CPU_IDLE_WAIT=y
++CONFIG_GENERIC_HWEIGHT=y
++# CONFIG_ARCH_NO_VIRT_TO_BUS is not set
++CONFIG_PPC=y
++CONFIG_EARLY_PRINTK=y
++CONFIG_GENERIC_NVRAM=y
++CONFIG_SCHED_OMIT_FRAME_POINTER=y
++CONFIG_ARCH_MAY_HAVE_PC_FDC=y
++CONFIG_PPC_OF=y
++# CONFIG_PPC_UDBG_16550 is not set
++CONFIG_GENERIC_TBSYNC=y
++CONFIG_AUDIT_ARCH=y
++CONFIG_GENERIC_BUG=y
++# CONFIG_EPAPR_BOOT is not set
++# CONFIG_DEFAULT_UIMAGE is not set
++CONFIG_ARCH_HIBERNATION_POSSIBLE=y
++# CONFIG_PPC_DCR_NATIVE is not set
++# CONFIG_PPC_DCR_MMIO is not set
++CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC=y
++CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
++CONFIG_HAVE_IRQ_WORK=y
++
++#
++# General setup
++#
++CONFIG_EXPERIMENTAL=y
++CONFIG_INIT_ENV_ARG_LIMIT=32
++CONFIG_CROSS_COMPILE=""
++CONFIG_LOCALVERSION=""
++CONFIG_LOCALVERSION_AUTO=y
++CONFIG_DEFAULT_HOSTNAME="(none)"
++CONFIG_SWAP=y
++CONFIG_SYSVIPC=y
++CONFIG_SYSVIPC_SYSCTL=y
++# CONFIG_POSIX_MQUEUE is not set
++# CONFIG_BSD_PROCESS_ACCT is not set
++# CONFIG_FHANDLE is not set
++# CONFIG_TASKSTATS is not set
++# CONFIG_AUDIT is not set
++CONFIG_HAVE_GENERIC_HARDIRQS=y
++
++#
++# IRQ subsystem
++#
++CONFIG_GENERIC_HARDIRQS=y
++CONFIG_GENERIC_IRQ_SHOW=y
++CONFIG_GENERIC_IRQ_SHOW_LEVEL=y
++CONFIG_IRQ_DOMAIN=y
++CONFIG_IRQ_FORCED_THREADING=y
++CONFIG_SPARSE_IRQ=y
++
++#
++# RCU Subsystem
++#
++CONFIG_TREE_RCU=y
++# CONFIG_PREEMPT_RCU is not set
++CONFIG_RCU_FANOUT=32
++# CONFIG_RCU_FANOUT_EXACT is not set
++# CONFIG_RCU_FAST_NO_HZ is not set
++# CONFIG_TREE_RCU_TRACE is not set
++# CONFIG_IKCONFIG is not set
++CONFIG_LOG_BUF_SHIFT=14
++# CONFIG_CGROUPS is not set
++# CONFIG_CHECKPOINT_RESTORE is not set
++# CONFIG_NAMESPACES is not set
++# CONFIG_SCHED_AUTOGROUP is not set
++# CONFIG_SYSFS_DEPRECATED is not set
++# CONFIG_RELAY is not set
++CONFIG_BLK_DEV_INITRD=y
++CONFIG_INITRAMFS_SOURCE=""
++CONFIG_RD_GZIP=y
++# CONFIG_RD_BZIP2 is not set
++# CONFIG_RD_LZMA is not set
++# CONFIG_RD_XZ is not set
++# CONFIG_RD_LZO is not set
++# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
++CONFIG_SYSCTL=y
++CONFIG_ANON_INODES=y
++CONFIG_EXPERT=y
++# CONFIG_SYSCTL_SYSCALL is not set
++CONFIG_KALLSYMS=y
++# CONFIG_KALLSYMS_ALL is not set
++CONFIG_HOTPLUG=y
++CONFIG_PRINTK=y
++CONFIG_BUG=y
++CONFIG_ELF_CORE=y
++CONFIG_BASE_FULL=y
++CONFIG_FUTEX=y
++CONFIG_EPOLL=y
++CONFIG_SIGNALFD=y
++CONFIG_TIMERFD=y
++CONFIG_EVENTFD=y
++CONFIG_SHMEM=y
++CONFIG_AIO=y
++# CONFIG_EMBEDDED is not set
++CONFIG_HAVE_PERF_EVENTS=y
++
++#
++# Kernel Performance Events And Counters
++#
++# CONFIG_PERF_EVENTS is not set
++# CONFIG_PERF_COUNTERS is not set
++CONFIG_VM_EVENT_COUNTERS=y
++CONFIG_SLUB_DEBUG=y
++CONFIG_COMPAT_BRK=y
++# CONFIG_SLAB is not set
++CONFIG_SLUB=y
++# CONFIG_SLOB is not set
++# CONFIG_PROFILING is not set
++CONFIG_HAVE_OPROFILE=y
++# CONFIG_KPROBES is not set
++# CONFIG_JUMP_LABEL is not set
++CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS=y
++CONFIG_HAVE_IOREMAP_PROT=y
++CONFIG_HAVE_KPROBES=y
++CONFIG_HAVE_KRETPROBES=y
++CONFIG_HAVE_ARCH_TRACEHOOK=y
++CONFIG_HAVE_DMA_ATTRS=y
++CONFIG_USE_GENERIC_SMP_HELPERS=y
++CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
++CONFIG_HAVE_DMA_API_DEBUG=y
++CONFIG_HAVE_ARCH_JUMP_LABEL=y
++CONFIG_HAVE_RCU_TABLE_FREE=y
++CONFIG_ARCH_HAVE_NMI_SAFE_CMPXCHG=y
++CONFIG_QSP=y
++
++#
++# GCOV-based kernel profiling
++#
++# CONFIG_HAVE_GENERIC_DMA_COHERENT is not set
++CONFIG_SLABINFO=y
++CONFIG_RT_MUTEXES=y
++CONFIG_BASE_SMALL=0
++CONFIG_MODULES=y
++# CONFIG_MODULE_FORCE_LOAD is not set
++# CONFIG_MODULE_UNLOAD is not set
++# CONFIG_MODVERSIONS is not set
++# CONFIG_MODULE_SRCVERSION_ALL is not set
++CONFIG_BLOCK=y
++CONFIG_LBDAF=y
++# CONFIG_BLK_DEV_BSG is not set
++# CONFIG_BLK_DEV_BSGLIB is not set
++# CONFIG_BLK_DEV_INTEGRITY is not set
++
++#
++# Partition Types
++#
++CONFIG_PARTITION_ADVANCED=y
++# CONFIG_ACORN_PARTITION is not set
++# CONFIG_OSF_PARTITION is not set
++# CONFIG_AMIGA_PARTITION is not set
++# CONFIG_ATARI_PARTITION is not set
++# CONFIG_MAC_PARTITION is not set
++CONFIG_MSDOS_PARTITION=y
++# CONFIG_BSD_DISKLABEL is not set
++# CONFIG_MINIX_SUBPARTITION is not set
++# CONFIG_SOLARIS_X86_PARTITION is not set
++# CONFIG_UNIXWARE_DISKLABEL is not set
++# CONFIG_LDM_PARTITION is not set
++# CONFIG_SGI_PARTITION is not set
++# CONFIG_ULTRIX_PARTITION is not set
++# CONFIG_SUN_PARTITION is not set
++# CONFIG_KARMA_PARTITION is not set
++# CONFIG_EFI_PARTITION is not set
++# CONFIG_SYSV68_PARTITION is not set
++
++#
++# IO Schedulers
++#
++CONFIG_IOSCHED_NOOP=y
++CONFIG_IOSCHED_DEADLINE=y
++CONFIG_IOSCHED_CFQ=y
++# CONFIG_DEFAULT_DEADLINE is not set
++# CONFIG_DEFAULT_CFQ is not set
++CONFIG_DEFAULT_NOOP=y
++CONFIG_DEFAULT_IOSCHED="noop"
++# CONFIG_INLINE_SPIN_TRYLOCK is not set
++# CONFIG_INLINE_SPIN_TRYLOCK_BH is not set
++# CONFIG_INLINE_SPIN_LOCK is not set
++# CONFIG_INLINE_SPIN_LOCK_BH is not set
++# CONFIG_INLINE_SPIN_LOCK_IRQ is not set
++# CONFIG_INLINE_SPIN_LOCK_IRQSAVE is not set
++# CONFIG_INLINE_SPIN_UNLOCK_BH is not set
++CONFIG_INLINE_SPIN_UNLOCK_IRQ=y
++# CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE is not set
++# CONFIG_INLINE_READ_TRYLOCK is not set
++# CONFIG_INLINE_READ_LOCK is not set
++# CONFIG_INLINE_READ_LOCK_BH is not set
++# CONFIG_INLINE_READ_LOCK_IRQ is not set
++# CONFIG_INLINE_READ_LOCK_IRQSAVE is not set
++CONFIG_INLINE_READ_UNLOCK=y
++# CONFIG_INLINE_READ_UNLOCK_BH is not set
++CONFIG_INLINE_READ_UNLOCK_IRQ=y
++# CONFIG_INLINE_READ_UNLOCK_IRQRESTORE is not set
++# CONFIG_INLINE_WRITE_TRYLOCK is not set
++# CONFIG_INLINE_WRITE_LOCK is not set
++# CONFIG_INLINE_WRITE_LOCK_BH is not set
++# CONFIG_INLINE_WRITE_LOCK_IRQ is not set
++# CONFIG_INLINE_WRITE_LOCK_IRQSAVE is not set
++CONFIG_INLINE_WRITE_UNLOCK=y
++# CONFIG_INLINE_WRITE_UNLOCK_BH is not set
++CONFIG_INLINE_WRITE_UNLOCK_IRQ=y
++# CONFIG_INLINE_WRITE_UNLOCK_IRQRESTORE is not set
++CONFIG_MUTEX_SPIN_ON_OWNER=y
++# CONFIG_FREEZER is not set
++# CONFIG_PPC_XICS is not set
++# CONFIG_PPC_ICP_NATIVE is not set
++# CONFIG_PPC_ICP_HV is not set
++# CONFIG_PPC_ICS_RTAS is not set
++# CONFIG_GE_FPGA is not set
++
++#
++# Platform support
++#
++# CONFIG_PPC_CHRP is not set
++# CONFIG_PPC_MPC512x is not set
++# CONFIG_PPC_MPC52xx is not set
++# CONFIG_PPC_PMAC is not set
++# CONFIG_PPC_CELL is not set
++# CONFIG_PPC_CELL_NATIVE is not set
++# CONFIG_PPC_82xx is not set
++# CONFIG_PQ2ADS is not set
++# CONFIG_PPC_83xx is not set
++# CONFIG_PPC_86xx is not set
++# CONFIG_PPC_WSP is not set
++CONFIG_PPC_QSP=y
++# CONFIG_PPC_QSP_SYNC_TIMEBASE is not set
++# CONFIG_KVM_GUEST is not set
++CONFIG_PPC_OF_BOOT_TRAMPOLINE=y
++# CONFIG_IPIC is not set
++# CONFIG_MPIC is not set
++# CONFIG_PPC_EPAPR_HV_PIC is not set
++# CONFIG_MPIC_WEIRD is not set
++# CONFIG_PPC_I8259 is not set
++# CONFIG_PPC_RTAS is not set
++# CONFIG_MMIO_NVRAM is not set
++# CONFIG_MPIC_U3_HT_IRQS is not set
++# CONFIG_PPC_MPC106 is not set
++# CONFIG_PPC_970_NAP is not set
++# CONFIG_PPC_P7_NAP is not set
++
++#
++# CPU Frequency scaling
++#
++# CONFIG_CPU_FREQ is not set
++
++#
++# CPUIdle driver
++#
++# CONFIG_CPU_IDLE is not set
++# CONFIG_TAU is not set
++# CONFIG_FSL_ULI1575 is not set
++# CONFIG_SIMPLE_GPIO is not set
++
++#
++# Kernel options
++#
++CONFIG_HIGHMEM=y
++CONFIG_TICK_ONESHOT=y
++CONFIG_NO_HZ=y
++CONFIG_HIGH_RES_TIMERS=y
++CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
++# CONFIG_HZ_100 is not set
++CONFIG_HZ_250=y
++# CONFIG_HZ_300 is not set
++# CONFIG_HZ_1000 is not set
++CONFIG_HZ=250
++CONFIG_SCHED_HRTICK=y
++CONFIG_PREEMPT_NONE=y
++# CONFIG_PREEMPT_VOLUNTARY is not set
++# CONFIG_PREEMPT is not set
++CONFIG_BINFMT_ELF=y
++CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS=y
++# CONFIG_HAVE_AOUT is not set
++CONFIG_BINFMT_MISC=y
++# CONFIG_IOMMU_HELPER is not set
++# CONFIG_SWIOTLB is not set
++CONFIG_ARCH_ENABLE_MEMORY_HOTPLUG=y
++CONFIG_ARCH_HAS_WALK_MEMORY=y
++CONFIG_ARCH_ENABLE_MEMORY_HOTREMOVE=y
++# CONFIG_KEXEC is not set
++# CONFIG_CRASH_DUMP is not set
++# CONFIG_IRQ_ALL_CPUS is not set
++CONFIG_MAX_ACTIVE_REGIONS=32
++CONFIG_ARCH_FLATMEM_ENABLE=y
++CONFIG_SELECT_MEMORY_MODEL=y
++CONFIG_FLATMEM_MANUAL=y
++CONFIG_FLATMEM=y
++CONFIG_FLAT_NODE_MEM_MAP=y
++CONFIG_HAVE_MEMBLOCK=y
++CONFIG_HAVE_MEMBLOCK_NODE_MAP=y
++CONFIG_PAGEFLAGS_EXTENDED=y
++CONFIG_SPLIT_PTLOCK_CPUS=4
++# CONFIG_COMPACTION is not set
++CONFIG_MIGRATION=y
++# CONFIG_PHYS_ADDR_T_64BIT is not set
++CONFIG_ZONE_DMA_FLAG=1
++CONFIG_BOUNCE=y
++CONFIG_VIRT_TO_BUS=y
++# CONFIG_KSM is not set
++CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
++# CONFIG_CLEANCACHE is not set
++CONFIG_PPC_4K_PAGES=y
++CONFIG_FORCE_MAX_ZONEORDER=11
++CONFIG_CMDLINE_BOOL=y
++CONFIG_CMDLINE="console=ttyS0,115200"
++CONFIG_EXTRA_TARGETS=""
++# CONFIG_HIBERNATION is not set
++# CONFIG_PM_RUNTIME is not set
++# CONFIG_SECCOMP is not set
++# CONFIG_ISA_DMA_API is not set
++
++#
++# Bus options
++#
++CONFIG_ZONE_DMA=y
++# CONFIG_NEED_DMA_MAP_STATE is not set
++CONFIG_NEED_SG_DMA_LENGTH=y
++# CONFIG_PCI is not set
++# CONFIG_PCI_DOMAINS is not set
++# CONFIG_PCI_SYSCALL is not set
++# CONFIG_ARCH_SUPPORTS_MSI is not set
++# CONFIG_PCCARD is not set
++# CONFIG_HAS_RAPIDIO is not set
++# CONFIG_NONSTATIC_KERNEL is not set
++
++#
++# Advanced setup
++#
++# CONFIG_ADVANCED_OPTIONS is not set
++
++#
++# Default settings for advanced configuration options are used
++#
++CONFIG_LOWMEM_SIZE=0x30000000
++CONFIG_PAGE_OFFSET=0xc0000000
++CONFIG_KERNEL_START=0xc0000000
++CONFIG_PHYSICAL_START=0x00000000
++CONFIG_TASK_SIZE=0xc0000000
++CONFIG_NET=y
++
++#
++# Networking options
++#
++CONFIG_PACKET=y
++CONFIG_UNIX=y
++# CONFIG_UNIX_DIAG is not set
++CONFIG_XFRM=y
++CONFIG_XFRM_USER=y
++# CONFIG_XFRM_SUB_POLICY is not set
++# CONFIG_XFRM_MIGRATE is not set
++# CONFIG_XFRM_STATISTICS is not set
++# CONFIG_NET_KEY is not set
++CONFIG_INET=y
++CONFIG_IP_MULTICAST=y
++# CONFIG_IP_ADVANCED_ROUTER is not set
++CONFIG_IP_PNP=y
++CONFIG_IP_PNP_DHCP=y
++CONFIG_IP_PNP_BOOTP=y
++# CONFIG_IP_PNP_RARP is not set
++# CONFIG_NET_IPIP is not set
++# CONFIG_NET_IPGRE_DEMUX is not set
++# CONFIG_IP_MROUTE is not set
++# CONFIG_ARPD is not set
++CONFIG_SYN_COOKIES=y
++# CONFIG_INET_AH is not set
++# CONFIG_INET_ESP is not set
++# CONFIG_INET_IPCOMP is not set
++# CONFIG_INET_XFRM_TUNNEL is not set
++# CONFIG_INET_TUNNEL is not set
++CONFIG_INET_XFRM_MODE_TRANSPORT=y
++CONFIG_INET_XFRM_MODE_TUNNEL=y
++CONFIG_INET_XFRM_MODE_BEET=y
++# CONFIG_INET_LRO is not set
++CONFIG_INET_DIAG=y
++CONFIG_INET_TCP_DIAG=y
++# CONFIG_INET_UDP_DIAG is not set
++# CONFIG_TCP_CONG_ADVANCED is not set
++CONFIG_TCP_CONG_CUBIC=y
++CONFIG_DEFAULT_TCP_CONG="cubic"
++# CONFIG_TCP_MD5SIG is not set
++# CONFIG_IPV6 is not set
++# CONFIG_NETWORK_SECMARK is not set
++# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
++# CONFIG_NETFILTER is not set
++# CONFIG_IP_DCCP is not set
++# CONFIG_IP_SCTP is not set
++# CONFIG_RDS is not set
++# CONFIG_TIPC is not set
++# CONFIG_ATM is not set
++# CONFIG_L2TP is not set
++# CONFIG_BRIDGE is not set
++# CONFIG_NET_DSA is not set
++# CONFIG_VLAN_8021Q is not set
++# CONFIG_DECNET is not set
++# CONFIG_LLC2 is not set
++# CONFIG_IPX is not set
++# CONFIG_ATALK is not set
++# CONFIG_X25 is not set
++# CONFIG_LAPB is not set
++# CONFIG_ECONET is not set
++# CONFIG_WAN_ROUTER is not set
++# CONFIG_PHONET is not set
++# CONFIG_IEEE802154 is not set
++# CONFIG_NET_SCHED is not set
++# CONFIG_DCB is not set
++# CONFIG_BATMAN_ADV is not set
++# CONFIG_OPENVSWITCH is not set
++CONFIG_RPS=y
++CONFIG_RFS_ACCEL=y
++CONFIG_XPS=y
++CONFIG_BQL=y
++
++#
++# Network testing
++#
++# CONFIG_NET_PKTGEN is not set
++# CONFIG_HAMRADIO is not set
++# CONFIG_CAN is not set
++# CONFIG_IRDA is not set
++# CONFIG_BT is not set
++# CONFIG_AF_RXRPC is not set
++# CONFIG_WIRELESS is not set
++# CONFIG_WIMAX is not set
++# CONFIG_RFKILL is not set
++# CONFIG_NET_9P is not set
++# CONFIG_CAIF is not set
++# CONFIG_CEPH_LIB is not set
++# CONFIG_NFC is not set
++
++#
++# Device Drivers
++#
++
++#
++# Generic Driver Options
++#
++CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
++CONFIG_DEVTMPFS=y
++CONFIG_DEVTMPFS_MOUNT=y
++CONFIG_STANDALONE=y
++CONFIG_PREVENT_FIRMWARE_BUILD=y
++# CONFIG_FW_LOADER is not set
++# CONFIG_DEBUG_DRIVER is not set
++# CONFIG_DEBUG_DEVRES is not set
++# CONFIG_SYS_HYPERVISOR is not set
++# CONFIG_GENERIC_CPU_DEVICES is not set
++# CONFIG_DMA_SHARED_BUFFER is not set
++# CONFIG_CONNECTOR is not set
++CONFIG_MTD=y
++# CONFIG_MTD_TESTS is not set
++# CONFIG_MTD_REDBOOT_PARTS is not set
++# CONFIG_MTD_CMDLINE_PARTS is not set
++# CONFIG_MTD_OF_PARTS is not set
++# CONFIG_MTD_AR7_PARTS is not set
++
++#
++# User Modules And Translation Layers
++#
++CONFIG_MTD_CHAR=y
++CONFIG_MTD_BLKDEVS=y
++# CONFIG_MTD_BLOCK is not set
++# CONFIG_MTD_BLOCK_RO is not set
++CONFIG_FTL=y
++# CONFIG_NFTL is not set
++# CONFIG_INFTL is not set
++# CONFIG_RFD_FTL is not set
++# CONFIG_SSFDC is not set
++# CONFIG_SM_FTL is not set
++# CONFIG_MTD_OOPS is not set
++# CONFIG_MTD_SWAP is not set
++
++#
++# RAM/ROM/Flash chip drivers
++#
++# CONFIG_MTD_CFI is not set
++# CONFIG_MTD_JEDECPROBE is not set
++CONFIG_MTD_MAP_BANK_WIDTH_1=y
++CONFIG_MTD_MAP_BANK_WIDTH_2=y
++CONFIG_MTD_MAP_BANK_WIDTH_4=y
++# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
++# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
++# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
++CONFIG_MTD_CFI_I1=y
++CONFIG_MTD_CFI_I2=y
++# CONFIG_MTD_CFI_I4 is not set
++# CONFIG_MTD_CFI_I8 is not set
++# CONFIG_MTD_RAM is not set
++# CONFIG_MTD_ROM is not set
++# CONFIG_MTD_ABSENT is not set
++CONFIG_MTD_QSP_FLASH=y
++
++#
++# Mapping drivers for chip access
++#
++# CONFIG_MTD_COMPLEX_MAPPINGS is not set
++CONFIG_MTD_PHYSMAP=y
++CONFIG_MTD_PHYSMAP_COMPAT=y
++CONFIG_MTD_PHYSMAP_START=0xd0000000
++CONFIG_MTD_PHYSMAP_LEN=0x10000000
++CONFIG_MTD_PHYSMAP_BANKWIDTH=4
++# CONFIG_MTD_PLATRAM is not set
++
++#
++# Self-contained MTD device drivers
++#
++# CONFIG_MTD_SLRAM is not set
++# CONFIG_MTD_PHRAM is not set
++# CONFIG_MTD_MTDRAM is not set
++# CONFIG_MTD_BLOCK2MTD is not set
++
++#
++# Disk-On-Chip Device Drivers
++#
++# CONFIG_MTD_DOCG3 is not set
++# CONFIG_MTD_NAND is not set
++# CONFIG_MTD_ONENAND is not set
++
++#
++# LPDDR flash memory drivers
++#
++# CONFIG_MTD_LPDDR is not set
++CONFIG_MTD_UBI=y
++CONFIG_MTD_UBI_WL_THRESHOLD=4096
++CONFIG_MTD_UBI_BEB_RESERVE=1
++# CONFIG_MTD_UBI_GLUEBI is not set
++# CONFIG_MTD_UBI_DEBUG is not set
++CONFIG_DTC=y
++CONFIG_OF=y
++
++#
++# Device Tree and Open Firmware support
++#
++CONFIG_PROC_DEVICETREE=y
++# CONFIG_OF_SELFTEST is not set
++CONFIG_OF_FLATTREE=y
++CONFIG_OF_EARLY_FLATTREE=y
++CONFIG_OF_ADDRESS=y
++CONFIG_OF_IRQ=y
++CONFIG_OF_DEVICE=y
++CONFIG_OF_NET=y
++CONFIG_OF_MTD=y
++# CONFIG_PARPORT is not set
++CONFIG_BLK_DEV=y
++# CONFIG_BLK_DEV_FD is not set
++# CONFIG_BLK_DEV_COW_COMMON is not set
++CONFIG_BLK_DEV_LOOP=y
++CONFIG_BLK_DEV_LOOP_MIN_COUNT=8
++# CONFIG_BLK_DEV_CRYPTOLOOP is not set
++
++#
++# DRBD disabled because PROC_FS, INET or CONNECTOR not selected
++#
++# CONFIG_BLK_DEV_NBD is not set
++CONFIG_BLK_DEV_RAM=y
++CONFIG_BLK_DEV_RAM_COUNT=16
++CONFIG_BLK_DEV_RAM_SIZE=131072
++# CONFIG_BLK_DEV_XIP is not set
++# CONFIG_CDROM_PKTCDVD is not set
++# CONFIG_ATA_OVER_ETH is not set
++# CONFIG_BLK_DEV_HD is not set
++# CONFIG_BLK_DEV_RBD is not set
++CONFIG_BLK_DEV_QSP=y
++
++#
++# Misc devices
++#
++# CONFIG_SENSORS_LIS3LV02D is not set
++# CONFIG_ENCLOSURE_SERVICES is not set
++# CONFIG_C2PORT is not set
++
++#
++# EEPROM support
++#
++# CONFIG_EEPROM_93CX6 is not set
++
++#
++# Texas Instruments shared transport line discipline
++#
++
++#
++# Altera FPGA firmware download module
++#
++CONFIG_HAVE_IDE=y
++# CONFIG_IDE is not set
++
++#
++# SCSI device support
++#
++CONFIG_SCSI_MOD=y
++# CONFIG_RAID_ATTRS is not set
++CONFIG_SCSI=y
++CONFIG_SCSI_DMA=y
++# CONFIG_SCSI_TGT is not set
++# CONFIG_SCSI_NETLINK is not set
++CONFIG_SCSI_PROC_FS=y
++
++#
++# SCSI support type (disk, tape, CD-ROM)
++#
++CONFIG_BLK_DEV_SD=y
++# CONFIG_CHR_DEV_ST is not set
++# CONFIG_CHR_DEV_OSST is not set
++# CONFIG_BLK_DEV_SR is not set
++# CONFIG_CHR_DEV_SG is not set
++# CONFIG_CHR_DEV_SCH is not set
++# CONFIG_SCSI_MULTI_LUN is not set
++# CONFIG_SCSI_CONSTANTS is not set
++# CONFIG_SCSI_LOGGING is not set
++# CONFIG_SCSI_SCAN_ASYNC is not set
++CONFIG_SCSI_WAIT_SCAN=m
++
++#
++# SCSI Transports
++#
++# CONFIG_SCSI_SPI_ATTRS is not set
++# CONFIG_SCSI_FC_ATTRS is not set
++# CONFIG_SCSI_ISCSI_ATTRS is not set
++# CONFIG_SCSI_SAS_ATTRS is not set
++# CONFIG_SCSI_SAS_LIBSAS is not set
++# CONFIG_SCSI_SRP_ATTRS is not set
++CONFIG_SCSI_LOWLEVEL=y
++# CONFIG_ISCSI_TCP is not set
++# CONFIG_ISCSI_BOOT_SYSFS is not set
++# CONFIG_LIBFC is not set
++# CONFIG_LIBFCOE is not set
++# CONFIG_SCSI_DEBUG is not set
++# CONFIG_SCSI_DH is not set
++# CONFIG_SCSI_OSD_INITIATOR is not set
++CONFIG_ATA=y
++# CONFIG_ATA_NONSTANDARD is not set
++CONFIG_ATA_VERBOSE_ERROR=y
++CONFIG_SATA_PMP=y
++
++#
++# Controllers with non-SFF native interface
++#
++# CONFIG_SATA_AHCI_PLATFORM is not set
++CONFIG_ATA_SFF=y
++
++#
++# SFF controllers with custom DMA interface
++#
++CONFIG_ATA_BMDMA=y
++
++#
++# SATA SFF controllers with BMDMA
++#
++# CONFIG_SATA_MV is not set
++
++#
++# PATA SFF controllers with BMDMA
++#
++
++#
++# PIO-only SFF controllers
++#
++# CONFIG_PATA_PLATFORM is not set
++
++#
++# Generic fallback / legacy drivers
++#
++# CONFIG_MD is not set
++# CONFIG_TARGET_CORE is not set
++# CONFIG_MACINTOSH_DRIVERS is not set
++CONFIG_NETDEVICES=y
++CONFIG_NET_CORE=y
++# CONFIG_BONDING is not set
++# CONFIG_DUMMY is not set
++# CONFIG_EQUALIZER is not set
++# CONFIG_MII is not set
++# CONFIG_NET_TEAM is not set
++# CONFIG_MACVLAN is not set
++# CONFIG_NETCONSOLE is not set
++# CONFIG_NETPOLL is not set
++# CONFIG_NET_POLL_CONTROLLER is not set
++# CONFIG_TUN is not set
++# CONFIG_VETH is not set
++
++#
++# CAIF transport drivers
++#
++CONFIG_ETHERNET=y
++# CONFIG_NET_VENDOR_BROADCOM is not set
++# CONFIG_NET_CALXEDA_XGMAC is not set
++# CONFIG_NET_VENDOR_CHELSIO is not set
++# CONFIG_DNET is not set
++# CONFIG_NET_VENDOR_INTEL is not set
++# CONFIG_NET_VENDOR_MARVELL is not set
++# CONFIG_NET_VENDOR_MICREL is not set
++# CONFIG_NET_VENDOR_NATSEMI is not set
++# CONFIG_ETHOC is not set
++# CONFIG_NET_VENDOR_SEEQ is not set
++# CONFIG_NET_VENDOR_STMICRO is not set
++# CONFIG_NET_VENDOR_XILINX is not set
++CONFIG_NET_QSP=y
++# CONFIG_PHYLIB is not set
++# CONFIG_PPP is not set
++# CONFIG_SLIP is not set
++# CONFIG_WLAN is not set
++
++#
++# Enable WiMAX (Networking options) to see the WiMAX drivers
++#
++# CONFIG_WAN is not set
++# CONFIG_ISDN is not set
++
++#
++# Input device support
++#
++CONFIG_INPUT=y
++# CONFIG_INPUT_FF_MEMLESS is not set
++# CONFIG_INPUT_POLLDEV is not set
++# CONFIG_INPUT_SPARSEKMAP is not set
++
++#
++# Userland interfaces
++#
++# CONFIG_INPUT_MOUSEDEV is not set
++# CONFIG_INPUT_JOYDEV is not set
++# CONFIG_INPUT_EVDEV is not set
++# CONFIG_INPUT_EVBUG is not set
++
++#
++# Input Device Drivers
++#
++# CONFIG_INPUT_KEYBOARD is not set
++# CONFIG_INPUT_MOUSE is not set
++# CONFIG_INPUT_JOYSTICK is not set
++# CONFIG_INPUT_TABLET is not set
++# CONFIG_INPUT_TOUCHSCREEN is not set
++# CONFIG_INPUT_MISC is not set
++
++#
++# Hardware I/O ports
++#
++# CONFIG_SERIO is not set
++# CONFIG_GAMEPORT is not set
++
++#
++# Character devices
++#
++# CONFIG_VT is not set
++CONFIG_UNIX98_PTYS=y
++# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
++CONFIG_LEGACY_PTYS=y
++CONFIG_LEGACY_PTY_COUNT=256
++# CONFIG_SERIAL_NONSTANDARD is not set
++# CONFIG_N_GSM is not set
++# CONFIG_TRACE_SINK is not set
++# CONFIG_PPC_EPAPR_HV_BYTECHAN is not set
++CONFIG_DEVKMEM=y
++
++#
++# Serial drivers
++#
++# CONFIG_SERIAL_8250 is not set
++
++#
++# Non-8250 serial port support
++#
++# CONFIG_SERIAL_UARTLITE is not set
++CONFIG_SERIAL_CORE=y
++CONFIG_SERIAL_CORE_CONSOLE=y
++# CONFIG_SERIAL_TIMBERDALE is not set
++# CONFIG_SERIAL_ALTERA_JTAGUART is not set
++# CONFIG_SERIAL_ALTERA_UART is not set
++# CONFIG_SERIAL_XILINX_PS_UART is not set
++CONFIG_SERIAL_QSP_UART=y
++CONFIG_SERIAL_QSP_MAXPORTS=16
++CONFIG_SERIAL_QSP_CONSOLE=y
++# CONFIG_TTY_PRINTK is not set
++# CONFIG_HVC_UDBG is not set
++# CONFIG_IPMI_HANDLER is not set
++# CONFIG_HW_RANDOM is not set
++# CONFIG_NVRAM is not set
++# CONFIG_R3964 is not set
++# CONFIG_RAW_DRIVER is not set
++# CONFIG_TCG_TPM is not set
++# CONFIG_RAMOOPS is not set
++# CONFIG_I2C is not set
++# CONFIG_SPI is not set
++# CONFIG_HSI is not set
++
++#
++# PPS support
++#
++# CONFIG_PPS is not set
++
++#
++# PPS generators support
++#
++
++#
++# PTP clock support
++#
++
++#
++# Enable Device Drivers -> PPS to see the PTP clock options.
++#
++CONFIG_ARCH_WANT_OPTIONAL_GPIOLIB=y
++# CONFIG_GPIOLIB is not set
++# CONFIG_W1 is not set
++# CONFIG_POWER_SUPPLY is not set
++CONFIG_HWMON=y
++# CONFIG_HWMON_VID is not set
++# CONFIG_HWMON_DEBUG_CHIP is not set
++
++#
++# Native drivers
++#
++# CONFIG_SENSORS_NTC_THERMISTOR is not set
++# CONFIG_SENSORS_SCH56XX_COMMON is not set
++# CONFIG_THERMAL is not set
++# CONFIG_WATCHDOG is not set
++CONFIG_SSB_POSSIBLE=y
++
++#
++# Sonics Silicon Backplane
++#
++# CONFIG_SSB is not set
++CONFIG_BCMA_POSSIBLE=y
++
++#
++# Broadcom specific AMBA
++#
++# CONFIG_BCMA is not set
++
++#
++# Multifunction device drivers
++#
++# CONFIG_MFD_CORE is not set
++# CONFIG_MFD_SM501 is not set
++# CONFIG_HTC_PASIC3 is not set
++# CONFIG_MFD_TMIO is not set
++# CONFIG_ABX500_CORE is not set
++# CONFIG_REGULATOR is not set
++# CONFIG_MEDIA_SUPPORT is not set
++
++#
++# Graphics support
++#
++# CONFIG_DRM is not set
++# CONFIG_VGASTATE is not set
++# CONFIG_VIDEO_OUTPUT_CONTROL is not set
++# CONFIG_FB is not set
++# CONFIG_EXYNOS_VIDEO is not set
++# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
++# CONFIG_SOUND is not set
++CONFIG_HID_SUPPORT=y
++CONFIG_HID=y
++# CONFIG_HIDRAW is not set
++# CONFIG_HID_PID is not set
++
++#
++# Special HID drivers
++#
++# CONFIG_USB_ARCH_HAS_OHCI is not set
++# CONFIG_USB_ARCH_HAS_EHCI is not set
++# CONFIG_USB_ARCH_HAS_XHCI is not set
++# CONFIG_USB_SUPPORT is not set
++# CONFIG_MMC is not set
++# CONFIG_MEMSTICK is not set
++CONFIG_NEW_LEDS=y
++CONFIG_LEDS_CLASS=y
++
++#
++# LED drivers
++#
++# CONFIG_LEDS_OT200 is not set
++CONFIG_LEDS_QSP=y
++CONFIG_LEDS_TRIGGERS=y
++
++#
++# LED Triggers
++#
++CONFIG_LEDS_TRIGGER_TIMER=y
++CONFIG_LEDS_TRIGGER_HEARTBEAT=y
++# CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
++CONFIG_LEDS_TRIGGER_DEFAULT_ON=y
++
++#
++# iptables trigger is under Netfilter config (LED target)
++#
++# CONFIG_ACCESSIBILITY is not set
++# CONFIG_EDAC is not set
++CONFIG_RTC_LIB=y
++CONFIG_RTC_CLASS=y
++CONFIG_RTC_HCTOSYS=y
++CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
++# CONFIG_RTC_DEBUG is not set
++
++#
++# RTC interfaces
++#
++CONFIG_RTC_INTF_SYSFS=y
++CONFIG_RTC_INTF_PROC=y
++CONFIG_RTC_INTF_DEV=y
++# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
++# CONFIG_RTC_DRV_TEST is not set
++
++#
++# SPI RTC drivers
++#
++
++#
++# Platform RTC drivers
++#
++# CONFIG_RTC_DRV_CMOS is not set
++# CONFIG_RTC_DRV_DS1286 is not set
++# CONFIG_RTC_DRV_DS1511 is not set
++# CONFIG_RTC_DRV_DS1553 is not set
++# CONFIG_RTC_DRV_DS1742 is not set
++# CONFIG_RTC_DRV_STK17TA8 is not set
++# CONFIG_RTC_DRV_M48T86 is not set
++# CONFIG_RTC_DRV_M48T35 is not set
++# CONFIG_RTC_DRV_M48T59 is not set
++# CONFIG_RTC_DRV_MSM6242 is not set
++# CONFIG_RTC_DRV_BQ4802 is not set
++# CONFIG_RTC_DRV_RP5C01 is not set
++# CONFIG_RTC_DRV_V3020 is not set
++
++#
++# on-CPU RTC drivers
++#
++# CONFIG_RTC_DRV_GENERIC is not set
++CONFIG_RTC_DRV_QSP=y
++# CONFIG_DMADEVICES is not set
++# CONFIG_AUXDISPLAY is not set
++# CONFIG_UIO is not set
++
++#
++# Virtio drivers
++#
++# CONFIG_VIRTIO_BALLOON is not set
++# CONFIG_VIRTIO_MMIO is not set
++
++#
++# Microsoft Hyper-V guest support
++#
++# CONFIG_STAGING is not set
++
++#
++# Hardware Spinlock drivers
++#
++# CONFIG_CLK_QSP is not set
++CONFIG_IOMMU_SUPPORT=y
++
++#
++# Remoteproc drivers (EXPERIMENTAL)
++#
++
++#
++# Rpmsg drivers (EXPERIMENTAL)
++#
++# CONFIG_VIRT_DRIVERS is not set
++# CONFIG_PM_DEVFREQ is not set
++CONFIG_PIC_SUPPORT=y
++CONFIG_QSP_PIC=y
++
++#
++# File systems
++#
++CONFIG_EXT2_FS=y
++# CONFIG_EXT2_FS_XATTR is not set
++# CONFIG_EXT2_FS_XIP is not set
++CONFIG_EXT3_FS=y
++CONFIG_EXT3_DEFAULTS_TO_ORDERED=y
++CONFIG_EXT3_FS_XATTR=y
++# CONFIG_EXT3_FS_POSIX_ACL is not set
++# CONFIG_EXT3_FS_SECURITY is not set
++# CONFIG_EXT4_FS is not set
++CONFIG_JBD=y
++CONFIG_FS_MBCACHE=y
++# CONFIG_REISERFS_FS is not set
++# CONFIG_JFS_FS is not set
++# CONFIG_XFS_FS is not set
++# CONFIG_GFS2_FS is not set
++# CONFIG_BTRFS_FS is not set
++# CONFIG_NILFS2_FS is not set
++# CONFIG_FS_POSIX_ACL is not set
++CONFIG_FILE_LOCKING=y
++CONFIG_FSNOTIFY=y
++CONFIG_DNOTIFY=y
++CONFIG_INOTIFY_USER=y
++# CONFIG_FANOTIFY is not set
++# CONFIG_QUOTA is not set
++# CONFIG_QUOTACTL is not set
++# CONFIG_AUTOFS4_FS is not set
++# CONFIG_FUSE_FS is not set
++
++#
++# Caches
++#
++# CONFIG_FSCACHE is not set
++
++#
++# CD-ROM/DVD Filesystems
++#
++# CONFIG_ISO9660_FS is not set
++# CONFIG_UDF_FS is not set
++
++#
++# DOS/FAT/NT Filesystems
++#
++# CONFIG_MSDOS_FS is not set
++# CONFIG_VFAT_FS is not set
++# CONFIG_NTFS_FS is not set
++
++#
++# Pseudo filesystems
++#
++CONFIG_PROC_FS=y
++CONFIG_PROC_KCORE=y
++CONFIG_PROC_SYSCTL=y
++CONFIG_PROC_PAGE_MONITOR=y
++CONFIG_SYSFS=y
++CONFIG_TMPFS=y
++# CONFIG_TMPFS_POSIX_ACL is not set
++# CONFIG_TMPFS_XATTR is not set
++# CONFIG_HUGETLB_PAGE is not set
++# CONFIG_CONFIGFS_FS is not set
++CONFIG_MISC_FILESYSTEMS=y
++# CONFIG_ADFS_FS is not set
++# CONFIG_AFFS_FS is not set
++# CONFIG_HFS_FS is not set
++# CONFIG_HFSPLUS_FS is not set
++# CONFIG_BEFS_FS is not set
++# CONFIG_BFS_FS is not set
++# CONFIG_EFS_FS is not set
++CONFIG_JFFS2_FS=m
++CONFIG_JFFS2_FS_DEBUG=0
++CONFIG_JFFS2_FS_WRITEBUFFER=y
++# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
++# CONFIG_JFFS2_SUMMARY is not set
++# CONFIG_JFFS2_FS_XATTR is not set
++# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
++CONFIG_JFFS2_ZLIB=y
++# CONFIG_JFFS2_LZO is not set
++CONFIG_JFFS2_RTIME=y
++# CONFIG_JFFS2_RUBIN is not set
++CONFIG_UBIFS_FS=m
++# CONFIG_UBIFS_FS_XATTR is not set
++# CONFIG_UBIFS_FS_ADVANCED_COMPR is not set
++CONFIG_UBIFS_FS_LZO=y
++CONFIG_UBIFS_FS_ZLIB=y
++# CONFIG_UBIFS_FS_DEBUG is not set
++# CONFIG_LOGFS is not set
++# CONFIG_CRAMFS is not set
++# CONFIG_SQUASHFS is not set
++# CONFIG_VXFS_FS is not set
++# CONFIG_MINIX_FS is not set
++# CONFIG_OMFS_FS is not set
++# CONFIG_HPFS_FS is not set
++# CONFIG_QNX4FS_FS is not set
++# CONFIG_QNX6FS_FS is not set
++# CONFIG_ROMFS_FS is not set
++# CONFIG_PSTORE is not set
++# CONFIG_SYSV_FS is not set
++# CONFIG_UFS_FS is not set
++CONFIG_SIMICSFS=y
++CONFIG_SIMICSFS_ADDRESS="0xe0200000"
++CONFIG_NETWORK_FILESYSTEMS=y
++CONFIG_NFS_FS=y
++# CONFIG_NFS_V3 is not set
++# CONFIG_NFS_V4 is not set
++CONFIG_ROOT_NFS=y
++# CONFIG_NFSD is not set
++CONFIG_LOCKD=y
++CONFIG_NFS_COMMON=y
++CONFIG_SUNRPC=y
++# CONFIG_SUNRPC_DEBUG is not set
++# CONFIG_CEPH_FS is not set
++# CONFIG_CIFS is not set
++# CONFIG_NCP_FS is not set
++# CONFIG_CODA_FS is not set
++# CONFIG_AFS_FS is not set
++# CONFIG_NLS is not set
++# CONFIG_BINARY_PRINTF is not set
++
++#
++# Library routines
++#
++CONFIG_BITREVERSE=y
++CONFIG_GENERIC_IO=y
++# CONFIG_CRC_CCITT is not set
++CONFIG_CRC16=m
++# CONFIG_CRC_T10DIF is not set
++# CONFIG_CRC_ITU_T is not set
++CONFIG_CRC32=y
++# CONFIG_CRC32_SELFTEST is not set
++CONFIG_CRC32_SLICEBY8=y
++# CONFIG_CRC32_SLICEBY4 is not set
++# CONFIG_CRC32_SARWATE is not set
++# CONFIG_CRC32_BIT is not set
++# CONFIG_CRC7 is not set
++# CONFIG_LIBCRC32C is not set
++# CONFIG_CRC8 is not set
++CONFIG_ZLIB_INFLATE=y
++CONFIG_ZLIB_DEFLATE=m
++CONFIG_LZO_COMPRESS=m
++CONFIG_LZO_DECOMPRESS=m
++# CONFIG_XZ_DEC is not set
++# CONFIG_XZ_DEC_BCJ is not set
++CONFIG_DECOMPRESS_GZIP=y
++CONFIG_HAS_IOMEM=y
++CONFIG_HAS_IOPORT=y
++CONFIG_HAS_DMA=y
++CONFIG_CPU_RMAP=y
++CONFIG_DQL=y
++CONFIG_NLATTR=y
++CONFIG_GENERIC_ATOMIC64=y
++# CONFIG_AVERAGE is not set
++# CONFIG_CORDIC is not set
++
++#
++# Kernel hacking
++#
++# CONFIG_PRINTK_TIME is not set
++CONFIG_DEFAULT_MESSAGE_LOGLEVEL=4
++CONFIG_ENABLE_WARN_DEPRECATED=y
++CONFIG_ENABLE_MUST_CHECK=y
++CONFIG_FRAME_WARN=1024
++CONFIG_MAGIC_SYSRQ=y
++# CONFIG_STRIP_ASM_SYMS is not set
++# CONFIG_UNUSED_SYMBOLS is not set
++# CONFIG_DEBUG_FS is not set
++# CONFIG_HEADERS_CHECK is not set
++# CONFIG_DEBUG_SECTION_MISMATCH is not set
++CONFIG_DEBUG_KERNEL=y
++# CONFIG_DEBUG_SHIRQ is not set
++# CONFIG_LOCKUP_DETECTOR is not set
++# CONFIG_HARDLOCKUP_DETECTOR is not set
++# CONFIG_DETECT_HUNG_TASK is not set
++# CONFIG_SCHED_DEBUG is not set
++# CONFIG_SCHEDSTATS is not set
++# CONFIG_TIMER_STATS is not set
++# CONFIG_DEBUG_OBJECTS is not set
++# CONFIG_SLUB_DEBUG_ON is not set
++# CONFIG_SLUB_STATS is not set
++# CONFIG_DEBUG_KMEMLEAK is not set
++# CONFIG_DEBUG_RT_MUTEXES is not set
++# CONFIG_RT_MUTEX_TESTER is not set
++# CONFIG_DEBUG_SPINLOCK is not set
++# CONFIG_DEBUG_MUTEXES is not set
++# CONFIG_DEBUG_LOCK_ALLOC is not set
++# CONFIG_PROVE_LOCKING is not set
++# CONFIG_SPARSE_RCU_POINTER is not set
++# CONFIG_LOCK_STAT is not set
++# CONFIG_DEBUG_ATOMIC_SLEEP is not set
++# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
++# CONFIG_DEBUG_STACK_USAGE is not set
++# CONFIG_DEBUG_KOBJECT is not set
++# CONFIG_DEBUG_HIGHMEM is not set
++CONFIG_DEBUG_BUGVERBOSE=y
++CONFIG_DEBUG_INFO=y
++# CONFIG_DEBUG_INFO_REDUCED is not set
++# CONFIG_DEBUG_VM is not set
++# CONFIG_DEBUG_WRITECOUNT is not set
++# CONFIG_DEBUG_MEMORY_INIT is not set
++# CONFIG_DEBUG_LIST is not set
++# CONFIG_TEST_LIST_SORT is not set
++# CONFIG_DEBUG_SG is not set
++# CONFIG_DEBUG_NOTIFIERS is not set
++# CONFIG_DEBUG_CREDENTIALS is not set
++# CONFIG_RCU_TORTURE_TEST is not set
++CONFIG_RCU_CPU_STALL_TIMEOUT=60
++# CONFIG_RCU_CPU_STALL_INFO is not set
++# CONFIG_RCU_TRACE is not set
++# CONFIG_BACKTRACE_SELF_TEST is not set
++# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
++# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
++# CONFIG_DEBUG_PER_CPU_MAPS is not set
++# CONFIG_FAULT_INJECTION is not set
++# CONFIG_LATENCYTOP is not set
++# CONFIG_DEBUG_PAGEALLOC is not set
++CONFIG_HAVE_FUNCTION_TRACER=y
++CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
++CONFIG_HAVE_DYNAMIC_FTRACE=y
++CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
++CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
++CONFIG_TRACING_SUPPORT=y
++CONFIG_FTRACE=y
++# CONFIG_FUNCTION_TRACER is not set
++# CONFIG_IRQSOFF_TRACER is not set
++# CONFIG_SCHED_TRACER is not set
++# CONFIG_ENABLE_DEFAULT_TRACERS is not set
++# CONFIG_FTRACE_SYSCALLS is not set
++CONFIG_BRANCH_PROFILE_NONE=y
++# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
++# CONFIG_PROFILE_ALL_BRANCHES is not set
++# CONFIG_STACK_TRACER is not set
++# CONFIG_BLK_DEV_IO_TRACE is not set
++# CONFIG_DMA_API_DEBUG is not set
++# CONFIG_ATOMIC64_SELFTEST is not set
++# CONFIG_SAMPLES is not set
++CONFIG_HAVE_ARCH_KGDB=y
++# CONFIG_KGDB is not set
++# CONFIG_TEST_KSTRTOX is not set
++# CONFIG_PPC_DISABLE_WERROR is not set
++CONFIG_PPC_WERROR=y
++CONFIG_PRINT_STACK_DEPTH=64
++# CONFIG_DEBUG_STACKOVERFLOW is not set
++# CONFIG_CODE_PATCHING_SELFTEST is not set
++# CONFIG_FTR_FIXUP_SELFTEST is not set
++# CONFIG_MSI_BITMAP_SELFTEST is not set
++CONFIG_XMON=y
++CONFIG_XMON_DEFAULT=y
++CONFIG_XMON_DISASSEMBLY=y
++CONFIG_DEBUGGER=y
++# CONFIG_BDI_SWITCH is not set
++# CONFIG_BOOTX_TEXT is not set
++CONFIG_PPC_EARLY_DEBUG=y
++CONFIG_STRICT_DEVMEM=y
++
++#
++# Security options
++#
++# CONFIG_KEYS is not set
++# CONFIG_SECURITY_DMESG_RESTRICT is not set
++# CONFIG_SECURITY is not set
++# CONFIG_SECURITYFS is not set
++CONFIG_DEFAULT_SECURITY_DAC=y
++CONFIG_DEFAULT_SECURITY=""
++CONFIG_CRYPTO=y
++
++#
++# Crypto core or helper
++#
++# CONFIG_CRYPTO_FIPS is not set
++CONFIG_CRYPTO_ALGAPI=m
++CONFIG_CRYPTO_ALGAPI2=m
++CONFIG_CRYPTO_RNG=m
++CONFIG_CRYPTO_RNG2=m
++# CONFIG_CRYPTO_MANAGER is not set
++# CONFIG_CRYPTO_MANAGER2 is not set
++# CONFIG_CRYPTO_USER is not set
++# CONFIG_CRYPTO_GF128MUL is not set
++# CONFIG_CRYPTO_NULL is not set
++# CONFIG_CRYPTO_PCRYPT is not set
++# CONFIG_CRYPTO_CRYPTD is not set
++# CONFIG_CRYPTO_AUTHENC is not set
++# CONFIG_CRYPTO_TEST is not set
++
++#
++# Authenticated Encryption with Associated Data
++#
++# CONFIG_CRYPTO_CCM is not set
++# CONFIG_CRYPTO_GCM is not set
++# CONFIG_CRYPTO_SEQIV is not set
++
++#
++# Block modes
++#
++# CONFIG_CRYPTO_CBC is not set
++# CONFIG_CRYPTO_CTR is not set
++# CONFIG_CRYPTO_CTS is not set
++# CONFIG_CRYPTO_ECB is not set
++# CONFIG_CRYPTO_LRW is not set
++# CONFIG_CRYPTO_PCBC is not set
++# CONFIG_CRYPTO_XTS is not set
++
++#
++# Hash modes
++#
++# CONFIG_CRYPTO_HMAC is not set
++# CONFIG_CRYPTO_XCBC is not set
++# CONFIG_CRYPTO_VMAC is not set
++
++#
++# Digest
++#
++# CONFIG_CRYPTO_CRC32C is not set
++# CONFIG_CRYPTO_GHASH is not set
++# CONFIG_CRYPTO_MD4 is not set
++# CONFIG_CRYPTO_MD5 is not set
++# CONFIG_CRYPTO_MICHAEL_MIC is not set
++# CONFIG_CRYPTO_RMD128 is not set
++# CONFIG_CRYPTO_RMD160 is not set
++# CONFIG_CRYPTO_RMD256 is not set
++# CONFIG_CRYPTO_RMD320 is not set
++# CONFIG_CRYPTO_SHA1 is not set
++# CONFIG_CRYPTO_SHA256 is not set
++# CONFIG_CRYPTO_SHA512 is not set
++# CONFIG_CRYPTO_TGR192 is not set
++# CONFIG_CRYPTO_WP512 is not set
++
++#
++# Ciphers
++#
++CONFIG_CRYPTO_AES=m
++# CONFIG_CRYPTO_ANUBIS is not set
++# CONFIG_CRYPTO_ARC4 is not set
++# CONFIG_CRYPTO_BLOWFISH is not set
++# CONFIG_CRYPTO_CAMELLIA is not set
++# CONFIG_CRYPTO_CAST5 is not set
++# CONFIG_CRYPTO_CAST6 is not set
++# CONFIG_CRYPTO_DES is not set
++# CONFIG_CRYPTO_FCRYPT is not set
++# CONFIG_CRYPTO_KHAZAD is not set
++# CONFIG_CRYPTO_SALSA20 is not set
++# CONFIG_CRYPTO_SEED is not set
++# CONFIG_CRYPTO_SERPENT is not set
++# CONFIG_CRYPTO_TEA is not set
++# CONFIG_CRYPTO_TWOFISH is not set
++
++#
++# Compression
++#
++CONFIG_CRYPTO_DEFLATE=m
++# CONFIG_CRYPTO_ZLIB is not set
++CONFIG_CRYPTO_LZO=m
++
++#
++# Random Number Generation
++#
++CONFIG_CRYPTO_ANSI_CPRNG=m
++# CONFIG_CRYPTO_USER_API_HASH is not set
++# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
++CONFIG_CRYPTO_HW=y
++# CONFIG_PPC_CLOCK is not set
++# CONFIG_VIRTUALIZATION is not set
+diff --git a/arch/powerpc/platforms/Kconfig b/arch/powerpc/platforms/Kconfig
+index a35ca44..ed05619 100644
+--- a/arch/powerpc/platforms/Kconfig
++++ b/arch/powerpc/platforms/Kconfig
+@@ -21,6 +21,7 @@ source "arch/powerpc/platforms/44x/Kconfig"
+ source "arch/powerpc/platforms/40x/Kconfig"
+ source "arch/powerpc/platforms/amigaone/Kconfig"
+ source "arch/powerpc/platforms/wsp/Kconfig"
++source "arch/powerpc/platforms/qsp/Kconfig"
+ 
+ config KVM_GUEST
+ 	bool "KVM Guest support"
+diff --git a/arch/powerpc/platforms/Makefile b/arch/powerpc/platforms/Makefile
+index 879b4a4..127e230 100644
+--- a/arch/powerpc/platforms/Makefile
++++ b/arch/powerpc/platforms/Makefile
+@@ -23,3 +23,4 @@ obj-$(CONFIG_PPC_PS3)		+= ps3/
+ obj-$(CONFIG_EMBEDDED6xx)	+= embedded6xx/
+ obj-$(CONFIG_AMIGAONE)		+= amigaone/
+ obj-$(CONFIG_PPC_WSP)		+= wsp/
++obj-$(CONFIG_PPC_QSP)		+= qsp/
+diff --git a/arch/powerpc/platforms/qsp/Kconfig b/arch/powerpc/platforms/qsp/Kconfig
+new file mode 100644
+index 0000000..8c04cc4
+--- /dev/null
++++ b/arch/powerpc/platforms/qsp/Kconfig
+@@ -0,0 +1,18 @@
++config PPC_QSP
++	bool "Simics QSP for PPC"
++	default n
++	select QSP
++	select QSP_PIC
++	help
++	  This option enables support for the QSP simics platform for PowerPC.
++
++config PPC_QSP_SYNC_TIMEBASE
++	bool "Manual sync of timebase between cores"
++	default n
++	depends on PPC_QSP && SMP
++	help
++	  This option enables generic code for manually syncing the timebase between cores
++	  on startup for SMP systems. This is very time consuming and will not yield perfect
++	  results anyway since simics runs each cores time slice in serial. When a core
++	  is enabled via the sysregs it's timebase is copied from core 0 which yields a good
++	  enough sync and a speedy boot so you can safely leave this option to N.
+diff --git a/arch/powerpc/platforms/qsp/Makefile b/arch/powerpc/platforms/qsp/Makefile
+new file mode 100644
+index 0000000..ada1c63
+--- /dev/null
++++ b/arch/powerpc/platforms/qsp/Makefile
+@@ -0,0 +1,4 @@
++obj-$(CONFIG_PPC_QSP)				+= setup.o
++obj-$(CONFIG_SMP)				+= smp.o head_smp.o
++
++
+diff --git a/arch/powerpc/platforms/qsp/head_smp.S b/arch/powerpc/platforms/qsp/head_smp.S
+new file mode 100644
+index 0000000..c8c9e2c
+--- /dev/null
++++ b/arch/powerpc/platforms/qsp/head_smp.S
+@@ -0,0 +1,26 @@
++
++/* This is instead of a bootloader...
++ */
++#include <asm/ppc_asm.h>
++#include <asm/reg.h>
++
++#define CPU_ID_REG 0xe0001010
++
++	.text
++	.global __secondary_start_qsp
++__secondary_start_qsp:
++	/* Enable timebase. Normally done in u-boot and will be done later
++	 * when we restore cpu context from core 0, but it doesn't
++	 * hurt to do it here since there might be some delays early on.
++	 */
++	mfspr	r11, SPRN_HID0
++	oris	r11,r11,HID0_TBEN@ha
++	mtspr	SPRN_HID0, r11
++
++	/* Fetch cpu id from sysregs and pass it on to generic code. */
++	lis	r3,CPU_ID_REG@ha
++	addi	r4,r3,CPU_ID_REG@l
++	lwbrx   r3,r5,r4 /* in wrong endian... */
++	stw	r3, __secondary_hold_acknowledge@l(0)
++	mr	r24, r3			/* cpu # */
++	b	__secondary_start
+diff --git a/arch/powerpc/platforms/qsp/setup.c b/arch/powerpc/platforms/qsp/setup.c
+new file mode 100644
+index 0000000..62103e9
+--- /dev/null
++++ b/arch/powerpc/platforms/qsp/setup.c
+@@ -0,0 +1,68 @@
++/*
++ * QSP PPC setup and early boot code plus other random bits.
++ *
++ * Copyright 2011 Wind River
++ *
++ * This program is free software; you can redistribute  it and/or modify it
++ * under  the terms of  the GNU General  Public License as published by the
++ * Free Software Foundation;  either version 2 of the  License, or (at your
++ * option) any later version.
++ */
++
++#include <asm/udbg.h>
++#include <linux/kernel.h>
++#include <asm/machdep.h>
++#include <linux/of_platform.h>
++#include <linux/qsp/qsp_pic.h>
++
++#include "smp.h"
++
++static int __init declare_of_platform_devices(void)
++{
++	of_platform_populate(NULL, of_default_bus_match_table, NULL, NULL);
++	return 0;
++}
++machine_device_initcall(qsp, declare_of_platform_devices);
++
++static void __init qsp_setup_arch(void)
++{
++	pr_info("QSP setup arch.");
++#ifdef CONFIG_SMP
++	qsp_smp_init();
++#endif
++}
++
++static void qsp_show_cpuinfo(struct seq_file *m)
++{
++	seq_printf(m, "machine\t\t: qsp-ppc\n");
++}
++
++/*
++ * Called very early, device-tree isn't unflattened
++ */
++static int __init qsp_probe(void)
++{
++	unsigned long root = of_get_flat_dt_root();
++	pr_debug("Probe QSP\n");
++	return of_flat_dt_is_compatible(root, "simics,qsp-ppc");
++}
++
++static void __init qsp_init_early(void)
++{
++	pr_info("QSP early init\n");
++#ifdef CONFIG_SMP
++	qsp_smp_early_init();
++#endif
++}
++
++define_machine(qsp) {
++	.name			= "QSP PPC",
++	.probe			= qsp_probe,
++	.init_early             = qsp_init_early,
++	.setup_arch		= qsp_setup_arch,
++	.init_IRQ		= qsp_pic_init,
++	.show_cpuinfo		= qsp_show_cpuinfo,
++	.get_irq		= qsp_pic_get_irq,
++	.calibrate_decr		= generic_calibrate_decr,
++};
++
+diff --git a/arch/powerpc/platforms/qsp/smp.c b/arch/powerpc/platforms/qsp/smp.c
+new file mode 100644
+index 0000000..c5092e2
+--- /dev/null
++++ b/arch/powerpc/platforms/qsp/smp.c
+@@ -0,0 +1,103 @@
++#include <linux/smp.h>
++#include <linux/kernel.h>
++#include <linux/of.h>
++#include <linux/io.h>
++#include <linux/delay.h>
++#include <linux/qsp/qsp_pic.h>
++
++#include "smp.h"
++
++#define ID_REG	       0x00
++#define ENABLE_REG     0x04
++#define DISABLE_REG    0x08
++#define BOOT_PC_REG    0x0c
++#define CPU_STATUS_REG 0x14
++#define PROBE_REG      0x18
++
++#define QSP_MAX_CPUS 128
++
++static void __iomem *sysregs_base;
++
++/* For QSP-PPC The default dtb is populated with all possible cpus (i.e 128)
++ * since there is no bootloader competent enough to create the exact dtb.
++ *
++ * We probe sysregs early to find out how many is actually present so the
++ * cpu_possible map setup in setup-common.c is not larger than needed.
++ */
++static void __init qsp_setup_max_cpus(void)
++{
++	int hw_cpu;
++	int possible = 0;
++
++	for (hw_cpu = 0; hw_cpu < QSP_MAX_CPUS; hw_cpu++) {
++		writel(hw_cpu, sysregs_base + PROBE_REG);
++		if (readl(sysregs_base + CPU_STATUS_REG) != 1) {
++			pr_debug(KERN_INFO "Probe cpu:%d not present.", hw_cpu);
++		} else {
++			possible++;
++			pr_debug(KERN_INFO "Probe cpu:%d present.", hw_cpu);
++		}
++	}
++	pr_info("QSP found %d possible cpus from probing sysregs.", possible);
++	pr_info(" previoud maxcpus %d\n", setup_max_cpus);
++	if (possible < setup_max_cpus) {
++		pr_info(" adjusting maxcpus from %d down to %d\n",
++			setup_max_cpus, possible);
++		setup_max_cpus = possible;
++	}
++}
++
++static int __init smp_qsp_kick_cpu(int nr)
++{
++	int n;
++	int hw_cpu = get_hard_smp_processor_id(nr);
++
++	BUG_ON(sysregs_base == NULL);
++
++	writel(__pa(__secondary_start_qsp), sysregs_base + BOOT_PC_REG);
++	writel(hw_cpu, sysregs_base + ENABLE_REG);
++	if (readl(sysregs_base + CPU_STATUS_REG) != 1) {
++		printk(KERN_INFO "cpu:%d not present.", hw_cpu);
++		return -EINVAL;
++	}
++
++	n = 0;
++	/* Wait a bit for the CPU to ack. */
++	while ((__secondary_hold_acknowledge != hw_cpu) && (++n < 1000))
++		mdelay(1);
++
++	if (__secondary_hold_acknowledge != hw_cpu) {
++		printk(KERN_WARNING "cpu:%d stuck (post %08lx)\n", nr,
++		       __secondary_hold_acknowledge);
++		return -EINVAL;
++	}
++
++	return 0;
++}
++
++static struct smp_ops_t smp_qsp_ops = {
++	.kick_cpu       = smp_qsp_kick_cpu,
++	.message_pass   = qsp_pic_message_pass,
++	.probe          = smp_qsp_pic_probe,
++	.setup_cpu	= smp_qsp_pic_setup_cpu,
++#ifdef CONFIG_PPC_QSP_SYNC_TIMEBASE
++	.take_timebase  = smp_generic_take_timebase,
++	.give_timebase  = smp_generic_give_timebase,
++#endif
++};
++
++void __init qsp_smp_init(void)
++{
++	pr_info("QSP smp  init\n");
++}
++
++void __init qsp_smp_early_init(void)
++{
++	struct device_node *np;
++	pr_info("QSP smp early init\n");
++	np = of_find_node_by_type(NULL, "sysregs");
++	if (np)
++		sysregs_base = of_iomap(np, 0);
++	qsp_setup_max_cpus();
++	smp_ops = &smp_qsp_ops;
++}
+diff --git a/arch/powerpc/platforms/qsp/smp.h b/arch/powerpc/platforms/qsp/smp.h
+new file mode 100644
+index 0000000..cf332cf
+--- /dev/null
++++ b/arch/powerpc/platforms/qsp/smp.h
+@@ -0,0 +1,17 @@
++/*
++ * Copyright 2012 Wind River
++ *
++ * This program is free software; you can redistribute  it and/or modify it
++ * under  the terms of  the GNU General  Public License as published by the
++ * Free Software Foundation;  either version 2 of the  License, or (at your
++ * option) any later version.
++ */
++
++#ifndef __QSP_SMP_H
++#define __QSP_SMP_H
++
++void qsp_smp_init(void);
++void qsp_smp_early_init(void);
++extern void __secondary_start_qsp(void);
++
++#endif
+-- 
+1.7.9.5
+
diff -pNur buildroot.2014.08/board/windriver/qsp-ppc/linux-0007-qsp-ppc-Workaround-for-timebase-going-back-in-time-o.patch buildroot/board/windriver/qsp-ppc/linux-0007-qsp-ppc-Workaround-for-timebase-going-back-in-time-o.patch
--- buildroot.2014.08/board/windriver/qsp-ppc/linux-0007-qsp-ppc-Workaround-for-timebase-going-back-in-time-o.patch	1970-01-01 07:00:00.000000000 +0700
+++ buildroot/board/windriver/qsp-ppc/linux-0007-qsp-ppc-Workaround-for-timebase-going-back-in-time-o.patch	2014-12-09 13:19:53.705729700 +0800
@@ -0,0 +1,39 @@
+From 75d569e91c7860d9e734de73966b17e9cc182d62 Mon Sep 17 00:00:00 2001
+From: Ivar Holmqvist <ivarholmqvist@gmail.com>
+Date: Fri, 15 Jun 2012 10:50:14 +0200
+Subject: [PATCH] qsp-ppc: Workaround for timebase going back in time on
+ simcics sometimes.
+
+---
+ arch/powerpc/kernel/time.c |   14 ++++++++++++++
+ 1 file changed, 14 insertions(+)
+
+diff --git a/arch/powerpc/kernel/time.c b/arch/powerpc/kernel/time.c
+index 2c42cd7..f881969 100644
+--- a/arch/powerpc/kernel/time.c
++++ b/arch/powerpc/kernel/time.c
+@@ -691,7 +691,21 @@ static cycle_t rtc_read(struct clocksource *cs)
+ 
+ static cycle_t timebase_read(struct clocksource *cs)
+ {
++#ifdef CONFIG_QSP
++	/* FIXME: This is strange, I would think that this was equivalent to
++	 * timebase_mode = fast-forward in simics.
++	 * However, this seems to work, fast-forward doesnt....
++	 *
++	 * FIXME: This is not wrap-around proof. 2^64 for the default timebase
++	 *	frequency (1Ghz/8) is 4679 years, however that might happen
++	 *	with hypersim and NO_HZ. However I intend to analyze this
++	 *	further and figure out why Simics itself can't provide this
++	 *	functionality...
++	 */
++	return max_t(cycle_t, cs->cycle_last, (cycle_t)get_tb());
++#else
+ 	return (cycle_t)get_tb();
++#endif
+ }
+ 
+ void update_vsyscall(struct timespec *wall_time, struct timespec *wtm,
+-- 
+1.7.9.5
+
diff -pNur buildroot.2014.08/board/windriver/qsp-ppc/linux-0008-qsp-ppc-Enable-powersave-nap-early-for-qsp.patch buildroot/board/windriver/qsp-ppc/linux-0008-qsp-ppc-Enable-powersave-nap-early-for-qsp.patch
--- buildroot.2014.08/board/windriver/qsp-ppc/linux-0008-qsp-ppc-Enable-powersave-nap-early-for-qsp.patch	1970-01-01 07:00:00.000000000 +0700
+++ buildroot/board/windriver/qsp-ppc/linux-0008-qsp-ppc-Enable-powersave-nap-early-for-qsp.patch	2014-12-09 13:19:53.705729700 +0800
@@ -0,0 +1,31 @@
+From 086cb871e3f836312b1ed715fa6c74d195e4cc47 Mon Sep 17 00:00:00 2001
+From: Ivar Holmqvist <ivarholmqvist@gmail.com>
+Date: Fri, 9 Mar 2012 09:28:16 +0100
+Subject: [PATCH] qsp-ppc: Enable powersave-nap early for qsp.
+
+---
+ arch/powerpc/kernel/idle.c |    7 +++++++
+ 1 file changed, 7 insertions(+)
+
+diff --git a/arch/powerpc/kernel/idle.c b/arch/powerpc/kernel/idle.c
+index 6d2209a..142201e 100644
+--- a/arch/powerpc/kernel/idle.c
++++ b/arch/powerpc/kernel/idle.c
+@@ -136,7 +136,14 @@ void cpu_idle_wait(void)
+ }
+ EXPORT_SYMBOL_GPL(cpu_idle_wait);
+ 
++#ifdef CONFIG_QSP
++/* Enabling powersave early makes a huge difference for
++ * SMP boot speed on simulated systems.
++ */
++int powersave_nap = 1;
++#else
+ int powersave_nap;
++#endif
+ 
+ #ifdef CONFIG_SYSCTL
+ /*
+-- 
+1.7.9.5
+
diff -pNur buildroot.2014.08/board/windriver/qsp-ppc/linux-0009-qsp-arm-Initial-support-for-qsp-arm-platform.patch buildroot/board/windriver/qsp-ppc/linux-0009-qsp-arm-Initial-support-for-qsp-arm-platform.patch
--- buildroot.2014.08/board/windriver/qsp-ppc/linux-0009-qsp-arm-Initial-support-for-qsp-arm-platform.patch	1970-01-01 07:00:00.000000000 +0700
+++ buildroot/board/windriver/qsp-ppc/linux-0009-qsp-arm-Initial-support-for-qsp-arm-platform.patch	2014-12-09 13:19:53.705729700 +0800
@@ -0,0 +1,3884 @@
+From 5627cef7033f56cbab97c5575ec9a767cd77b995 Mon Sep 17 00:00:00 2001
+From: Ivar Holmqvist <ivarholmqvist@gmail.com>
+Date: Mon, 16 Jul 2012 17:44:35 +0200
+Subject: [PATCH] qsp-arm: Initial support for qsp-arm platform.
+
+---
+ arch/arm/Kconfig                             |   21 +-
+ arch/arm/Makefile                            |    1 +
+ arch/arm/boot/dts/qsp.dts                    | 1861 ++++++++++++++++++++++++++
+ arch/arm/configs/qsp_defconfig               | 1379 +++++++++++++++++++
+ arch/arm/mach-qsp/Kconfig                    |   17 +
+ arch/arm/mach-qsp/Makefile                   |    2 +
+ arch/arm/mach-qsp/Makefile.boot              |    3 +
+ arch/arm/mach-qsp/include/mach/entry-macro.S |   16 +
+ arch/arm/mach-qsp/include/mach/io.h          |   26 +
+ arch/arm/mach-qsp/include/mach/irqs.h        |    4 +
+ arch/arm/mach-qsp/include/mach/system.h      |   37 +
+ arch/arm/mach-qsp/include/mach/timex.h       |   22 +
+ arch/arm/mach-qsp/include/mach/uncompress.h  |   53 +
+ arch/arm/mach-qsp/include/mach/vmalloc.h     |   21 +
+ arch/arm/mach-qsp/platsmp.c                  |  161 +++
+ arch/arm/mach-qsp/setup.c                    |   91 ++
+ 16 files changed, 3711 insertions(+), 4 deletions(-)
+
+diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
+index 36586dba..ae993d2 100644
+--- a/arch/arm/Kconfig
++++ b/arch/arm/Kconfig
+@@ -908,6 +908,15 @@ config ARCH_SHARK
+ 	  Support for the StrongARM based Digital DNARD machine, also known
+ 	  as "Shark" (<http://www.shark-linux.de/shark.html>).
+ 
++config ARCH_QSP
++	bool "Simics QSP Platform"
++	select CPU_V7
++	select GENERIC_CLOCKEVENTS
++	select USE_OF
++	select MULTI_IRQ_HANDLER
++	help
++	  Support for Simics QSP Platform
++
+ config ARCH_U300
+ 	bool "ST-Ericsson U300 Series"
+ 	depends on MMU
+@@ -1016,6 +1025,8 @@ endchoice
+ # Kconfigs may be included either alphabetically (according to the
+ # plat- suffix) or along side the corresponding mach-* source.
+ #
++source "arch/arm/mach-qsp/Kconfig"
++
+ source "arch/arm/mach-at91/Kconfig"
+ 
+ source "arch/arm/mach-bcmring/Kconfig"
+@@ -1491,7 +1502,7 @@ config SMP
+ 	depends on HAVE_SMP
+ 	depends on MMU
+ 	select USE_GENERIC_SMP_HELPERS
+-	select HAVE_ARM_SCU if !ARCH_MSM_SCORPIONMP
++	select HAVE_ARM_SCU if !ARCH_MSM_SCORPIONMP && !MACH_QSP
+ 	help
+ 	  This enables support for systems with more than one CPU. If you have
+ 	  a system with only one CPU, like most personal computers, say N. If
+@@ -1583,7 +1594,9 @@ config PAGE_OFFSET
+ 	default 0xC0000000
+ 
+ config NR_CPUS
+-	int "Maximum number of CPUs (2-32)"
++	int "Maximum number of CPUs"
++	range 2 128 if MACH_QSP
++	default 128 if MACH_QSP
+ 	range 2 32
+ 	depends on SMP
+ 	default "4"
+@@ -1599,7 +1612,7 @@ config LOCAL_TIMERS
+ 	bool "Use local timer interrupts"
+ 	depends on SMP
+ 	default y
+-	select HAVE_ARM_TWD if (!ARCH_MSM_SCORPIONMP && !EXYNOS4_MCT)
++	select HAVE_ARM_TWD if (!ARCH_MSM_SCORPIONMP && !EXYNOS4_MCT && !MACH_QSP)
+ 	help
+ 	  Enable support for local timers on SMP platforms, rather then the
+ 	  legacy IPI broadcast method.  Local timers allows the system
+@@ -2281,7 +2294,7 @@ menu "Power management options"
+ source "kernel/power/Kconfig"
+ 
+ config ARCH_SUSPEND_POSSIBLE
+-	depends on !ARCH_S5PC100
++	depends on !ARCH_S5PC100 && !MACH_QSP
+ 	depends on CPU_ARM920T || CPU_ARM926T || CPU_SA1100 || \
+ 		CPU_V6 || CPU_V6K || CPU_V7 || CPU_XSC3 || CPU_XSCALE
+ 	def_bool y
+diff --git a/arch/arm/Makefile b/arch/arm/Makefile
+index 047a207..862eedf 100644
+--- a/arch/arm/Makefile
++++ b/arch/arm/Makefile
+@@ -134,6 +134,7 @@ textofs-$(CONFIG_ARCH_MSM8960) := 0x00208000
+ 
+ # Machine directory name.  This list is sorted alphanumerically
+ # by CONFIG_* macro name.
++machine-$(CONFIG_ARCH_QSP)		:= qsp
+ machine-$(CONFIG_ARCH_AT91)		:= at91
+ machine-$(CONFIG_ARCH_BCMRING)		:= bcmring
+ machine-$(CONFIG_ARCH_CLPS711X)		:= clps711x
+diff --git a/arch/arm/boot/dts/qsp.dts b/arch/arm/boot/dts/qsp.dts
+new file mode 100644
+index 0000000..e064656
+--- /dev/null
++++ b/arch/arm/boot/dts/qsp.dts
+@@ -0,0 +1,1861 @@
++/*
++ * Copyright 2011, Wind River
++ * 2006 (c) G. Liakhovetski <g.liakhovetski@gmx.de>
++ * Copyright 2008 Freescale Semiconductor, Inc.
++ *
++ * This file is licensed under
++ * the terms of the GNU General Public License version 2.  This program
++ * is licensed "as is" without any warranty of any kind, whether express
++ * or implied.
++ */
++
++/* The dts file for an QSP virtual board can (and should) be generated
++ * by simics itself from the actual configuration. This is a simple version
++ * with just one of each device hardcoded into it and 512Mb memory.
++ */
++
++/dts-v1/;
++
++
++/ {
++	model = "Simics QSP";
++	compatible = "simics,qsp-arm";
++	#address-cells = <1>;
++	#size-cells = <1>;
++
++	cpus {
++		#address-cells = <1>;
++		#size-cells = <0>;
++
++		cpu@0 {
++			compatible = "arm,cortex-a9";
++			reg = <0>;
++		};
++	};
++
++
++	memory {
++		name = "memory";
++		device_type = "memory";
++		reg = <0x00000000 0x2000000>;
++	};
++	chosen {
++		bootargs = "root=0x6300 console=ttyAM0 ";
++	};
++
++	soc@0xe0000000 {
++		#address-cells = <2>;
++		#size-cells = <1>;
++		device_type = "soc";
++		compatible = "simple-bus";
++		ranges = <		0 0 0xe0000000 0x1000 //pic0
++		1 0 0xe0001000 0x1000 //sysregs0
++		2 0 0xe0002000 0x1000 //rtc0
++		3 0 0xe0010000 0x1000 //uart0
++		4 0 0xe0011000 0x1000 //uart1
++		5 0 0xe0012000 0x1000 //uart2
++		6 0 0xe0013000 0x1000 //uart3
++		7 0 0xe0014000 0x1000 //uart4
++		8 0 0xe0015000 0x1000 //uart5
++		9 0 0xe0016000 0x1000 //uart6
++		10 0 0xe0017000 0x1000 //uart7
++		11 0 0xe0018000 0x1000 //uart8
++		12 0 0xe0019000 0x1000 //uart9
++		13 0 0xe001a000 0x1000 //uart10
++		14 0 0xe001b000 0x1000 //uart11
++		15 0 0xe001c000 0x1000 //uart12
++		16 0 0xe001d000 0x1000 //uart13
++		17 0 0xe001e000 0x1000 //uart14
++		18 0 0xe001f000 0x1000 //uart15
++		19 0 0xe0020000 0x1000 //timer0
++		20 0 0xe0030000 0x1000 //led0
++		21 0 0xe0031000 0x1000 //led1
++		22 0 0xe0032000 0x1000 //led2
++		23 0 0xe0033000 0x1000 //led3
++		24 0 0xe0034000 0x1000 //led4
++		25 0 0xe0035000 0x1000 //led5
++		26 0 0xe0036000 0x1000 //led6
++		27 0 0xe0037000 0x1000 //led7
++		28 0 0xe0038000 0x1000 //led8
++		29 0 0xe0039000 0x1000 //led9
++		30 0 0xe003a000 0x1000 //led10
++		31 0 0xe003b000 0x1000 //led11
++		32 0 0xe003c000 0x1000 //led12
++		33 0 0xe003d000 0x1000 //led13
++		34 0 0xe003e000 0x1000 //led14
++		35 0 0xe003f000 0x1000 //led15
++		36 0 0xe0040000 0x1000 //mac0
++		37 0 0xe0041000 0x1000 //mac1
++		38 0 0xe0042000 0x1000 //mac2
++		39 0 0xe0043000 0x1000 //mac3
++		40 0 0xe0044000 0x1000 //mac4
++		41 0 0xe0045000 0x1000 //mac5
++		42 0 0xe0046000 0x1000 //mac6
++		43 0 0xe0047000 0x1000 //mac7
++		44 0 0xe0048000 0x1000 //mac8
++		45 0 0xe0049000 0x1000 //mac9
++		46 0 0xe004a000 0x1000 //mac10
++		47 0 0xe004b000 0x1000 //mac11
++		48 0 0xe004c000 0x1000 //mac12
++		49 0 0xe004d000 0x1000 //mac13
++		50 0 0xe004e000 0x1000 //mac14
++		51 0 0xe004f000 0x1000 //mac15
++		52 0 0xe0050000 0x1000 //disk_ctrl0
++		53 0 0xe0051000 0x1000 //disk_ctrl1
++		54 0 0xe0052000 0x1000 //disk_ctrl2
++		55 0 0xe0053000 0x1000 //disk_ctrl3
++		56 0 0xe0054000 0x1000 //disk_ctrl4
++		57 0 0xe0055000 0x1000 //disk_ctrl5
++		58 0 0xe0056000 0x1000 //disk_ctrl6
++		59 0 0xe0057000 0x1000 //disk_ctrl7
++		60 0 0xe0058000 0x1000 //disk_ctrl8
++		61 0 0xe0059000 0x1000 //disk_ctrl9
++		62 0 0xe005a000 0x1000 //disk_ctrl10
++		63 0 0xe005b000 0x1000 //disk_ctrl11
++		64 0 0xe005c000 0x1000 //disk_ctrl12
++		65 0 0xe005d000 0x1000 //disk_ctrl13
++		66 0 0xe005e000 0x1000 //disk_ctrl14
++		67 0 0xe005f000 0x1000 //disk_ctrl15
++>;
++		bus-frequency = <0>;
++
++		PIC: interrupt-controller@0,0 {
++			#interrupt-cells = <2>;
++			cell-index = <0>;
++			device_type = "interrupt-controller";
++			compatible = "qsp-pic";
++			interrupt-controller;
++			reg = <0 0x0 0x1000>;
++		};
++
++		SYSREGS: sysregs {
++			device_type = "sysregs";
++			compatible = "qsp,sysregs";
++			reg = <1 0x0 0x1000>;
++		};
++
++		RTC: rtc {
++			device_type = "rtc";
++			compatible = "qsp-rtc";
++			reg = <2 0x0 0x1000>;
++		};
++
++		UART0: qspserial0 {
++			device_type = "serial";
++			compatible = "qsp-serial";
++			reg = <3 0x0 0x1000>;
++			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
++			interrupt-parent = <&PIC>;
++ 			interrupts = <16 0x1>;
++		};
++
++		UART1: qspserial1 {
++			device_type = "serial";
++			compatible = "qsp-serial";
++			reg = <4 0x0 0x1000>;
++			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
++			interrupt-parent = <&PIC>;
++ 			interrupts = <17 0x1>;
++		};
++
++		UART2: qspserial2 {
++			device_type = "serial";
++			compatible = "qsp-serial";
++			reg = <5 0x0 0x1000>;
++			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
++			interrupt-parent = <&PIC>;
++ 			interrupts = <18 0x1>;
++		};
++
++		UART3: qspserial3 {
++			device_type = "serial";
++			compatible = "qsp-serial";
++			reg = <6 0x0 0x1000>;
++			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
++			interrupt-parent = <&PIC>;
++ 			interrupts = <19 0x1>;
++		};
++
++		UART4: qspserial4 {
++			device_type = "serial";
++			compatible = "qsp-serial";
++			reg = <7 0x0 0x1000>;
++			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
++			interrupt-parent = <&PIC>;
++ 			interrupts = <20 0x1>;
++		};
++
++		UART5: qspserial5 {
++			device_type = "serial";
++			compatible = "qsp-serial";
++			reg = <8 0x0 0x1000>;
++			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
++			interrupt-parent = <&PIC>;
++ 			interrupts = <21 0x1>;
++		};
++
++		UART6: qspserial6 {
++			device_type = "serial";
++			compatible = "qsp-serial";
++			reg = <9 0x0 0x1000>;
++			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
++			interrupt-parent = <&PIC>;
++ 			interrupts = <22 0x1>;
++		};
++
++		UART7: qspserial7 {
++			device_type = "serial";
++			compatible = "qsp-serial";
++			reg = <10 0x0 0x1000>;
++			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
++			interrupt-parent = <&PIC>;
++ 			interrupts = <23 0x1>;
++		};
++
++		UART8: qspserial8 {
++			device_type = "serial";
++			compatible = "qsp-serial";
++			reg = <11 0x0 0x1000>;
++			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
++			interrupt-parent = <&PIC>;
++ 			interrupts = <24 0x1>;
++		};
++
++		UART9: qspserial9 {
++			device_type = "serial";
++			compatible = "qsp-serial";
++			reg = <12 0x0 0x1000>;
++			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
++			interrupt-parent = <&PIC>;
++ 			interrupts = <25 0x1>;
++		};
++
++		UART10: qspserial10 {
++			device_type = "serial";
++			compatible = "qsp-serial";
++			reg = <13 0x0 0x1000>;
++			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
++			interrupt-parent = <&PIC>;
++ 			interrupts = <26 0x1>;
++		};
++
++		UART11: qspserial11 {
++			device_type = "serial";
++			compatible = "qsp-serial";
++			reg = <14 0x0 0x1000>;
++			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
++			interrupt-parent = <&PIC>;
++ 			interrupts = <27 0x1>;
++		};
++
++		UART12: qspserial12 {
++			device_type = "serial";
++			compatible = "qsp-serial";
++			reg = <15 0x0 0x1000>;
++			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
++			interrupt-parent = <&PIC>;
++ 			interrupts = <28 0x1>;
++		};
++
++		UART13: qspserial13 {
++			device_type = "serial";
++			compatible = "qsp-serial";
++			reg = <16 0x0 0x1000>;
++			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
++			interrupt-parent = <&PIC>;
++ 			interrupts = <29 0x1>;
++		};
++
++		UART14: qspserial14 {
++			device_type = "serial";
++			compatible = "qsp-serial";
++			reg = <17 0x0 0x1000>;
++			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
++			interrupt-parent = <&PIC>;
++ 			interrupts = <30 0x1>;
++		};
++
++		UART15: qspserial15 {
++			device_type = "serial";
++			compatible = "qsp-serial";
++			reg = <18 0x0 0x1000>;
++			clock-frequency = <1000000>; /* ignored by our driver, but needed by generic of_serial.c */
++			interrupt-parent = <&PIC>;
++ 			interrupts = <31 0x1>;
++		};
++
++		TIMER0: qsptimer0 {
++			compatible = "qsp,timer";
++			reg = <19 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <32 0x1>;
++		};
++
++		led0 {
++		 	 label = "led0";
++                         compatible = "leds-qsp";
++                         reg = <20 0x0 0x1000>;
++
++		 	 linux,default-trigger = "default-on";
++
++			led0 {
++				label = "power";
++				index = <0>;
++				linux,default-trigger = "default-on";
++			};
++			led01 {
++				label = "heartbeat";
++				index = <1>;
++				linux,default-trigger = "heartbeat";
++			};
++			led02 {
++				label = "timer";
++				index = <2>;
++				//linux,default-trigger = "timer";
++			};
++			led03 {
++				label = "cpu0";
++				index = <3>;
++				//linux,default-trigger = "cpu0";
++			};
++			led04 {
++				label = "cpu1";
++				index = <4>;
++				//linux,default-trigger = "cpu1";
++			};
++			led05 {
++				label = "cpu2";
++				index = <5>;
++				//linux,default-trigger = "cpu2";
++			};
++			led06 {
++				label = "cpu3";
++				index = <6>;
++				//linux,default-trigger = "cpu3";
++			};
++			led07 {
++				label = "led07";
++				index = <7>;
++			};
++			led08 {
++				label = "led08";
++				index = <8>;
++			};
++			led09 {
++				label = "led09";
++				index = <9>;
++			};
++			led10 {
++				label = "led10";
++				index = <10>;
++			};
++			led11 {
++				label = "led11";
++				index = <11>;
++			};
++			led12 {
++				label = "led12";
++				index = <12>;
++			};
++			led13 {
++				label = "led13";
++				index = <13>;
++			};
++			led14 {
++				label = "led14";
++				index = <14>;
++			};
++			led15 {
++				label = "led15";
++				index = <15>;
++			};
++
++		};
++
++		led1 {
++		 	 label = "led1";
++                         compatible = "leds-qsp";
++                         reg = <21 0x0 0x1000>;
++
++		 	 linux,default-trigger = "default-on";
++
++			led0 {
++				label = "power";
++				index = <0>;
++				linux,default-trigger = "default-on";
++			};
++			led01 {
++				label = "heartbeat";
++				index = <1>;
++				linux,default-trigger = "heartbeat";
++			};
++			led02 {
++				label = "timer";
++				index = <2>;
++				//linux,default-trigger = "timer";
++			};
++			led03 {
++				label = "cpu0";
++				index = <3>;
++				//linux,default-trigger = "cpu0";
++			};
++			led04 {
++				label = "cpu1";
++				index = <4>;
++				//linux,default-trigger = "cpu1";
++			};
++			led05 {
++				label = "cpu2";
++				index = <5>;
++				//linux,default-trigger = "cpu2";
++			};
++			led06 {
++				label = "cpu3";
++				index = <6>;
++				//linux,default-trigger = "cpu3";
++			};
++			led07 {
++				label = "led07";
++				index = <7>;
++			};
++			led08 {
++				label = "led08";
++				index = <8>;
++			};
++			led09 {
++				label = "led09";
++				index = <9>;
++			};
++			led10 {
++				label = "led10";
++				index = <10>;
++			};
++			led11 {
++				label = "led11";
++				index = <11>;
++			};
++			led12 {
++				label = "led12";
++				index = <12>;
++			};
++			led13 {
++				label = "led13";
++				index = <13>;
++			};
++			led14 {
++				label = "led14";
++				index = <14>;
++			};
++			led15 {
++				label = "led15";
++				index = <15>;
++			};
++
++		};
++
++		led2 {
++		 	 label = "led2";
++                         compatible = "leds-qsp";
++                         reg = <22 0x0 0x1000>;
++
++		 	 linux,default-trigger = "default-on";
++
++			led0 {
++				label = "power";
++				index = <0>;
++				linux,default-trigger = "default-on";
++			};
++			led01 {
++				label = "heartbeat";
++				index = <1>;
++				linux,default-trigger = "heartbeat";
++			};
++			led02 {
++				label = "timer";
++				index = <2>;
++				//linux,default-trigger = "timer";
++			};
++			led03 {
++				label = "cpu0";
++				index = <3>;
++				//linux,default-trigger = "cpu0";
++			};
++			led04 {
++				label = "cpu1";
++				index = <4>;
++				//linux,default-trigger = "cpu1";
++			};
++			led05 {
++				label = "cpu2";
++				index = <5>;
++				//linux,default-trigger = "cpu2";
++			};
++			led06 {
++				label = "cpu3";
++				index = <6>;
++				//linux,default-trigger = "cpu3";
++			};
++			led07 {
++				label = "led07";
++				index = <7>;
++			};
++			led08 {
++				label = "led08";
++				index = <8>;
++			};
++			led09 {
++				label = "led09";
++				index = <9>;
++			};
++			led10 {
++				label = "led10";
++				index = <10>;
++			};
++			led11 {
++				label = "led11";
++				index = <11>;
++			};
++			led12 {
++				label = "led12";
++				index = <12>;
++			};
++			led13 {
++				label = "led13";
++				index = <13>;
++			};
++			led14 {
++				label = "led14";
++				index = <14>;
++			};
++			led15 {
++				label = "led15";
++				index = <15>;
++			};
++
++		};
++
++		led3 {
++		 	 label = "led3";
++                         compatible = "leds-qsp";
++                         reg = <23 0x0 0x1000>;
++
++		 	 linux,default-trigger = "default-on";
++
++			led0 {
++				label = "power";
++				index = <0>;
++				linux,default-trigger = "default-on";
++			};
++			led01 {
++				label = "heartbeat";
++				index = <1>;
++				linux,default-trigger = "heartbeat";
++			};
++			led02 {
++				label = "timer";
++				index = <2>;
++				//linux,default-trigger = "timer";
++			};
++			led03 {
++				label = "cpu0";
++				index = <3>;
++				//linux,default-trigger = "cpu0";
++			};
++			led04 {
++				label = "cpu1";
++				index = <4>;
++				//linux,default-trigger = "cpu1";
++			};
++			led05 {
++				label = "cpu2";
++				index = <5>;
++				//linux,default-trigger = "cpu2";
++			};
++			led06 {
++				label = "cpu3";
++				index = <6>;
++				//linux,default-trigger = "cpu3";
++			};
++			led07 {
++				label = "led07";
++				index = <7>;
++			};
++			led08 {
++				label = "led08";
++				index = <8>;
++			};
++			led09 {
++				label = "led09";
++				index = <9>;
++			};
++			led10 {
++				label = "led10";
++				index = <10>;
++			};
++			led11 {
++				label = "led11";
++				index = <11>;
++			};
++			led12 {
++				label = "led12";
++				index = <12>;
++			};
++			led13 {
++				label = "led13";
++				index = <13>;
++			};
++			led14 {
++				label = "led14";
++				index = <14>;
++			};
++			led15 {
++				label = "led15";
++				index = <15>;
++			};
++
++		};
++
++		led4 {
++		 	 label = "led4";
++                         compatible = "leds-qsp";
++                         reg = <24 0x0 0x1000>;
++
++		 	 linux,default-trigger = "default-on";
++
++			led0 {
++				label = "power";
++				index = <0>;
++				linux,default-trigger = "default-on";
++			};
++			led01 {
++				label = "heartbeat";
++				index = <1>;
++				linux,default-trigger = "heartbeat";
++			};
++			led02 {
++				label = "timer";
++				index = <2>;
++				//linux,default-trigger = "timer";
++			};
++			led03 {
++				label = "cpu0";
++				index = <3>;
++				//linux,default-trigger = "cpu0";
++			};
++			led04 {
++				label = "cpu1";
++				index = <4>;
++				//linux,default-trigger = "cpu1";
++			};
++			led05 {
++				label = "cpu2";
++				index = <5>;
++				//linux,default-trigger = "cpu2";
++			};
++			led06 {
++				label = "cpu3";
++				index = <6>;
++				//linux,default-trigger = "cpu3";
++			};
++			led07 {
++				label = "led07";
++				index = <7>;
++			};
++			led08 {
++				label = "led08";
++				index = <8>;
++			};
++			led09 {
++				label = "led09";
++				index = <9>;
++			};
++			led10 {
++				label = "led10";
++				index = <10>;
++			};
++			led11 {
++				label = "led11";
++				index = <11>;
++			};
++			led12 {
++				label = "led12";
++				index = <12>;
++			};
++			led13 {
++				label = "led13";
++				index = <13>;
++			};
++			led14 {
++				label = "led14";
++				index = <14>;
++			};
++			led15 {
++				label = "led15";
++				index = <15>;
++			};
++
++		};
++
++		led5 {
++		 	 label = "led5";
++                         compatible = "leds-qsp";
++                         reg = <25 0x0 0x1000>;
++
++		 	 linux,default-trigger = "default-on";
++
++			led0 {
++				label = "power";
++				index = <0>;
++				linux,default-trigger = "default-on";
++			};
++			led01 {
++				label = "heartbeat";
++				index = <1>;
++				linux,default-trigger = "heartbeat";
++			};
++			led02 {
++				label = "timer";
++				index = <2>;
++				//linux,default-trigger = "timer";
++			};
++			led03 {
++				label = "cpu0";
++				index = <3>;
++				//linux,default-trigger = "cpu0";
++			};
++			led04 {
++				label = "cpu1";
++				index = <4>;
++				//linux,default-trigger = "cpu1";
++			};
++			led05 {
++				label = "cpu2";
++				index = <5>;
++				//linux,default-trigger = "cpu2";
++			};
++			led06 {
++				label = "cpu3";
++				index = <6>;
++				//linux,default-trigger = "cpu3";
++			};
++			led07 {
++				label = "led07";
++				index = <7>;
++			};
++			led08 {
++				label = "led08";
++				index = <8>;
++			};
++			led09 {
++				label = "led09";
++				index = <9>;
++			};
++			led10 {
++				label = "led10";
++				index = <10>;
++			};
++			led11 {
++				label = "led11";
++				index = <11>;
++			};
++			led12 {
++				label = "led12";
++				index = <12>;
++			};
++			led13 {
++				label = "led13";
++				index = <13>;
++			};
++			led14 {
++				label = "led14";
++				index = <14>;
++			};
++			led15 {
++				label = "led15";
++				index = <15>;
++			};
++
++		};
++
++		led6 {
++		 	 label = "led6";
++                         compatible = "leds-qsp";
++                         reg = <26 0x0 0x1000>;
++
++		 	 linux,default-trigger = "default-on";
++
++			led0 {
++				label = "power";
++				index = <0>;
++				linux,default-trigger = "default-on";
++			};
++			led01 {
++				label = "heartbeat";
++				index = <1>;
++				linux,default-trigger = "heartbeat";
++			};
++			led02 {
++				label = "timer";
++				index = <2>;
++				//linux,default-trigger = "timer";
++			};
++			led03 {
++				label = "cpu0";
++				index = <3>;
++				//linux,default-trigger = "cpu0";
++			};
++			led04 {
++				label = "cpu1";
++				index = <4>;
++				//linux,default-trigger = "cpu1";
++			};
++			led05 {
++				label = "cpu2";
++				index = <5>;
++				//linux,default-trigger = "cpu2";
++			};
++			led06 {
++				label = "cpu3";
++				index = <6>;
++				//linux,default-trigger = "cpu3";
++			};
++			led07 {
++				label = "led07";
++				index = <7>;
++			};
++			led08 {
++				label = "led08";
++				index = <8>;
++			};
++			led09 {
++				label = "led09";
++				index = <9>;
++			};
++			led10 {
++				label = "led10";
++				index = <10>;
++			};
++			led11 {
++				label = "led11";
++				index = <11>;
++			};
++			led12 {
++				label = "led12";
++				index = <12>;
++			};
++			led13 {
++				label = "led13";
++				index = <13>;
++			};
++			led14 {
++				label = "led14";
++				index = <14>;
++			};
++			led15 {
++				label = "led15";
++				index = <15>;
++			};
++
++		};
++
++		led7 {
++		 	 label = "led7";
++                         compatible = "leds-qsp";
++                         reg = <27 0x0 0x1000>;
++
++		 	 linux,default-trigger = "default-on";
++
++			led0 {
++				label = "power";
++				index = <0>;
++				linux,default-trigger = "default-on";
++			};
++			led01 {
++				label = "heartbeat";
++				index = <1>;
++				linux,default-trigger = "heartbeat";
++			};
++			led02 {
++				label = "timer";
++				index = <2>;
++				//linux,default-trigger = "timer";
++			};
++			led03 {
++				label = "cpu0";
++				index = <3>;
++				//linux,default-trigger = "cpu0";
++			};
++			led04 {
++				label = "cpu1";
++				index = <4>;
++				//linux,default-trigger = "cpu1";
++			};
++			led05 {
++				label = "cpu2";
++				index = <5>;
++				//linux,default-trigger = "cpu2";
++			};
++			led06 {
++				label = "cpu3";
++				index = <6>;
++				//linux,default-trigger = "cpu3";
++			};
++			led07 {
++				label = "led07";
++				index = <7>;
++			};
++			led08 {
++				label = "led08";
++				index = <8>;
++			};
++			led09 {
++				label = "led09";
++				index = <9>;
++			};
++			led10 {
++				label = "led10";
++				index = <10>;
++			};
++			led11 {
++				label = "led11";
++				index = <11>;
++			};
++			led12 {
++				label = "led12";
++				index = <12>;
++			};
++			led13 {
++				label = "led13";
++				index = <13>;
++			};
++			led14 {
++				label = "led14";
++				index = <14>;
++			};
++			led15 {
++				label = "led15";
++				index = <15>;
++			};
++
++		};
++
++		led8 {
++		 	 label = "led8";
++                         compatible = "leds-qsp";
++                         reg = <28 0x0 0x1000>;
++
++		 	 linux,default-trigger = "default-on";
++
++			led0 {
++				label = "power";
++				index = <0>;
++				linux,default-trigger = "default-on";
++			};
++			led01 {
++				label = "heartbeat";
++				index = <1>;
++				linux,default-trigger = "heartbeat";
++			};
++			led02 {
++				label = "timer";
++				index = <2>;
++				//linux,default-trigger = "timer";
++			};
++			led03 {
++				label = "cpu0";
++				index = <3>;
++				//linux,default-trigger = "cpu0";
++			};
++			led04 {
++				label = "cpu1";
++				index = <4>;
++				//linux,default-trigger = "cpu1";
++			};
++			led05 {
++				label = "cpu2";
++				index = <5>;
++				//linux,default-trigger = "cpu2";
++			};
++			led06 {
++				label = "cpu3";
++				index = <6>;
++				//linux,default-trigger = "cpu3";
++			};
++			led07 {
++				label = "led07";
++				index = <7>;
++			};
++			led08 {
++				label = "led08";
++				index = <8>;
++			};
++			led09 {
++				label = "led09";
++				index = <9>;
++			};
++			led10 {
++				label = "led10";
++				index = <10>;
++			};
++			led11 {
++				label = "led11";
++				index = <11>;
++			};
++			led12 {
++				label = "led12";
++				index = <12>;
++			};
++			led13 {
++				label = "led13";
++				index = <13>;
++			};
++			led14 {
++				label = "led14";
++				index = <14>;
++			};
++			led15 {
++				label = "led15";
++				index = <15>;
++			};
++
++		};
++
++		led9 {
++		 	 label = "led9";
++                         compatible = "leds-qsp";
++                         reg = <29 0x0 0x1000>;
++
++		 	 linux,default-trigger = "default-on";
++
++			led0 {
++				label = "power";
++				index = <0>;
++				linux,default-trigger = "default-on";
++			};
++			led01 {
++				label = "heartbeat";
++				index = <1>;
++				linux,default-trigger = "heartbeat";
++			};
++			led02 {
++				label = "timer";
++				index = <2>;
++				//linux,default-trigger = "timer";
++			};
++			led03 {
++				label = "cpu0";
++				index = <3>;
++				//linux,default-trigger = "cpu0";
++			};
++			led04 {
++				label = "cpu1";
++				index = <4>;
++				//linux,default-trigger = "cpu1";
++			};
++			led05 {
++				label = "cpu2";
++				index = <5>;
++				//linux,default-trigger = "cpu2";
++			};
++			led06 {
++				label = "cpu3";
++				index = <6>;
++				//linux,default-trigger = "cpu3";
++			};
++			led07 {
++				label = "led07";
++				index = <7>;
++			};
++			led08 {
++				label = "led08";
++				index = <8>;
++			};
++			led09 {
++				label = "led09";
++				index = <9>;
++			};
++			led10 {
++				label = "led10";
++				index = <10>;
++			};
++			led11 {
++				label = "led11";
++				index = <11>;
++			};
++			led12 {
++				label = "led12";
++				index = <12>;
++			};
++			led13 {
++				label = "led13";
++				index = <13>;
++			};
++			led14 {
++				label = "led14";
++				index = <14>;
++			};
++			led15 {
++				label = "led15";
++				index = <15>;
++			};
++
++		};
++
++		led10 {
++		 	 label = "led10";
++                         compatible = "leds-qsp";
++                         reg = <30 0x0 0x1000>;
++
++		 	 linux,default-trigger = "default-on";
++
++			led0 {
++				label = "power";
++				index = <0>;
++				linux,default-trigger = "default-on";
++			};
++			led01 {
++				label = "heartbeat";
++				index = <1>;
++				linux,default-trigger = "heartbeat";
++			};
++			led02 {
++				label = "timer";
++				index = <2>;
++				//linux,default-trigger = "timer";
++			};
++			led03 {
++				label = "cpu0";
++				index = <3>;
++				//linux,default-trigger = "cpu0";
++			};
++			led04 {
++				label = "cpu1";
++				index = <4>;
++				//linux,default-trigger = "cpu1";
++			};
++			led05 {
++				label = "cpu2";
++				index = <5>;
++				//linux,default-trigger = "cpu2";
++			};
++			led06 {
++				label = "cpu3";
++				index = <6>;
++				//linux,default-trigger = "cpu3";
++			};
++			led07 {
++				label = "led07";
++				index = <7>;
++			};
++			led08 {
++				label = "led08";
++				index = <8>;
++			};
++			led09 {
++				label = "led09";
++				index = <9>;
++			};
++			led10 {
++				label = "led10";
++				index = <10>;
++			};
++			led11 {
++				label = "led11";
++				index = <11>;
++			};
++			led12 {
++				label = "led12";
++				index = <12>;
++			};
++			led13 {
++				label = "led13";
++				index = <13>;
++			};
++			led14 {
++				label = "led14";
++				index = <14>;
++			};
++			led15 {
++				label = "led15";
++				index = <15>;
++			};
++
++		};
++
++		led11 {
++		 	 label = "led11";
++                         compatible = "leds-qsp";
++                         reg = <31 0x0 0x1000>;
++
++		 	 linux,default-trigger = "default-on";
++
++			led0 {
++				label = "power";
++				index = <0>;
++				linux,default-trigger = "default-on";
++			};
++			led01 {
++				label = "heartbeat";
++				index = <1>;
++				linux,default-trigger = "heartbeat";
++			};
++			led02 {
++				label = "timer";
++				index = <2>;
++				//linux,default-trigger = "timer";
++			};
++			led03 {
++				label = "cpu0";
++				index = <3>;
++				//linux,default-trigger = "cpu0";
++			};
++			led04 {
++				label = "cpu1";
++				index = <4>;
++				//linux,default-trigger = "cpu1";
++			};
++			led05 {
++				label = "cpu2";
++				index = <5>;
++				//linux,default-trigger = "cpu2";
++			};
++			led06 {
++				label = "cpu3";
++				index = <6>;
++				//linux,default-trigger = "cpu3";
++			};
++			led07 {
++				label = "led07";
++				index = <7>;
++			};
++			led08 {
++				label = "led08";
++				index = <8>;
++			};
++			led09 {
++				label = "led09";
++				index = <9>;
++			};
++			led10 {
++				label = "led10";
++				index = <10>;
++			};
++			led11 {
++				label = "led11";
++				index = <11>;
++			};
++			led12 {
++				label = "led12";
++				index = <12>;
++			};
++			led13 {
++				label = "led13";
++				index = <13>;
++			};
++			led14 {
++				label = "led14";
++				index = <14>;
++			};
++			led15 {
++				label = "led15";
++				index = <15>;
++			};
++
++		};
++
++		led12 {
++		 	 label = "led12";
++                         compatible = "leds-qsp";
++                         reg = <32 0x0 0x1000>;
++
++		 	 linux,default-trigger = "default-on";
++
++			led0 {
++				label = "power";
++				index = <0>;
++				linux,default-trigger = "default-on";
++			};
++			led01 {
++				label = "heartbeat";
++				index = <1>;
++				linux,default-trigger = "heartbeat";
++			};
++			led02 {
++				label = "timer";
++				index = <2>;
++				//linux,default-trigger = "timer";
++			};
++			led03 {
++				label = "cpu0";
++				index = <3>;
++				//linux,default-trigger = "cpu0";
++			};
++			led04 {
++				label = "cpu1";
++				index = <4>;
++				//linux,default-trigger = "cpu1";
++			};
++			led05 {
++				label = "cpu2";
++				index = <5>;
++				//linux,default-trigger = "cpu2";
++			};
++			led06 {
++				label = "cpu3";
++				index = <6>;
++				//linux,default-trigger = "cpu3";
++			};
++			led07 {
++				label = "led07";
++				index = <7>;
++			};
++			led08 {
++				label = "led08";
++				index = <8>;
++			};
++			led09 {
++				label = "led09";
++				index = <9>;
++			};
++			led10 {
++				label = "led10";
++				index = <10>;
++			};
++			led11 {
++				label = "led11";
++				index = <11>;
++			};
++			led12 {
++				label = "led12";
++				index = <12>;
++			};
++			led13 {
++				label = "led13";
++				index = <13>;
++			};
++			led14 {
++				label = "led14";
++				index = <14>;
++			};
++			led15 {
++				label = "led15";
++				index = <15>;
++			};
++
++		};
++
++		led13 {
++		 	 label = "led13";
++                         compatible = "leds-qsp";
++                         reg = <33 0x0 0x1000>;
++
++		 	 linux,default-trigger = "default-on";
++
++			led0 {
++				label = "power";
++				index = <0>;
++				linux,default-trigger = "default-on";
++			};
++			led01 {
++				label = "heartbeat";
++				index = <1>;
++				linux,default-trigger = "heartbeat";
++			};
++			led02 {
++				label = "timer";
++				index = <2>;
++				//linux,default-trigger = "timer";
++			};
++			led03 {
++				label = "cpu0";
++				index = <3>;
++				//linux,default-trigger = "cpu0";
++			};
++			led04 {
++				label = "cpu1";
++				index = <4>;
++				//linux,default-trigger = "cpu1";
++			};
++			led05 {
++				label = "cpu2";
++				index = <5>;
++				//linux,default-trigger = "cpu2";
++			};
++			led06 {
++				label = "cpu3";
++				index = <6>;
++				//linux,default-trigger = "cpu3";
++			};
++			led07 {
++				label = "led07";
++				index = <7>;
++			};
++			led08 {
++				label = "led08";
++				index = <8>;
++			};
++			led09 {
++				label = "led09";
++				index = <9>;
++			};
++			led10 {
++				label = "led10";
++				index = <10>;
++			};
++			led11 {
++				label = "led11";
++				index = <11>;
++			};
++			led12 {
++				label = "led12";
++				index = <12>;
++			};
++			led13 {
++				label = "led13";
++				index = <13>;
++			};
++			led14 {
++				label = "led14";
++				index = <14>;
++			};
++			led15 {
++				label = "led15";
++				index = <15>;
++			};
++
++		};
++
++		led14 {
++		 	 label = "led14";
++                         compatible = "leds-qsp";
++                         reg = <34 0x0 0x1000>;
++
++		 	 linux,default-trigger = "default-on";
++
++			led0 {
++				label = "power";
++				index = <0>;
++				linux,default-trigger = "default-on";
++			};
++			led01 {
++				label = "heartbeat";
++				index = <1>;
++				linux,default-trigger = "heartbeat";
++			};
++			led02 {
++				label = "timer";
++				index = <2>;
++				//linux,default-trigger = "timer";
++			};
++			led03 {
++				label = "cpu0";
++				index = <3>;
++				//linux,default-trigger = "cpu0";
++			};
++			led04 {
++				label = "cpu1";
++				index = <4>;
++				//linux,default-trigger = "cpu1";
++			};
++			led05 {
++				label = "cpu2";
++				index = <5>;
++				//linux,default-trigger = "cpu2";
++			};
++			led06 {
++				label = "cpu3";
++				index = <6>;
++				//linux,default-trigger = "cpu3";
++			};
++			led07 {
++				label = "led07";
++				index = <7>;
++			};
++			led08 {
++				label = "led08";
++				index = <8>;
++			};
++			led09 {
++				label = "led09";
++				index = <9>;
++			};
++			led10 {
++				label = "led10";
++				index = <10>;
++			};
++			led11 {
++				label = "led11";
++				index = <11>;
++			};
++			led12 {
++				label = "led12";
++				index = <12>;
++			};
++			led13 {
++				label = "led13";
++				index = <13>;
++			};
++			led14 {
++				label = "led14";
++				index = <14>;
++			};
++			led15 {
++				label = "led15";
++				index = <15>;
++			};
++
++		};
++
++		led15 {
++		 	 label = "led15";
++                         compatible = "leds-qsp";
++                         reg = <35 0x0 0x1000>;
++
++		 	 linux,default-trigger = "default-on";
++
++			led0 {
++				label = "power";
++				index = <0>;
++				linux,default-trigger = "default-on";
++			};
++			led01 {
++				label = "heartbeat";
++				index = <1>;
++				linux,default-trigger = "heartbeat";
++			};
++			led02 {
++				label = "timer";
++				index = <2>;
++				//linux,default-trigger = "timer";
++			};
++			led03 {
++				label = "cpu0";
++				index = <3>;
++				//linux,default-trigger = "cpu0";
++			};
++			led04 {
++				label = "cpu1";
++				index = <4>;
++				//linux,default-trigger = "cpu1";
++			};
++			led05 {
++				label = "cpu2";
++				index = <5>;
++				//linux,default-trigger = "cpu2";
++			};
++			led06 {
++				label = "cpu3";
++				index = <6>;
++				//linux,default-trigger = "cpu3";
++			};
++			led07 {
++				label = "led07";
++				index = <7>;
++			};
++			led08 {
++				label = "led08";
++				index = <8>;
++			};
++			led09 {
++				label = "led09";
++				index = <9>;
++			};
++			led10 {
++				label = "led10";
++				index = <10>;
++			};
++			led11 {
++				label = "led11";
++				index = <11>;
++			};
++			led12 {
++				label = "led12";
++				index = <12>;
++			};
++			led13 {
++				label = "led13";
++				index = <13>;
++			};
++			led14 {
++				label = "led14";
++				index = <14>;
++			};
++			led15 {
++				label = "led15";
++				index = <15>;
++			};
++		};
++
++		ETH0: eth0 {
++			device_type = "eth";
++			compatible = "qsp-mac";
++			reg = <36 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <64 0x1>;
++
++		};
++
++		ETH1: eth1 {
++			device_type = "eth";
++			compatible = "qsp-mac";
++			reg = <37 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <65 0x1>;
++
++		};
++
++		ETH2: eth2 {
++			device_type = "eth";
++			compatible = "qsp-mac";
++			reg = <38 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <66 0x1>;
++
++		};
++
++		ETH3: eth3 {
++			device_type = "eth";
++			compatible = "qsp-mac";
++			reg = <39 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <67 0x1>;
++
++		};
++
++		ETH4: eth4 {
++			device_type = "eth";
++			compatible = "qsp-mac";
++			reg = <40 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <68 0x1>;
++
++		};
++
++		ETH5: eth5 {
++			device_type = "eth";
++			compatible = "qsp-mac";
++			reg = <41 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <69 0x1>;
++
++		};
++
++		ETH6: eth6 {
++			device_type = "eth";
++			compatible = "qsp-mac";
++			reg = <42 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <70 0x1>;
++
++		};
++
++		ETH7: eth7 {
++			device_type = "eth";
++			compatible = "qsp-mac";
++			reg = <43 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <71 0x1>;
++
++		};
++
++		ETH8: eth8 {
++			device_type = "eth";
++			compatible = "qsp-mac";
++			reg = <44 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <72 0x1>;
++
++		};
++
++		ETH9: eth9 {
++			device_type = "eth";
++			compatible = "qsp-mac";
++			reg = <45 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <73 0x1>;
++
++		};
++
++		ETH10: eth10 {
++			device_type = "eth";
++			compatible = "qsp-mac";
++			reg = <46 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <74 0x1>;
++
++		};
++
++		ETH11: eth11 {
++			device_type = "eth";
++			compatible = "qsp-mac";
++			reg = <47 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <75 0x1>;
++
++		};
++
++		ETH12: eth12 {
++			device_type = "eth";
++			compatible = "qsp-mac";
++			reg = <48 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <76 0x1>;
++
++		};
++
++		ETH13: eth13 {
++			device_type = "eth";
++			compatible = "qsp-mac";
++			reg = <49 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <77 0x1>;
++
++		};
++
++		ETH14: eth14 {
++			device_type = "eth";
++			compatible = "qsp-mac";
++			reg = <50 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <78 0x1>;
++
++		};
++
++		ETH15: eth15 {
++			device_type = "eth";
++			compatible = "qsp-mac";
++			reg = <51 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <79 0x1>;
++
++		};
++
++		DISKCTL0: diskctrl0 {
++			device_type = "disk-controller";
++			compatible = "qsp,disk-controller";
++			reg = <52 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <80 0x1>;
++		};
++
++		DISKCTL1: diskctrl1 {
++			device_type = "disk-controller";
++			compatible = "qsp,disk-controller";
++			reg = <53 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <81 0x1>;
++		};
++
++		DISKCTL2: diskctrl2 {
++			device_type = "disk-controller";
++			compatible = "qsp,disk-controller";
++			reg = <54 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <82 0x1>;
++		};
++
++		DISKCTL3: diskctrl3 {
++			device_type = "disk-controller";
++			compatible = "qsp,disk-controller";
++			reg = <55 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <83 0x1>;
++		};
++
++		DISKCTL4: diskctrl4 {
++			device_type = "disk-controller";
++			compatible = "qsp,disk-controller";
++			reg = <56 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <84 0x1>;
++		};
++
++		DISKCTL5: diskctrl5 {
++			device_type = "disk-controller";
++			compatible = "qsp,disk-controller";
++			reg = <57 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <85 0x1>;
++		};
++
++		DISKCTL6: diskctrl6 {
++			device_type = "disk-controller";
++			compatible = "qsp,disk-controller";
++			reg = <58 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <86 0x1>;
++		};
++
++		DISKCTL7: diskctrl7 {
++			device_type = "disk-controller";
++			compatible = "qsp,disk-controller";
++			reg = <59 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <87 0x1>;
++		};
++
++		DISKCTL8: diskctrl8 {
++			device_type = "disk-controller";
++			compatible = "qsp,disk-controller";
++			reg = <60 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <88 0x1>;
++		};
++
++		DISKCTL9: diskctrl9 {
++			device_type = "disk-controller";
++			compatible = "qsp,disk-controller";
++			reg = <61 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <89 0x1>;
++		};
++
++		DISKCTL10: diskctrl10 {
++			device_type = "disk-controller";
++			compatible = "qsp,disk-controller";
++			reg = <62 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <90 0x1>;
++		};
++
++		DISKCTL11: diskctrl11 {
++			device_type = "disk-controller";
++			compatible = "qsp,disk-controller";
++			reg = <63 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <91 0x1>;
++		};
++
++		DISKCTL12: diskctrl12 {
++			device_type = "disk-controller";
++			compatible = "qsp,disk-controller";
++			reg = <64 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <92 0x1>;
++		};
++
++		DISKCTL13: diskctrl13 {
++			device_type = "disk-controller";
++			compatible = "qsp,disk-controller";
++			reg = <65 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <93 0x1>;
++		};
++
++		DISKCTL14: diskctrl14 {
++			device_type = "disk-controller";
++			compatible = "qsp,disk-controller";
++			reg = <66 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <94 0x1>;
++		};
++
++		DISKCTL15: diskctrl15 {
++			device_type = "disk-controller";
++			compatible = "qsp,disk-controller";
++			reg = <67 0x0 0x1000>;
++			interrupt-parent = <&PIC>;
++			interrupts = <95 0x1>;
++		};
++	};
++};
+\ No newline at end of file
+diff --git a/arch/arm/configs/qsp_defconfig b/arch/arm/configs/qsp_defconfig
+new file mode 100644
+index 0000000..9652c7e
+--- /dev/null
++++ b/arch/arm/configs/qsp_defconfig
+@@ -0,0 +1,1379 @@
++#
++# Automatically generated file; DO NOT EDIT.
++# Linux/arm 3.4.0 Kernel Configuration
++#
++CONFIG_ARM=y
++CONFIG_SYS_SUPPORTS_APM_EMULATION=y
++# CONFIG_ARCH_USES_GETTIMEOFFSET is not set
++CONFIG_GENERIC_CLOCKEVENTS=y
++CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
++CONFIG_KTIME_SCALAR=y
++CONFIG_HAVE_PROC_CPU=y
++CONFIG_STACKTRACE_SUPPORT=y
++CONFIG_LOCKDEP_SUPPORT=y
++CONFIG_TRACE_IRQFLAGS_SUPPORT=y
++CONFIG_HARDIRQS_SW_RESEND=y
++CONFIG_GENERIC_IRQ_PROBE=y
++CONFIG_RWSEM_GENERIC_SPINLOCK=y
++CONFIG_ARCH_HAS_CPU_IDLE_WAIT=y
++CONFIG_GENERIC_HWEIGHT=y
++CONFIG_GENERIC_CALIBRATE_DELAY=y
++CONFIG_NEED_DMA_MAP_STATE=y
++CONFIG_VECTORS_BASE=0xffff0000
++CONFIG_ARM_PATCH_PHYS_VIRT=y
++CONFIG_GENERIC_BUG=y
++CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
++CONFIG_HAVE_IRQ_WORK=y
++
++#
++# General setup
++#
++CONFIG_EXPERIMENTAL=y
++CONFIG_INIT_ENV_ARG_LIMIT=32
++CONFIG_CROSS_COMPILE=""
++CONFIG_LOCALVERSION=""
++CONFIG_LOCALVERSION_AUTO=y
++CONFIG_HAVE_KERNEL_GZIP=y
++CONFIG_HAVE_KERNEL_LZMA=y
++CONFIG_HAVE_KERNEL_XZ=y
++CONFIG_HAVE_KERNEL_LZO=y
++CONFIG_KERNEL_GZIP=y
++# CONFIG_KERNEL_LZMA is not set
++# CONFIG_KERNEL_XZ is not set
++# CONFIG_KERNEL_LZO is not set
++CONFIG_DEFAULT_HOSTNAME="(none)"
++CONFIG_SWAP=y
++CONFIG_SYSVIPC=y
++CONFIG_SYSVIPC_SYSCTL=y
++# CONFIG_POSIX_MQUEUE is not set
++# CONFIG_BSD_PROCESS_ACCT is not set
++# CONFIG_FHANDLE is not set
++# CONFIG_TASKSTATS is not set
++# CONFIG_AUDIT is not set
++CONFIG_HAVE_GENERIC_HARDIRQS=y
++
++#
++# IRQ subsystem
++#
++CONFIG_GENERIC_HARDIRQS=y
++CONFIG_GENERIC_IRQ_SHOW=y
++CONFIG_IRQ_DOMAIN=y
++
++#
++# RCU Subsystem
++#
++CONFIG_TREE_RCU=y
++# CONFIG_PREEMPT_RCU is not set
++CONFIG_RCU_FANOUT=32
++# CONFIG_RCU_FANOUT_EXACT is not set
++# CONFIG_RCU_FAST_NO_HZ is not set
++# CONFIG_TREE_RCU_TRACE is not set
++# CONFIG_IKCONFIG is not set
++CONFIG_LOG_BUF_SHIFT=14
++# CONFIG_CGROUPS is not set
++# CONFIG_CHECKPOINT_RESTORE is not set
++# CONFIG_NAMESPACES is not set
++# CONFIG_SCHED_AUTOGROUP is not set
++# CONFIG_SYSFS_DEPRECATED is not set
++# CONFIG_RELAY is not set
++CONFIG_BLK_DEV_INITRD=y
++CONFIG_INITRAMFS_SOURCE=""
++CONFIG_RD_GZIP=y
++# CONFIG_RD_BZIP2 is not set
++# CONFIG_RD_LZMA is not set
++# CONFIG_RD_XZ is not set
++# CONFIG_RD_LZO is not set
++# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
++CONFIG_SYSCTL=y
++CONFIG_ANON_INODES=y
++CONFIG_EXPERT=y
++CONFIG_UID16=y
++# CONFIG_SYSCTL_SYSCALL is not set
++CONFIG_KALLSYMS=y
++# CONFIG_KALLSYMS_ALL is not set
++CONFIG_HOTPLUG=y
++CONFIG_PRINTK=y
++CONFIG_BUG=y
++CONFIG_ELF_CORE=y
++CONFIG_BASE_FULL=y
++CONFIG_FUTEX=y
++CONFIG_EPOLL=y
++CONFIG_SIGNALFD=y
++CONFIG_TIMERFD=y
++CONFIG_EVENTFD=y
++CONFIG_SHMEM=y
++CONFIG_AIO=y
++# CONFIG_EMBEDDED is not set
++CONFIG_HAVE_PERF_EVENTS=y
++CONFIG_PERF_USE_VMALLOC=y
++
++#
++# Kernel Performance Events And Counters
++#
++# CONFIG_PERF_EVENTS is not set
++# CONFIG_PERF_COUNTERS is not set
++CONFIG_VM_EVENT_COUNTERS=y
++CONFIG_SLUB_DEBUG=y
++CONFIG_COMPAT_BRK=y
++# CONFIG_SLAB is not set
++CONFIG_SLUB=y
++# CONFIG_SLOB is not set
++# CONFIG_PROFILING is not set
++CONFIG_HAVE_OPROFILE=y
++# CONFIG_KPROBES is not set
++# CONFIG_JUMP_LABEL is not set
++CONFIG_HAVE_KPROBES=y
++CONFIG_HAVE_KRETPROBES=y
++CONFIG_USE_GENERIC_SMP_HELPERS=y
++CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
++CONFIG_HAVE_DMA_API_DEBUG=y
++CONFIG_HAVE_ARCH_JUMP_LABEL=y
++CONFIG_QSP=y
++
++#
++# GCOV-based kernel profiling
++#
++CONFIG_HAVE_GENERIC_DMA_COHERENT=y
++CONFIG_SLABINFO=y
++CONFIG_RT_MUTEXES=y
++CONFIG_BASE_SMALL=0
++CONFIG_MODULES=y
++# CONFIG_MODULE_FORCE_LOAD is not set
++# CONFIG_MODULE_UNLOAD is not set
++# CONFIG_MODVERSIONS is not set
++# CONFIG_MODULE_SRCVERSION_ALL is not set
++CONFIG_BLOCK=y
++CONFIG_LBDAF=y
++# CONFIG_BLK_DEV_BSG is not set
++# CONFIG_BLK_DEV_BSGLIB is not set
++# CONFIG_BLK_DEV_INTEGRITY is not set
++
++#
++# Partition Types
++#
++CONFIG_PARTITION_ADVANCED=y
++# CONFIG_ACORN_PARTITION is not set
++# CONFIG_OSF_PARTITION is not set
++# CONFIG_AMIGA_PARTITION is not set
++# CONFIG_ATARI_PARTITION is not set
++# CONFIG_MAC_PARTITION is not set
++CONFIG_MSDOS_PARTITION=y
++# CONFIG_BSD_DISKLABEL is not set
++# CONFIG_MINIX_SUBPARTITION is not set
++# CONFIG_SOLARIS_X86_PARTITION is not set
++# CONFIG_UNIXWARE_DISKLABEL is not set
++# CONFIG_LDM_PARTITION is not set
++# CONFIG_SGI_PARTITION is not set
++# CONFIG_ULTRIX_PARTITION is not set
++# CONFIG_SUN_PARTITION is not set
++# CONFIG_KARMA_PARTITION is not set
++# CONFIG_EFI_PARTITION is not set
++# CONFIG_SYSV68_PARTITION is not set
++
++#
++# IO Schedulers
++#
++CONFIG_IOSCHED_NOOP=y
++CONFIG_IOSCHED_DEADLINE=y
++CONFIG_IOSCHED_CFQ=y
++# CONFIG_DEFAULT_DEADLINE is not set
++CONFIG_DEFAULT_CFQ=y
++# CONFIG_DEFAULT_NOOP is not set
++CONFIG_DEFAULT_IOSCHED="cfq"
++# CONFIG_INLINE_SPIN_TRYLOCK is not set
++# CONFIG_INLINE_SPIN_TRYLOCK_BH is not set
++# CONFIG_INLINE_SPIN_LOCK is not set
++# CONFIG_INLINE_SPIN_LOCK_BH is not set
++# CONFIG_INLINE_SPIN_LOCK_IRQ is not set
++# CONFIG_INLINE_SPIN_LOCK_IRQSAVE is not set
++# CONFIG_INLINE_SPIN_UNLOCK_BH is not set
++CONFIG_INLINE_SPIN_UNLOCK_IRQ=y
++# CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE is not set
++# CONFIG_INLINE_READ_TRYLOCK is not set
++# CONFIG_INLINE_READ_LOCK is not set
++# CONFIG_INLINE_READ_LOCK_BH is not set
++# CONFIG_INLINE_READ_LOCK_IRQ is not set
++# CONFIG_INLINE_READ_LOCK_IRQSAVE is not set
++CONFIG_INLINE_READ_UNLOCK=y
++# CONFIG_INLINE_READ_UNLOCK_BH is not set
++CONFIG_INLINE_READ_UNLOCK_IRQ=y
++# CONFIG_INLINE_READ_UNLOCK_IRQRESTORE is not set
++# CONFIG_INLINE_WRITE_TRYLOCK is not set
++# CONFIG_INLINE_WRITE_LOCK is not set
++# CONFIG_INLINE_WRITE_LOCK_BH is not set
++# CONFIG_INLINE_WRITE_LOCK_IRQ is not set
++# CONFIG_INLINE_WRITE_LOCK_IRQSAVE is not set
++CONFIG_INLINE_WRITE_UNLOCK=y
++# CONFIG_INLINE_WRITE_UNLOCK_BH is not set
++CONFIG_INLINE_WRITE_UNLOCK_IRQ=y
++# CONFIG_INLINE_WRITE_UNLOCK_IRQRESTORE is not set
++CONFIG_MUTEX_SPIN_ON_OWNER=y
++# CONFIG_FREEZER is not set
++
++#
++# System Type
++#
++CONFIG_MMU=y
++# CONFIG_ARCH_INTEGRATOR is not set
++# CONFIG_ARCH_REALVIEW is not set
++# CONFIG_ARCH_VERSATILE is not set
++# CONFIG_ARCH_VEXPRESS is not set
++# CONFIG_ARCH_AT91 is not set
++# CONFIG_ARCH_BCMRING is not set
++# CONFIG_ARCH_HIGHBANK is not set
++# CONFIG_ARCH_CLPS711X is not set
++# CONFIG_ARCH_CNS3XXX is not set
++# CONFIG_ARCH_GEMINI is not set
++# CONFIG_ARCH_PRIMA2 is not set
++# CONFIG_ARCH_EBSA110 is not set
++# CONFIG_ARCH_EP93XX is not set
++# CONFIG_ARCH_FOOTBRIDGE is not set
++# CONFIG_ARCH_MXC is not set
++# CONFIG_ARCH_MXS is not set
++# CONFIG_ARCH_NETX is not set
++# CONFIG_ARCH_H720X is not set
++# CONFIG_ARCH_IOP13XX is not set
++# CONFIG_ARCH_IOP32X is not set
++# CONFIG_ARCH_IOP33X is not set
++# CONFIG_ARCH_IXP23XX is not set
++# CONFIG_ARCH_IXP2000 is not set
++# CONFIG_ARCH_IXP4XX is not set
++# CONFIG_ARCH_DOVE is not set
++# CONFIG_ARCH_KIRKWOOD is not set
++# CONFIG_ARCH_LPC32XX is not set
++# CONFIG_ARCH_MV78XX0 is not set
++# CONFIG_ARCH_ORION5X is not set
++# CONFIG_ARCH_MMP is not set
++# CONFIG_ARCH_KS8695 is not set
++# CONFIG_ARCH_W90X900 is not set
++# CONFIG_ARCH_TEGRA is not set
++# CONFIG_ARCH_PICOXCELL is not set
++# CONFIG_ARCH_PNX4008 is not set
++# CONFIG_ARCH_PXA is not set
++# CONFIG_ARCH_MSM is not set
++# CONFIG_ARCH_SHMOBILE is not set
++# CONFIG_ARCH_RPC is not set
++# CONFIG_ARCH_SA1100 is not set
++# CONFIG_ARCH_S3C24XX is not set
++# CONFIG_ARCH_S3C64XX is not set
++# CONFIG_ARCH_S5P64X0 is not set
++# CONFIG_ARCH_S5PC100 is not set
++# CONFIG_ARCH_S5PV210 is not set
++# CONFIG_ARCH_EXYNOS is not set
++# CONFIG_ARCH_SHARK is not set
++CONFIG_ARCH_QSP=y
++# CONFIG_ARCH_U300 is not set
++# CONFIG_ARCH_U8500 is not set
++# CONFIG_ARCH_NOMADIK is not set
++# CONFIG_ARCH_DAVINCI is not set
++# CONFIG_ARCH_OMAP is not set
++# CONFIG_PLAT_SPEAR is not set
++# CONFIG_ARCH_VT8500 is not set
++# CONFIG_ARCH_ZYNQ is not set
++CONFIG_MACH_QSP=y
++CONFIG_ARM_QSP=y
++
++#
++# System MMU
++#
++
++#
++# Processor Type
++#
++CONFIG_CPU_V7=y
++CONFIG_CPU_32v6K=y
++CONFIG_CPU_32v7=y
++CONFIG_CPU_ABRT_EV7=y
++CONFIG_CPU_PABRT_V7=y
++CONFIG_CPU_CACHE_V7=y
++CONFIG_CPU_CACHE_VIPT=y
++CONFIG_CPU_COPY_V6=y
++CONFIG_CPU_TLB_V7=y
++CONFIG_CPU_HAS_ASID=y
++CONFIG_CPU_CP15=y
++CONFIG_CPU_CP15_MMU=y
++
++#
++# Processor Features
++#
++# CONFIG_ARM_LPAE is not set
++# CONFIG_ARCH_PHYS_ADDR_T_64BIT is not set
++CONFIG_ARM_THUMB=y
++# CONFIG_ARM_THUMBEE is not set
++CONFIG_SWP_EMULATE=y
++# CONFIG_CPU_ICACHE_DISABLE is not set
++# CONFIG_CPU_DCACHE_DISABLE is not set
++# CONFIG_CPU_BPREDICT_DISABLE is not set
++# CONFIG_CACHE_L2X0 is not set
++CONFIG_ARM_L1_CACHE_SHIFT_6=y
++CONFIG_ARM_L1_CACHE_SHIFT=6
++CONFIG_ARM_DMA_MEM_BUFFERABLE=y
++CONFIG_ARM_NR_BANKS=8
++CONFIG_CPU_HAS_PMU=y
++CONFIG_MULTI_IRQ_HANDLER=y
++# CONFIG_ARM_ERRATA_430973 is not set
++# CONFIG_ARM_ERRATA_458693 is not set
++# CONFIG_ARM_ERRATA_460075 is not set
++# CONFIG_ARM_ERRATA_742230 is not set
++# CONFIG_ARM_ERRATA_742231 is not set
++CONFIG_ARM_ERRATA_720789=y
++# CONFIG_ARM_ERRATA_743622 is not set
++# CONFIG_ARM_ERRATA_751472 is not set
++# CONFIG_ARM_ERRATA_754322 is not set
++# CONFIG_ARM_ERRATA_754327 is not set
++# CONFIG_ARM_ERRATA_764369 is not set
++
++#
++# Bus support
++#
++# CONFIG_PCI_SYSCALL is not set
++# CONFIG_ARCH_SUPPORTS_MSI is not set
++# CONFIG_PCCARD is not set
++
++#
++# Kernel Features
++#
++CONFIG_TICK_ONESHOT=y
++CONFIG_NO_HZ=y
++# CONFIG_HIGH_RES_TIMERS is not set
++CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
++CONFIG_HAVE_SMP=y
++CONFIG_SMP=y
++CONFIG_SMP_ON_UP=y
++# CONFIG_ARM_CPU_TOPOLOGY is not set
++CONFIG_VMSPLIT_3G=y
++# CONFIG_VMSPLIT_2G is not set
++# CONFIG_VMSPLIT_1G is not set
++CONFIG_PAGE_OFFSET=0xC0000000
++CONFIG_NR_CPUS=128
++# CONFIG_HOTPLUG_CPU is not set
++# CONFIG_LOCAL_TIMERS is not set
++CONFIG_ARCH_NR_GPIO=0
++CONFIG_PREEMPT_NONE=y
++# CONFIG_PREEMPT_VOLUNTARY is not set
++# CONFIG_PREEMPT is not set
++CONFIG_HZ=100
++# CONFIG_THUMB2_KERNEL is not set
++CONFIG_AEABI=y
++CONFIG_OABI_COMPAT=y
++# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
++# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
++CONFIG_HAVE_ARCH_PFN_VALID=y
++CONFIG_HIGHMEM=y
++# CONFIG_HIGHPTE is not set
++CONFIG_SELECT_MEMORY_MODEL=y
++CONFIG_FLATMEM_MANUAL=y
++CONFIG_FLATMEM=y
++CONFIG_FLAT_NODE_MEM_MAP=y
++CONFIG_HAVE_MEMBLOCK=y
++CONFIG_PAGEFLAGS_EXTENDED=y
++CONFIG_SPLIT_PTLOCK_CPUS=4
++# CONFIG_COMPACTION is not set
++# CONFIG_PHYS_ADDR_T_64BIT is not set
++CONFIG_ZONE_DMA_FLAG=0
++CONFIG_BOUNCE=y
++CONFIG_VIRT_TO_BUS=y
++# CONFIG_KSM is not set
++CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
++# CONFIG_CLEANCACHE is not set
++CONFIG_FORCE_MAX_ZONEORDER=11
++CONFIG_ALIGNMENT_TRAP=y
++# CONFIG_UACCESS_WITH_MEMCPY is not set
++# CONFIG_SECCOMP is not set
++# CONFIG_CC_STACKPROTECTOR is not set
++# CONFIG_DEPRECATED_PARAM_STRUCT is not set
++
++#
++# Boot options
++#
++CONFIG_USE_OF=y
++CONFIG_ZBOOT_ROM_TEXT=0
++CONFIG_ZBOOT_ROM_BSS=0
++# CONFIG_ARM_APPENDED_DTB is not set
++CONFIG_CMDLINE="console=ttyS0,115200"
++CONFIG_CMDLINE_FROM_BOOTLOADER=y
++# CONFIG_CMDLINE_EXTEND is not set
++# CONFIG_CMDLINE_FORCE is not set
++# CONFIG_XIP_KERNEL is not set
++# CONFIG_CRASH_DUMP is not set
++# CONFIG_AUTO_ZRELADDR is not set
++
++#
++# CPU Power Management
++#
++# CONFIG_CPU_IDLE is not set
++
++#
++# Floating point emulation
++#
++
++#
++# At least one emulation must be selected
++#
++# CONFIG_FPE_NWFPE is not set
++# CONFIG_FPE_FASTFPE is not set
++CONFIG_VFP=y
++CONFIG_VFPv3=y
++CONFIG_NEON=y
++
++#
++# Userspace binary formats
++#
++CONFIG_BINFMT_ELF=y
++CONFIG_ARCH_BINFMT_ELF_RANDOMIZE_PIE=y
++CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS=y
++CONFIG_HAVE_AOUT=y
++# CONFIG_BINFMT_AOUT is not set
++CONFIG_BINFMT_MISC=y
++
++#
++# Power management options
++#
++CONFIG_PM_RUNTIME=y
++CONFIG_PM=y
++# CONFIG_PM_DEBUG is not set
++# CONFIG_APM_EMULATION is not set
++# CONFIG_ARM_CPU_SUSPEND is not set
++CONFIG_NET=y
++
++#
++# Networking options
++#
++CONFIG_PACKET=y
++CONFIG_UNIX=y
++# CONFIG_UNIX_DIAG is not set
++CONFIG_XFRM=y
++CONFIG_XFRM_USER=y
++# CONFIG_XFRM_SUB_POLICY is not set
++# CONFIG_XFRM_MIGRATE is not set
++# CONFIG_XFRM_STATISTICS is not set
++# CONFIG_NET_KEY is not set
++CONFIG_INET=y
++CONFIG_IP_MULTICAST=y
++# CONFIG_IP_ADVANCED_ROUTER is not set
++CONFIG_IP_PNP=y
++CONFIG_IP_PNP_DHCP=y
++CONFIG_IP_PNP_BOOTP=y
++# CONFIG_IP_PNP_RARP is not set
++# CONFIG_NET_IPIP is not set
++# CONFIG_NET_IPGRE_DEMUX is not set
++# CONFIG_IP_MROUTE is not set
++# CONFIG_ARPD is not set
++CONFIG_SYN_COOKIES=y
++# CONFIG_INET_AH is not set
++# CONFIG_INET_ESP is not set
++# CONFIG_INET_IPCOMP is not set
++# CONFIG_INET_XFRM_TUNNEL is not set
++# CONFIG_INET_TUNNEL is not set
++CONFIG_INET_XFRM_MODE_TRANSPORT=y
++CONFIG_INET_XFRM_MODE_TUNNEL=y
++CONFIG_INET_XFRM_MODE_BEET=y
++# CONFIG_INET_LRO is not set
++CONFIG_INET_DIAG=y
++CONFIG_INET_TCP_DIAG=y
++# CONFIG_INET_UDP_DIAG is not set
++# CONFIG_TCP_CONG_ADVANCED is not set
++CONFIG_TCP_CONG_CUBIC=y
++CONFIG_DEFAULT_TCP_CONG="cubic"
++# CONFIG_TCP_MD5SIG is not set
++# CONFIG_IPV6 is not set
++# CONFIG_NETWORK_SECMARK is not set
++# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
++# CONFIG_NETFILTER is not set
++# CONFIG_IP_DCCP is not set
++# CONFIG_IP_SCTP is not set
++# CONFIG_RDS is not set
++# CONFIG_TIPC is not set
++# CONFIG_ATM is not set
++# CONFIG_L2TP is not set
++# CONFIG_BRIDGE is not set
++# CONFIG_NET_DSA is not set
++# CONFIG_VLAN_8021Q is not set
++# CONFIG_DECNET is not set
++# CONFIG_LLC2 is not set
++# CONFIG_IPX is not set
++# CONFIG_ATALK is not set
++# CONFIG_X25 is not set
++# CONFIG_LAPB is not set
++# CONFIG_ECONET is not set
++# CONFIG_WAN_ROUTER is not set
++# CONFIG_PHONET is not set
++# CONFIG_IEEE802154 is not set
++# CONFIG_NET_SCHED is not set
++# CONFIG_DCB is not set
++# CONFIG_BATMAN_ADV is not set
++# CONFIG_OPENVSWITCH is not set
++CONFIG_RPS=y
++CONFIG_RFS_ACCEL=y
++CONFIG_XPS=y
++CONFIG_BQL=y
++CONFIG_HAVE_BPF_JIT=y
++# CONFIG_BPF_JIT is not set
++
++#
++# Network testing
++#
++# CONFIG_NET_PKTGEN is not set
++# CONFIG_HAMRADIO is not set
++# CONFIG_CAN is not set
++# CONFIG_IRDA is not set
++# CONFIG_BT is not set
++# CONFIG_AF_RXRPC is not set
++CONFIG_WIRELESS=y
++# CONFIG_CFG80211 is not set
++# CONFIG_LIB80211 is not set
++
++#
++# CFG80211 needs to be enabled for MAC80211
++#
++# CONFIG_WIMAX is not set
++# CONFIG_RFKILL is not set
++# CONFIG_NET_9P is not set
++# CONFIG_CAIF is not set
++# CONFIG_CEPH_LIB is not set
++# CONFIG_NFC is not set
++
++#
++# Device Drivers
++#
++
++#
++# Generic Driver Options
++#
++CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
++CONFIG_DEVTMPFS=y
++CONFIG_DEVTMPFS_MOUNT=y
++CONFIG_STANDALONE=y
++CONFIG_PREVENT_FIRMWARE_BUILD=y
++# CONFIG_FW_LOADER is not set
++# CONFIG_DEBUG_DRIVER is not set
++# CONFIG_DEBUG_DEVRES is not set
++# CONFIG_SYS_HYPERVISOR is not set
++# CONFIG_GENERIC_CPU_DEVICES is not set
++# CONFIG_DMA_SHARED_BUFFER is not set
++# CONFIG_CONNECTOR is not set
++CONFIG_MTD=y
++# CONFIG_MTD_TESTS is not set
++# CONFIG_MTD_REDBOOT_PARTS is not set
++# CONFIG_MTD_CMDLINE_PARTS is not set
++# CONFIG_MTD_AFS_PARTS is not set
++# CONFIG_MTD_OF_PARTS is not set
++# CONFIG_MTD_AR7_PARTS is not set
++
++#
++# User Modules And Translation Layers
++#
++CONFIG_MTD_CHAR=y
++# CONFIG_MTD_BLKDEVS is not set
++# CONFIG_MTD_BLOCK is not set
++# CONFIG_MTD_BLOCK_RO is not set
++# CONFIG_FTL is not set
++# CONFIG_NFTL is not set
++# CONFIG_INFTL is not set
++# CONFIG_RFD_FTL is not set
++# CONFIG_SSFDC is not set
++# CONFIG_SM_FTL is not set
++# CONFIG_MTD_OOPS is not set
++# CONFIG_MTD_SWAP is not set
++
++#
++# RAM/ROM/Flash chip drivers
++#
++# CONFIG_MTD_CFI is not set
++# CONFIG_MTD_JEDECPROBE is not set
++CONFIG_MTD_MAP_BANK_WIDTH_1=y
++CONFIG_MTD_MAP_BANK_WIDTH_2=y
++CONFIG_MTD_MAP_BANK_WIDTH_4=y
++# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
++# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
++# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
++CONFIG_MTD_CFI_I1=y
++CONFIG_MTD_CFI_I2=y
++# CONFIG_MTD_CFI_I4 is not set
++# CONFIG_MTD_CFI_I8 is not set
++# CONFIG_MTD_RAM is not set
++# CONFIG_MTD_ROM is not set
++# CONFIG_MTD_ABSENT is not set
++CONFIG_MTD_QSP_FLASH=y
++
++#
++# Mapping drivers for chip access
++#
++# CONFIG_MTD_COMPLEX_MAPPINGS is not set
++CONFIG_MTD_PHYSMAP=y
++CONFIG_MTD_PHYSMAP_COMPAT=y
++CONFIG_MTD_PHYSMAP_START=0x00000000
++CONFIG_MTD_PHYSMAP_LEN=0x10000000
++CONFIG_MTD_PHYSMAP_BANKWIDTH=4
++# CONFIG_MTD_PLATRAM is not set
++
++#
++# Self-contained MTD device drivers
++#
++# CONFIG_MTD_SLRAM is not set
++# CONFIG_MTD_PHRAM is not set
++# CONFIG_MTD_MTDRAM is not set
++# CONFIG_MTD_BLOCK2MTD is not set
++
++#
++# Disk-On-Chip Device Drivers
++#
++# CONFIG_MTD_DOCG3 is not set
++# CONFIG_MTD_NAND is not set
++# CONFIG_MTD_ONENAND is not set
++
++#
++# LPDDR flash memory drivers
++#
++# CONFIG_MTD_LPDDR is not set
++CONFIG_MTD_UBI=m
++CONFIG_MTD_UBI_WL_THRESHOLD=4096
++CONFIG_MTD_UBI_BEB_RESERVE=1
++# CONFIG_MTD_UBI_GLUEBI is not set
++# CONFIG_MTD_UBI_DEBUG is not set
++CONFIG_DTC=y
++CONFIG_OF=y
++
++#
++# Device Tree and Open Firmware support
++#
++CONFIG_PROC_DEVICETREE=y
++# CONFIG_OF_SELFTEST is not set
++CONFIG_OF_FLATTREE=y
++CONFIG_OF_EARLY_FLATTREE=y
++CONFIG_OF_ADDRESS=y
++CONFIG_OF_IRQ=y
++CONFIG_OF_DEVICE=y
++CONFIG_OF_NET=y
++CONFIG_OF_MDIO=y
++CONFIG_OF_MTD=y
++# CONFIG_PARPORT is not set
++CONFIG_BLK_DEV=y
++# CONFIG_BLK_DEV_COW_COMMON is not set
++CONFIG_BLK_DEV_LOOP=y
++CONFIG_BLK_DEV_LOOP_MIN_COUNT=8
++# CONFIG_BLK_DEV_CRYPTOLOOP is not set
++
++#
++# DRBD disabled because PROC_FS, INET or CONNECTOR not selected
++#
++# CONFIG_BLK_DEV_NBD is not set
++CONFIG_BLK_DEV_RAM=y
++CONFIG_BLK_DEV_RAM_COUNT=16
++CONFIG_BLK_DEV_RAM_SIZE=131072
++# CONFIG_BLK_DEV_XIP is not set
++# CONFIG_CDROM_PKTCDVD is not set
++# CONFIG_ATA_OVER_ETH is not set
++# CONFIG_BLK_DEV_RBD is not set
++CONFIG_BLK_DEV_QSP=y
++
++#
++# Misc devices
++#
++# CONFIG_SENSORS_LIS3LV02D is not set
++# CONFIG_ENCLOSURE_SERVICES is not set
++# CONFIG_C2PORT is not set
++
++#
++# EEPROM support
++#
++# CONFIG_EEPROM_93CX6 is not set
++
++#
++# Texas Instruments shared transport line discipline
++#
++
++#
++# Altera FPGA firmware download module
++#
++
++#
++# SCSI device support
++#
++CONFIG_SCSI_MOD=y
++# CONFIG_RAID_ATTRS is not set
++CONFIG_SCSI=y
++CONFIG_SCSI_DMA=y
++# CONFIG_SCSI_TGT is not set
++# CONFIG_SCSI_NETLINK is not set
++CONFIG_SCSI_PROC_FS=y
++
++#
++# SCSI support type (disk, tape, CD-ROM)
++#
++CONFIG_BLK_DEV_SD=y
++# CONFIG_CHR_DEV_ST is not set
++# CONFIG_CHR_DEV_OSST is not set
++# CONFIG_BLK_DEV_SR is not set
++# CONFIG_CHR_DEV_SG is not set
++# CONFIG_CHR_DEV_SCH is not set
++# CONFIG_SCSI_MULTI_LUN is not set
++# CONFIG_SCSI_CONSTANTS is not set
++# CONFIG_SCSI_LOGGING is not set
++# CONFIG_SCSI_SCAN_ASYNC is not set
++CONFIG_SCSI_WAIT_SCAN=m
++
++#
++# SCSI Transports
++#
++# CONFIG_SCSI_SPI_ATTRS is not set
++# CONFIG_SCSI_FC_ATTRS is not set
++# CONFIG_SCSI_ISCSI_ATTRS is not set
++# CONFIG_SCSI_SAS_ATTRS is not set
++# CONFIG_SCSI_SAS_LIBSAS is not set
++# CONFIG_SCSI_SRP_ATTRS is not set
++CONFIG_SCSI_LOWLEVEL=y
++# CONFIG_ISCSI_TCP is not set
++# CONFIG_ISCSI_BOOT_SYSFS is not set
++# CONFIG_LIBFC is not set
++# CONFIG_LIBFCOE is not set
++# CONFIG_SCSI_DEBUG is not set
++# CONFIG_SCSI_DH is not set
++# CONFIG_SCSI_OSD_INITIATOR is not set
++# CONFIG_ATA is not set
++# CONFIG_MD is not set
++# CONFIG_TARGET_CORE is not set
++CONFIG_NETDEVICES=y
++CONFIG_NET_CORE=y
++# CONFIG_BONDING is not set
++# CONFIG_DUMMY is not set
++# CONFIG_EQUALIZER is not set
++# CONFIG_MII is not set
++# CONFIG_NET_TEAM is not set
++# CONFIG_MACVLAN is not set
++# CONFIG_NETCONSOLE is not set
++# CONFIG_NETPOLL is not set
++# CONFIG_NET_POLL_CONTROLLER is not set
++# CONFIG_TUN is not set
++# CONFIG_VETH is not set
++
++#
++# CAIF transport drivers
++#
++CONFIG_ETHERNET=y
++# CONFIG_NET_VENDOR_BROADCOM is not set
++# CONFIG_NET_CALXEDA_XGMAC is not set
++# CONFIG_NET_VENDOR_CHELSIO is not set
++# CONFIG_NET_VENDOR_CIRRUS is not set
++# CONFIG_DM9000 is not set
++# CONFIG_DNET is not set
++# CONFIG_NET_VENDOR_FARADAY is not set
++# CONFIG_NET_VENDOR_INTEL is not set
++# CONFIG_NET_VENDOR_MARVELL is not set
++# CONFIG_NET_VENDOR_MICREL is not set
++# CONFIG_NET_VENDOR_NATSEMI is not set
++# CONFIG_ETHOC is not set
++# CONFIG_NET_VENDOR_SEEQ is not set
++# CONFIG_NET_VENDOR_SMSC is not set
++# CONFIG_NET_VENDOR_STMICRO is not set
++CONFIG_NET_QSP=y
++CONFIG_PHYLIB=y
++
++#
++# MII PHY device drivers
++#
++# CONFIG_AMD_PHY is not set
++# CONFIG_MARVELL_PHY is not set
++# CONFIG_DAVICOM_PHY is not set
++# CONFIG_QSEMI_PHY is not set
++# CONFIG_LXT_PHY is not set
++# CONFIG_CICADA_PHY is not set
++# CONFIG_VITESSE_PHY is not set
++# CONFIG_SMSC_PHY is not set
++# CONFIG_BROADCOM_PHY is not set
++# CONFIG_ICPLUS_PHY is not set
++# CONFIG_REALTEK_PHY is not set
++# CONFIG_NATIONAL_PHY is not set
++# CONFIG_STE10XP is not set
++# CONFIG_LSI_ET1011C_PHY is not set
++# CONFIG_MICREL_PHY is not set
++# CONFIG_FIXED_PHY is not set
++# CONFIG_MDIO_BITBANG is not set
++# CONFIG_PPP is not set
++# CONFIG_SLIP is not set
++# CONFIG_WLAN is not set
++
++#
++# Enable WiMAX (Networking options) to see the WiMAX drivers
++#
++# CONFIG_WAN is not set
++# CONFIG_ISDN is not set
++
++#
++# Input device support
++#
++CONFIG_INPUT=y
++# CONFIG_INPUT_FF_MEMLESS is not set
++# CONFIG_INPUT_POLLDEV is not set
++# CONFIG_INPUT_SPARSEKMAP is not set
++
++#
++# Userland interfaces
++#
++# CONFIG_INPUT_MOUSEDEV is not set
++# CONFIG_INPUT_JOYDEV is not set
++# CONFIG_INPUT_EVDEV is not set
++# CONFIG_INPUT_EVBUG is not set
++
++#
++# Input Device Drivers
++#
++# CONFIG_INPUT_KEYBOARD is not set
++# CONFIG_INPUT_MOUSE is not set
++# CONFIG_INPUT_JOYSTICK is not set
++# CONFIG_INPUT_TABLET is not set
++# CONFIG_INPUT_TOUCHSCREEN is not set
++# CONFIG_INPUT_MISC is not set
++
++#
++# Hardware I/O ports
++#
++# CONFIG_SERIO is not set
++# CONFIG_GAMEPORT is not set
++
++#
++# Character devices
++#
++# CONFIG_VT is not set
++CONFIG_UNIX98_PTYS=y
++# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
++CONFIG_LEGACY_PTYS=y
++CONFIG_LEGACY_PTY_COUNT=256
++# CONFIG_SERIAL_NONSTANDARD is not set
++# CONFIG_N_GSM is not set
++# CONFIG_TRACE_SINK is not set
++CONFIG_DEVKMEM=y
++
++#
++# Serial drivers
++#
++# CONFIG_SERIAL_8250 is not set
++
++#
++# Non-8250 serial port support
++#
++CONFIG_SERIAL_CORE=y
++CONFIG_SERIAL_CORE_CONSOLE=y
++# CONFIG_SERIAL_TIMBERDALE is not set
++# CONFIG_SERIAL_ALTERA_JTAGUART is not set
++# CONFIG_SERIAL_ALTERA_UART is not set
++# CONFIG_SERIAL_XILINX_PS_UART is not set
++CONFIG_SERIAL_QSP_UART=y
++CONFIG_SERIAL_QSP_MAXPORTS=16
++CONFIG_SERIAL_QSP_CONSOLE=y
++# CONFIG_TTY_PRINTK is not set
++# CONFIG_HVC_DCC is not set
++# CONFIG_IPMI_HANDLER is not set
++# CONFIG_HW_RANDOM is not set
++# CONFIG_R3964 is not set
++# CONFIG_RAW_DRIVER is not set
++# CONFIG_TCG_TPM is not set
++# CONFIG_RAMOOPS is not set
++# CONFIG_I2C is not set
++# CONFIG_SPI is not set
++# CONFIG_HSI is not set
++
++#
++# PPS support
++#
++# CONFIG_PPS is not set
++
++#
++# PPS generators support
++#
++
++#
++# PTP clock support
++#
++
++#
++# Enable Device Drivers -> PPS to see the PTP clock options.
++#
++# CONFIG_W1 is not set
++# CONFIG_POWER_SUPPLY is not set
++# CONFIG_HWMON is not set
++# CONFIG_THERMAL is not set
++# CONFIG_WATCHDOG is not set
++CONFIG_SSB_POSSIBLE=y
++
++#
++# Sonics Silicon Backplane
++#
++# CONFIG_SSB is not set
++CONFIG_BCMA_POSSIBLE=y
++
++#
++# Broadcom specific AMBA
++#
++# CONFIG_BCMA is not set
++
++#
++# Multifunction device drivers
++#
++# CONFIG_MFD_CORE is not set
++# CONFIG_MFD_SM501 is not set
++# CONFIG_HTC_PASIC3 is not set
++# CONFIG_MFD_TMIO is not set
++# CONFIG_ABX500_CORE is not set
++# CONFIG_REGULATOR is not set
++# CONFIG_MEDIA_SUPPORT is not set
++
++#
++# Graphics support
++#
++# CONFIG_DRM is not set
++# CONFIG_VGASTATE is not set
++# CONFIG_VIDEO_OUTPUT_CONTROL is not set
++# CONFIG_FB is not set
++# CONFIG_EXYNOS_VIDEO is not set
++# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
++# CONFIG_SOUND is not set
++# CONFIG_HID_SUPPORT is not set
++# CONFIG_USB_ARCH_HAS_OHCI is not set
++# CONFIG_USB_ARCH_HAS_EHCI is not set
++# CONFIG_USB_ARCH_HAS_XHCI is not set
++# CONFIG_USB_SUPPORT is not set
++# CONFIG_MMC is not set
++# CONFIG_MEMSTICK is not set
++CONFIG_NEW_LEDS=y
++CONFIG_LEDS_CLASS=y
++
++#
++# LED drivers
++#
++# CONFIG_LEDS_OT200 is not set
++CONFIG_LEDS_QSP=y
++CONFIG_LEDS_TRIGGERS=y
++
++#
++# LED Triggers
++#
++CONFIG_LEDS_TRIGGER_TIMER=y
++CONFIG_LEDS_TRIGGER_HEARTBEAT=y
++# CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
++# CONFIG_LEDS_TRIGGER_DEFAULT_ON is not set
++
++#
++# iptables trigger is under Netfilter config (LED target)
++#
++# CONFIG_ACCESSIBILITY is not set
++CONFIG_RTC_LIB=y
++CONFIG_RTC_CLASS=y
++CONFIG_RTC_HCTOSYS=y
++CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
++# CONFIG_RTC_DEBUG is not set
++
++#
++# RTC interfaces
++#
++CONFIG_RTC_INTF_SYSFS=y
++CONFIG_RTC_INTF_PROC=y
++CONFIG_RTC_INTF_DEV=y
++# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
++# CONFIG_RTC_DRV_TEST is not set
++
++#
++# SPI RTC drivers
++#
++
++#
++# Platform RTC drivers
++#
++# CONFIG_RTC_DRV_CMOS is not set
++# CONFIG_RTC_DRV_DS1286 is not set
++# CONFIG_RTC_DRV_DS1511 is not set
++# CONFIG_RTC_DRV_DS1553 is not set
++# CONFIG_RTC_DRV_DS1742 is not set
++# CONFIG_RTC_DRV_STK17TA8 is not set
++# CONFIG_RTC_DRV_M48T86 is not set
++# CONFIG_RTC_DRV_M48T35 is not set
++# CONFIG_RTC_DRV_M48T59 is not set
++# CONFIG_RTC_DRV_MSM6242 is not set
++# CONFIG_RTC_DRV_BQ4802 is not set
++# CONFIG_RTC_DRV_RP5C01 is not set
++# CONFIG_RTC_DRV_V3020 is not set
++
++#
++# on-CPU RTC drivers
++#
++CONFIG_RTC_DRV_QSP=y
++# CONFIG_DMADEVICES is not set
++# CONFIG_AUXDISPLAY is not set
++# CONFIG_UIO is not set
++
++#
++# Virtio drivers
++#
++# CONFIG_VIRTIO_BALLOON is not set
++# CONFIG_VIRTIO_MMIO is not set
++
++#
++# Microsoft Hyper-V guest support
++#
++# CONFIG_STAGING is not set
++
++#
++# Hardware Spinlock drivers
++#
++CONFIG_CLK_QSP=y
++CONFIG_IOMMU_SUPPORT=y
++
++#
++# Remoteproc drivers (EXPERIMENTAL)
++#
++
++#
++# Rpmsg drivers (EXPERIMENTAL)
++#
++# CONFIG_VIRT_DRIVERS is not set
++# CONFIG_PM_DEVFREQ is not set
++CONFIG_PIC_SUPPORT=y
++CONFIG_QSP_PIC=y
++
++#
++# File systems
++#
++CONFIG_EXT2_FS=y
++# CONFIG_EXT2_FS_XATTR is not set
++# CONFIG_EXT2_FS_XIP is not set
++CONFIG_EXT3_FS=y
++CONFIG_EXT3_DEFAULTS_TO_ORDERED=y
++CONFIG_EXT3_FS_XATTR=y
++# CONFIG_EXT3_FS_POSIX_ACL is not set
++# CONFIG_EXT3_FS_SECURITY is not set
++# CONFIG_EXT4_FS is not set
++CONFIG_JBD=y
++CONFIG_FS_MBCACHE=y
++# CONFIG_REISERFS_FS is not set
++# CONFIG_JFS_FS is not set
++# CONFIG_XFS_FS is not set
++# CONFIG_GFS2_FS is not set
++# CONFIG_BTRFS_FS is not set
++# CONFIG_NILFS2_FS is not set
++# CONFIG_FS_POSIX_ACL is not set
++CONFIG_FILE_LOCKING=y
++CONFIG_FSNOTIFY=y
++CONFIG_DNOTIFY=y
++CONFIG_INOTIFY_USER=y
++# CONFIG_FANOTIFY is not set
++# CONFIG_QUOTA is not set
++# CONFIG_QUOTACTL is not set
++# CONFIG_AUTOFS4_FS is not set
++# CONFIG_FUSE_FS is not set
++
++#
++# Caches
++#
++# CONFIG_FSCACHE is not set
++
++#
++# CD-ROM/DVD Filesystems
++#
++# CONFIG_ISO9660_FS is not set
++# CONFIG_UDF_FS is not set
++
++#
++# DOS/FAT/NT Filesystems
++#
++# CONFIG_MSDOS_FS is not set
++# CONFIG_VFAT_FS is not set
++# CONFIG_NTFS_FS is not set
++
++#
++# Pseudo filesystems
++#
++CONFIG_PROC_FS=y
++CONFIG_PROC_SYSCTL=y
++CONFIG_PROC_PAGE_MONITOR=y
++CONFIG_SYSFS=y
++CONFIG_TMPFS=y
++# CONFIG_TMPFS_POSIX_ACL is not set
++# CONFIG_TMPFS_XATTR is not set
++# CONFIG_HUGETLB_PAGE is not set
++# CONFIG_CONFIGFS_FS is not set
++CONFIG_MISC_FILESYSTEMS=y
++# CONFIG_ADFS_FS is not set
++# CONFIG_AFFS_FS is not set
++# CONFIG_HFS_FS is not set
++# CONFIG_HFSPLUS_FS is not set
++# CONFIG_BEFS_FS is not set
++# CONFIG_BFS_FS is not set
++# CONFIG_EFS_FS is not set
++CONFIG_JFFS2_FS=m
++CONFIG_JFFS2_FS_DEBUG=0
++CONFIG_JFFS2_FS_WRITEBUFFER=y
++# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
++# CONFIG_JFFS2_SUMMARY is not set
++# CONFIG_JFFS2_FS_XATTR is not set
++# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
++CONFIG_JFFS2_ZLIB=y
++# CONFIG_JFFS2_LZO is not set
++CONFIG_JFFS2_RTIME=y
++# CONFIG_JFFS2_RUBIN is not set
++CONFIG_UBIFS_FS=m
++# CONFIG_UBIFS_FS_XATTR is not set
++# CONFIG_UBIFS_FS_ADVANCED_COMPR is not set
++CONFIG_UBIFS_FS_LZO=y
++CONFIG_UBIFS_FS_ZLIB=y
++# CONFIG_UBIFS_FS_DEBUG is not set
++# CONFIG_LOGFS is not set
++# CONFIG_CRAMFS is not set
++# CONFIG_SQUASHFS is not set
++# CONFIG_VXFS_FS is not set
++# CONFIG_MINIX_FS is not set
++# CONFIG_OMFS_FS is not set
++# CONFIG_HPFS_FS is not set
++# CONFIG_QNX4FS_FS is not set
++# CONFIG_QNX6FS_FS is not set
++# CONFIG_ROMFS_FS is not set
++# CONFIG_PSTORE is not set
++# CONFIG_SYSV_FS is not set
++# CONFIG_UFS_FS is not set
++CONFIG_SIMICSFS=y
++CONFIG_SIMICSFS_ADDRESS="0xe0200000"
++CONFIG_NETWORK_FILESYSTEMS=y
++CONFIG_NFS_FS=y
++# CONFIG_NFS_V3 is not set
++# CONFIG_NFS_V4 is not set
++CONFIG_ROOT_NFS=y
++# CONFIG_NFSD is not set
++CONFIG_LOCKD=y
++CONFIG_NFS_COMMON=y
++CONFIG_SUNRPC=y
++# CONFIG_SUNRPC_DEBUG is not set
++# CONFIG_CEPH_FS is not set
++# CONFIG_CIFS is not set
++# CONFIG_NCP_FS is not set
++# CONFIG_CODA_FS is not set
++# CONFIG_AFS_FS is not set
++# CONFIG_NLS is not set
++
++#
++# Kernel hacking
++#
++# CONFIG_PRINTK_TIME is not set
++CONFIG_DEFAULT_MESSAGE_LOGLEVEL=4
++CONFIG_ENABLE_WARN_DEPRECATED=y
++CONFIG_ENABLE_MUST_CHECK=y
++CONFIG_FRAME_WARN=1024
++CONFIG_MAGIC_SYSRQ=y
++# CONFIG_STRIP_ASM_SYMS is not set
++# CONFIG_UNUSED_SYMBOLS is not set
++# CONFIG_DEBUG_FS is not set
++# CONFIG_HEADERS_CHECK is not set
++# CONFIG_DEBUG_SECTION_MISMATCH is not set
++CONFIG_DEBUG_KERNEL=y
++# CONFIG_DEBUG_SHIRQ is not set
++# CONFIG_LOCKUP_DETECTOR is not set
++# CONFIG_HARDLOCKUP_DETECTOR is not set
++# CONFIG_DETECT_HUNG_TASK is not set
++# CONFIG_SCHED_DEBUG is not set
++# CONFIG_SCHEDSTATS is not set
++# CONFIG_TIMER_STATS is not set
++# CONFIG_DEBUG_OBJECTS is not set
++# CONFIG_SLUB_DEBUG_ON is not set
++# CONFIG_SLUB_STATS is not set
++# CONFIG_DEBUG_KMEMLEAK is not set
++# CONFIG_DEBUG_RT_MUTEXES is not set
++# CONFIG_RT_MUTEX_TESTER is not set
++# CONFIG_DEBUG_SPINLOCK is not set
++# CONFIG_DEBUG_MUTEXES is not set
++# CONFIG_DEBUG_LOCK_ALLOC is not set
++# CONFIG_PROVE_LOCKING is not set
++# CONFIG_SPARSE_RCU_POINTER is not set
++# CONFIG_LOCK_STAT is not set
++# CONFIG_DEBUG_ATOMIC_SLEEP is not set
++# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
++# CONFIG_DEBUG_STACK_USAGE is not set
++# CONFIG_DEBUG_KOBJECT is not set
++# CONFIG_DEBUG_HIGHMEM is not set
++CONFIG_DEBUG_BUGVERBOSE=y
++CONFIG_DEBUG_INFO=y
++# CONFIG_DEBUG_INFO_REDUCED is not set
++# CONFIG_DEBUG_VM is not set
++# CONFIG_DEBUG_WRITECOUNT is not set
++# CONFIG_DEBUG_MEMORY_INIT is not set
++# CONFIG_DEBUG_LIST is not set
++# CONFIG_TEST_LIST_SORT is not set
++# CONFIG_DEBUG_SG is not set
++# CONFIG_DEBUG_NOTIFIERS is not set
++# CONFIG_DEBUG_CREDENTIALS is not set
++# CONFIG_BOOT_PRINTK_DELAY is not set
++# CONFIG_RCU_TORTURE_TEST is not set
++CONFIG_RCU_CPU_STALL_TIMEOUT=60
++# CONFIG_RCU_CPU_STALL_INFO is not set
++# CONFIG_RCU_TRACE is not set
++# CONFIG_BACKTRACE_SELF_TEST is not set
++# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
++# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
++# CONFIG_DEBUG_PER_CPU_MAPS is not set
++# CONFIG_FAULT_INJECTION is not set
++# CONFIG_DEBUG_PAGEALLOC is not set
++CONFIG_HAVE_FUNCTION_TRACER=y
++CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
++CONFIG_HAVE_DYNAMIC_FTRACE=y
++CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
++CONFIG_HAVE_C_RECORDMCOUNT=y
++CONFIG_TRACING_SUPPORT=y
++CONFIG_FTRACE=y
++# CONFIG_FUNCTION_TRACER is not set
++# CONFIG_IRQSOFF_TRACER is not set
++# CONFIG_SCHED_TRACER is not set
++# CONFIG_ENABLE_DEFAULT_TRACERS is not set
++CONFIG_BRANCH_PROFILE_NONE=y
++# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
++# CONFIG_PROFILE_ALL_BRANCHES is not set
++# CONFIG_STACK_TRACER is not set
++# CONFIG_BLK_DEV_IO_TRACE is not set
++# CONFIG_DMA_API_DEBUG is not set
++# CONFIG_ATOMIC64_SELFTEST is not set
++# CONFIG_SAMPLES is not set
++CONFIG_HAVE_ARCH_KGDB=y
++# CONFIG_KGDB is not set
++# CONFIG_TEST_KSTRTOX is not set
++# CONFIG_STRICT_DEVMEM is not set
++CONFIG_ARM_UNWIND=y
++# CONFIG_DEBUG_USER is not set
++# CONFIG_DEBUG_LL is not set
++
++#
++# Security options
++#
++# CONFIG_KEYS is not set
++# CONFIG_SECURITY_DMESG_RESTRICT is not set
++# CONFIG_SECURITY is not set
++# CONFIG_SECURITYFS is not set
++CONFIG_DEFAULT_SECURITY_DAC=y
++CONFIG_DEFAULT_SECURITY=""
++CONFIG_CRYPTO=y
++
++#
++# Crypto core or helper
++#
++# CONFIG_CRYPTO_FIPS is not set
++CONFIG_CRYPTO_ALGAPI=m
++CONFIG_CRYPTO_ALGAPI2=m
++CONFIG_CRYPTO_RNG=m
++CONFIG_CRYPTO_RNG2=m
++# CONFIG_CRYPTO_MANAGER is not set
++# CONFIG_CRYPTO_MANAGER2 is not set
++# CONFIG_CRYPTO_USER is not set
++# CONFIG_CRYPTO_GF128MUL is not set
++# CONFIG_CRYPTO_NULL is not set
++# CONFIG_CRYPTO_PCRYPT is not set
++# CONFIG_CRYPTO_CRYPTD is not set
++# CONFIG_CRYPTO_AUTHENC is not set
++# CONFIG_CRYPTO_TEST is not set
++
++#
++# Authenticated Encryption with Associated Data
++#
++# CONFIG_CRYPTO_CCM is not set
++# CONFIG_CRYPTO_GCM is not set
++# CONFIG_CRYPTO_SEQIV is not set
++
++#
++# Block modes
++#
++# CONFIG_CRYPTO_CBC is not set
++# CONFIG_CRYPTO_CTR is not set
++# CONFIG_CRYPTO_CTS is not set
++# CONFIG_CRYPTO_ECB is not set
++# CONFIG_CRYPTO_LRW is not set
++# CONFIG_CRYPTO_PCBC is not set
++# CONFIG_CRYPTO_XTS is not set
++
++#
++# Hash modes
++#
++# CONFIG_CRYPTO_HMAC is not set
++# CONFIG_CRYPTO_XCBC is not set
++# CONFIG_CRYPTO_VMAC is not set
++
++#
++# Digest
++#
++# CONFIG_CRYPTO_CRC32C is not set
++# CONFIG_CRYPTO_GHASH is not set
++# CONFIG_CRYPTO_MD4 is not set
++# CONFIG_CRYPTO_MD5 is not set
++# CONFIG_CRYPTO_MICHAEL_MIC is not set
++# CONFIG_CRYPTO_RMD128 is not set
++# CONFIG_CRYPTO_RMD160 is not set
++# CONFIG_CRYPTO_RMD256 is not set
++# CONFIG_CRYPTO_RMD320 is not set
++# CONFIG_CRYPTO_SHA1 is not set
++# CONFIG_CRYPTO_SHA256 is not set
++# CONFIG_CRYPTO_SHA512 is not set
++# CONFIG_CRYPTO_TGR192 is not set
++# CONFIG_CRYPTO_WP512 is not set
++
++#
++# Ciphers
++#
++CONFIG_CRYPTO_AES=m
++# CONFIG_CRYPTO_ANUBIS is not set
++# CONFIG_CRYPTO_ARC4 is not set
++# CONFIG_CRYPTO_BLOWFISH is not set
++# CONFIG_CRYPTO_CAMELLIA is not set
++# CONFIG_CRYPTO_CAST5 is not set
++# CONFIG_CRYPTO_CAST6 is not set
++# CONFIG_CRYPTO_DES is not set
++# CONFIG_CRYPTO_FCRYPT is not set
++# CONFIG_CRYPTO_KHAZAD is not set
++# CONFIG_CRYPTO_SALSA20 is not set
++# CONFIG_CRYPTO_SEED is not set
++# CONFIG_CRYPTO_SERPENT is not set
++# CONFIG_CRYPTO_TEA is not set
++# CONFIG_CRYPTO_TWOFISH is not set
++
++#
++# Compression
++#
++CONFIG_CRYPTO_DEFLATE=m
++# CONFIG_CRYPTO_ZLIB is not set
++CONFIG_CRYPTO_LZO=m
++
++#
++# Random Number Generation
++#
++CONFIG_CRYPTO_ANSI_CPRNG=m
++# CONFIG_CRYPTO_USER_API_HASH is not set
++# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
++CONFIG_CRYPTO_HW=y
++# CONFIG_BINARY_PRINTF is not set
++
++#
++# Library routines
++#
++CONFIG_BITREVERSE=y
++CONFIG_GENERIC_PCI_IOMAP=y
++CONFIG_GENERIC_IO=y
++# CONFIG_CRC_CCITT is not set
++CONFIG_CRC16=m
++# CONFIG_CRC_T10DIF is not set
++# CONFIG_CRC_ITU_T is not set
++CONFIG_CRC32=y
++# CONFIG_CRC32_SELFTEST is not set
++CONFIG_CRC32_SLICEBY8=y
++# CONFIG_CRC32_SLICEBY4 is not set
++# CONFIG_CRC32_SARWATE is not set
++# CONFIG_CRC32_BIT is not set
++# CONFIG_CRC7 is not set
++# CONFIG_LIBCRC32C is not set
++# CONFIG_CRC8 is not set
++CONFIG_ZLIB_INFLATE=y
++CONFIG_ZLIB_DEFLATE=m
++CONFIG_LZO_COMPRESS=m
++CONFIG_LZO_DECOMPRESS=m
++# CONFIG_XZ_DEC is not set
++# CONFIG_XZ_DEC_BCJ is not set
++CONFIG_DECOMPRESS_GZIP=y
++CONFIG_HAS_IOMEM=y
++CONFIG_HAS_IOPORT=y
++CONFIG_HAS_DMA=y
++CONFIG_CPU_RMAP=y
++CONFIG_DQL=y
++CONFIG_NLATTR=y
++# CONFIG_AVERAGE is not set
++# CONFIG_CORDIC is not set
+diff --git a/arch/arm/mach-qsp/Kconfig b/arch/arm/mach-qsp/Kconfig
+new file mode 100644
+index 0000000..7a0c346
+--- /dev/null
++++ b/arch/arm/mach-qsp/Kconfig
+@@ -0,0 +1,17 @@
++config MACH_QSP
++	bool "Support Simics QSP platforms from device tree"
++	select ARM_QSP
++	select USE_OF
++	select HAVE_SMP
++	help
++	  Include support for Simics QSP based platforms
++	  using the device tree for discovery.
++
++config ARM_QSP
++	bool "Simics QSP for ARM"
++	default n
++	select QSP
++	select QSP_PIC
++	select CLK_QSP
++	help
++	  This option enables support for the QSP simics platform for arm.
+diff --git a/arch/arm/mach-qsp/Makefile b/arch/arm/mach-qsp/Makefile
+new file mode 100644
+index 0000000..4710e89
+--- /dev/null
++++ b/arch/arm/mach-qsp/Makefile
+@@ -0,0 +1,2 @@
++obj-y:=setup.o
++obj-$(CONFIG_SMP)			+= platsmp.o
+diff --git a/arch/arm/mach-qsp/Makefile.boot b/arch/arm/mach-qsp/Makefile.boot
+new file mode 100644
+index 0000000..917a00d
+--- /dev/null
++++ b/arch/arm/mach-qsp/Makefile.boot
+@@ -0,0 +1,3 @@
++zreladdr-$(CONFIG_ARM_QSP)	+= 0x10008000
++params_phys-$(CONFIG_ARM_QSP)	:= 0x10000100
++initrd_phys-$(CONFIG_ARM_QSP)	:= 0x10800000
+diff --git a/arch/arm/mach-qsp/include/mach/entry-macro.S b/arch/arm/mach-qsp/include/mach/entry-macro.S
+new file mode 100644
+index 0000000..18f7f43e
+--- /dev/null
++++ b/arch/arm/mach-qsp/include/mach/entry-macro.S
+@@ -0,0 +1,16 @@
++
++#ifndef HAVE_GET_IRQNR_PREAMBLE
++	.macro	get_irqnr_preamble, base, tmp
++	.endm
++#endif
++	.macro  get_irqnr_and_base, irqnr, irqstat, base, tmp
++	.endm
++
++	.macro test_for_ipi, irqnr, irqstat, base, tmp
++	.endm
++
++	.macro	disable_fiq
++	.endm
++
++	.macro	arch_ret_to_user, tmp1, tmp2
++	.endm
+diff --git a/arch/arm/mach-qsp/include/mach/io.h b/arch/arm/mach-qsp/include/mach/io.h
+new file mode 100644
+index 0000000..13522d8
+--- /dev/null
++++ b/arch/arm/mach-qsp/include/mach/io.h
+@@ -0,0 +1,26 @@
++/*
++ *  arch/arm/mach-vexpress/include/mach/io.h
++ *
++ *  Copyright (C) 2003 ARM Limited
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
++ */
++#ifndef __ASM_ARM_ARCH_IO_H
++#define __ASM_ARM_ARCH_IO_H
++
++#define __io(a)		__typesafe_io(a)
++#define __mem_pci(a)	(a)
++
++#endif
+diff --git a/arch/arm/mach-qsp/include/mach/irqs.h b/arch/arm/mach-qsp/include/mach/irqs.h
+new file mode 100644
+index 0000000..f285fad
+--- /dev/null
++++ b/arch/arm/mach-qsp/include/mach/irqs.h
+@@ -0,0 +1,4 @@
++#ifndef __ARM_QSP_IRQ_H
++#define __ARM_QSP_IRQ_H
++#define NR_IRQS	1024
++#endif
+diff --git a/arch/arm/mach-qsp/include/mach/system.h b/arch/arm/mach-qsp/include/mach/system.h
+new file mode 100644
+index 0000000..899a4e6
+--- /dev/null
++++ b/arch/arm/mach-qsp/include/mach/system.h
+@@ -0,0 +1,37 @@
++/*
++ *  arch/arm/mach-vexpress/include/mach/system.h
++ *
++ *  Copyright (C) 2003 ARM Limited
++ *  Copyright (C) 2000 Deep Blue Solutions Ltd
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
++ */
++#ifndef __ASM_ARCH_SYSTEM_H
++#define __ASM_ARCH_SYSTEM_H
++
++static inline void arch_idle(void)
++{
++	/*
++	 * This should do all the clock switching
++	 * and wait for interrupt tricks
++	 */
++	cpu_do_idle();
++}
++
++static inline void arch_reset(char mode, const char *cmd)
++{
++}
++
++#endif
+diff --git a/arch/arm/mach-qsp/include/mach/timex.h b/arch/arm/mach-qsp/include/mach/timex.h
+new file mode 100644
+index 0000000..08e8e41
+--- /dev/null
++++ b/arch/arm/mach-qsp/include/mach/timex.h
+@@ -0,0 +1,22 @@
++/*
++ *  arch/arm/mach-qsp/include/mach/timex.h
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
++ */
++
++/* Bogus value since we're using clocksource */
++#define CLOCK_TICK_RATE		(1000000)
++
++
+diff --git a/arch/arm/mach-qsp/include/mach/uncompress.h b/arch/arm/mach-qsp/include/mach/uncompress.h
+new file mode 100644
+index 0000000..8768b77
+--- /dev/null
++++ b/arch/arm/mach-qsp/include/mach/uncompress.h
+@@ -0,0 +1,53 @@
++/*
++ *  arch/arm/mach-qsp/include/mach/uncompress.h
++ *
++ *  Copyright (C) 2012 Wind River
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
++ */
++/* Status register bits
++ */
++#define TX_READY (1<<0)
++#define RX_READY (1<<1)
++
++/* Control register bits
++ */
++#define TX_INT (1<<0)
++#define RX_INT (1<<1)
++
++/* Register defines
++ */
++#define ID_REG      0x00
++#define STATUS_REG  0x04
++#define CONTROL_REG 0x08
++#define TXDATA_REG  0x0c
++#define RXDATA_REG  0x10
++
++#define QSP_SERIAL_BASE 0xe0010000
++
++/*
++ * This does not append a newline
++ */
++static inline void putc(int c)
++{
++	*(volatile unsigned long *)(QSP_SERIAL_BASE + TXDATA_REG) = c;
++}
++
++/*
++ * nothing to do
++ */
++#define arch_decomp_setup()
++#define arch_decomp_wdog()
++#define flush()
+diff --git a/arch/arm/mach-qsp/include/mach/vmalloc.h b/arch/arm/mach-qsp/include/mach/vmalloc.h
+new file mode 100644
+index 0000000..f43a36e
+--- /dev/null
++++ b/arch/arm/mach-qsp/include/mach/vmalloc.h
+@@ -0,0 +1,21 @@
++/*
++ *  arch/arm/mach-vexpress/include/mach/vmalloc.h
++ *
++ *  Copyright (C) 2003 ARM Limited
++ *  Copyright (C) 2000 Russell King.
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
++ */
++#define VMALLOC_END		0xf8000000UL
+diff --git a/arch/arm/mach-qsp/platsmp.c b/arch/arm/mach-qsp/platsmp.c
+new file mode 100644
+index 0000000..928a56c
+--- /dev/null
++++ b/arch/arm/mach-qsp/platsmp.c
+@@ -0,0 +1,161 @@
++/*
++ *  linux/arch/arm/mach-qsp/platsmp.c
++ *
++ *  Copyright (C) 2012 Wind River
++ *  All Rights Reserved
++ *  Author: Ivar Holmqvist <ivar.holmqvist@windriver.com>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ */
++
++#include <linux/init.h>
++#include <linux/errno.h>
++#include <linux/smp.h>
++#include <linux/io.h>
++#include <linux/of_fdt.h>
++#include <linux/of_address.h>
++#include <linux/spinlock.h>
++#include <linux/delay.h>
++#include <linux/jiffies.h>
++
++#include <linux/qsp/qsp_pic.h>
++
++/* TODO: The pen_release and boot_lock stuff are stolen from vexpress and
++ *       is really overkill on QSP and should be removed.
++ */
++
++#define ID_REG	       0x00
++#define ENABLE_REG     0x04
++#define DISABLE_REG    0x08
++#define BOOT_PC_REG    0x0c
++#define CPU_STATUS_REG 0x14
++#define PROBE_REG      0x18
++
++static void __iomem *sysregs_base;
++
++/*
++ * control for which core is the next to come out of the secondary
++ * boot "holding pen"
++ */
++volatile int __cpuinitdata pen_release = -1;
++
++/*
++ * Write pen_release in a way that is guaranteed to be visible to all
++ * observers, irrespective of whether they're taking part in coherency
++ * or not.  This is necessary for the hotplug code to work reliably.
++ */
++static void __cpuinit write_pen_release(int val)
++{
++	pen_release = val;
++}
++
++static DEFINE_SPINLOCK(boot_lock);
++
++
++/* FIXME: probe max cores from sysregs... */
++#define QSP_MAX_CORES 128
++
++static void generate_ipi(const struct cpumask *mask, unsigned int irq)
++{
++	int cpu;
++	BUG_ON(irq > 5);
++	for_each_cpu(cpu, mask) {
++		/* FIXME: should we do cpu_logical_map(cpu) here
++		 */
++		qsp_pic_message_pass(cpu, irq);
++	}
++}
++
++/*
++ * Initialise the CPU possible map early - this describes the CPUs
++ * which may be present or become present in the system.
++ */
++void __init smp_init_cpus(void)
++{
++	int hw_cpu;
++	struct device_node *np;
++
++	np = of_find_node_by_type(NULL, "sysregs");
++	BUG_ON(np == NULL);
++
++	sysregs_base = of_iomap(np, 0);
++	BUG_ON(sysregs_base == 0);
++
++	for (hw_cpu = 0; hw_cpu < QSP_MAX_CORES; ++hw_cpu) {
++		writel(hw_cpu, sysregs_base + PROBE_REG);
++		if (readl(sysregs_base + CPU_STATUS_REG) == 1)
++			set_cpu_possible(hw_cpu, true);
++	}
++
++	set_smp_cross_call(generate_ipi);
++
++}
++
++void __init platform_smp_prepare_cpus(unsigned int max_cpus)
++{
++	smp_qsp_pic_probe();
++}
++
++extern void secondary_startup(void);
++
++int __cpuinit boot_secondary(unsigned int cpu, struct task_struct *idle)
++{
++	int i;
++	/*
++	 * Set synchronisation state between this boot processor
++	 * and the secondary one
++	 */
++	spin_lock(&boot_lock);
++
++	/*
++	 * This is really belt and braces; we hold unintended secondary
++	 * CPUs in the holding pen until we're ready for them.  However,
++	 * since we haven't sent them a soft interrupt, they shouldn't
++	 * be there.
++	 */
++	write_pen_release(cpu);
++
++	/*
++	 * Send the secondary CPU a soft interrupt, thereby causing
++	 * the boot monitor to read the system wide flags register,
++	 * and branch to the address found there.
++	 */
++	writel(__pa(secondary_startup), sysregs_base + BOOT_PC_REG);
++	writel(cpu, sysregs_base + ENABLE_REG);
++	if (readl(sysregs_base + CPU_STATUS_REG) != 1)
++		return -ENOSYS;
++
++	for (i = 0; i < 10000; i++) {
++		if (pen_release == -1)
++			break;
++		udelay(100);
++	}
++
++	/*
++	 * now the secondary core is starting up let it run its
++	 * calibrations, then wait for it to finish
++	 */
++	spin_unlock(&boot_lock);
++	return pen_release != -1 ? -ENOSYS : 0;
++}
++
++
++void __cpuinit platform_secondary_init(unsigned int cpu)
++
++{
++	/*
++	 * let the primary processor know we're out of the
++	 * pen, then head off into the C entry point
++	 */
++	BUG_ON(pen_release != cpu);
++	write_pen_release(-1);
++
++	/*
++	 * Synchronise with the boot thread.
++	 */
++	spin_lock(&boot_lock);
++	spin_unlock(&boot_lock);
++}
++
+diff --git a/arch/arm/mach-qsp/setup.c b/arch/arm/mach-qsp/setup.c
+new file mode 100644
+index 0000000..9253a71
+--- /dev/null
++++ b/arch/arm/mach-qsp/setup.c
+@@ -0,0 +1,91 @@
++#include <linux/init.h>
++#include <linux/irq.h>
++#include <linux/irqdomain.h>
++#include <linux/of.h>
++#include <linux/of_irq.h>
++#include <linux/of_address.h>
++#include <linux/of_platform.h>
++#include <asm/mach/arch.h>
++#include <asm/mach/time.h>
++#include <asm/mach/map.h>
++#include <linux/qsp/qsp_pic.h>
++#include <linux/qsp/qsp_clk.h>
++
++static struct map_desc sysreg_io_desc[] __initdata = {
++	{
++		.virtual	= 0xf8000000,
++		.pfn		= __phys_to_pfn(0xe0000000),
++		.length		= SZ_128K,
++		.type		= MT_DEVICE,
++	},
++};
++
++void qsp_init_machine(void)
++{
++	of_platform_populate(NULL, of_default_bus_match_table, NULL, NULL);
++}
++
++static void __init qsp_map_io(void)
++{
++#ifdef CONFIG_SMP
++	/* platsmp.c - smp_init_cpus() needs to access sysreg early... */
++	iotable_init(sysreg_io_desc, ARRAY_SIZE(sysreg_io_desc));
++	pr_debug(KERN_INFO "qsp_map_io called\n");
++#endif
++}
++
++asmlinkage void qsp_pic_handle_irq(struct pt_regs *regs)
++{
++	int irq;
++	irq = qsp_pic_get_irq();
++	BUG_ON(irq == NO_IRQ);
++#if CONFIG_SMP
++	if (irq > IPI_BASE) {
++		qsp_ipi_eoi(irq);
++		handle_IPI(IPI_GET_MSG(irq), regs);
++		return;
++	}
++#endif
++	handle_IRQ(irq, regs);
++}
++
++static void qsp_timer_init(void)
++{
++
++	int irq;
++	struct device_node *np;
++	void __iomem *timer_base;
++
++	pr_info(KERN_INFO "qsp timer init\n");
++
++	np = of_find_compatible_node(NULL, NULL, "qsp,timer");
++	WARN_ON(np == NULL);
++
++	timer_base = of_iomap(np, 0);
++	WARN_ON(!timer_base);
++	pr_debug("Timer base %p\n", timer_base);
++
++	irq = irq_of_parse_and_map(np, 0);
++	WARN_ON(irq == 0);
++
++	qsp_timer_init_one(irq, timer_base);
++}
++
++static struct sys_timer qsp_timer = {
++	.init = qsp_timer_init,
++};
++
++static const char *qsp_dt_compat[] __initdata = {
++	"simics,qsp-arm",
++	NULL,
++};
++
++
++DT_MACHINE_START(QSP, "Simics QSP (Device Tree)")
++	.map_io		= qsp_map_io,
++	.init_irq	= qsp_pic_init,
++	.handle_irq	= qsp_pic_handle_irq,
++	.timer		= &qsp_timer,
++	.init_machine	= qsp_init_machine,
++	.dt_compat	= qsp_dt_compat,
++MACHINE_END
+-- 
+1.7.9.5
+
diff -pNur buildroot.2014.08/board/windriver/qsp-ppc/linux-0010-qsp-Add-a-common-qsp-config-that-can-be-used-indenpe.patch buildroot/board/windriver/qsp-ppc/linux-0010-qsp-Add-a-common-qsp-config-that-can-be-used-indenpe.patch
--- buildroot.2014.08/board/windriver/qsp-ppc/linux-0010-qsp-Add-a-common-qsp-config-that-can-be-used-indenpe.patch	1970-01-01 07:00:00.000000000 +0700
+++ buildroot/board/windriver/qsp-ppc/linux-0010-qsp-Add-a-common-qsp-config-that-can-be-used-indenpe.patch	2014-12-09 13:19:53.705729700 +0800
@@ -0,0 +1,27 @@
+From 482060fd9dd03b885b3274cc3819b12d91fcda22 Mon Sep 17 00:00:00 2001
+From: Ivar Holmqvist <ivarholmqvist@gmail.com>
+Date: Mon, 16 Jul 2012 17:46:27 +0200
+Subject: [PATCH] qsp: Add a common qsp config that can be used indenpendant
+ of architecture (i.e in drivers).
+
+---
+ arch/Kconfig |    3 +++
+ 1 file changed, 3 insertions(+)
+
+diff --git a/arch/Kconfig b/arch/Kconfig
+index 684eb5a..b73f48f 100644
+--- a/arch/Kconfig
++++ b/arch/Kconfig
+@@ -214,6 +214,9 @@ config HAVE_CMPXCHG_DOUBLE
+ 	bool
+ 
+ config ARCH_WANT_OLD_COMPAT_IPC
++       bool
++
++config QSP
+ 	bool
+ 
+ source "kernel/gcov/Kconfig"
+-- 
+1.7.9.5
+
diff -pNur buildroot.2014.08/board/windriver/qsp-ppc/linux-0011-qsp-Add-common-defines-for-qsp-device-ids.patch buildroot/board/windriver/qsp-ppc/linux-0011-qsp-Add-common-defines-for-qsp-device-ids.patch
--- buildroot.2014.08/board/windriver/qsp-ppc/linux-0011-qsp-Add-common-defines-for-qsp-device-ids.patch	1970-01-01 07:00:00.000000000 +0700
+++ buildroot/board/windriver/qsp-ppc/linux-0011-qsp-Add-common-defines-for-qsp-device-ids.patch	2014-12-09 13:19:53.705729700 +0800
@@ -0,0 +1,67 @@
+From 39f1952ed89491ecd35c21d45da256d1b674c880 Mon Sep 17 00:00:00 2001
+From: Ivar Holmqvist <ivarholmqvist@gmail.com>
+Date: Mon, 16 Jul 2012 18:32:10 +0200
+Subject: [PATCH] qsp: Add common defines for qsp device ids.
+
+---
+ include/linux/qsp/qsp.h |   49 +++++++++++++++++++++++++++++++++++++++++++++++
+ 1 file changed, 49 insertions(+)
+
+diff --git a/include/linux/qsp/qsp.h b/include/linux/qsp/qsp.h
+new file mode 100644
+index 0000000..cfcf547
+--- /dev/null
++++ b/include/linux/qsp/qsp.h
+@@ -0,0 +1,49 @@
++/*
++ *  Copyright 2012 Wind River, Inc
++ *
++ *  This program is free software; you can redistribute it and/or modify
++ *  it under the terms of the GNU General Public License as published by
++ *  the Free Software Foundation; either version 2, or (at your option)
++ *  any later version.
++ *
++ *  This program is distributed in the hope that it will be useful,
++ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
++ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ *  GNU General Public License for more details.
++ *
++ *  You should have received a copy of the GNU General Public License
++ *  along with this program; see the file COPYING.  If not, write to
++ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
++ */
++
++#ifndef __LINUX_QSP_H
++#define __LINUX_QSP_H
++
++#define QSP_ID_VAL 0x12340000
++
++#define QSP_PIC_ID_VAL     (QSP_ID_VAL | 0x0001)
++#define QSP_SERIAL_ID_VAL  (QSP_ID_VAL | 0x0002)
++#define QSP_BLK_ID_VAL     (QSP_ID_VAL | 0x0003)
++#define QSP_RTC_ID_VAL     (QSP_ID_VAL | 0x0004)
++#define QSP_LED_ID_VAL     (QSP_ID_VAL | 0x0005)
++#define QSP_NET_ID_VAL     (QSP_ID_VAL | 0x0006)
++#define QSP_TIMER_ID_VAL   (QSP_ID_VAL | 0x0007)
++#define QSP_SYSREGS_ID_VAL (QSP_ID_VAL | 0x0008)
++#define QSP_FLASH_ID_VAL   (QSP_ID_VAL | 0x0009)
++#define QSP_PROBE_ID_VAL   (QSP_ID_VAL | 0x9999)
++
++
++static inline int qsp_device_valid(unsigned char __iomem *addr, int device_id)
++{
++	int id = readl(addr);
++	if (id == QSP_PROBE_ID_VAL) {
++		pr_debug("Device id is probe (%x != %x)\n", id, device_id);
++		return -EINVAL;
++	} else if (id != device_id) {
++		pr_warn("Device id is wrong (%x != %x)\n", id, device_id);
++		return -EINVAL;
++	} else
++		return 0;
++}
++
++#endif /* __LINUX_QSP_H */
+-- 
+1.7.9.5
+
diff -pNur buildroot.2014.08/board/windriver/qsp-ppc/linux-0012-qsp-Add-qsp-documentation.patch buildroot/board/windriver/qsp-ppc/linux-0012-qsp-Add-qsp-documentation.patch
--- buildroot.2014.08/board/windriver/qsp-ppc/linux-0012-qsp-Add-qsp-documentation.patch	1970-01-01 07:00:00.000000000 +0700
+++ buildroot/board/windriver/qsp-ppc/linux-0012-qsp-Add-qsp-documentation.patch	2014-12-09 13:19:53.705729700 +0800
@@ -0,0 +1,25 @@
+From a67cb80887a55a25accb1d26f662490a5d321853 Mon Sep 17 00:00:00 2001
+From: Ivar Holmqvist <ivarholmqvist@gmail.com>
+Date: Mon, 16 Jul 2012 18:33:05 +0200
+Subject: [PATCH] qsp: Add qsp documentation.
+
+---
+ Documentation/qsp/qsp.txt |    7 +++++++
+ 1 file changed, 7 insertions(+)
+
+diff --git a/Documentation/qsp/qsp.txt b/Documentation/qsp/qsp.txt
+new file mode 100644
+index 0000000..9e97612
+--- /dev/null
++++ b/Documentation/qsp/qsp.txt
+@@ -0,0 +1,7 @@
++Simics QSP
++==========
++
++The QSP boards are pure virtual boards for the Wind River Simics (tm) system
++simulator. They serve as demonstration/example boards. The intention is to keep the Linux port as simple and elegant as possible, while maintaining code reuse across all major architectures.
++
++The devices on these boards are designed for simplicity first and perfomance second.
+-- 
+1.7.9.5
+
diff -pNur buildroot.2014.08/board/windriver/qsp-ppc/linux-0013-qsp-pic-Initial-support-for-qsp-interrupt-controller.patch buildroot/board/windriver/qsp-ppc/linux-0013-qsp-pic-Initial-support-for-qsp-interrupt-controller.patch
--- buildroot.2014.08/board/windriver/qsp-ppc/linux-0013-qsp-pic-Initial-support-for-qsp-interrupt-controller.patch	1970-01-01 07:00:00.000000000 +0700
+++ buildroot/board/windriver/qsp-ppc/linux-0013-qsp-pic-Initial-support-for-qsp-interrupt-controller.patch	2014-12-09 13:19:53.705729700 +0800
@@ -0,0 +1,569 @@
+From 8fb11c732496e70b3772dd2ecf527d9bbd873bf2 Mon Sep 17 00:00:00 2001
+From: Ivar Holmqvist <ivarholmqvist@gmail.com>
+Date: Mon, 16 Jul 2012 17:49:58 +0200
+Subject: [PATCH] qsp-pic: Initial support for qsp interrupt controller.
+
+The qsp-pic is cross architecture interrupt controller using the irq_domains api and
+currently works with (and have been tested on) ppc32 and arm.
+---
+ drivers/Kconfig             |    2 +
+ drivers/Makefile            |    2 +
+ drivers/pic/Kconfig         |   16 ++
+ drivers/pic/Makefile        |    1 +
+ drivers/pic/qsp_pic.c       |  444 +++++++++++++++++++++++++++++++++++++++++++
+ include/linux/qsp/qsp_pic.h |   44 +++++
+ 6 files changed, 509 insertions(+)
+
+diff --git a/drivers/Kconfig b/drivers/Kconfig
+index d236aef..9dcd286 100644
+--- a/drivers/Kconfig
++++ b/drivers/Kconfig
+@@ -140,4 +140,6 @@ source "drivers/virt/Kconfig"
+ 
+ source "drivers/devfreq/Kconfig"
+ 
++source "drivers/pic/Kconfig"
++
+ endmenu
+diff --git a/drivers/Makefile b/drivers/Makefile
+index 95952c8..bf68dce 100644
+--- a/drivers/Makefile
++++ b/drivers/Makefile
+@@ -134,3 +134,5 @@ obj-$(CONFIG_VIRT_DRIVERS)	+= virt/
+ obj-$(CONFIG_HYPERV)		+= hv/
+ 
+ obj-$(CONFIG_PM_DEVFREQ)	+= devfreq/
++
++obj-y				+= pic/
+diff --git a/drivers/pic/Kconfig b/drivers/pic/Kconfig
+new file mode 100644
+index 0000000..f22c8b6
+--- /dev/null
++++ b/drivers/pic/Kconfig
+@@ -0,0 +1,16 @@
++menuconfig PIC_SUPPORT
++	bool "Support for programmable interrupt controllers"
++	help
++	  Say Y to enable Linux PIC support.  This allows control of supported
++	  programmable intterupt controllers. Note that these are normally
++	  enabled by the platform/machine support.
++
++config QSP_PIC
++	boolean "QSP Programmable interrupt controller"
++	default y if QSP
++	depends on PIC_SUPPORT
++	help
++	  QSP Programmable interrupt controller
++	  This driver is required if you want to use any QSP style boards.
++
++	  Say Y here to compile support for QSP PIC into the kernel.
+diff --git a/drivers/pic/Makefile b/drivers/pic/Makefile
+new file mode 100644
+index 0000000..de5a77e
+--- /dev/null
++++ b/drivers/pic/Makefile
+@@ -0,0 +1 @@
++obj-$(CONFIG_QSP_PIC) += qsp_pic.o
+diff --git a/drivers/pic/qsp_pic.c b/drivers/pic/qsp_pic.c
+new file mode 100644
+index 0000000..e60f31b
+--- /dev/null
++++ b/drivers/pic/qsp_pic.c
+@@ -0,0 +1,444 @@
++/*
++
++ * QSP Programmable Interrup Controller
++ *
++ * Copyright 2011 Ivar Holmqvist <ivar.holmqvist@windriver.com> Wind River
++ * Copyright 2007 David Gibson <dwg@au1.ibm.com>, IBM Corporation.
++ *
++ * This program is free software; you can redistribute  it and/or modify it
++ * under  the terms of  the GNU General  Public License as published by the
++ * Free Software Foundation;  either version 2 of the  License, or (at your
++ * option) any later version.
++ *
++ * Most code stolen from uic.c/mpic.c
++ */
++
++/* This is an attempt to create a arch independant interrupt controller.
++ * It's been tested on arm (cortexA9) and ppc (e600)
++ *
++ * Currently the major difference is that ppc version
++ * assumes that the platform/arch code registers normal handlers
++ * for IPIs (i.e requst_irq()). When compiled for arm, we shortcut
++ * this and directly enables IPIs and they are handled separately
++ * in the machine specific parts.
++ */
++
++#include <linux/kernel.h>
++#include <linux/module.h>
++#include <linux/init.h>
++#include <linux/errno.h>
++#include <linux/reboot.h>
++#include <linux/slab.h>
++#include <linux/stddef.h>
++#include <linux/sched.h>
++#include <linux/signal.h>
++#include <linux/device.h>
++#include <linux/bootmem.h>
++#include <linux/spinlock.h>
++#include <linux/irq.h>
++#include <linux/irqdomain.h>
++#include <linux/interrupt.h>
++#include <linux/kernel_stat.h>
++#include <linux/io.h>
++#include <linux/err.h>
++
++#include <asm/irq.h>
++
++#include <linux/of_fdt.h>
++#include <linux/of_address.h>
++#include <linux/of_irq.h>
++#include <linux/platform_device.h>
++
++#include <linux/qsp/qsp.h>
++#include <linux/qsp/qsp_pic.h>
++
++#if 0
++#define DEBUG_IPI
++#define DBG(fmt, args...) printk(KERN_DEBUG "PIC:" fmt, ## args)
++#else
++#define DBG(fmt, args...) do {} while (0)
++#endif
++#define NR_QSP_PIC_INTS	1024
++
++/* Register offsets */
++#define QSP_PIC_ID      0x00
++#define QSP_PIC_ENABLE  0x04
++#define QSP_PIC_DISABLE 0x08
++#define QSP_PIC_DST     0x10
++#define QSP_PIC_GEN     0x14
++#define QSP_PIC_TYPE    0x18
++
++#define QSP_PIC_PENDING 0x20
++#define QSP_PIC_EOI     0x24
++
++#define QSP_NO_IRQ      (NR_QSP_PIC_INTS + 1)
++
++/* bit definitions */
++#define TYPE_EDGE (1<<16)
++
++#define CPU_DST_SHIFT (16)
++
++
++static struct qsp_pic *primary_qsp_pic;
++
++/* TODO: Need to properly investigate which handlers are best
++ * for this interrupt controller (keeping in mind that I can
++ * rewrite the controller itself if needed). Seems like the
++ * lockless percpu handlers would be best.
++ */
++
++struct qsp_pic {
++	int index;
++	void __iomem *base;
++	struct irq_domain *domain;
++};
++
++static void qsp_pic_write_register(struct qsp_pic *pic, int reg_num, u32 val)
++{
++	writel(val, pic->base + reg_num);
++}
++
++static u32 qsp_pic_read_register(struct qsp_pic *pic, int reg_num)
++{
++	u32 ret;
++	ret = readl(pic->base + reg_num);
++	return ret;
++}
++
++
++static void qsp_pic_unmask_irq(struct irq_data *d)
++{
++	struct qsp_pic *qsp_pic = irq_data_get_irq_chip_data(d);
++
++	DBG("unamsk %d\n", d->hwirq);
++	qsp_pic_write_register(qsp_pic, QSP_PIC_ENABLE, d->hwirq);
++}
++
++static void qsp_pic_mask_irq(struct irq_data *d)
++{
++	struct qsp_pic *qsp_pic = irq_data_get_irq_chip_data(d);
++
++	DBG("mask %d\n", d->hwirq);
++	qsp_pic_write_register(qsp_pic, QSP_PIC_DISABLE, d->hwirq);
++}
++
++static void qsp_pic_eoi(struct irq_data *d)
++{
++	struct qsp_pic *qsp_pic = irq_data_get_irq_chip_data(d);
++
++	DBG("EOI %d hw:%d\n", d->irq, d->hwirq);
++	qsp_pic_write_register(qsp_pic, QSP_PIC_EOI, d->hwirq);
++}
++
++/* Only used by arm machines.
++ */
++void qsp_ipi_eoi(int irq)
++{
++	struct qsp_pic *qsp_pic = primary_qsp_pic;
++	qsp_pic_write_register(qsp_pic, QSP_PIC_EOI, irq);
++}
++
++static int qsp_pic_set_irq_type(struct irq_data *d, unsigned int flow_type)
++{
++	struct qsp_pic *qsp_pic = irq_data_get_irq_chip_data(d);
++	u32 edge;
++
++	switch (flow_type & IRQ_TYPE_SENSE_MASK) {
++	case IRQ_TYPE_NONE:
++		DBG("set type none %d\n", d->hwirq);
++		qsp_pic_mask_irq(d);
++		return 0;
++
++	case IRQ_TYPE_EDGE_RISING:
++		DBG("set type edge rising %d\n", d->hwirq);
++		edge = TYPE_EDGE;
++		break;
++
++	case IRQ_TYPE_LEVEL_HIGH:
++		DBG("set type level high %d\n", d->hwirq);
++		edge = 0;
++		break;
++
++	case IRQ_TYPE_LEVEL_LOW:
++	case IRQ_TYPE_EDGE_FALLING:
++		printk(KERN_ERR "Unhandled flow type %d\n", flow_type);
++		BUG();
++		break;
++
++	default:
++		printk(KERN_ERR "Illegal flow type %d\n", flow_type);
++		BUG();
++		return -EINVAL;
++	}
++
++
++	qsp_pic_write_register(qsp_pic, QSP_PIC_TYPE, edge | d->hwirq);
++	irqd_set_trigger_type(d, flow_type);
++
++	return 0;
++}
++
++#ifdef CONFIG_SMP
++
++static void qsp_pic_request_ipis(int nr_cpus)
++{
++	struct qsp_pic *qsp_pic = primary_qsp_pic;
++	int i;
++	int cpu;
++	cpumask_t tmpmask;
++
++	BUG_ON(qsp_pic == NULL);
++
++	for (cpu = 0; cpu < nr_cpus; cpu++) {
++		cpumask_clear(&tmpmask);
++		cpumask_set_cpu(cpu, &tmpmask);
++		for (i = 0; i < IPI_NUM_TYPES; i++) {
++
++			unsigned int vipi = irq_create_mapping(qsp_pic->domain,
++							       IPI_NR(cpu, i));
++			if (vipi == NO_IRQ) {
++				printk(KERN_ERR "Failed to map ipi %d\n", i);
++				continue;
++			}
++			irq_set_irq_type(vipi, IRQ_TYPE_EDGE_RISING);
++			irq_set_affinity(vipi, &tmpmask);
++
++#ifdef CONFIG_ARM
++			/* FIXME: Maybe we should switch to request_irq()
++			 * based ipi handling in arm as well instead of
++			 * shortcutting it in machine->handle_irq()
++			 */
++			qsp_pic_write_register(qsp_pic,
++					       QSP_PIC_ENABLE,
++					       IPI_NR(cpu, i));
++#else
++			/* powerpc does a simple request_irq() here.*/
++			smp_request_message_ipi(vipi, i);
++#endif
++		}
++	}
++}
++
++int __init smp_qsp_pic_probe(void)
++{
++	int nr_possible;
++	int nr_ipis;
++
++	pr_debug("smp_qsp_pic_probe()...\n");
++	/* QSP-PPC updates setup_max_cpus since possible_map is always "full".
++	 * We just wan't as few IPIs as possible.
++	 */
++	nr_possible = cpumask_weight(cpu_possible_mask);
++	nr_ipis = min_t(int, nr_possible, setup_max_cpus);
++
++	if (nr_ipis > 1) {
++		pr_info("qps-pic: Requesting %d ipis (cpu_possible=%d, maxcpus=%d)\n",
++			nr_ipis,
++			nr_possible,
++			setup_max_cpus);
++		qsp_pic_request_ipis(nr_ipis);
++	}
++
++	return nr_ipis;
++}
++
++void __devinit smp_qsp_pic_setup_cpu(int cpu)
++{
++}
++
++static int qsp_pic_set_affinity(struct irq_data *d,
++				const struct cpumask *cpumask,
++				bool force)
++{
++	struct qsp_pic *qsp_pic = irq_data_get_irq_chip_data(d);
++	unsigned int irq = d->hwirq;
++	int cpuid;
++
++	BUG_ON(cpumask_weight(cpumask) == 0);
++	cpuid = cpumask_first(cpumask);
++
++	DBG("single dest cpu -> %d (mask;%08lx)\n",
++	    cpuid, cpumask_bits(cpumask)[0]);
++	qsp_pic_write_register(qsp_pic, QSP_PIC_DST,
++			       (cpuid<<CPU_DST_SHIFT) | irq);
++
++	return 0;
++}
++
++void qsp_pic_message_pass(int cpu, int msg)
++{
++	struct qsp_pic *qsp_pic = primary_qsp_pic;
++
++	BUG_ON(qsp_pic == NULL);
++
++	/* make sure we're sending something that translates to an IPI */
++	if ((unsigned int)msg > IPI_NUM_TYPES) {
++		printk(KERN_ERR "SMP %d: smp_message_pass: unknown msg %d\n",
++		       smp_processor_id(), msg);
++		return;
++	}
++
++#ifdef DEBUG_IPI
++	DBG("%s: %d->%d (vipi:%d) send_ipi(ipi_no: %d)\n", "qsp_pic",
++	    smp_processor_id(), cpu, IPI_NR(cpu, msg), msg);
++#endif
++	qsp_pic_write_register(qsp_pic, QSP_PIC_GEN, IPI_NR(cpu, msg));
++}
++#endif
++
++
++static struct irq_chip qsp_pic_irq_chip = {
++	.name		= "QSP_PIC",
++	.irq_unmask	= qsp_pic_unmask_irq,
++	.irq_mask	= qsp_pic_mask_irq,
++	.irq_set_type	= qsp_pic_set_irq_type,
++	.irq_eoi	= qsp_pic_eoi,
++#ifdef CONFIG_SMP
++	.irq_set_affinity = qsp_pic_set_affinity,
++#endif
++};
++
++
++static int qsp_pic_domain_map(struct irq_domain *d, unsigned int virq,
++			    unsigned long hw)
++{
++	struct qsp_pic *qsp_pic = d->host_data;
++
++	irq_set_chip_data(virq, qsp_pic);
++
++	if ((hw - IPI_BASE) > 0 && (hw - IPI_BASE) < IPI_NUM_TYPES) {
++		DBG("MAP IPI %ld (%ld:%ld)\n", hw,
++		    IPI_GET_CPU(hw), IPI_GET_MSG(hw));
++		irq_set_chip_data(virq, qsp_pic);
++		irq_set_chip_and_handler(virq, &qsp_pic_irq_chip,
++					 handle_percpu_irq);
++		return 0;
++	}
++
++	/* Use fasteoi_irq as handler.
++	 */
++	irq_set_chip_and_handler(virq, &qsp_pic_irq_chip, handle_fasteoi_irq);
++
++	/* Set default irq type */
++	irq_set_irq_type(virq, IRQ_TYPE_NONE);
++
++	return 0;
++}
++
++static int qsp_pic_domain_xlate(struct irq_domain *d, struct device_node *ct,
++			      const u32 *intspec, unsigned int intsize,
++			      unsigned long *out_hwirq,
++			      unsigned int *out_type)
++
++{
++	/* QSP_PIC intspecs must have 2 cells src and type.
++	 */
++	BUG_ON(intsize != 2);
++	*out_hwirq = intspec[0];
++	*out_type = intspec[1]; /* i.e edge or level */
++	return 0;
++}
++
++const struct irq_domain_ops qsp_irq_domain_ops = {
++	.map = qsp_pic_domain_map,
++	.xlate = qsp_pic_domain_xlate,
++};
++
++static struct qsp_pic * __init qsp_pic_init_one(struct device_node *node)
++{
++	struct qsp_pic *qsp_pic;
++	const u32 *indexp, *reg;
++	int len;
++	int i;
++	u32 id;
++
++	BUG_ON(!of_device_is_compatible(node, "qsp-pic"));
++	WARN_ON(NR_QSP_PIC_INTS > NR_IRQS);
++
++	qsp_pic = kzalloc(sizeof(*qsp_pic), GFP_KERNEL);
++	if (!qsp_pic)
++		return NULL;
++
++	indexp = of_get_property(node, "cell-index", &len);
++	if (!indexp || (len != sizeof(u32))) {
++		printk(KERN_ERR "qsp_pic: Device node %s has missing or" \
++		       "invalid cell-index property\n", node->full_name);
++		return NULL;
++	}
++	qsp_pic->index = *indexp;
++
++	reg = of_get_property(node, "reg", &len);
++	if (!reg || (len != 3*sizeof(u32))) {
++		printk(KERN_ERR "qsp_pic: Device node %s has missing or"\
++		       "invalid reg property\n", node->full_name);
++		return NULL;
++	}
++	qsp_pic->base = of_iomap(node, 0);
++	BUG_ON(qsp_pic->base == NULL);
++
++	/* Probe ID of pic.
++	 */
++	id = qsp_pic_read_register(qsp_pic, QSP_PIC_ID);
++	if (id != QSP_PIC_ID_VAL)
++		panic("pic id %08x != %08x\n", id, QSP_PIC_ID_VAL);
++
++	/* Disable all interrupts. */
++	for (i = 0; i < NR_QSP_PIC_INTS; i++)
++		qsp_pic_write_register(qsp_pic, QSP_PIC_DISABLE, i);
++
++	qsp_pic->domain = irq_domain_add_tree(node,
++					      &qsp_irq_domain_ops,
++					      (void *)qsp_pic);
++
++	DBG("QSP_PIC%d (%d IRQ sources) @%p\n", qsp_pic->index,
++	    NR_QSP_PIC_INTS, qsp_pic->base);
++
++	return qsp_pic;
++}
++
++void __init qsp_pic_init(void)
++{
++	struct device_node *np;
++	const u32 *interrupts;
++
++	/* First locate and initialize the top-level QSP_PIC */
++	for_each_compatible_node(np, NULL, "qsp-pic") {
++		interrupts = of_get_property(np, "interrupts", NULL);
++		if (!interrupts)
++			break;
++	}
++
++	BUG_ON(!np); /* qsp_pic_init_tree() assumes there's a QSP_PIC as the
++		      * top-level interrupt controller */
++	primary_qsp_pic = qsp_pic_init_one(np);
++	if (!primary_qsp_pic)
++		panic("Unable to initialize primary QSP_PIC %s\n",
++		      np->full_name);
++
++	of_node_put(np);
++
++}
++
++/* Return an interrupt vector or NO_IRQ if no interrupt is pending. */
++unsigned int qsp_pic_get_irq(void)
++{
++	u32 pending;
++	u32 rev;
++	BUG_ON(!primary_qsp_pic);
++
++	pending = qsp_pic_read_register(primary_qsp_pic, QSP_PIC_PENDING);
++	DBG("get irq %d\n", pending);
++
++	if (pending == QSP_NO_IRQ)
++		return NO_IRQ;
++
++	rev = irq_find_mapping(primary_qsp_pic->domain, pending);
++
++#ifdef DEBUG_IPI
++	if (rev > IPI_BASE)
++		DBG("%s IPI  %d -> cpu:%d msg:%d\n", __func__, rev,
++		    IPI_GET_CPU(rev), IPI_GET_MSG(rev));
++#endif
++	return rev;
++}
++
+diff --git a/include/linux/qsp/qsp_pic.h b/include/linux/qsp/qsp_pic.h
+new file mode 100644
+index 0000000..69c9788
+--- /dev/null
++++ b/include/linux/qsp/qsp_pic.h
+@@ -0,0 +1,44 @@
++/*
++ *  Copyright 2012 Wind River, Inc
++ *
++ *  This program is free software; you can redistribute it and/or modify
++ *  it under the terms of the GNU General Public License as published by
++ *  the Free Software Foundation; either version 2, or (at your option)
++ *  any later version.
++ *
++ *  This program is distributed in the hope that it will be useful,
++ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
++ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ *  GNU General Public License for more details.
++ *
++ *  You should have received a copy of the GNU General Public License
++ *  along with this program; see the file COPYING.  If not, write to
++ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
++ */
++
++#ifndef __LINUX_QSP_PIC_H
++#define __LINUX_QSP_PIC_H
++
++void  qsp_pic_init(void);
++unsigned int qsp_pic_get_irq(void);
++
++#ifdef CONFIG_SMP
++void qsp_pic_message_pass(int cpu, int msg);
++void smp_qsp_pic_setup_cpu(int cpu);
++int __init smp_qsp_pic_probe(void);
++void qsp_ipi_eoi(int irq);
++
++#define IPI_BASE 128
++#ifdef CONFIG_ARM
++/* FIXME: */
++#define IPI_NUM_TYPES 6
++#else
++#define IPI_NUM_TYPES 4
++#endif
++#define IPI_NR(cpu, type) (IPI_BASE+(cpu)*IPI_NUM_TYPES+type)
++#define IPI_GET_CPU(vipi) (((vipi)-IPI_BASE)/IPI_NUM_TYPES)
++#define IPI_GET_MSG(vipi) (((vipi)-IPI_BASE)%IPI_NUM_TYPES)
++
++#endif
++
++#endif /* __LINUX_QSP_PIC_H */
+-- 
+1.7.9.5
+
diff -pNur buildroot.2014.08/board/windriver/qsp-ppc/linux-0014-qsp-blk-Initial-support-for-qsp-block-device-control.patch buildroot/board/windriver/qsp-ppc/linux-0014-qsp-blk-Initial-support-for-qsp-block-device-control.patch
--- buildroot.2014.08/board/windriver/qsp-ppc/linux-0014-qsp-blk-Initial-support-for-qsp-block-device-control.patch	1970-01-01 07:00:00.000000000 +0700
+++ buildroot/board/windriver/qsp-ppc/linux-0014-qsp-blk-Initial-support-for-qsp-block-device-control.patch	2014-12-09 13:19:53.705729700 +0800
@@ -0,0 +1,418 @@
+From 8bc67b0e5d91f20bc5a33926faa3869bf8b0be41 Mon Sep 17 00:00:00 2001
+From: Ivar Holmqvist <ivarholmqvist@gmail.com>
+Date: Mon, 16 Jul 2012 17:51:12 +0200
+Subject: [PATCH] qsp-blk: Initial support for qsp block device controller.
+
+---
+ drivers/block/Kconfig   |    8 +
+ drivers/block/Makefile  |    1 +
+ drivers/block/qsp_blk.c |  370 +++++++++++++++++++++++++++++++++++++++++++++++
+ 3 files changed, 379 insertions(+)
+
+diff --git a/drivers/block/Kconfig b/drivers/block/Kconfig
+index a796407..947ae50 100644
+--- a/drivers/block/Kconfig
++++ b/drivers/block/Kconfig
+@@ -555,4 +555,12 @@ config BLK_DEV_RBD
+ 
+ 	  If unsure, say N.
+ 
++config BLK_DEV_QSP
++	tristate "QSP block device"
++	default y if QSP
++	help
++	  Say Y here if you want include support the QSP disk controller,
++	  found on Simics virtual QSP boards.
++
++
+ endif # BLK_DEV
+diff --git a/drivers/block/Makefile b/drivers/block/Makefile
+index 5b79505..eda4d10 100644
+--- a/drivers/block/Makefile
++++ b/drivers/block/Makefile
+@@ -41,5 +41,6 @@ obj-$(CONFIG_XEN_BLKDEV_BACKEND)	+= xen-blkback/
+ obj-$(CONFIG_BLK_DEV_DRBD)     += drbd/
+ obj-$(CONFIG_BLK_DEV_RBD)     += rbd.o
+ obj-$(CONFIG_BLK_DEV_PCIESSD_MTIP32XX)	+= mtip32xx/
++obj-$(CONFIG_BLK_DEV_QSP)     += qsp_blk.o
+ 
+ swim_mod-y	:= swim.o swim_asm.o
+diff --git a/drivers/block/qsp_blk.c b/drivers/block/qsp_blk.c
+new file mode 100644
+index 0000000..4bcd0ac
+--- /dev/null
++++ b/drivers/block/qsp_blk.c
+@@ -0,0 +1,370 @@
++/*
++ * QSP disk controller
++ *
++ * Based on ps3disk.c, xen-blkfront.c and the example block driver in ldd.
++ *
++ * (C) Copyright 2012, Ivar Holmqvist <ivarholmqvist@gmail.com>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ */
++#undef DEBUG
++
++#include <linux/module.h>
++#include <linux/sched.h>
++#include <linux/kernel.h>
++#include <linux/slab.h>
++#include <linux/fs.h>
++#include <linux/errno.h>
++#include <linux/hdreg.h>
++#include <linux/genhd.h>
++#include <linux/blkdev.h>
++#include <linux/bio.h>
++#include <linux/of_platform.h>
++#include <linux/of_address.h>
++#include <linux/of_irq.h>
++#include <linux/interrupt.h>
++
++#include <linux/qsp/qsp.h>
++
++#define MINOR_SHIFT     4
++#define QSP_BLK_MINORS	(1<<MINOR_SHIFT)
++#define QSP_BLK_MAJOR	99
++#define DEVICE_NAME	"qspblk"
++#define QSP_DISK_NAME	"qspd"
++#define QSP_BLK_SIZE	512
++
++/* Commands */
++#define QSP_BLK_CMD_READ  0x101
++#define QSP_BLK_CMD_WRITE 0x102
++#define QSP_BLK_CMD_SENSE 0x103
++
++/* Registers */
++#define ID            0x00
++#define STATUS        0x04
++#define CONTROL       0x08
++#define CMD           0x0C
++#define CMD_RESPONSE  0x10
++#define BLOCK         0x14
++#define PADDR         0x18
++
++
++/* Status Register Bits */
++#define STATUS_CMD_COMPLETE (1<<0)
++#define STATUS_CHANN_ERR    (1<<1)
++#define STATUS_SEEK_ERR     (1<<2)
++#define STATUS_DMA_ERR      (1<<3)
++#define STATUS_DISK_PRESENT (1<<4)
++
++/* Control Register Bits */
++#define CONTROL_IE   (1<<0)
++
++static atomic_t usage_count = ATOMIC_INIT(0);
++
++static int qsp_getgeo(struct block_device *bd, struct hd_geometry *hg)
++{
++	/* We don't have real geometry info, but let's at least return
++	 * values consistent with the size of the device
++	 */
++	sector_t nsect = get_capacity(bd->bd_disk);
++	sector_t cylinders = nsect;
++
++	hg->heads = 0xff;
++	hg->sectors = 0x3f;
++	sector_div(cylinders, hg->heads * hg->sectors);
++	hg->cylinders = cylinders;
++	if ((sector_t)(hg->cylinders + 1) * hg->heads * hg->sectors < nsect)
++		hg->cylinders = 0xffff;
++	return 0;
++}
++/*
++ * The device operations structure.
++ */
++static const struct block_device_operations qsp_blk_ops = {
++	.owner   = THIS_MODULE,
++	.getgeo  = qsp_getgeo,
++};
++
++struct qsp_blk {
++	struct platform_device *ofdev;
++	struct gendisk *gd;
++	struct request_queue *queue;
++	int idx;
++	u64 size;
++	unsigned int irq;
++	void __iomem *base;
++};
++
++static void qsp_blk_write_register(struct qsp_blk *blk, int reg_num, u32 val)
++{
++	dev_dbg(&blk->ofdev->dev, "write reg %08x %08x\n", reg_num, val);
++	writel(val, blk->base + reg_num);
++}
++
++static u32 qsp_blk_read_register(struct qsp_blk *blk, int reg_num)
++{
++	u32 ret;
++	ret = readl(blk->base + reg_num);
++	dev_dbg(&blk->ofdev->dev, "read reg %08x -> %08x\n", reg_num, ret);
++	return ret;
++}
++
++/* The direct make request version.
++ */
++static void ablk_make_request(struct request_queue *q, struct bio *bio)
++{
++	struct qsp_blk *ablk = q->queuedata;
++	int i;
++	struct bio_vec *bvec;
++	sector_t sector = bio->bi_sector;
++	u32 status;
++
++	dev_dbg(&ablk->ofdev->dev, "MAKE REQUEST %lld", sector);
++
++	bio_for_each_segment(bvec, bio, i) {
++		u64 paddr = page_to_phys(bvec->bv_page) + bvec->bv_offset;
++		size_t len = bvec->bv_len;
++
++		dev_dbg(&ablk->ofdev->dev, "i=%d\n", i);
++		while (len > 0) {
++			dev_dbg(&ablk->ofdev->dev, "paddr:%llx\n", paddr);
++			qsp_blk_write_register(ablk, PADDR, (u32)paddr);
++			qsp_blk_write_register(ablk, BLOCK, (u32)(sector));
++
++			dev_dbg(&ablk->ofdev->dev,
++				"sector: %lld len:%d size:%d\n", sector, len,
++				bio->bi_size);
++
++			switch (bio_data_dir(bio)) {
++			case WRITE:
++				qsp_blk_write_register(ablk,
++						       CMD, QSP_BLK_CMD_WRITE);
++				break;
++			case READ:
++				qsp_blk_write_register(ablk,
++						       CMD, QSP_BLK_CMD_READ);
++				break;
++			}
++
++			status = qsp_blk_read_register(ablk, STATUS);
++			if (status & STATUS_CHANN_ERR) {
++				dev_err(&ablk->ofdev->dev, "channel error\n");
++				bio_endio(bio, -1);
++				return;
++			}
++			if (status & STATUS_DMA_ERR) {
++				dev_err(&ablk->ofdev->dev, "DMA error\n");
++				bio_endio(bio, -1);
++				return;
++			}
++			if (status & STATUS_SEEK_ERR) {
++				dev_err(&ablk->ofdev->dev, "seek error\n");
++				bio_endio(bio, -1);
++				return;
++			}
++			if (status & STATUS_CMD_COMPLETE)
++				dev_dbg(&ablk->ofdev->dev, "cmd complete\n");
++
++			paddr += QSP_BLK_SIZE;
++			sector += 1;
++			len -= QSP_BLK_SIZE;
++			dev_dbg(&ablk->ofdev->dev, "remain len %d\n", len);
++		}
++	}
++	bio_endio(bio, 0);
++}
++
++
++static irqreturn_t ablk_interrupt(int irq, void *dev_id)
++{
++	pr_info("FIXME: CMD_SENSE interrupt.\n");
++	return IRQ_HANDLED;
++}
++
++
++static int __devinit qsp_blk_probe(struct platform_device *ofdev)
++{
++	int err;
++	struct qsp_blk *ablk;
++	u32 status;
++	u32 id;
++	pr_debug("probe\n");
++
++	ablk = kzalloc(sizeof(struct qsp_blk), GFP_KERNEL);
++	if (!ablk) {
++		err = -ENOMEM;
++		goto no_mem;
++	}
++	ablk->ofdev = ofdev;
++	dev_set_drvdata(&ofdev->dev, ablk);
++
++	ablk->base = of_iomap(ofdev->dev.of_node, 0);
++	if (ablk->base == NULL) {
++		dev_err(&ofdev->dev, "failed to map resources.\n");
++		err = -EINVAL;
++		goto no_map;
++	}
++
++	id = qsp_blk_read_register(ablk, ID);
++	if (id != QSP_BLK_ID_VAL) {
++		dev_dbg(&ofdev->dev, "Failed to probe hardware with ID=0x%08x "
++			" @%p\n", id, ablk->base);
++		err = -ENODEV;
++		goto bad_id;
++	}
++
++	/* FIXME: we assume that CMD_SENSE completes immediately if there
++	 * is a disk connected...
++	 */
++	qsp_blk_write_register(ablk, CMD, QSP_BLK_CMD_SENSE);
++	status = qsp_blk_read_register(ablk, STATUS);
++	if (!(status & STATUS_CMD_COMPLETE)) {
++		dev_info(&ofdev->dev, "No disk present, skipping this controller.");
++		goto no_disk;
++	}
++	ablk->size = qsp_blk_read_register(ablk, CMD_RESPONSE);
++	dev_info(&ofdev->dev, "Disk of size %lld attached\n", ablk->size);
++
++	/* Setup the queue
++	 * Direct make request is the easiest block device interface, would
++	 * blk_init_queue() be significantly faster?
++	 */
++	ablk->queue = blk_alloc_queue(GFP_KERNEL);
++	blk_queue_make_request(ablk->queue, ablk_make_request);
++	if (ablk->queue == NULL) {
++		err = -ENOMEM;
++		goto no_queue;
++	}
++	ablk->queue->queuedata = ablk;
++
++	/* Setup the disk
++	 */
++	ablk->gd = alloc_disk(QSP_BLK_MINORS);
++	if (ablk->gd == NULL) {
++		err = -ENOMEM;
++		goto no_disk_mem;
++	}
++
++	ablk->idx = atomic_inc_return(&usage_count);
++	ablk->gd->major = QSP_BLK_MAJOR;
++	ablk->gd->first_minor = (ablk->idx - 1) << MINOR_SHIFT;
++	ablk->gd->fops = &qsp_blk_ops;
++	ablk->gd->queue = ablk->queue;
++	ablk->gd->private_data = ofdev;
++	ablk->gd->driverfs_dev = &ofdev->dev;
++	snprintf(ablk->gd->disk_name,
++		 sizeof(ablk->gd->disk_name),
++		 "%s%c",
++		 QSP_DISK_NAME,
++		 ablk->idx+'a');
++	set_capacity(ablk->gd, ablk->size);
++	add_disk(ablk->gd);
++	dev_info(&ofdev->dev, "add disk name:%s size:%lld done\n",
++		 ablk->gd->disk_name, get_capacity(ablk->gd));
++
++	/* Setup interrupt (currently unused...)
++	 */
++	ablk->irq = irq_of_parse_and_map(ofdev->dev.of_node,  0);
++	dev_dbg(&ofdev->dev, "got irq %d\n", ablk->irq);
++	if (!ablk->irq) {
++		dev_err(&ofdev->dev, "IRQ not specified in dtb\n");
++		return -EINVAL;
++	}
++	err = request_irq(ablk->irq, ablk_interrupt, 0, "qsp_blk",
++			  ablk);
++	if (err != 0) {
++		dev_err(&ofdev->dev, "Failed to request irq %d\n",  err);
++		return err;
++	}
++
++	return 0;
++no_disk_mem:
++	blk_cleanup_queue(ablk->queue);
++no_queue:
++no_disk:
++	iounmap(ablk->base);
++no_map:
++bad_id:
++	kfree(ablk);
++no_mem:
++	return err;
++}
++
++static int __devexit qsp_blk_remove(struct platform_device *ofdev)
++{
++	struct qsp_blk *ablk = dev_get_drvdata(&ofdev->dev);
++
++	dev_info(&ofdev->dev, "removing disk\n");
++	atomic_dec(&usage_count);
++
++	if (ablk->gd) {
++		dev_dbg(&ofdev->dev, "delete gendisk\n");
++		del_gendisk(ablk->gd);
++		put_disk(ablk->gd);
++	}
++	if (ablk->queue) {
++		dev_dbg(&ofdev->dev, "cleanup queue\n");
++		blk_cleanup_queue(ablk->queue);
++	}
++
++	dev_set_drvdata(&ofdev->dev, NULL);
++	kfree(ablk);
++
++	return 0;
++}
++
++static const struct of_device_id qsp_blk_match[] = {
++	{ .compatible = "qsp,disk-controller" },
++	{},
++};
++MODULE_DEVICE_TABLE(of, qsp_blk_match);
++
++static struct platform_driver qsp_blk_driver = {
++	.probe		= qsp_blk_probe,
++	.remove		= __devexit_p(qsp_blk_remove),
++	.driver = {
++		.name = "adb-blk",
++		.owner = THIS_MODULE,
++		.of_match_table = qsp_blk_match,
++	},
++};
++
++static int __init qsp_blk_init(void)
++{
++	int berror;
++	int perror;
++
++	berror = register_blkdev(QSP_BLK_MAJOR, DEVICE_NAME);
++	if (berror < 0) {
++		pr_err("%s: register_blkdev failed - %d (major %d)\n",
++		       DEVICE_NAME,
++		       berror,
++		       QSP_BLK_MAJOR);
++		return berror;
++	}
++
++	perror = platform_driver_register(&qsp_blk_driver);
++	if (perror) {
++		pr_err("%s: platform_driver_register failed - %d\n",
++		       DEVICE_NAME, berror);
++		unregister_blkdev(QSP_BLK_MAJOR, DEVICE_NAME);
++		return perror;
++	}
++
++	pr_info("%s: registered succesfully\n", DEVICE_NAME);
++	return 0;
++}
++
++static void __exit qsp_blk_exit(void)
++{
++	platform_driver_unregister(&qsp_blk_driver);
++}
++
++module_init(qsp_blk_init);
++module_exit(qsp_blk_exit);
++
++MODULE_AUTHOR("Ivar Holmqvist <ivarholmqvist@gmail.com>");
++MODULE_DESCRIPTION("Block device driver for disk controllers on QSP boards.");
++MODULE_LICENSE("GPL");
+-- 
+1.7.9.5
+
diff -pNur buildroot.2014.08/board/windriver/qsp-ppc/linux-0015-qsp-timer-Initial-support-for-qsp-timer.patch buildroot/board/windriver/qsp-ppc/linux-0015-qsp-timer-Initial-support-for-qsp-timer.patch
--- buildroot.2014.08/board/windriver/qsp-ppc/linux-0015-qsp-timer-Initial-support-for-qsp-timer.patch	1970-01-01 07:00:00.000000000 +0700
+++ buildroot/board/windriver/qsp-ppc/linux-0015-qsp-timer-Initial-support-for-qsp-timer.patch	2014-12-09 13:19:53.705729700 +0800
@@ -0,0 +1,243 @@
+From 628907dfa80ed5c96bd7eca298ae4365bdaa8136 Mon Sep 17 00:00:00 2001
+From: Ivar Holmqvist <ivarholmqvist@gmail.com>
+Date: Mon, 16 Jul 2012 17:52:02 +0200
+Subject: [PATCH] qsp-timer: Initial support for qsp timer.
+
+---
+ drivers/clocksource/Kconfig   |    7 ++
+ drivers/clocksource/Makefile  |    3 +-
+ drivers/clocksource/qsp_clk.c |  161 +++++++++++++++++++++++++++++++++++++++++
+ include/linux/qsp/qsp_clk.h   |   27 +++++++
+ 4 files changed, 197 insertions(+), 1 deletion(-)
+
+diff --git a/drivers/clocksource/Kconfig b/drivers/clocksource/Kconfig
+index 5138927..87936c1 100644
+--- a/drivers/clocksource/Kconfig
++++ b/drivers/clocksource/Kconfig
+@@ -29,3 +29,10 @@ config CLKSRC_DBX500_PRCMU_SCHED_CLOCK
+ 	default y
+ 	help
+ 	  Use the always on PRCMU Timer as sched_clock
++
++config CLK_QSP
++	bool "Clocksource/event support for QSP timers."
++	help
++	  Enable clockevent/clocksource driver for QSP timers.
++
++
+diff --git a/drivers/clocksource/Makefile b/drivers/clocksource/Makefile
+index 8d81a1d..d2ed64dc 100644
+--- a/drivers/clocksource/Makefile
++++ b/drivers/clocksource/Makefile
+@@ -9,4 +9,5 @@ obj-$(CONFIG_SH_TIMER_TMU)	+= sh_tmu.o
+ obj-$(CONFIG_CLKBLD_I8253)	+= i8253.o
+ obj-$(CONFIG_CLKSRC_MMIO)	+= mmio.o
+ obj-$(CONFIG_DW_APB_TIMER)	+= dw_apb_timer.o
+-obj-$(CONFIG_CLKSRC_DBX500_PRCMU)	+= clksrc-dbx500-prcmu.o
+\ No newline at end of file
++obj-$(CONFIG_CLKSRC_DBX500_PRCMU)	+= clksrc-dbx500-prcmu.o
++obj-$(CONFIG_CLK_QSP)	+= qsp_clk.o
+\ No newline at end of file
+diff --git a/drivers/clocksource/qsp_clk.c b/drivers/clocksource/qsp_clk.c
+new file mode 100644
+index 0000000..bc15fec
+--- /dev/null
++++ b/drivers/clocksource/qsp_clk.c
+@@ -0,0 +1,161 @@
++/*
++ * QSP disk controller
++ *
++ * Based on ps3disk.c, xen-blkfront.c and the example block driver in ldd.
++ *
++ * (C) Copyright 2012, Ivar Holmqvist <ivarholmqvist@gmail.com>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ */
++#undef DEBUG
++
++#include <linux/clockchips.h>
++#include <linux/init.h>
++#include <linux/io.h>
++#include <linux/spinlock.h>
++#include <linux/timex.h>
++#include <linux/module.h>
++#include <linux/smp.h>
++#include <linux/irq.h>
++#include <linux/irqreturn.h>
++#include <linux/interrupt.h>
++#include <linux/qsp/qsp_clk.h>
++
++/* TODO:
++ * - This driver only supports 1 instance...
++ * - Cleanup
++ */
++
++DEFINE_RAW_SPINLOCK(qsp_lock);
++
++static void __iomem *clk_base;
++
++#define CLK_ID      0x00
++#define CLK_FREQ    0x04
++#define CLK_COUNT   0x08
++#define CLK_ONESHOT 0x0c
++#define CLK_PERIOD  0x10
++
++cycle_t qsp_read(struct clocksource *cs)
++{
++	return readl(clk_base + CLK_COUNT);
++}
++
++
++static struct clocksource qsp_cs = {
++	.name		= "qsp",
++	.rating		= 110,
++	.read		= qsp_read,
++	.mask		= CLOCKSOURCE_MASK(32),
++};
++
++
++/*
++ * Initialize the QSP timer.
++ *
++ */
++static void init_qsp_timer(enum clock_event_mode mode,
++			   struct clock_event_device *evt)
++{
++	u32 freq;
++	pr_debug("INIT TIMER\n");
++	raw_spin_lock(&qsp_lock);
++
++	switch (mode) {
++	case CLOCK_EVT_MODE_PERIODIC:
++		pr_debug("PERIODIC\n");
++		freq = readl(clk_base + CLK_FREQ);
++		pr_info("Setting up periodic mode freq:%dHz HZ:%dHz\n",
++			freq, HZ);
++		WARN_ON(freq % HZ != 0);
++		writel(freq/HZ, clk_base + CLK_PERIOD);
++		break;
++
++	case CLOCK_EVT_MODE_SHUTDOWN:
++		pr_debug("SHUTDOWN\n");
++		/* Fall-through */
++	case CLOCK_EVT_MODE_UNUSED:
++		pr_debug("UNUSED\n");
++		writel(0, clk_base + CLK_ONESHOT);
++		break;
++
++	case CLOCK_EVT_MODE_ONESHOT:
++		pr_debug("ONESHOT\n");
++		WARN_ON(evt->mode == CLOCK_EVT_MODE_ONESHOT ||
++			evt->mode == CLOCK_EVT_MODE_PERIODIC);
++		/* One shot setup not needed, all is done in next event. */
++		break;
++
++	case CLOCK_EVT_MODE_RESUME:
++		pr_debug("RESUME\n");
++		/* Nothing to do here */
++		break;
++	}
++	raw_spin_unlock(&qsp_lock);
++}
++
++/*
++ * Program the next event in oneshot mode
++ *
++ * Delta is given in QSP ticks
++ */
++static int qsp_next_event(unsigned long delta, struct clock_event_device *evt)
++{
++	WARN_ON(evt->mode != CLOCK_EVT_MODE_ONESHOT);
++	writel(delta, clk_base + CLK_ONESHOT);
++	return 0;
++}
++
++struct clock_event_device qsp_clockevent = {
++	.name		= "qsp",
++	.features	= CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT,
++	.set_mode	= init_qsp_timer,
++	.set_next_event = qsp_next_event,
++};
++
++static irqreturn_t qsp_timer_interrupt(int irq, void *dev_id)
++{
++	struct clock_event_device *evt = dev_id;
++	if (dev_id == NULL) {
++		pr_err("Spurious timer irq %d\n", irq);
++		return IRQ_NONE;
++	}
++	evt->event_handler(evt);
++
++	return IRQ_HANDLED;
++}
++
++static struct irqaction qsp_timer_irq = {
++	.name		= "timer",
++	.flags		= IRQF_TIMER,
++	.handler	= qsp_timer_interrupt,
++	.dev_id		= &qsp_clockevent,
++};
++
++
++/*
++ * Register this timer as both clocksource and clockevent.
++ */
++void __init qsp_timer_init_one(int irq, void __iomem *base)
++{
++	u32 freq;
++
++	/* FIXME: one timer per cpu? arm...
++	 */
++	qsp_clockevent.cpumask = cpumask_of(0);
++
++	freq = readl(base + CLK_FREQ);
++	pr_debug("IRQ %d freq %d\\n", irq, freq);
++	clk_base = base;
++	setup_irq(irq, &qsp_timer_irq);
++	clockevents_config_and_register(&qsp_clockevent, freq,
++					0xF, 0xFFFFFFFF);
++
++	clocksource_register_hz(&qsp_cs, freq);
++}
++
++
++
+diff --git a/include/linux/qsp/qsp_clk.h b/include/linux/qsp/qsp_clk.h
+new file mode 100644
+index 0000000..38271f8
+--- /dev/null
++++ b/include/linux/qsp/qsp_clk.h
+@@ -0,0 +1,27 @@
++/*
++ *  Copyright 2012 Wind River, Inc
++ *
++ *  This program is free software; you can redistribute it and/or modify
++ *  it under the terms of the GNU General Public License as published by
++ *  the Free Software Foundation; either version 2, or (at your option)
++ *  any later version.
++ *
++ *  This program is distributed in the hope that it will be useful,
++ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
++ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ *  GNU General Public License for more details.
++ *
++ *  You should have received a copy of the GNU General Public License
++ *  along with this program; see the file COPYING.  If not, write to
++ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
++ */
++
++#ifndef __LINUX_QSP_CLK_H
++#define __LINUX_QSP_CLK_H
++
++#include <linux/clocksource.h>
++
++void qsp_timer_init_one(int irq, void __iomem *base);
++cycle_t qsp_read(struct clocksource *cs);
++
++#endif /* __LINUX_QSP_PIC_H */
+-- 
+1.7.9.5
+
diff -pNur buildroot.2014.08/board/windriver/qsp-ppc/linux-0016-qsp-led-Initial-support-for-qsp-led-controller.patch buildroot/board/windriver/qsp-ppc/linux-0016-qsp-led-Initial-support-for-qsp-led-controller.patch
--- buildroot.2014.08/board/windriver/qsp-ppc/linux-0016-qsp-led-Initial-support-for-qsp-led-controller.patch	1970-01-01 07:00:00.000000000 +0700
+++ buildroot/board/windriver/qsp-ppc/linux-0016-qsp-led-Initial-support-for-qsp-led-controller.patch	2014-12-09 13:19:53.705729700 +0800
@@ -0,0 +1,272 @@
+From 2f965d8fdd1de67b8e1953ca4b3d5de565f5d446 Mon Sep 17 00:00:00 2001
+From: Ivar Holmqvist <ivarholmqvist@gmail.com>
+Date: Mon, 16 Jul 2012 17:54:10 +0200
+Subject: [PATCH] qsp-led: Initial support for qsp led controller.
+
+---
+ drivers/leds/Kconfig    |    7 ++
+ drivers/leds/Makefile   |    1 +
+ drivers/leds/leds-qsp.c |  222 +++++++++++++++++++++++++++++++++++++++++++++++
+ 3 files changed, 230 insertions(+)
+
+diff --git a/drivers/leds/Kconfig b/drivers/leds/Kconfig
+index ff4b8cf..fb58f03 100644
+--- a/drivers/leds/Kconfig
++++ b/drivers/leds/Kconfig
+@@ -401,6 +401,13 @@ config LEDS_OT200
+ 	  This option enables support for the LEDs on the Bachmann OT200.
+ 	  Say Y to enable LEDs on the Bachmann OT200.
+ 
++config LEDS_QSP
++	bool "LED support for QSP"
++	depends on LEDS_CLASS && QSP
++	default y
++	help
++	  This option enables build of the LED QSP platform driver.
++
+ config LEDS_TRIGGERS
+ 	bool "LED Trigger support"
+ 	depends on LEDS_CLASS
+diff --git a/drivers/leds/Makefile b/drivers/leds/Makefile
+index 890481c..2ffddfa 100644
+--- a/drivers/leds/Makefile
++++ b/drivers/leds/Makefile
+@@ -45,6 +45,7 @@ obj-$(CONFIG_LEDS_NETXBIG)		+= leds-netxbig.o
+ obj-$(CONFIG_LEDS_ASIC3)		+= leds-asic3.o
+ obj-$(CONFIG_LEDS_RENESAS_TPU)		+= leds-renesas-tpu.o
+ obj-$(CONFIG_LEDS_MAX8997)		+= leds-max8997.o
++obj-$(CONFIG_LEDS_QSP)			+= leds-qsp.o
+ 
+ # LED SPI Drivers
+ obj-$(CONFIG_LEDS_DAC124S085)		+= leds-dac124s085.o
+diff --git a/drivers/leds/leds-qsp.c b/drivers/leds/leds-qsp.c
+new file mode 100644
+index 0000000..c95de23
+--- /dev/null
++++ b/drivers/leds/leds-qsp.c
+@@ -0,0 +1,222 @@
++/*
++ * drivers/leds/leds-qsp.c
++ *
++ * LEDs driver for the QSP, driver based on the leds-gpio driver
++ *
++ * Copyright (c) 2012 Wind River Systems, Inc.
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
++ * See the GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
++ *
++ */
++
++#include <linux/kernel.h>
++#include <linux/leds.h>
++#include <linux/of_platform.h>
++#include <linux/of_address.h>
++#include <linux/of_irq.h>
++#include <linux/slab.h>
++#include <linux/module.h>
++#include <linux/io.h>
++#include <linux/qsp/qsp.h>
++
++#define NO_OF_LEDS       16
++
++/* Register offsets */
++#define ID_REG           0x00
++#define LED_REG          0x04
++
++/* LED register bits */
++#define BRIGHTNESS_SHIFT 0
++#define BRIGHTNESS_MASK  0x00000001
++
++struct qsp_led_data {
++	struct led_classdev cdev;
++	unsigned char __iomem *reg;
++};
++
++struct qsp_leds_priv {
++	unsigned char __iomem *membase;
++	int num_leds;
++	struct qsp_led_data leds[NO_OF_LEDS];
++};
++
++static void qsp_led_set(struct led_classdev *led_cdev,
++			enum led_brightness value)
++{
++	struct qsp_led_data *led_data =
++		container_of(led_cdev, struct qsp_led_data, cdev);
++
++	pr_debug("%s: %s = %i\n", __func__, led_data->cdev.name, value);
++	writel(value, led_data->reg);
++}
++
++static enum led_brightness qsp_led_get(struct led_classdev *led_cdev)
++{
++	int value;
++	struct qsp_led_data *led_data =
++		container_of(led_cdev, struct qsp_led_data, cdev);
++
++	value = readl(led_data->reg);
++	pr_debug("%s: %i\n", __func__, value);
++
++	return value & BRIGHTNESS_MASK;
++}
++
++static int qsp_index_get(struct device_node *np)
++{
++	int index;
++
++	if (of_property_read_u32(np, "index", &index)) {
++		pr_warn("LED index not specified (%s)\n", np->name);
++		return -EINVAL;
++	}
++
++	if ((index < 0) || (index >= NO_OF_LEDS)) {
++		pr_warn("LED index outside valid area %i (0 - %i)\n",
++			index, NO_OF_LEDS);
++		return -EINVAL;
++	}
++
++	return index;
++}
++
++static char *qsp_get_led_name(struct device_node *np, struct device_node *child)
++{
++	const char *led_name;
++	const char *ctrl_name;
++	char *led_long_name;
++
++	ctrl_name = of_get_property(np, "label", NULL) ? : np->name;
++	led_name  = of_get_property(child, "label", NULL) ? : child->name;
++
++	led_long_name = kmalloc(strlen(ctrl_name) + strlen(led_name) + 2,
++				GFP_KERNEL);
++	BUG_ON(led_long_name == NULL);
++
++	strcpy(led_long_name, ctrl_name);
++	strcat(led_long_name, "-");
++	strcat(led_long_name, led_name);
++	return led_long_name;
++}
++
++static struct qsp_leds_priv * __devinit qsp_leds_create_of(
++	struct platform_device *pdev)
++{
++	struct device_node *np = pdev->dev.of_node, *child;
++	struct qsp_leds_priv *priv;
++	int ret;
++
++	dev_dbg(&pdev->dev, "%s: Controller %s\n", __func__, np->name);
++
++	priv = kzalloc(sizeof(struct qsp_leds_priv), GFP_KERNEL);
++	if (!priv)
++		return NULL;
++
++	priv->membase = of_iomap(pdev->dev.of_node, 0);
++	if (priv->membase == NULL)
++		goto err1;
++
++	if (qsp_device_valid(priv->membase, QSP_LED_ID_VAL) != 0)
++		goto err2;
++
++	for_each_child_of_node(np, child) {
++		struct qsp_led_data *led_data;
++		int index;
++
++		if (priv->num_leds >= NO_OF_LEDS) {
++			dev_warn(&pdev->dev, "To many LEDS defined in DTB\n");
++			break;
++		}
++
++		led_data = &priv->leds[priv->num_leds];
++
++		index = qsp_index_get(child);
++		if (index < 0)
++			continue;
++
++		led_data->reg = priv->membase + (LED_REG + index * 4);
++		led_data->cdev.name = qsp_get_led_name(np, child);
++		led_data->cdev.default_trigger =
++			of_get_property(child, "linux,default-trigger", NULL);
++		led_data->cdev.brightness_set = qsp_led_set;
++		led_data->cdev.brightness_get = qsp_led_get;
++		led_data->cdev.brightness = 0; /* LED_OFF */
++		led_data->cdev.max_brightness = 1;
++
++		ret = led_classdev_register(&pdev->dev, &led_data->cdev);
++		if (ret < 0) {
++			dev_err(&pdev->dev, "Can't register LED device (%i)\n",
++				ret);
++			goto err2;
++		}
++
++		priv->num_leds++;
++	}
++	return priv;
++
++err2:
++	iounmap(priv->membase);
++err1:
++	kfree(priv);
++	return NULL;
++}
++
++static int __devinit qsp_led_probe(struct platform_device *pdev)
++{
++	struct qsp_leds_priv *priv;
++
++	priv = qsp_leds_create_of(pdev);
++	if (!priv)
++		return -ENODEV;
++
++	platform_set_drvdata(pdev, priv);
++
++	return 0;
++}
++
++static int __devexit qsp_led_remove(struct platform_device *pdev)
++{
++	struct qsp_leds_priv *priv = platform_get_drvdata(pdev);
++	int i;
++
++	for (i = 0; i < priv->num_leds; i++)
++		led_classdev_unregister(&priv->leds[i].cdev);
++
++	platform_set_drvdata(pdev, NULL);
++	iounmap(priv->membase);
++
++	kfree(priv);
++	return 0;
++}
++
++static const struct of_device_id of_qsp_leds_match[] = {
++	{ .compatible = "leds-qsp", },
++	{ },
++};
++
++static struct platform_driver qsp_led_driver = {
++	.probe = qsp_led_probe,
++	.remove = __devexit_p(qsp_led_remove),
++	.driver = {
++		.name = "qsp-leds",
++		.owner = THIS_MODULE,
++		.of_match_table = of_qsp_leds_match,
++	},
++};
++
++module_platform_driver(qsp_led_driver);
++
++MODULE_LICENSE("GPL v2");
++MODULE_DESCRIPTION("LED support for QSP");
++MODULE_AUTHOR("Anders Wallin <anders.wallin@windriver.com>");
+-- 
+1.7.9.5
+
diff -pNur buildroot.2014.08/board/windriver/qsp-ppc/linux-0017-qsp-rtc-Initial-support-for-qsp-rtc.patch buildroot/board/windriver/qsp-ppc/linux-0017-qsp-rtc-Initial-support-for-qsp-rtc.patch
--- buildroot.2014.08/board/windriver/qsp-ppc/linux-0017-qsp-rtc-Initial-support-for-qsp-rtc.patch	1970-01-01 07:00:00.000000000 +0700
+++ buildroot/board/windriver/qsp-ppc/linux-0017-qsp-rtc-Initial-support-for-qsp-rtc.patch	2014-12-09 13:19:53.705729700 +0800
@@ -0,0 +1,190 @@
+From 9794864867077fdf31912aadbead36d3821f3f07 Mon Sep 17 00:00:00 2001
+From: Ivar Holmqvist <ivarholmqvist@gmail.com>
+Date: Mon, 16 Jul 2012 17:54:50 +0200
+Subject: [PATCH] qsp-rtc: Initial support for qsp rtc.
+
+---
+ drivers/rtc/Kconfig   |    7 +++
+ drivers/rtc/Makefile  |    1 +
+ drivers/rtc/rtc-qsp.c |  145 +++++++++++++++++++++++++++++++++++++++++++++++++
+ 3 files changed, 153 insertions(+)
+
+diff --git a/drivers/rtc/Kconfig b/drivers/rtc/Kconfig
+index 8c8377d..88979c4 100644
+--- a/drivers/rtc/Kconfig
++++ b/drivers/rtc/Kconfig
+@@ -1087,4 +1087,11 @@ config RTC_DRV_LOONGSON1
+ 	  This driver can also be built as a module. If so, the module
+ 	  will be called rtc-ls1x.
+ 
++config RTC_DRV_QSP
++	tristate "RTC support for QSP"
++	depends on RTC_CLASS || QSP
++	default y
++	help
++	  This option enables build of the RTC QSP platform driver.
++
+ endif # RTC_CLASS
+diff --git a/drivers/rtc/Makefile b/drivers/rtc/Makefile
+index 727ae77..04a0236 100644
+--- a/drivers/rtc/Makefile
++++ b/drivers/rtc/Makefile
+@@ -111,3 +111,4 @@ obj-$(CONFIG_RTC_DRV_VT8500)	+= rtc-vt8500.o
+ obj-$(CONFIG_RTC_DRV_WM831X)	+= rtc-wm831x.o
+ obj-$(CONFIG_RTC_DRV_WM8350)	+= rtc-wm8350.o
+ obj-$(CONFIG_RTC_DRV_X1205)	+= rtc-x1205.o
++obj-$(CONFIG_RTC_DRV_QSP)	+= rtc-qsp.o
+diff --git a/drivers/rtc/rtc-qsp.c b/drivers/rtc/rtc-qsp.c
+new file mode 100644
+index 0000000..ac7df87
+--- /dev/null
++++ b/drivers/rtc/rtc-qsp.c
+@@ -0,0 +1,145 @@
++/*
++ * .../drivers/rtc/rtc-qsp.c
++ *
++ * Real-time clock driver for the QSP platform
++ *
++ * Copyright (c) 2012 Wind River Systems, Inc.
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
++ * See the GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
++ *
++ */
++
++#include <linux/init.h>
++#include <linux/module.h>
++#include <linux/rtc.h>
++#include <linux/of_device.h>
++#include <linux/of_platform.h>
++#include <linux/of_address.h>
++#include <linux/io.h>
++#include <linux/slab.h>
++#include <linux/qsp/qsp.h>
++
++/* Register offsets */
++#define ID_REG           0x00
++#define TIME_REG         0x04
++#define OFFSET_REG       0x08
++
++struct qsp_rtc_priv {
++	unsigned char __iomem *membase;
++	struct rtc_device *rtc;
++};
++
++static int qsp_rtc_read_time(struct device *dev, struct rtc_time *tm)
++{
++	struct qsp_rtc_priv *priv = dev_get_drvdata(dev);
++	unsigned long now;
++
++	now = readl(priv->membase + TIME_REG) +
++		readl(priv->membase + OFFSET_REG);
++	pr_debug("%s: %li\n", __func__, now);
++	rtc_time_to_tm(now, tm);
++
++	return 0;
++}
++
++
++static int qsp_rtc_set_time(struct device *dev, struct rtc_time *tm)
++{
++	struct qsp_rtc_priv *priv = dev_get_drvdata(dev);
++	unsigned long now;
++
++	rtc_tm_to_time(tm, &now);
++	now = now - readl(priv->membase + TIME_REG);
++
++	pr_debug("%s: %li\n", __func__, now);
++	writel(now, priv->membase + OFFSET_REG);
++
++	return 0;
++}
++
++static const struct rtc_class_ops qsp_rtc_ops = {
++	.read_time = qsp_rtc_read_time,
++	.set_time = qsp_rtc_set_time,
++};
++
++static int __devinit qsp_rtc_probe(struct platform_device *pdev)
++{
++	struct qsp_rtc_priv *priv;
++
++	dev_dbg(&pdev->dev, "%s\n", __func__);
++
++	priv = kzalloc(sizeof(struct qsp_rtc_priv), GFP_KERNEL);
++	if (!priv)
++		return -ENODEV;
++
++	priv->membase = of_iomap(pdev->dev.of_node, 0);
++	if (priv->membase == NULL)
++		goto err1;
++
++	if (qsp_device_valid(priv->membase, QSP_RTC_ID_VAL) != 0)
++		goto err2;
++
++	platform_set_drvdata(pdev, priv);
++
++	priv->rtc = rtc_device_register("qsp-rtc", &pdev->dev,
++					&qsp_rtc_ops, THIS_MODULE);
++	if (IS_ERR_OR_NULL(priv->rtc)) {
++		dev_err(&pdev->dev, "Can't register RTC device (%p)\n",
++			priv->rtc);
++		goto err2;
++	}
++
++	return 0;
++
++err2:
++	iounmap(priv->membase);
++err1:
++	kfree(priv);
++	return -ENODEV;
++}
++
++static int __devexit qsp_rtc_remove(struct platform_device *pdev)
++{
++	struct qsp_rtc_priv *priv = platform_get_drvdata(pdev);
++
++	dev_dbg(&pdev->dev, "%s\n", __func__);
++
++	rtc_device_unregister(priv->rtc);
++	platform_set_drvdata(pdev, NULL);
++	iounmap(priv->membase);
++	kfree(priv);
++
++	return 0;
++}
++
++static struct of_device_id of_qsp_rtc_match[] __devinitdata = {
++	{ .compatible = "qsp-rtc", },
++	{},
++};
++
++static struct platform_driver qsp_rtc_driver = {
++	.probe = qsp_rtc_probe,
++	.remove = __devexit_p(qsp_rtc_remove),
++	.driver = {
++		.name = "qsp-rtc",
++		.owner = THIS_MODULE,
++		.of_match_table = of_qsp_rtc_match,
++	},
++};
++
++module_platform_driver(qsp_rtc_driver);
++
++MODULE_LICENSE("GPL v2");
++MODULE_DESCRIPTION("LED support for QSP");
++MODULE_AUTHOR("Anders Wallin <anders.wallin@windriver.com>");
+-- 
+1.7.9.5
+
diff -pNur buildroot.2014.08/board/windriver/qsp-ppc/linux-0018-qsp-flash-Initial-support-for-qsp-flash-controller.patch buildroot/board/windriver/qsp-ppc/linux-0018-qsp-flash-Initial-support-for-qsp-flash-controller.patch
--- buildroot.2014.08/board/windriver/qsp-ppc/linux-0018-qsp-flash-Initial-support-for-qsp-flash-controller.patch	1970-01-01 07:00:00.000000000 +0700
+++ buildroot/board/windriver/qsp-ppc/linux-0018-qsp-flash-Initial-support-for-qsp-flash-controller.patch	2014-12-09 13:19:53.705729700 +0800
@@ -0,0 +1,293 @@
+From b1e783d6a7cdbd4a35f0e6471c0fa3962d927df7 Mon Sep 17 00:00:00 2001
+From: Ivar Holmqvist <ivarholmqvist@gmail.com>
+Date: Mon, 16 Jul 2012 17:55:45 +0200
+Subject: [PATCH] qsp-flash: Initial support for qsp flash controller.
+
+---
+ drivers/mtd/chips/Kconfig     |    9 ++
+ drivers/mtd/chips/Makefile    |    1 +
+ drivers/mtd/chips/qsp-flash.c |  219 +++++++++++++++++++++++++++++++++++++++++
+ drivers/mtd/maps/Kconfig      |    2 +-
+ drivers/mtd/maps/physmap.c    |    1 +
+ 5 files changed, 231 insertions(+), 1 deletion(-)
+
+diff --git a/drivers/mtd/chips/Kconfig b/drivers/mtd/chips/Kconfig
+index b1e3c26..e3cca7d 100644
+--- a/drivers/mtd/chips/Kconfig
++++ b/drivers/mtd/chips/Kconfig
+@@ -239,4 +239,13 @@ config MTD_XIP
+ 	  used for XIP purposes.  If you're not sure what this is all about
+ 	  then say N.
+ 
++config MTD_QSP_FLASH
++	tristate "MTD Driver for QSP Flash"
++	help
++	  The MTD driver for the QSP platform is very simple and has three
++	  states:
++	  - READ_ARRAY_MODE (initial state)
++	  - WRITE_MODE
++	  - PROPERTY_QUERY_MODE
++
+ endmenu
+diff --git a/drivers/mtd/chips/Makefile b/drivers/mtd/chips/Makefile
+index 3658241..19bb09b 100644
+--- a/drivers/mtd/chips/Makefile
++++ b/drivers/mtd/chips/Makefile
+@@ -13,3 +13,4 @@ obj-$(CONFIG_MTD_JEDECPROBE)	+= jedec_probe.o
+ obj-$(CONFIG_MTD_RAM)		+= map_ram.o
+ obj-$(CONFIG_MTD_ROM)		+= map_rom.o
+ obj-$(CONFIG_MTD_ABSENT)	+= map_absent.o
++obj-$(CONFIG_MTD_QSP_FLASH)	+= qsp-flash.o
+diff --git a/drivers/mtd/chips/qsp-flash.c b/drivers/mtd/chips/qsp-flash.c
+new file mode 100644
+index 0000000..c5f1781
+--- /dev/null
++++ b/drivers/mtd/chips/qsp-flash.c
+@@ -0,0 +1,219 @@
++/*
++ * drivers/mtd/chips/qsp-flash.c
++ *
++ * Flash driver for the QSP platform
++ *
++ * Copyright (c) 2012 Wind River Systems, Inc.
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
++ * See the GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
++ *
++ */
++
++#include <linux/module.h>
++#include <linux/types.h>
++#include <linux/kernel.h>
++#include <linux/io.h>
++#include <asm/byteorder.h>
++#include <linux/errno.h>
++#include <linux/slab.h>
++#include <linux/init.h>
++#include <linux/mtd/mtd.h>
++#include <linux/mtd/map.h>
++#include <linux/qsp/qsp.h>
++
++#define DEVICE_TYPE "QSP Flash"
++
++static int qsp_flash_read(struct mtd_info *, loff_t, size_t,
++			  size_t *, u_char *);
++static int qsp_flash_write(struct mtd_info *, loff_t, size_t,
++			   size_t *, const u_char *);
++static int qsp_flash_erase(struct mtd_info *, struct erase_info *);
++static void qsp_flash_nop(struct mtd_info *);
++static struct mtd_info *qsp_flash_probe(struct map_info *map);
++static unsigned long qsp_flash_unmapped_area(struct mtd_info *, unsigned long,
++					     unsigned long, unsigned long);
++
++static struct mtd_chip_driver qsp_flash_chipdrv = {
++	.probe	= qsp_flash_probe,
++	.name	= "qsp-flash",
++	.module	= THIS_MODULE
++};
++
++static uint32_t flash_property_at(struct map_info *map, uint32_t at)
++{
++	volatile uint32_t *flash = (uint32_t *)map->virt;
++	*flash = 0xd00dd00d;
++	flash += at;
++	return *flash;
++}
++
++static struct mtd_info *qsp_flash_probe(struct map_info *map)
++{
++	struct mtd_info *mtd;
++	uint32_t fl_size = 0;
++	pr_info(DEVICE_TYPE ": Probing Chip at %p (virt) / 0x%x (phys)\n",
++		map->virt, map->phys);
++
++	if (flash_property_at(map, 0) == QSP_FLASH_ID_VAL)
++		pr_info(DEVICE_TYPE ": Detected QSP Flash!\n");
++	else
++		return NULL;
++
++	fl_size = flash_property_at(map, 1);
++	pr_info(DEVICE_TYPE ": Detected Size of 0x%x!\n", fl_size);
++	if (fl_size != map->size) {
++		pr_info(DEVICE_TYPE ": Size does not match kernel config!\n");
++		return NULL;
++	}
++
++	mtd = kzalloc(sizeof(*mtd), GFP_KERNEL);
++	if (!mtd)
++		return NULL;
++
++	map->fldrv = &qsp_flash_chipdrv;
++	mtd->priv = map;
++	mtd->name = map->name;
++	mtd->type = MTD_NORFLASH;
++	mtd->size = map->size;
++	mtd->_erase = qsp_flash_erase;
++	mtd->_get_unmapped_area = qsp_flash_unmapped_area;
++	mtd->_read = qsp_flash_read;
++	mtd->_write = qsp_flash_write;
++	mtd->_sync = qsp_flash_nop;
++	mtd->flags = MTD_CAP_NORFLASH;
++	mtd->writesize = 1;
++
++	mtd->erasesize = PAGE_SIZE;
++	while (mtd->size & (mtd->erasesize - 1))
++		mtd->erasesize >>= 1;
++
++	__module_get(THIS_MODULE);
++	return mtd;
++}
++
++/* Allow NOMMU mmap() to directly map the device (if not NULL)
++ * - return the address to which the offset maps
++ * - return -ENOSYS to indicate refusal to do the mapping
++ */
++static unsigned long qsp_flash_unmapped_area(struct mtd_info *mtd,
++					     unsigned long len,
++					     unsigned long offset,
++					     unsigned long flags)
++{
++	struct map_info *map = mtd->priv;
++	return (unsigned long) map->virt + offset;
++}
++
++static int qsp_flash_read(struct mtd_info *mtd, loff_t from,
++			  size_t len, size_t *retlen, u_char *buf)
++{
++	struct map_info *map = mtd->priv;
++	map_copy_from(map, buf, from, len);
++	*retlen = len;
++	return 0;
++}
++
++static int qsp_flash_write(struct mtd_info *mtd, loff_t to,
++			   size_t len, size_t *retlen, const u_char *buf)
++{
++	struct map_info *map = mtd->priv;
++	volatile uint8_t *flash = map->virt + to;
++	unsigned int i, num, left;
++	volatile uint32_t *aligned;
++	uint32_t data;
++
++	num = (uint32_t)to & 0x3;
++	aligned = (volatile uint32_t *)((unsigned long)flash - num);
++	left = len;
++
++	if (num != 0) {
++		data = *aligned;
++
++		for (i = num ; i < 4; i++) {
++			data &= ~(0xFF << ((3 - i) * 8));
++			data |= ((*(buf + i - num)) << ((3 - i) * 8));
++		}
++
++		*aligned = 0xdeadbeef;
++		*aligned = data;
++
++		buf  += (4 - num);
++		left -= (4 - num);
++		aligned++;
++	}
++
++	while (left >= 4) {
++		data = *(uint32_t *)buf;
++		*aligned = 0xdeadbeef;
++		*aligned = data;
++		buf  += 4;
++		left -= 4;
++		aligned++;
++	}
++
++	if (left > 0) {
++		data = *aligned;
++
++		for (i = 0 ; i < left; i++) {
++			data &= ~(0xFF << ((3 - i) * 8));
++			data |= ((*(buf + i)) << ((3 - i) * 8));
++		}
++
++		*aligned = 0xdeadbeef;
++		*aligned = data;
++	}
++
++	*retlen = len;
++	return 0;
++}
++
++static int qsp_flash_erase(struct mtd_info *mtd, struct erase_info *instr)
++{
++	struct map_info *map = mtd->priv;
++	unsigned long i;
++	volatile uint32_t *flash =
++		(volatile uint32_t *)((uint8_t *)map->virt + instr->addr);
++
++	for (i = 0; i < instr->len; i += 4) {
++		*flash = 0xdeadbeef;
++		*flash = 0xffffffff;
++		flash++;
++	}
++	instr->state = MTD_ERASE_DONE;
++	mtd_erase_callback(instr);
++	return 0;
++}
++
++static void qsp_flash_nop(struct mtd_info *mtd)
++{
++	/* Nothing to see here */
++}
++
++static int __init qsp_flash_init(void)
++{
++	pr_info("QSP FLash Init");
++	register_mtd_chip_driver(&qsp_flash_chipdrv);
++	return 0;
++}
++
++static void __exit qsp_flash_exit(void)
++{
++	unregister_mtd_chip_driver(&qsp_flash_chipdrv);
++}
++module_init(qsp_flash_init);
++module_exit(qsp_flash_exit);
++
++MODULE_LICENSE("GPL v2");
++MODULE_AUTHOR("Wind River");
++MODULE_DESCRIPTION("MTD chip driver for QSP Flash");
+diff --git a/drivers/mtd/maps/Kconfig b/drivers/mtd/maps/Kconfig
+index 8af67cf..b5529f2 100644
+--- a/drivers/mtd/maps/Kconfig
++++ b/drivers/mtd/maps/Kconfig
+@@ -10,7 +10,7 @@ config MTD_COMPLEX_MAPPINGS
+ 
+ config MTD_PHYSMAP
+ 	tristate "Flash device in physical memory map"
+-	depends on MTD_CFI || MTD_JEDECPROBE || MTD_ROM || MTD_LPDDR
++	depends on MTD_CFI || MTD_JEDECPROBE || MTD_ROM || MTD_LPDDR || MTD_QSP_FLASH
+ 	help
+ 	  This provides a 'mapping' driver which allows the NOR Flash and
+ 	  ROM driver code to communicate with chips which are mapped
+diff --git a/drivers/mtd/maps/physmap.c b/drivers/mtd/maps/physmap.c
+index 21b0b71..32e3591 100644
+--- a/drivers/mtd/maps/physmap.c
++++ b/drivers/mtd/maps/physmap.c
+@@ -92,6 +92,7 @@ static const char *rom_probe_types[] = {
+ 					"jedec_probe",
+ 					"qinfo_probe",
+ 					"map_rom",
++					"qsp-flash",
+ 					NULL };
+ static const char *part_probe_types[] = { "cmdlinepart", "RedBoot", "afs",
+ 					  NULL };
+-- 
+1.7.9.5
+
diff -pNur buildroot.2014.08/board/windriver/qsp-ppc/linux-0019-qsp-serial-Initial-support-for-qsp-serial-controller.patch buildroot/board/windriver/qsp-ppc/linux-0019-qsp-serial-Initial-support-for-qsp-serial-controller.patch
--- buildroot.2014.08/board/windriver/qsp-ppc/linux-0019-qsp-serial-Initial-support-for-qsp-serial-controller.patch	1970-01-01 07:00:00.000000000 +0700
+++ buildroot/board/windriver/qsp-ppc/linux-0019-qsp-serial-Initial-support-for-qsp-serial-controller.patch	2014-12-09 13:19:53.705729700 +0800
@@ -0,0 +1,595 @@
+From 27b261fe078910fda86c7db5c8bb6b680388a269 Mon Sep 17 00:00:00 2001
+From: Ivar Holmqvist <ivarholmqvist@gmail.com>
+Date: Mon, 16 Jul 2012 17:58:40 +0200
+Subject: [PATCH] qsp-serial: Initial support for qsp serial controller.
+
+---
+ drivers/tty/serial/Kconfig    |   24 ++
+ drivers/tty/serial/Makefile   |    1 +
+ drivers/tty/serial/qsp_uart.c |  518 +++++++++++++++++++++++++++++++++++++++++
+ include/linux/serial_core.h   |    3 +
+ 4 files changed, 546 insertions(+)
+
+diff --git a/drivers/tty/serial/Kconfig b/drivers/tty/serial/Kconfig
+index 070b442..8b6b983 100644
+--- a/drivers/tty/serial/Kconfig
++++ b/drivers/tty/serial/Kconfig
+@@ -1360,4 +1360,28 @@ config SERIAL_EFM32_UART_CONSOLE
+ 	depends on SERIAL_EFM32_UART=y
+ 	select SERIAL_CORE_CONSOLE
+ 
++config SERIAL_QSP_UART
++	tristate "QSP uart/serial support"
++	default y if QSP
++	select SERIAL_CORE
++	help
++	  This driver supports the QSP serial/uart.
++
++config SERIAL_QSP_MAXPORTS
++	int "Maximum number of QSP UART ports"
++	depends on SERIAL_QSP_UART
++	default 16
++	help
++	  This setting lets you define the maximum number of the QSP
++	  UART ports. The usual default varies from board to board, and
++	  this setting is a way of catering for that.
++
++config SERIAL_QSP_CONSOLE
++	bool "QSP UART console support"
++	depends on SERIAL_QSP_UART=y
++	select SERIAL_CORE_CONSOLE
++	help
++	  Enable a QSP UART port to be the system console.
++
++
+ endmenu
+diff --git a/drivers/tty/serial/Makefile b/drivers/tty/serial/Makefile
+index 7257c5d..07c1e30 100644
+--- a/drivers/tty/serial/Makefile
++++ b/drivers/tty/serial/Makefile
+@@ -79,3 +79,4 @@ obj-$(CONFIG_SERIAL_XILINX_PS_UART) += xilinx_uartps.o
+ obj-$(CONFIG_SERIAL_SIRFSOC) += sirfsoc_uart.o
+ obj-$(CONFIG_SERIAL_AR933X)   += ar933x_uart.o
+ obj-$(CONFIG_SERIAL_EFM32_UART) += efm32-uart.o
++obj-$(CONFIG_SERIAL_QSP_UART) += qsp_uart.o
+diff --git a/drivers/tty/serial/qsp_uart.c b/drivers/tty/serial/qsp_uart.c
+new file mode 100644
+index 0000000..bead678
+--- /dev/null
++++ b/drivers/tty/serial/qsp_uart.c
+@@ -0,0 +1,518 @@
++/*
++ * qsp_uart.c -- QSP Serial driver
++ *
++ * Based on altera_uart.c -- Altera UART driver
++ *
++ * (C) Copyright 2012, Ivar Holmqvist <ivarholmqvist@gmail.com>
++ * (C) Copyright 2003-2007, Greg Ungerer <gerg@snapgear.com>
++ * (C) Copyright 2008, Thomas Chou <thomas@wytron.com.tw>
++ * (C) Copyright 2010, Tobias Klauser <tklauser@distanz.ch>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ */
++#include <linux/kernel.h>
++#include <linux/init.h>
++#include <linux/timer.h>
++#include <linux/interrupt.h>
++#include <linux/module.h>
++#include <linux/console.h>
++#include <linux/tty.h>
++#include <linux/tty_flip.h>
++#include <linux/serial.h>
++#include <linux/serial_core.h>
++#include <linux/platform_device.h>
++#include <linux/of_address.h>
++#include <linux/of_irq.h>
++#include <linux/of.h>
++#include <linux/io.h>
++#include <linux/device.h>
++
++#include <linux/qsp/qsp.h>
++
++#define DRV_NAME "qsp_uart"
++#define SERIAL_QSP_MAJOR 204
++#define SERIAL_QSP_MINOR 16
++
++#define CONFIG_SERIAL_QSP_UART_MAXPORTS 32
++#define QSP_UART_SIZE			32
++
++/* Register offfsets
++ */
++#define ID_REG      0x00
++#define STATUS_REG  0x04
++#define CONTROL_REG 0x08
++#define TXDATA_REG  0x0c
++#define RXDATA_REG  0x10
++
++/* Status register bits
++ */
++#define TX_READY (1<<0)
++#define RX_READY (1<<1)
++
++/* Control register bits
++ */
++#define TX_INT (1<<0)
++#define RX_INT (1<<1)
++
++/*
++ * Local per-uart structure.
++ */
++struct qsp_uart {
++	struct uart_port port;
++	int irq;
++};
++
++static u32 qsp_uart_readl(struct uart_port *port, int reg)
++{
++	return readl(port->membase + (reg << port->regshift));
++}
++
++static void qsp_uart_writel(struct uart_port *port, u32 dat, int reg)
++{
++	writel(dat, port->membase + (reg << port->regshift));
++}
++
++static unsigned int qsp_uart_tx_empty(struct uart_port *port)
++{
++	return (qsp_uart_readl(port, STATUS_REG) & TX_READY) ? TIOCSER_TEMT : 0;
++}
++
++/* No modem control lines
++ */
++static unsigned int qsp_uart_get_mctrl(struct uart_port *port)
++{
++	return TIOCM_CAR | TIOCM_DSR | TIOCM_CTS;
++}
++
++static void qsp_uart_set_mctrl(struct uart_port *port, unsigned int mctrl)
++{
++}
++
++static void qsp_uart_start_tx(struct uart_port *port)
++{
++	u32 pre;
++
++	pre = qsp_uart_readl(port, CONTROL_REG);
++	qsp_uart_writel(port, pre|TX_INT, CONTROL_REG);
++}
++
++static void qsp_uart_stop_tx(struct uart_port *port)
++{
++	u32 pre;
++
++	pre = qsp_uart_readl(port, CONTROL_REG);
++	qsp_uart_writel(port, pre & ~TX_INT, CONTROL_REG);
++}
++
++static void qsp_uart_stop_rx(struct uart_port *port)
++{
++	u32 pre;
++
++	pre = qsp_uart_readl(port, CONTROL_REG);
++	qsp_uart_writel(port, pre & ~RX_INT, CONTROL_REG);
++}
++
++static void qsp_uart_break_ctl(struct uart_port *port, int break_state)
++{
++	dev_dbg(port->dev, "ignoring break_ctl\n");
++}
++
++static void qsp_uart_enable_ms(struct uart_port *port)
++{
++	dev_dbg(port->dev, "ignoring enable_ms\n");
++}
++
++static void qsp_uart_set_termios(struct uart_port *port,
++				    struct ktermios *termios,
++				    struct ktermios *old)
++{
++	unsigned int baud;
++
++	baud = uart_get_baud_rate(port, termios, old, 0, 4000000);
++
++	if (old)
++		tty_termios_copy_hw(termios, old);
++	tty_termios_encode_baud_rate(termios, baud, baud);
++
++	uart_update_timeout(port, termios->c_cflag, baud);
++}
++
++static void qsp_uart_rx_chars(struct qsp_uart *pp)
++{
++	struct uart_port *port = &pp->port;
++	unsigned char ch, flag;
++	unsigned short status;
++
++	while ((status = qsp_uart_readl(port, STATUS_REG)) &
++	       RX_READY) {
++		ch = qsp_uart_readl(port, RXDATA_REG);
++		flag = TTY_NORMAL;
++		port->icount.rx++;
++
++		/* There is no possibility to errors on this HW (i.e framing
++		 * etc) so there's no other icount updates and we always
++		 * return TTY_NORMAL.
++		 */
++
++		if (uart_handle_sysrq_char(port, ch))
++			continue;
++
++		/* RX Ovverun not supported by HW, so we skip passing
++		 * status/mask for that.
++		 */
++		uart_insert_char(port, 0, 0, ch, flag);
++	}
++
++	tty_flip_buffer_push(port->state->port.tty);
++}
++
++static void qsp_uart_tx_chars(struct qsp_uart *pp)
++{
++	struct uart_port *port = &pp->port;
++	struct circ_buf *xmit = &port->state->xmit;
++
++	if (port->x_char) {
++		/* Send special char - probably flow control */
++		qsp_uart_writel(port, port->x_char, TXDATA_REG);
++		port->x_char = 0;
++		port->icount.tx++;
++		return;
++	}
++
++	while (qsp_uart_readl(port, STATUS_REG) &
++	       TX_READY) {
++		if (xmit->head == xmit->tail)
++			break;
++		qsp_uart_writel(port, xmit->buf[xmit->tail],
++		       TXDATA_REG);
++		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
++		port->icount.tx++;
++	}
++
++	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
++		uart_write_wakeup(port);
++
++	if (xmit->head == xmit->tail) {
++		qsp_uart_writel(port,
++				   qsp_uart_readl(port, CONTROL_REG) & ~TX_INT,
++				   CONTROL_REG);
++	}
++}
++
++static irqreturn_t qsp_uart_interrupt(int irq, void *data)
++{
++	struct uart_port *port = data;
++	struct qsp_uart *pp = container_of(port, struct qsp_uart, port);
++	unsigned int isr;
++
++	isr = qsp_uart_readl(port, STATUS_REG) &
++		qsp_uart_readl(port, CONTROL_REG);
++
++	spin_lock(&port->lock);
++	if (isr & RX_READY)
++		qsp_uart_rx_chars(pp);
++	if (isr & TX_READY)
++		qsp_uart_tx_chars(pp);
++	spin_unlock(&port->lock);
++
++	return IRQ_RETVAL(isr);
++}
++
++static void qsp_uart_config_port(struct uart_port *port, int flags)
++{
++	port->type = PORT_QSP_UART;
++
++	/* Clear interrupt mask */
++	qsp_uart_writel(port, 0, CONTROL_REG);
++}
++
++static int qsp_uart_startup(struct uart_port *port)
++{
++	int ret;
++	unsigned long flags;
++	u32 pre;
++
++	dev_dbg(port->dev, "startup\n");
++
++	port->irq = irq_of_parse_and_map(port->dev->of_node,  0);
++	if (!port->irq) {
++		dev_err(port->dev, "IRQ not specified in dtb\n");
++		return -EINVAL;
++	}
++	dev_dbg(port->dev, "got irq %d\n", port->irq);
++
++	ret = request_irq(port->irq, qsp_uart_interrupt, 0,
++			DRV_NAME, port);
++	if (ret) {
++		pr_err(DRV_NAME ": unable to attach Adp UART %d "
++		       "interrupt vector=%d\n", port->line, port->irq);
++		return ret;
++	}
++
++	/* Enable RX interrupts now */
++	spin_lock_irqsave(&port->lock, flags);
++	pre = qsp_uart_readl(port, CONTROL_REG);
++	qsp_uart_writel(port, pre | RX_INT, CONTROL_REG);
++	spin_unlock_irqrestore(&port->lock, flags);
++
++	return 0;
++}
++
++static void qsp_uart_shutdown(struct uart_port *port)
++{
++	unsigned long flags;
++
++	spin_lock_irqsave(&port->lock, flags);
++
++	/* Disable all interrupts now */
++	qsp_uart_writel(port, 0, CONTROL_REG);
++
++	spin_unlock_irqrestore(&port->lock, flags);
++
++	free_irq(port->irq, port);
++}
++
++static const char *qsp_uart_type(struct uart_port *port)
++{
++	return (port->type == PORT_QSP_UART) ? "QSP UART" : NULL;
++}
++
++static int qsp_uart_request_port(struct uart_port *port)
++{
++	/* Resources taken in probe. */
++	dev_dbg(port->dev, "request port\n");
++	return 0;
++}
++
++static void qsp_uart_release_port(struct uart_port *port)
++{
++	/* Nothing to release... */
++	dev_dbg(port->dev, "release port\n");
++}
++
++static int qsp_uart_verify_port(struct uart_port *port,
++				   struct serial_struct *ser)
++{
++	if ((ser->type != PORT_UNKNOWN) && (ser->type != PORT_QSP_UART))
++		return -EINVAL;
++	return 0;
++}
++
++/* Define the basic serial functions we support.
++ */
++static struct uart_ops qsp_uart_ops = {
++	.tx_empty	= qsp_uart_tx_empty,
++	.get_mctrl	= qsp_uart_get_mctrl,
++	.set_mctrl	= qsp_uart_set_mctrl,
++	.start_tx	= qsp_uart_start_tx,
++	.stop_tx	= qsp_uart_stop_tx,
++	.stop_rx	= qsp_uart_stop_rx,
++	.enable_ms	= qsp_uart_enable_ms,
++	.break_ctl	= qsp_uart_break_ctl,
++	.startup	= qsp_uart_startup,
++	.shutdown	= qsp_uart_shutdown,
++	.set_termios	= qsp_uart_set_termios,
++	.type		= qsp_uart_type,
++	.request_port	= qsp_uart_request_port,
++	.release_port	= qsp_uart_release_port,
++	.config_port	= qsp_uart_config_port,
++	.verify_port	= qsp_uart_verify_port,
++};
++
++static struct qsp_uart qsp_uart_ports[CONFIG_SERIAL_QSP_MAXPORTS];
++
++#if defined(CONFIG_SERIAL_QSP_CONSOLE)
++
++
++static void qsp_uart_console_putc(struct uart_port *port, const char c)
++{
++	while (!(qsp_uart_readl(port, STATUS_REG) &
++		 TX_READY))
++		cpu_relax();
++
++	qsp_uart_writel(port, c, TXDATA_REG);
++}
++
++static void qsp_uart_console_write(struct console *co, const char *s,
++				      unsigned int count)
++{
++	struct uart_port *port = &(qsp_uart_ports + co->index)->port;
++
++	for (; count; count--, s++) {
++		qsp_uart_console_putc(port, *s);
++		if (*s == '\n')
++			qsp_uart_console_putc(port, '\r');
++	}
++}
++
++static int __init qsp_uart_console_setup(struct console *co, char *options)
++{
++	struct uart_port *port;
++	int baud = 115200;
++	int bits = 8;
++	int parity = 'n';
++	int flow = 'n';
++
++	if (co->index < 0 || co->index >= CONFIG_SERIAL_QSP_MAXPORTS)
++		return -EINVAL;
++
++	port = &qsp_uart_ports[co->index].port;
++	if (!port->membase)
++		return -ENODEV;
++
++	if (options)
++		uart_parse_options(options, &baud, &parity, &bits, &flow);
++
++	return uart_set_options(port, co, baud, parity, bits, flow);
++}
++
++static struct uart_driver qsp_uart_driver;
++
++static struct console qsp_uart_console = {
++	.name	= "ttyAM",
++	.write	= qsp_uart_console_write,
++	.device	= uart_console_device,
++	.setup	= qsp_uart_console_setup,
++	.flags	= CON_PRINTBUFFER,
++	.index	= -1,
++	.data	= &qsp_uart_driver,
++};
++
++static int __init qsp_uart_console_init(void)
++{
++	register_console(&qsp_uart_console);
++	return 0;
++}
++
++console_initcall(qsp_uart_console_init);
++
++#define	ALT_UART_KEEP_CONSOLE	(&qsp_uart_console)
++
++#else
++
++#define	ALT_UART_KEEP_CONSOLE	NULL
++
++#endif /* CONFIG_ALT_UART_KEEP_CONSOLE */
++
++/* Define the qsp_uart UART driver structure.
++ */
++static struct uart_driver qsp_uart_driver = {
++	.owner		= THIS_MODULE,
++	.driver_name	= DRV_NAME,
++	.dev_name	= "ttyAM",
++	.major		= SERIAL_QSP_MAJOR,
++	.minor		= SERIAL_QSP_MINOR,
++	.nr		= CONFIG_SERIAL_QSP_MAXPORTS,
++	.cons		= ALT_UART_KEEP_CONSOLE,
++};
++
++static int __devinit qsp_uart_probe(struct platform_device *pdev)
++{
++	struct resource res;
++	struct uart_port *port;
++	int i = pdev->id;
++	u32 id;
++
++	dev_dbg(&pdev->dev, "probe %d\n", i);
++	/* if id is -1 scan for a free id and use that one */
++	if (i == -1) {
++		for (i = 0; i < CONFIG_SERIAL_QSP_MAXPORTS; i++)
++			if (qsp_uart_ports[i].port.membase == 0)
++				break;
++	}
++
++	if (i < 0 || i >= CONFIG_SERIAL_QSP_MAXPORTS)
++		return -EINVAL;
++
++	dev_dbg(&pdev->dev, "using index %d\n", i);
++	port = &qsp_uart_ports[i].port;
++
++	port->membase = of_iomap(pdev->dev.of_node, 0);
++	port->irq = irq_of_parse_and_map(pdev->dev.of_node,  0);
++	port->line = i;
++	port->type = PORT_QSP_UART;
++	port->iotype = SERIAL_IO_MEM;
++	port->fifosize = 1;
++	port->ops = &qsp_uart_ops;
++	port->flags = UPF_BOOT_AUTOCONF;
++	port->dev = &pdev->dev;
++	dev_set_drvdata(&pdev->dev, port);
++
++	/* Get phys addr of membase as well,
++	 * for pretty print out by serial_core.c */
++	of_address_to_resource(pdev->dev.of_node, 0, &res);
++	port->mapbase = res.start;
++
++	id = qsp_uart_readl(port, 0);
++	dev_dbg(&pdev->dev, "id %08x\n", id);
++	if (id != QSP_SERIAL_ID_VAL)
++		return -ENODEV;
++
++	uart_add_one_port(&qsp_uart_driver, port);
++	dev_dbg(&pdev->dev, "one port added\n");
++	return 0;
++}
++
++static int __devexit qsp_uart_remove(struct platform_device *pdev)
++{
++	struct uart_port *port = dev_get_drvdata(&pdev->dev);
++
++	if (port) {
++		uart_remove_one_port(&qsp_uart_driver, port);
++		dev_set_drvdata(&pdev->dev, NULL);
++		port->mapbase = 0;
++	}
++
++	return 0;
++}
++
++static struct of_device_id qsp_uart_match[] = {
++	{ .compatible = "qsp-serial" },
++	{},
++};
++MODULE_DEVICE_TABLE(of, qsp_uart_match);
++
++static struct platform_driver qsp_uart_platform_driver = {
++	.probe	= qsp_uart_probe,
++	.remove	= __devexit_p(qsp_uart_remove),
++	.driver	= {
++		.name		= DRV_NAME,
++		.owner		= THIS_MODULE,
++		.of_match_table	= of_match_ptr(qsp_uart_match),
++	},
++};
++
++static int __init qsp_uart_init(void)
++{
++	int rc;
++	rc = uart_register_driver(&qsp_uart_driver);
++	if (rc) {
++		pr_err(DRV_NAME "Failed to register uart driver.\n");
++		return rc;
++	}
++
++	rc = platform_driver_register(&qsp_uart_platform_driver);
++	if (rc) {
++		pr_err(DRV_NAME "Failed to register platform driver.\n");
++		uart_unregister_driver(&qsp_uart_driver);
++	}
++	return rc;
++}
++
++static void __exit qsp_uart_exit(void)
++{
++	platform_driver_unregister(&qsp_uart_platform_driver);
++	uart_unregister_driver(&qsp_uart_driver);
++}
++
++module_init(qsp_uart_init);
++module_exit(qsp_uart_exit);
++
++MODULE_DESCRIPTION("QSP UART driver");
++MODULE_AUTHOR("Ivar Holmqvist <ivarholmqvist@gmail.com>");
++MODULE_LICENSE("GPL");
++MODULE_ALIAS("platform:" DRV_NAME);
++MODULE_ALIAS_CHARDEV_MAJOR(SERIAL_QSP_MAJOR);
+diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
+index 2db407a..d514acd 100644
+--- a/include/linux/serial_core.h
++++ b/include/linux/serial_core.h
+@@ -213,6 +213,9 @@
+ /* Energy Micro efm32 SoC */
+ #define PORT_EFMUART   100
+ 
++/* QSP UART */
++#define PORT_QSP_UART	99
++
+ #ifdef __KERNEL__
+ 
+ #include <linux/compiler.h>
+-- 
+1.7.9.5
+
diff -pNur buildroot.2014.08/board/windriver/qsp-ppc/linux-0020-qsp-eth-Initial-support-for-qsp-ethernet-controller.patch buildroot/board/windriver/qsp-ppc/linux-0020-qsp-eth-Initial-support-for-qsp-ethernet-controller.patch
--- buildroot.2014.08/board/windriver/qsp-ppc/linux-0020-qsp-eth-Initial-support-for-qsp-ethernet-controller.patch	1970-01-01 07:00:00.000000000 +0700
+++ buildroot/board/windriver/qsp-ppc/linux-0020-qsp-eth-Initial-support-for-qsp-ethernet-controller.patch	2014-12-09 13:19:53.705729700 +0800
@@ -0,0 +1,702 @@
+From bd21b5c3b095f7d95da438f6d3e1f28385e6bdb5 Mon Sep 17 00:00:00 2001
+From: Ivar Holmqvist <ivarholmqvist@gmail.com>
+Date: Mon, 16 Jul 2012 18:05:22 +0200
+Subject: [PATCH] qsp-eth: Initial support for qsp ethernet controller.
+
+---
+ drivers/net/ethernet/Kconfig        |    1 +
+ drivers/net/ethernet/Makefile       |    1 +
+ drivers/net/ethernet/qsp/Kconfig    |   15 +
+ drivers/net/ethernet/qsp/Makefile   |    6 +
+ drivers/net/ethernet/qsp/qsp_main.c |  627 +++++++++++++++++++++++++++++++++++
+ 5 files changed, 650 insertions(+)
+
+diff --git a/drivers/net/ethernet/Kconfig b/drivers/net/ethernet/Kconfig
+index c63a64c..40501d8 100644
+--- a/drivers/net/ethernet/Kconfig
++++ b/drivers/net/ethernet/Kconfig
+@@ -176,5 +176,6 @@ source "drivers/net/ethernet/tundra/Kconfig"
+ source "drivers/net/ethernet/via/Kconfig"
+ source "drivers/net/ethernet/xilinx/Kconfig"
+ source "drivers/net/ethernet/xircom/Kconfig"
++source "drivers/net/ethernet/qsp/Kconfig"
+ 
+ endif # ETHERNET
+diff --git a/drivers/net/ethernet/Makefile b/drivers/net/ethernet/Makefile
+index 9676a51..ac9ecb1 100644
+--- a/drivers/net/ethernet/Makefile
++++ b/drivers/net/ethernet/Makefile
+@@ -75,3 +75,4 @@ obj-$(CONFIG_NET_VENDOR_TUNDRA) += tundra/
+ obj-$(CONFIG_NET_VENDOR_VIA) += via/
+ obj-$(CONFIG_NET_VENDOR_XILINX) += xilinx/
+ obj-$(CONFIG_NET_VENDOR_XIRCOM) += xircom/
++obj-$(CONFIG_NET_QSP) += qsp/
+diff --git a/drivers/net/ethernet/qsp/Kconfig b/drivers/net/ethernet/qsp/Kconfig
+new file mode 100644
+index 0000000..aac90a8
+--- /dev/null
++++ b/drivers/net/ethernet/qsp/Kconfig
+@@ -0,0 +1,15 @@
++#
++# QSP ethernet device configuration
++#
++
++config NET_QSP
++	tristate "QSP Ethernet MAC driver"
++	default n
++	depends on QSP
++	---help---
++	  If you have a network (Ethernet) card belonging to this class, say Y
++	  and read the Ethernet-HOWTO, available from
++	  <http://www.tldp.org/docs.html#howto>.
++
++	  This driver supports the QSP Ethernet MAC used on the Wind River
++	  QSP simics platform
+diff --git a/drivers/net/ethernet/qsp/Makefile b/drivers/net/ethernet/qsp/Makefile
+new file mode 100644
+index 0000000..6933bfb
+--- /dev/null
++++ b/drivers/net/ethernet/qsp/Makefile
+@@ -0,0 +1,6 @@
++#
++# Makefile for the QSP network device driver.
++#
++
++#qsp_mac-objs := qsp_main.o qsp_mdio.o
++obj-$(CONFIG_NET_QSP) += qsp_main.o
+diff --git a/drivers/net/ethernet/qsp/qsp_main.c b/drivers/net/ethernet/qsp/qsp_main.c
+new file mode 100644
+index 0000000..f1e43fe
+--- /dev/null
++++ b/drivers/net/ethernet/qsp/qsp_main.c
+@@ -0,0 +1,627 @@
++/*
++ * Driver for QSP Ethernet device
++ *
++ * Copyright (c) 2012 Wind River Systems, Inc.
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
++ * See the GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
++ *
++ */
++#include <linux/delay.h>
++#include <linux/etherdevice.h>
++#include <linux/init.h>
++#include <linux/module.h>
++#include <linux/netdevice.h>
++#include <linux/of.h>
++#include <linux/of_device.h>
++#include <linux/of_platform.h>
++#include <linux/of_address.h>
++#include <linux/of_irq.h>
++#include <linux/skbuff.h>
++#include <linux/spinlock.h>
++#include <linux/phy.h>
++#include <linux/in.h>
++#include <linux/io.h>
++#include <linux/ip.h>
++#include <linux/slab.h>
++#include <linux/interrupt.h>
++#include <linux/dma-mapping.h>
++#include <linux/spinlock.h>
++#include <linux/qsp/qsp.h>
++
++
++#define TX_BD_NUM   128
++#define RX_BD_NUM   128
++
++#define QSP_FRAME_SIZE 1518
++
++/* Register offsets.
++ */
++#define QSP_NET_ID       0x0000
++#define QSP_NET_STATUS   0x0004
++#define QSP_NET_CONTROL  0x0008
++#define QSP_NET_TX_DESC  0x0010
++#define QSP_NET_TX_SZ    0x0014
++#define QSP_NET_TX_CI    0x0018
++#define QSP_NET_TX_PI    0x001c
++#define QSP_NET_RX_DESC  0x0020
++#define QSP_NET_RX_SZ    0x0024
++#define QSP_NET_RX_CI    0x0028
++#define QSP_NET_RX_PI    0x002c
++#define QSP_NET_MDIO     0x0100
++
++#define QSP_NET_MAC_ADDR(i)     (0x030+(i)*4)
++
++/* Bit defines.
++ */
++#define CONTROL_RESET (1<<0)
++
++
++struct qsp_net_bd {
++	u32 __phys;
++	u32 __len;
++};
++
++/* Don't access the buffer descriptors directly. They are big-endian.
++ */
++#define BD_GET_PHYS(bd) be32_to_cpu((bd).__phys)
++#define BD_GET_LEN(bd)  be32_to_cpu((bd).__len)
++#define BD_SET_PHYS(bd, p) do {(bd).__phys = cpu_to_be32(p); } while (0)
++#define BD_SET_LEN(bd, l)  do {(bd).__len = cpu_to_be32(l); } while (0)
++
++struct qsp_net_local {
++	struct net_device *ndev;
++	struct device *dev;
++
++	void __iomem *regs;
++	int tx_irq;
++
++	struct sk_buff **rx_skb;
++	struct sk_buff **tx_skb;
++	spinlock_t tx_lock;
++
++	/* Buffer descriptors */
++	struct qsp_net_bd *tx_bd_v;
++	dma_addr_t tx_bd_p;
++	struct qsp_net_bd *rx_bd_v;
++	dma_addr_t rx_bd_p;
++};
++
++
++/*
++ * Low level register access functions
++ */
++u32 qsp_net_readl(struct qsp_net_local *lp, int offset)
++{
++	u32 ret;
++	ret = readl(lp->regs + offset);
++	pr_debug("read %08x regs @ %p -> %08x\n", offset, lp->regs, ret);
++	return ret;
++}
++
++u8 qsp_net_readb(struct qsp_net_local *lp, int offset)
++{
++	u8 ret;
++	ret = (u8)readl(lp->regs + offset);
++	pr_debug("read %08x regs @ %p -> %08x\n", offset, lp->regs, ret);
++	return ret;
++}
++
++void qsp_net_writel(struct qsp_net_local *lp, int offset, u32 value)
++{
++	pr_debug("write %08x %08x regs @ %p\n", value, offset, lp->regs);
++	writel(value, lp->regs + offset);
++}
++
++void qsp_net_writeb(struct qsp_net_local *lp, int offset, u8 value)
++{
++	pr_debug("write %08x %08x regs @ %p\n", value, offset, lp->regs);
++	writel((u32)value, lp->regs + offset);
++}
++
++/**
++ *  qsp_net_bd_release - Release buffer descriptor rings
++ */
++static void qsp_net_bd_release(struct net_device *ndev)
++{
++	struct qsp_net_local *lp = netdev_priv(ndev);
++	int i;
++
++	/* Release/free descriptors, skb:s and ptr arrays.
++	 */
++	if (lp->rx_skb) {
++		for (i = 0; i < RX_BD_NUM; i++) {
++			if (!lp->rx_skb[i])
++				continue;
++			pr_debug("Release RX skb %p\n", lp->rx_skb[i]);
++			dev_kfree_skb(lp->rx_skb[i]);
++			lp->rx_skb[i] = 0;
++		}
++		pr_debug("Release RX skb_arr %p\n", lp->rx_skb);
++		kfree(lp->rx_skb);
++		lp->rx_skb = 0;
++	}
++	if (lp->rx_bd_v) {
++		pr_debug("Release rx_bd_v %p\n", lp->rx_bd_v);
++		kfree(lp->rx_bd_v);
++		lp->rx_bd_v = 0;
++	}
++
++	if (lp->tx_skb) {
++		for (i = 0; i < TX_BD_NUM; i++) {
++			if (!lp->tx_skb[i])
++				continue;
++			pr_debug("Release TX skb %p\n", lp->tx_skb[i]);
++			dev_kfree_skb(lp->tx_skb[i]);
++			lp->tx_skb[i] = 0;
++		}
++		pr_debug("Release TX skb_arr %p\n", lp->tx_skb);
++		kfree(lp->tx_skb);
++		lp->tx_skb = 0;
++	}
++	if (lp->tx_bd_v) {
++		pr_debug("Release tx_bd_v %p\n", lp->tx_bd_v);
++		kfree(lp->tx_bd_v);
++		lp->tx_bd_v = 0;
++	}
++	pr_debug("bd_release done.\n");
++}
++
++static int add_one_rx_bd(struct net_device *ndev)
++{
++	struct qsp_net_local *lp = netdev_priv(ndev);
++	struct sk_buff *skb;
++	int pi;
++
++	pi  = qsp_net_readl(lp, QSP_NET_RX_PI);
++	if (pi == RX_BD_NUM)
++		return 0;
++
++	skb = netdev_alloc_skb_ip_align(ndev,
++					QSP_FRAME_SIZE);
++	if (skb == 0) {
++		dev_err(&ndev->dev, "alloc_skb error %d\n", pi);
++		return 0;
++	}
++	pr_debug("num_frags %d\n", skb_shinfo(skb)->nr_frags);
++	BUG_ON(skb_shinfo(skb)->nr_frags > 1);
++	lp->rx_skb[pi] = skb;
++	/* returns physical address of skb->data */
++	BD_SET_PHYS(lp->rx_bd_v[pi], virt_to_phys(skb->data));
++	BD_SET_LEN(lp->rx_bd_v[pi], QSP_FRAME_SIZE);
++
++	pr_debug("add_one_rx_bd[%d]: phys:%08x len:%d (%d)\n",
++		 pi,
++		 BD_GET_PHYS(lp->rx_bd_v[pi]),
++		 BD_GET_LEN(lp->rx_bd_v[pi]), QSP_FRAME_SIZE);
++	qsp_net_writel(lp, QSP_NET_RX_PI, pi);
++	return 1;
++}
++
++static void process_tx(struct net_device *ndev, int in_interrupt)
++{
++	struct qsp_net_local *lp = netdev_priv(ndev);
++	int ti;
++	struct sk_buff *skb;
++	int loops;
++
++	/* Check for transmitted entries on the consumer index.
++	 */
++	loops = 0;
++	while ((ti = qsp_net_readl(lp, QSP_NET_TX_CI)) != TX_BD_NUM) {
++		pr_debug("got tx index %d\n", ti);
++		loops++;
++		skb = lp->tx_skb[ti];
++		WARN_ON(skb == NULL);
++		if (in_interrupt)
++			dev_kfree_skb_irq(skb);
++		else
++			dev_kfree_skb(skb);
++		lp->tx_skb[ti] = 0;
++		ndev->stats.tx_packets++;
++		ndev->stats.tx_bytes += BD_GET_LEN(lp->tx_bd_v[ti]);
++
++		/* Release the entry back to the mac
++		 */
++		qsp_net_writel(lp, QSP_NET_TX_CI, ti);
++		netif_wake_queue(ndev);
++	}
++	pr_debug("process_tx: Handled %d skb:s in %s mode\n",
++		 loops, in_interrupt ? "interrupt" : "normal");
++}
++
++
++/**
++ * qsp_net_bd_init - Setup buffer descriptor rings
++ */
++static int qsp_net_bd_init(struct net_device *ndev)
++{
++	struct qsp_net_local *lp = netdev_priv(ndev);
++
++	int num_rx;
++
++	lp->rx_skb = kcalloc(RX_BD_NUM, sizeof(*lp->rx_skb), GFP_KERNEL);
++	if (!lp->rx_skb) {
++		dev_err(&ndev->dev,
++			"can't allocate memory for DMA RX skb pointers.\n");
++		goto out;
++	}
++	lp->tx_skb = kcalloc(TX_BD_NUM, sizeof(*lp->tx_skb), GFP_KERNEL);
++	if (!lp->tx_skb) {
++		dev_err(&ndev->dev,
++			"can't allocate memory for DMA TX skb pointers.\n");
++		goto out;
++	}
++	/* allocate the tx and rx ring buffer descriptors. */
++	/* returns a virtual address and a physical address. */
++	lp->rx_skb = kcalloc(RX_BD_NUM, sizeof(*lp->rx_skb), GFP_KERNEL);
++	lp->tx_bd_v = kcalloc(TX_BD_NUM, sizeof(struct qsp_net_bd), GFP_KERNEL);
++	if (!lp->tx_bd_v) {
++		dev_err(&ndev->dev,
++				"unable to allocate DMA TX buffer descriptors");
++		goto out;
++	}
++	lp->rx_bd_v = kcalloc(RX_BD_NUM, sizeof(struct qsp_net_bd), GFP_KERNEL);
++	if (!lp->rx_bd_v) {
++		dev_err(&ndev->dev,
++				"unable to allocate DMA RX buffer descriptors");
++		goto out;
++	}
++
++	memset(lp->tx_bd_v, 0, sizeof(*lp->tx_bd_v) * TX_BD_NUM);
++	qsp_net_writel(lp, QSP_NET_TX_DESC, virt_to_phys(lp->tx_bd_v));
++	qsp_net_writel(lp, QSP_NET_TX_SZ, TX_BD_NUM);
++
++	qsp_net_writel(lp, QSP_NET_RX_DESC, virt_to_phys(lp->rx_bd_v));
++	qsp_net_writel(lp, QSP_NET_RX_SZ, RX_BD_NUM);
++
++	num_rx = 0;
++	while (add_one_rx_bd(ndev) == 1)
++		num_rx++;
++
++	pr_debug("%d != %d\n", num_rx, RX_BD_NUM);
++	WARN_ON(num_rx+1 != RX_BD_NUM);
++
++	return 0;
++
++out:
++	qsp_net_bd_release(ndev);
++	return -ENOMEM;
++}
++
++/* ---------------------------------------------------------------------
++ * net_device_ops
++ */
++
++static int qsp_net_set_mac_address(struct net_device *ndev, void *address)
++{
++	int i;
++	struct qsp_net_local *lp = netdev_priv(ndev);
++
++	if (address)
++		memcpy(ndev->dev_addr, address, ETH_ALEN);
++
++	if (!is_valid_ether_addr(ndev->dev_addr))
++		eth_hw_addr_random(ndev);
++	else
++		ndev->addr_assign_type &= ~NET_ADDR_RANDOM;
++
++	for (i = 0; i < 6; i++)
++		qsp_net_writeb(lp, QSP_NET_MAC_ADDR(i), ndev->dev_addr[i]);
++
++	return 0;
++}
++
++static int netdev_set_mac_address(struct net_device *ndev, void *p)
++{
++	struct sockaddr *addr = p;
++
++	return qsp_net_set_mac_address(ndev, addr->sa_data);
++}
++
++/* Initialize qsp_net */
++static void qsp_net_device_reset(struct net_device *ndev)
++{
++	if (qsp_net_bd_init(ndev)) {
++		dev_err(&ndev->dev,
++			"qsp_net_device_reset descriptor allocation failed\n");
++	}
++
++	qsp_net_set_mac_address(ndev, NULL);
++
++	/* Init Driver variable */
++	ndev->trans_start = jiffies; /* prevent tx timeout */
++}
++
++
++static int qsp_net_start_xmit(struct sk_buff *skb, struct net_device *ndev)
++{
++	struct qsp_net_local *lp = netdev_priv(ndev);
++
++	pr_debug("Transmit %p %p\n", skb, skb->data);
++	BUG_ON(skb_shinfo(skb)->nr_frags > 1);
++	{
++		int ti;
++		unsigned long flags;
++
++		/* Try to get a fresh producer index in the ring.
++		 */
++		ti = qsp_net_readl(lp, QSP_NET_TX_PI);
++		if (ti == TX_BD_NUM) {
++			pr_debug("Not enough free tx descriptors in ring.\n");
++			if (!netif_queue_stopped(ndev)) {
++				pr_debug("Stopping queue\n");
++				netif_stop_queue(ndev);
++			}
++			return NETDEV_TX_BUSY;
++		}
++		pr_debug("xmit index %d\n", ti);
++
++		/* Fill in the buffer descriptor at that index.
++		 */
++		BD_SET_PHYS(lp->tx_bd_v[ti], virt_to_phys(skb->data));
++		BD_SET_LEN(lp->tx_bd_v[ti], skb->len);
++
++		pr_debug("Send packet of len %d\n", skb->len);
++
++		/* Kick off the transfer.
++		 */
++		pr_debug("tx_desc[%d]: %08x %d\n", ti,
++			 BD_GET_PHYS(lp->tx_bd_v[ti]),
++			 BD_GET_LEN(lp->tx_bd_v[ti]));
++		lp->tx_skb[ti] = skb;
++		spin_lock_irqsave(&lp->tx_lock, flags);
++		qsp_net_writel(lp, QSP_NET_TX_PI, ti);
++		skb_tx_timestamp(skb);
++		/* Check if it trasmitted immediately?
++		 */
++		process_tx(ndev, 0);
++		spin_unlock_irqrestore(&lp->tx_lock, flags);
++	}
++
++	return NETDEV_TX_OK;
++}
++
++
++static void process_rx(struct net_device *ndev)
++{
++	struct qsp_net_local *lp = netdev_priv(ndev);
++	struct sk_buff *skb;
++	struct qsp_net_bd *cur_p;
++	int ci;
++
++	do {
++		ci = qsp_net_readl(lp, QSP_NET_RX_CI);
++		if (ci == RX_BD_NUM) {
++			pr_debug("No more rx descriptors in ring.\n");
++			break;
++		}
++		pr_debug("Got rx index %d\n", ci);
++		qsp_net_writel(lp, QSP_NET_RX_CI, ci);
++
++		cur_p = &lp->rx_bd_v[ci];
++		skb = lp->rx_skb[ci];
++		pr_debug("bd[%d] skb:%p phys:0x%08x : %d\n",
++			 ci, skb, BD_GET_PHYS(*cur_p), BD_GET_LEN(*cur_p));
++		skb_put(skb, BD_GET_LEN(*cur_p));
++
++		skb->dev = ndev;
++		skb->protocol = eth_type_trans(skb, ndev);
++
++		if (!skb_defer_rx_timestamp(skb)) {
++			lp->rx_skb[ci] = 0;
++			netif_rx(skb);
++		} else {
++			/* FIXME: needs investigation... */
++			BUG_ON(1);
++		}
++
++		ndev->stats.rx_packets++;
++		ndev->stats.rx_bytes += BD_GET_LEN(*cur_p);
++
++		add_one_rx_bd(ndev);
++
++	} while (1);
++}
++
++static irqreturn_t ll_qsp_net_irq(int irq, void *_ndev)
++{
++	struct net_device *ndev = _ndev;
++	struct qsp_net_local *lp = netdev_priv(ndev);
++
++	pr_debug("GOT IRQ\n");
++	process_rx(ndev);
++	spin_lock(&lp->tx_lock);
++	process_tx(ndev, 1);
++	spin_unlock(&lp->tx_lock);
++	return IRQ_HANDLED;
++}
++
++static int qsp_net_open(struct net_device *ndev)
++{
++	struct qsp_net_local *lp = netdev_priv(ndev);
++	int rc;
++
++	dev_dbg(&ndev->dev, "qsp_net_open()\n");
++
++	qsp_net_device_reset(ndev);
++
++	rc = request_irq(lp->tx_irq, ll_qsp_net_irq, 0, ndev->name, ndev);
++	if (rc) {
++		dev_err(lp->dev, "request_irq() failed\n");
++		return rc;
++	}
++	return 0;
++}
++
++static int qsp_net_stop(struct net_device *ndev)
++{
++	struct qsp_net_local *lp = netdev_priv(ndev);
++
++	/* Stop tx/rx
++	 */
++	qsp_net_writel(lp, QSP_NET_CONTROL, CONTROL_RESET);
++
++	dev_dbg(&ndev->dev, "qsp_net_close()\n");
++
++	free_irq(lp->tx_irq, ndev);
++
++#if 0
++	if (lp->phy_dev)
++		phy_disconnect(lp->phy_dev);
++	lp->phy_dev = NULL;
++#endif
++	qsp_net_bd_release(ndev);
++
++	return 0;
++}
++
++static int qsp_net_ioctl(struct net_device *ndev, struct ifreq *rq, int cmd)
++{
++	return -EINVAL;
++}
++
++static const struct net_device_ops qsp_net_netdev_ops = {
++	.ndo_open = qsp_net_open,
++	.ndo_stop = qsp_net_stop,
++	.ndo_start_xmit = qsp_net_start_xmit,
++	.ndo_set_mac_address = netdev_set_mac_address,
++	.ndo_validate_addr = eth_validate_addr,
++	.ndo_do_ioctl = qsp_net_ioctl,
++#ifdef CONFIG_NET_POLL_CONTROLLER
++	.ndo_poll_controller = qsp_net_poll_controller,
++#endif
++};
++
++
++static int __devinit qsp_mac_probe(struct platform_device *op)
++{
++	struct device_node *np;
++	struct qsp_net_local *lp;
++	struct net_device *ndev;
++	u8 macaddr[6];
++
++	int rc = 0;
++	int i;
++
++	/* Init network device structure */
++	ndev = alloc_etherdev(sizeof(*lp));
++	if (!ndev) {
++		pr_err("Failed to alloc etherdev\n");
++		return -ENOMEM;
++	}
++	ether_setup(ndev);
++	dev_set_drvdata(&op->dev, ndev);
++	SET_NETDEV_DEV(ndev, &op->dev);
++	ndev->flags &= ~IFF_MULTICAST;  /* clear multicast */
++#if 0
++	ndev->features = NETIF_F_SG | NETIF_F_FRAGLIST;
++#endif
++	ndev->netdev_ops = &qsp_net_netdev_ops;
++
++	ndev->features |= NETIF_F_HIGHDMA; /* Can DMA to high memory. */
++
++	/* setup qsp_net private info structure */
++	lp = netdev_priv(ndev);
++	lp->ndev = ndev;
++	lp->dev = &op->dev;
++
++	spin_lock_init(&lp->tx_lock);
++
++	/* map device registers */
++	lp->regs = of_iomap(op->dev.of_node, 0);
++	if (!lp->regs) {
++		dev_err(&op->dev, "could not map qsp_net regs eth.\n");
++		goto nodev;
++	}
++	pr_debug("regs @ %p\n", lp->regs);
++
++	/* Check that it's instantiated.
++	 */
++	if (qsp_net_readl(lp, QSP_NET_ID) != QSP_NET_ID_VAL) {
++		pr_debug("Could not find eth\n");
++		goto nodev;
++	}
++
++	np = op->dev.of_node;
++	pr_debug("IRQ 0 %p\n", np);
++	lp->tx_irq = irq_of_parse_and_map(np, 0);
++	pr_debug("ok %d\n", lp->tx_irq);
++
++	of_node_put(np); /* Finished with the node; drop the reference */
++
++	if (!lp->tx_irq) {
++		dev_err(&op->dev, "could not determine irq\n");
++		rc = -ENOMEM;
++		goto err_no_irq;
++	}
++
++
++	for (i = 0; i < 6; i++) {
++		/* Retrieve the MAC address */
++		macaddr[i] = qsp_net_readb(lp, QSP_NET_MAC_ADDR(i));
++		pr_debug("MAC%d %02x\n", i, macaddr[i]);
++	}
++	qsp_net_set_mac_address(ndev, (void *)macaddr);
++
++	rc = register_netdev(lp->ndev);
++	if (rc) {
++		dev_err(lp->dev, "register_netdev() error (%i)\n", rc);
++		goto err_register_ndev;
++	}
++	pr_info("qsp_net: succesfully probed\n");
++	return 0;
++
++ err_no_irq:
++ err_register_ndev:
++	iounmap(lp->regs);
++ nodev:
++	free_netdev(ndev);
++	ndev = NULL;
++	return rc;
++}
++
++static int __devexit qsp_mac_remove(struct platform_device *op)
++{
++	struct net_device *ndev = dev_get_drvdata(&op->dev);
++	struct qsp_net_local *lp = netdev_priv(ndev);
++
++	unregister_netdev(ndev);
++
++	dev_set_drvdata(&op->dev, NULL);
++	iounmap(lp->regs);
++	free_netdev(ndev);
++	return 0;
++}
++
++static struct of_device_id qsp_mac_match[] __devinitdata = {
++	{ .compatible = "qsp-mac", },
++	{},
++};
++MODULE_DEVICE_TABLE(of, qsp_mac_match);
++
++static struct platform_driver qsp_mac_driver = {
++	.probe = qsp_mac_probe,
++	.remove = __devexit_p(qsp_mac_remove),
++	.driver = {
++		.owner = THIS_MODULE,
++		.name = "qsp-mac",
++		.of_match_table = qsp_mac_match,
++	},
++};
++
++module_platform_driver(qsp_mac_driver);
++
++MODULE_LICENSE("GPL v2");
++MODULE_DESCRIPTION("Ethernet support for QSP");
++MODULE_AUTHOR("Anders Wallin <anders.wallin@windriver.com>");
+-- 
+1.7.9.5
+
diff -pNur buildroot.2014.08/board/windriver/qsp-ppc/linux-0021-qsp-flash-Allow-PHYSMAP_OF-i.e-specifying-physaddr-o.patch buildroot/board/windriver/qsp-ppc/linux-0021-qsp-flash-Allow-PHYSMAP_OF-i.e-specifying-physaddr-o.patch
--- buildroot.2014.08/board/windriver/qsp-ppc/linux-0021-qsp-flash-Allow-PHYSMAP_OF-i.e-specifying-physaddr-o.patch	1970-01-01 07:00:00.000000000 +0700
+++ buildroot/board/windriver/qsp-ppc/linux-0021-qsp-flash-Allow-PHYSMAP_OF-i.e-specifying-physaddr-o.patch	2014-12-09 13:19:53.705729700 +0800
@@ -0,0 +1,56 @@
+From 2290e85a9cb4062cc4ce7d28e40d1cdf2095919c Mon Sep 17 00:00:00 2001
+From: Ivar Holmqvist <ivarholmqvist@gmail.com>
+Date: Tue, 17 Jul 2012 18:38:35 +0200
+Subject: [PATCH] qsp-flash: Allow PHYSMAP_OF (i.e specifying physaddr of
+ flash in dts) support for qsp-flash.
+
+---
+ drivers/mtd/chips/qsp-flash.c |    2 +-
+ drivers/mtd/maps/Kconfig      |    2 +-
+ drivers/mtd/maps/physmap_of.c |    4 ++++
+ 3 files changed, 6 insertions(+), 2 deletions(-)
+
+diff --git a/drivers/mtd/chips/qsp-flash.c b/drivers/mtd/chips/qsp-flash.c
+index c5f1781..6683671 100644
+--- a/drivers/mtd/chips/qsp-flash.c
++++ b/drivers/mtd/chips/qsp-flash.c
+@@ -46,7 +46,7 @@ static unsigned long qsp_flash_unmapped_area(struct mtd_info *, unsigned long,
+ 
+ static struct mtd_chip_driver qsp_flash_chipdrv = {
+ 	.probe	= qsp_flash_probe,
+-	.name	= "qsp-flash",
++	.name	= "qsp-probe",
+ 	.module	= THIS_MODULE
+ };
+ 
+diff --git a/drivers/mtd/maps/Kconfig b/drivers/mtd/maps/Kconfig
+index b5529f2..630cf32 100644
+--- a/drivers/mtd/maps/Kconfig
++++ b/drivers/mtd/maps/Kconfig
+@@ -67,7 +67,7 @@ config MTD_PHYSMAP_BANKWIDTH
+ 
+ config MTD_PHYSMAP_OF
+ 	tristate "Flash device in physical memory map based on OF description"
+-	depends on OF && (MTD_CFI || MTD_JEDECPROBE || MTD_ROM)
++	depends on OF && (MTD_CFI || MTD_JEDECPROBE || MTD_ROM || MTD_QSP_FLASH)
+ 	help
+ 	  This provides a 'mapping' driver which allows the NOR Flash and
+ 	  ROM driver code to communicate with chips which are mapped
+diff --git a/drivers/mtd/maps/physmap_of.c b/drivers/mtd/maps/physmap_of.c
+index 2e6fb68..7171fac 100644
+--- a/drivers/mtd/maps/physmap_of.c
++++ b/drivers/mtd/maps/physmap_of.c
+@@ -324,6 +324,10 @@ static struct of_device_id of_flash_match[] = {
+ 		.type		= "rom",
+ 		.compatible	= "direct-mapped"
+ 	},
++	{
++		.compatible     = "qsp-flash",
++		.data	= (void *)"qsp-probe"
++	},
+ 	{ },
+ };
+ MODULE_DEVICE_TABLE(of, of_flash_match);
+-- 
+1.7.9.5
+
diff -pNur buildroot.2014.08/board/windriver/qsp-ppc/linux-0022-qsp-ppc-Changed-from-specifying-mtd-physmap-in-confi.patch buildroot/board/windriver/qsp-ppc/linux-0022-qsp-ppc-Changed-from-specifying-mtd-physmap-in-confi.patch
--- buildroot.2014.08/board/windriver/qsp-ppc/linux-0022-qsp-ppc-Changed-from-specifying-mtd-physmap-in-confi.patch	1970-01-01 07:00:00.000000000 +0700
+++ buildroot/board/windriver/qsp-ppc/linux-0022-qsp-ppc-Changed-from-specifying-mtd-physmap-in-confi.patch	2014-12-09 13:19:53.705729700 +0800
@@ -0,0 +1,73 @@
+From b476b199b98918a1cfc554d80173823378846af1 Mon Sep 17 00:00:00 2001
+From: Ivar Holmqvist <ivarholmqvist@gmail.com>
+Date: Tue, 17 Jul 2012 18:37:22 +0200
+Subject: [PATCH] qsp-ppc: Changed from specifying mtd physmap in config to
+ dts.
+
+---
+ arch/powerpc/boot/dts/qsp.dts      |   20 ++++++++++++++++++++
+ arch/powerpc/configs/qsp_defconfig |   10 ++++------
+ 2 files changed, 24 insertions(+), 6 deletions(-)
+
+diff --git a/arch/powerpc/boot/dts/qsp.dts b/arch/powerpc/boot/dts/qsp.dts
+index ca396a6..5fcf712 100644
+--- a/arch/powerpc/boot/dts/qsp.dts
++++ b/arch/powerpc/boot/dts/qsp.dts
+@@ -1443,6 +1443,26 @@
+ 		reg = <0x0 0x20000000>;
+ 	};
+ 
++	flash@0xd0000000 {
++		#address-cells = <2>;
++		#size-cells = <1>;
++		compatible = "simple-bus";
++		ranges = <0 0 0xd0000000 0x10000000>;
++		qsp_flash@0,0 {
++					compatible = "qsp-flash";
++					bank-width = <2>;
++					reg = <0 0x00000000 0x10000000>;
++					#address-cells = <1>;
++					#size-cells = <1>;
++					partition@0 {
++						label = "entire_flash";
++						reg = <0x00000000 0x10000000>;
++					};
++
++
++				   };
++	 };
++
+ 	soc@0xe0000000 {
+ 		#address-cells = <2>;
+ 		#size-cells = <1>;
+diff --git a/arch/powerpc/configs/qsp_defconfig b/arch/powerpc/configs/qsp_defconfig
+index 3fd8553..3f312f1 100644
+--- a/arch/powerpc/configs/qsp_defconfig
++++ b/arch/powerpc/configs/qsp_defconfig
+@@ -493,8 +493,8 @@ CONFIG_PREVENT_FIRMWARE_BUILD=y
+ CONFIG_MTD=y
+ # CONFIG_MTD_TESTS is not set
+ # CONFIG_MTD_REDBOOT_PARTS is not set
+-# CONFIG_MTD_CMDLINE_PARTS is not set
+-# CONFIG_MTD_OF_PARTS is not set
++CONFIG_MTD_CMDLINE_PARTS=y
++CONFIG_MTD_OF_PARTS=y
+ # CONFIG_MTD_AR7_PARTS is not set
+ 
+ #
+@@ -538,10 +538,8 @@ CONFIG_MTD_QSP_FLASH=y
+ #
+ # CONFIG_MTD_COMPLEX_MAPPINGS is not set
+ CONFIG_MTD_PHYSMAP=y
+-CONFIG_MTD_PHYSMAP_COMPAT=y
+-CONFIG_MTD_PHYSMAP_START=0xd0000000
+-CONFIG_MTD_PHYSMAP_LEN=0x10000000
+-CONFIG_MTD_PHYSMAP_BANKWIDTH=4
++# CONFIG_MTD_PHYSMAP_COMPAT is not set
++CONFIG_MTD_PHYSMAP_OF=y
+ # CONFIG_MTD_PLATRAM is not set
+ 
+ #
+-- 
+1.7.9.5
+
diff -pNur buildroot.2014.08/board/windriver/qsp-ppc/linux-0023-qsp-arm-Changed-from-specifying-mtd-physmap-in-confi.patch buildroot/board/windriver/qsp-ppc/linux-0023-qsp-arm-Changed-from-specifying-mtd-physmap-in-confi.patch
--- buildroot.2014.08/board/windriver/qsp-ppc/linux-0023-qsp-arm-Changed-from-specifying-mtd-physmap-in-confi.patch	1970-01-01 07:00:00.000000000 +0700
+++ buildroot/board/windriver/qsp-ppc/linux-0023-qsp-arm-Changed-from-specifying-mtd-physmap-in-confi.patch	2014-12-09 13:19:53.705729700 +0800
@@ -0,0 +1,74 @@
+From 8e813f5bc1ff7a9b7d190493d3a2fe17aa386678 Mon Sep 17 00:00:00 2001
+From: Ivar Holmqvist <ivarholmqvist@gmail.com>
+Date: Tue, 17 Jul 2012 18:37:33 +0200
+Subject: [PATCH] qsp-arm: Changed from specifying mtd physmap in config to
+ dts.
+
+---
+ arch/arm/boot/dts/qsp.dts      |   20 ++++++++++++++++++++
+ arch/arm/configs/qsp_defconfig |   10 ++++------
+ 2 files changed, 24 insertions(+), 6 deletions(-)
+
+diff --git a/arch/arm/boot/dts/qsp.dts b/arch/arm/boot/dts/qsp.dts
+index e064656..d5358a5 100644
+--- a/arch/arm/boot/dts/qsp.dts
++++ b/arch/arm/boot/dts/qsp.dts
+@@ -43,6 +43,26 @@
+ 		bootargs = "root=0x6300 console=ttyAM0 ";
+ 	};
+ 
++	flash@0x00000000 {
++		#address-cells = <2>;
++		#size-cells = <1>;
++		compatible = "simple-bus";
++		ranges = <0 0 0x00000000 0x10000000>;
++		qsp_flash@0,0 {
++					compatible = "qsp-flash";
++					bank-width = <2>;
++					reg = <0 0x00000000 0x10000000>;
++					#address-cells = <1>;
++					#size-cells = <1>;
++					partition@0 {
++						label = "entire_flash";
++						reg = <0x00000000 0x10000000>;
++					};
++
++
++				   };
++	 };
++
+ 	soc@0xe0000000 {
+ 		#address-cells = <2>;
+ 		#size-cells = <1>;
+diff --git a/arch/arm/configs/qsp_defconfig b/arch/arm/configs/qsp_defconfig
+index 9652c7e..9ff0a15 100644
+--- a/arch/arm/configs/qsp_defconfig
++++ b/arch/arm/configs/qsp_defconfig
+@@ -555,9 +555,9 @@ CONFIG_PREVENT_FIRMWARE_BUILD=y
+ CONFIG_MTD=y
+ # CONFIG_MTD_TESTS is not set
+ # CONFIG_MTD_REDBOOT_PARTS is not set
+-# CONFIG_MTD_CMDLINE_PARTS is not set
++CONFIG_MTD_CMDLINE_PARTS=y
+ # CONFIG_MTD_AFS_PARTS is not set
+-# CONFIG_MTD_OF_PARTS is not set
++CONFIG_MTD_OF_PARTS=y
+ # CONFIG_MTD_AR7_PARTS is not set
+ 
+ #
+@@ -601,10 +601,8 @@ CONFIG_MTD_QSP_FLASH=y
+ #
+ # CONFIG_MTD_COMPLEX_MAPPINGS is not set
+ CONFIG_MTD_PHYSMAP=y
+-CONFIG_MTD_PHYSMAP_COMPAT=y
+-CONFIG_MTD_PHYSMAP_START=0x00000000
+-CONFIG_MTD_PHYSMAP_LEN=0x10000000
+-CONFIG_MTD_PHYSMAP_BANKWIDTH=4
++# CONFIG_MTD_PHYSMAP_COMPAT is not set
++CONFIG_MTD_PHYSMAP_OF=y
+ # CONFIG_MTD_PLATRAM is not set
+ 
+ #
+-- 
+1.7.9.5
+
diff -pNur buildroot.2014.08/board/windriver/qsp-ppc/linux-0024-qsp-serial-Update-internal-serial_core-number-from-9.patch buildroot/board/windriver/qsp-ppc/linux-0024-qsp-serial-Update-internal-serial_core-number-from-9.patch
--- buildroot.2014.08/board/windriver/qsp-ppc/linux-0024-qsp-serial-Update-internal-serial_core-number-from-9.patch	1970-01-01 07:00:00.000000000 +0700
+++ buildroot/board/windriver/qsp-ppc/linux-0024-qsp-serial-Update-internal-serial_core-number-from-9.patch	2014-12-09 13:19:53.705729700 +0800
@@ -0,0 +1,28 @@
+From 60a4065bb3342a541cc85aceb72b8a26a9e10943 Mon Sep 17 00:00:00 2001
+From: Ivar Holmqvist <ivarholmqvist@gmail.com>
+Date: Wed, 18 Jul 2012 11:35:39 +0200
+Subject: [PATCH] qsp-serial: Update internal serial_core number from 99 ->
+ 101.
+
+Apparently the rebase from v3.4-rc1 -> v3.4 didn't conflict on the
+fact that we lost "our" number for the qsp-serial. Oh well fixed now.
+---
+ include/linux/serial_core.h |    2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
+index d514acd..da70156 100644
+--- a/include/linux/serial_core.h
++++ b/include/linux/serial_core.h
+@@ -214,7 +214,7 @@
+ #define PORT_EFMUART   100
+ 
+ /* QSP UART */
+-#define PORT_QSP_UART	99
++#define PORT_QSP_UART	101
+ 
+ #ifdef __KERNEL__
+ 
+-- 
+1.7.9.5
+
diff -pNur buildroot.2014.08/board/windriver/qsp-ppc/linux-0025-qsp-ppc-Add-make-target-for-qsp.dtb.patch buildroot/board/windriver/qsp-ppc/linux-0025-qsp-ppc-Add-make-target-for-qsp.dtb.patch
--- buildroot.2014.08/board/windriver/qsp-ppc/linux-0025-qsp-ppc-Add-make-target-for-qsp.dtb.patch	1970-01-01 07:00:00.000000000 +0700
+++ buildroot/board/windriver/qsp-ppc/linux-0025-qsp-ppc-Add-make-target-for-qsp.dtb.patch	2014-12-09 13:19:53.705729700 +0800
@@ -0,0 +1,26 @@
+From 820da8f9f2859fe0bbe0735478b8d01b2984f15f Mon Sep 17 00:00:00 2001
+From: Ivar Holmqvist <ivarholmqvist@gmail.com>
+Date: Tue, 9 Oct 2012 15:02:12 +0200
+Subject: [PATCH] qsp-ppc: Add make target for qsp.dtb
+
+---
+ arch/powerpc/boot/Makefile |    3 +++
+ 1 file changed, 3 insertions(+)
+
+diff --git a/arch/powerpc/boot/Makefile b/arch/powerpc/boot/Makefile
+index e8461cb..bd20925 100644
+--- a/arch/powerpc/boot/Makefile
++++ b/arch/powerpc/boot/Makefile
+@@ -270,6 +270,9 @@ image-$(CONFIG_WII)			+= dtbImage.wii
+ # Board port in arch/powerpc/platform/amigaone/Kconfig
+ image-$(CONFIG_AMIGAONE)		+= cuImage.amigaone
+ 
++# Board port in arch/powerpc/platform/qsp/Kconfig
++image-$(CONFIG_PPC_QSP)			+= qsp.dtb
++
+ # For 32-bit powermacs, build the COFF and miboot images
+ # as well as the ELF images.
+ ifeq ($(CONFIG_PPC32),y)
+-- 
+1.7.9.5
+
diff -pNur buildroot.2014.08/board/windriver/qsp-ppc/linux-0026-qsp-arm-Add-reboot-support.patch buildroot/board/windriver/qsp-ppc/linux-0026-qsp-arm-Add-reboot-support.patch
--- buildroot.2014.08/board/windriver/qsp-ppc/linux-0026-qsp-arm-Add-reboot-support.patch	1970-01-01 07:00:00.000000000 +0700
+++ buildroot/board/windriver/qsp-ppc/linux-0026-qsp-arm-Add-reboot-support.patch	2014-12-09 13:19:53.705729700 +0800
@@ -0,0 +1,50 @@
+From 990b3e0f5da0335678cd8b68f278f37abc67cae1 Mon Sep 17 00:00:00 2001
+From: "Gao, Lu" <Lu.Gao@windriver.com>
+Date: Sat, 11 Oct 2014 17:11:03 +0800
+Subject: [PATCH] qsp-arm: Add reboot support.
+
+---
+ arch/arm/mach-qsp/setup.c |   22 ++++++++++++++++++++++
+ 1 file changed, 22 insertions(+)
+
+diff --git a/arch/arm/mach-qsp/setup.c b/arch/arm/mach-qsp/setup.c
+index 9253a71..118301f 100644
+--- a/arch/arm/mach-qsp/setup.c
++++ b/arch/arm/mach-qsp/setup.c
+@@ -10,6 +10,27 @@
+ #include <asm/mach/map.h>
+ #include <linux/qsp/qsp_pic.h>
+ #include <linux/qsp/qsp_clk.h>
++#include <linux/delay.h>
++
++#define SOFT_RESET_REG 0x30
++/*
++ * Reset the system. It is called by machine_restart().
++ */
++void qsp_restart(char mode, const char *cmd)
++{
++        static void __iomem *sysregs_base;
++        struct device_node *np;
++        np = of_find_node_by_type(NULL, "sysregs");
++        BUG_ON(np == NULL);
++
++        sysregs_base = of_iomap(np, 0);
++        BUG_ON(sysregs_base == 0);
++
++        // write reset register
++        writel(1, sysregs_base + SOFT_RESET_REG);
++
++        mdelay(500);
++}
+ 
+ static struct map_desc sysreg_io_desc[] __initdata = {
+ 	{
+@@ -88,4 +109,5 @@ DT_MACHINE_START(QSP, "Simics QSP (Device Tree)")
+ 	.timer		= &qsp_timer,
+ 	.init_machine	= qsp_init_machine,
+ 	.dt_compat	= qsp_dt_compat,
++        .restart	= qsp_restart,
+ MACHINE_END
+-- 
+1.7.9.5
+
diff -pNur buildroot.2014.08/board/windriver/qsp-ppc/linux-0027-qsp-ppc-Add-reboot-support.patch buildroot/board/windriver/qsp-ppc/linux-0027-qsp-ppc-Add-reboot-support.patch
--- buildroot.2014.08/board/windriver/qsp-ppc/linux-0027-qsp-ppc-Add-reboot-support.patch	1970-01-01 07:00:00.000000000 +0700
+++ buildroot/board/windriver/qsp-ppc/linux-0027-qsp-ppc-Add-reboot-support.patch	2014-12-09 13:19:53.705729700 +0800
@@ -0,0 +1,59 @@
+From d68961f50fe15d227de0fe7c1f7841ecd4f961d3 Mon Sep 17 00:00:00 2001
+From: "Gao, Lu" <Lu.Gao@windriver.com>
+Date: Sat, 11 Oct 2014 17:11:16 +0800
+Subject: [PATCH] qsp-ppc: Add reboot support.
+
+---
+ arch/powerpc/platforms/qsp/setup.c |   23 +++++++++++++++++++++++
+ 1 file changed, 23 insertions(+)
+
+diff --git a/arch/powerpc/platforms/qsp/setup.c b/arch/powerpc/platforms/qsp/setup.c
+index 62103e9..083c62d 100644
+--- a/arch/powerpc/platforms/qsp/setup.c
++++ b/arch/powerpc/platforms/qsp/setup.c
+@@ -16,6 +16,7 @@
+ #include <linux/qsp/qsp_pic.h>
+ 
+ #include "smp.h"
++#include <linux/delay.h>
+ 
+ static int __init declare_of_platform_devices(void)
+ {
+@@ -24,6 +25,27 @@ static int __init declare_of_platform_devices(void)
+ }
+ machine_device_initcall(qsp, declare_of_platform_devices);
+ 
++#define SOFT_RESET_REG 0x30
++
++/*
++ * Reset the system. It is called by machine_restart().
++ */
++void qsp_restart(char *cmd)
++{
++        static void __iomem *sysregs_base;
++        struct device_node *np;
++        np = of_find_node_by_type(NULL, "sysregs");
++        BUG_ON(np == NULL);
++
++        sysregs_base = of_iomap(np, 0);
++        BUG_ON(sysregs_base == 0);
++
++        // write reset register
++        writel(1, sysregs_base + 0x30);
++
++        mdelay(500);
++}
++
+ static void __init qsp_setup_arch(void)
+ {
+ 	pr_info("QSP setup arch.");
+@@ -64,5 +86,6 @@ define_machine(qsp) {
+ 	.show_cpuinfo		= qsp_show_cpuinfo,
+ 	.get_irq		= qsp_pic_get_irq,
+ 	.calibrate_decr		= generic_calibrate_decr,
++        .restart                = qsp_restart,
+ };
+ 
+-- 
+1.7.9.5
+
diff -pNur buildroot.2014.08/board/windriver/qsp-ppc/linux-0028-qsp-arm-Fixed-IPI-number-problem.patch buildroot/board/windriver/qsp-ppc/linux-0028-qsp-arm-Fixed-IPI-number-problem.patch
--- buildroot.2014.08/board/windriver/qsp-ppc/linux-0028-qsp-arm-Fixed-IPI-number-problem.patch	1970-01-01 07:00:00.000000000 +0700
+++ buildroot/board/windriver/qsp-ppc/linux-0028-qsp-arm-Fixed-IPI-number-problem.patch	2014-12-09 13:19:53.705729700 +0800
@@ -0,0 +1,56 @@
+From df0ca658b31776b4ceadfeb2cdc96227acbcba8d Mon Sep 17 00:00:00 2001
+From: "Gao, Lu" <Lu.Gao@windriver.com>
+Date: Mon, 13 Oct 2014 10:10:27 +0800
+Subject: [PATCH] qsp-arm: Fixed IPI number problem.
+
+---
+ arch/arm/mach-qsp/platsmp.c |    2 +-
+ drivers/pic/qsp_pic.c       |    2 +-
+ include/linux/qsp/qsp_pic.h |    5 ++++-
+ 3 files changed, 6 insertions(+), 3 deletions(-)
+
+diff --git a/arch/arm/mach-qsp/platsmp.c b/arch/arm/mach-qsp/platsmp.c
+index 928a56c..af11a2f 100644
+--- a/arch/arm/mach-qsp/platsmp.c
++++ b/arch/arm/mach-qsp/platsmp.c
+@@ -60,7 +60,7 @@ static DEFINE_SPINLOCK(boot_lock);
+ static void generate_ipi(const struct cpumask *mask, unsigned int irq)
+ {
+ 	int cpu;
+-	BUG_ON(irq > 5);
++	BUG_ON(irq > (IPI_NUM_TYPES - 1));
+ 	for_each_cpu(cpu, mask) {
+ 		/* FIXME: should we do cpu_logical_map(cpu) here
+ 		 */
+diff --git a/drivers/pic/qsp_pic.c b/drivers/pic/qsp_pic.c
+index e60f31b..1386b45 100644
+--- a/drivers/pic/qsp_pic.c
++++ b/drivers/pic/qsp_pic.c
+@@ -272,7 +272,7 @@ void qsp_pic_message_pass(int cpu, int msg)
+ 	BUG_ON(qsp_pic == NULL);
+ 
+ 	/* make sure we're sending something that translates to an IPI */
+-	if ((unsigned int)msg > IPI_NUM_TYPES) {
++	if ((unsigned int)msg > (IPI_NUM_TYPES - 1)) {
+ 		printk(KERN_ERR "SMP %d: smp_message_pass: unknown msg %d\n",
+ 		       smp_processor_id(), msg);
+ 		return;
+diff --git a/include/linux/qsp/qsp_pic.h b/include/linux/qsp/qsp_pic.h
+index 69c9788..2817c89 100644
+--- a/include/linux/qsp/qsp_pic.h
++++ b/include/linux/qsp/qsp_pic.h
+@@ -31,7 +31,10 @@ void qsp_ipi_eoi(int irq);
+ #define IPI_BASE 128
+ #ifdef CONFIG_ARM
+ /* FIXME: */
+-#define IPI_NUM_TYPES 6
++// ipi_msg_type for ARM begins from IPI_TIMER = 2 to IPI_CPU_STOP = 6
++// then our IPI_NUM_TYPES needs to be 7. 7 is fine for the irq number limit
++// in pic model
++#define IPI_NUM_TYPES 7
+ #else
+ #define IPI_NUM_TYPES 4
+ #endif
+-- 
+1.7.9.5
+
diff -pNur buildroot.2014.08/board/windriver/qsp-ppc/linux-0029-qsp-sysregs-changed-offset-of-sreset-to-0x48-avoidin.patch buildroot/board/windriver/qsp-ppc/linux-0029-qsp-sysregs-changed-offset-of-sreset-to-0x48-avoidin.patch
--- buildroot.2014.08/board/windriver/qsp-ppc/linux-0029-qsp-sysregs-changed-offset-of-sreset-to-0x48-avoidin.patch	1970-01-01 07:00:00.000000000 +0700
+++ buildroot/board/windriver/qsp-ppc/linux-0029-qsp-sysregs-changed-offset-of-sreset-to-0x48-avoidin.patch	2014-12-09 13:19:53.705729700 +0800
@@ -0,0 +1,49 @@
+From b9476e1de336c12b56b4f3abb2899e8a0caee84e Mon Sep 17 00:00:00 2001
+From: "Gao, Lu" <lu.gao@windriver.com>
+Date: Fri, 28 Nov 2014 12:46:33 +0800
+Subject: [PATCH] qsp-sysregs: changed offset of sreset to 0x48 avoiding
+ conflict with 4.8
+
+---
+ arch/arm/mach-qsp/setup.c          |    2 +-
+ arch/powerpc/platforms/qsp/setup.c |    4 ++--
+ 2 files changed, 3 insertions(+), 3 deletions(-)
+
+diff --git a/arch/arm/mach-qsp/setup.c b/arch/arm/mach-qsp/setup.c
+index 118301f..46aecac 100644
+--- a/arch/arm/mach-qsp/setup.c
++++ b/arch/arm/mach-qsp/setup.c
+@@ -12,7 +12,7 @@
+ #include <linux/qsp/qsp_clk.h>
+ #include <linux/delay.h>
+ 
+-#define SOFT_RESET_REG 0x30
++#define SOFT_RESET_REG 0x48
+ /*
+  * Reset the system. It is called by machine_restart().
+  */
+diff --git a/arch/powerpc/platforms/qsp/setup.c b/arch/powerpc/platforms/qsp/setup.c
+index 083c62d..029af52 100644
+--- a/arch/powerpc/platforms/qsp/setup.c
++++ b/arch/powerpc/platforms/qsp/setup.c
+@@ -25,7 +25,7 @@ static int __init declare_of_platform_devices(void)
+ }
+ machine_device_initcall(qsp, declare_of_platform_devices);
+ 
+-#define SOFT_RESET_REG 0x30
++#define SOFT_RESET_REG 0x48
+ 
+ /*
+  * Reset the system. It is called by machine_restart().
+@@ -41,7 +41,7 @@ void qsp_restart(char *cmd)
+         BUG_ON(sysregs_base == 0);
+ 
+         // write reset register
+-        writel(1, sysregs_base + 0x30);
++        writel(1, sysregs_base + SOFT_RESET_REG);
+ 
+         mdelay(500);
+ }
+-- 
+1.7.9.5
+
diff -pNur buildroot.2014.08/board/windriver/qsp-ppc/uboot-2011.12-0001-qsp-arm-Initial-support-for-qsp-arm-board.patch buildroot/board/windriver/qsp-ppc/uboot-2011.12-0001-qsp-arm-Initial-support-for-qsp-arm-board.patch
--- buildroot.2014.08/board/windriver/qsp-ppc/uboot-2011.12-0001-qsp-arm-Initial-support-for-qsp-arm-board.patch	1970-01-01 07:00:00.000000000 +0700
+++ buildroot/board/windriver/qsp-ppc/uboot-2011.12-0001-qsp-arm-Initial-support-for-qsp-arm-board.patch	2014-12-09 13:19:53.701729700 +0800
@@ -0,0 +1,473 @@
+From 45d5d83ea69fae4ed6f2f3a96e47a547a62a2c94 Mon Sep 17 00:00:00 2001
+From: Ivar Holmqvist <ivarholmqvist@gmail.com>
+Date: Tue, 17 Jul 2012 19:32:22 +0200
+Subject: [PATCH] qsp-arm: Initial support for qsp-arm board.
+
+---
+ arch/arm/cpu/armv7/qsp/Makefile   |   46 ++++++++++
+ arch/arm/cpu/armv7/qsp/config.mk  |   26 ++++++
+ arch/arm/cpu/armv7/qsp/sys_info.c |   32 +++++++
+ board/windriver/qsp_arm/Makefile  |   43 ++++++++++
+ board/windriver/qsp_arm/qsp_arm.c |  170 +++++++++++++++++++++++++++++++++++++
+ boards.cfg                        |    1 +
+ include/configs/qsp_arm.h         |   90 ++++++++++++++++++++
+ 7 files changed, 408 insertions(+)
+
+diff --git a/arch/arm/cpu/armv7/qsp/Makefile b/arch/arm/cpu/armv7/qsp/Makefile
+new file mode 100644
+index 0000000..1fd202a
+--- /dev/null
++++ b/arch/arm/cpu/armv7/qsp/Makefile
+@@ -0,0 +1,46 @@
++#
++# (C) Copyright 2000-2006
++# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
++#
++# See file CREDITS for list of people who contributed to this
++# project.
++#
++# This program is free software; you can redistribute it and/or
++# modify it under the terms of the GNU General Public License as
++# published by the Free Software Foundation; either version 2 of
++# the License, or (at your option) any later version.
++#
++# This program is distributed in the hope that it will be useful,
++# but WITHOUT ANY WARRANTY; without even the implied warranty of
++# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++# GNU General Public License for more details.
++#
++# You should have received a copy of the GNU General Public License
++# along with this program; if not, write to the Free Software
++# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
++# MA 02111-1307 USA
++#
++
++include $(TOPDIR)/config.mk
++
++LIB	= $(obj)lib$(SOC).o
++
++COBJS	:= sys_info.o
++SOBJS	:=
++
++SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
++OBJS	:= $(addprefix $(obj),$(COBJS) $(SOBJS))
++
++all:	$(obj).depend $(LIB)
++
++$(LIB):	$(OBJS)
++	$(call cmd_link_o_target, $(OBJS))
++
++#########################################################################
++
++# defines $(obj).depend target
++include $(SRCTREE)/rules.mk
++
++sinclude $(obj).depend
++
++#########################################################################
+diff --git a/arch/arm/cpu/armv7/qsp/config.mk b/arch/arm/cpu/armv7/qsp/config.mk
+new file mode 100644
+index 0000000..23b0b85
+--- /dev/null
++++ b/arch/arm/cpu/armv7/qsp/config.mk
+@@ -0,0 +1,26 @@
++#
++# (C) Copyright 2010,2011
++# NVIDIA Corporation <www.nvidia.com>
++#
++# (C) Copyright 2002
++# Gary Jennejohn, DENX Software Engineering, <garyj@denx.de>
++#
++# See file CREDITS for list of people who contributed to this
++# project.
++#
++# This program is free software; you can redistribute it and/or
++# modify it under the terms of the GNU General Public License as
++# published by the Free Software Foundation; either version 2 of
++# the License, or (at your option) any later version.
++#
++# This program is distributed in the hope that it will be useful,
++# but WITHOUT ANY WARRANTY; without even the implied warranty of
++# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++# GNU General Public License for more details.
++#
++# You should have received a copy of the GNU General Public License
++# along with this program; if not, write to the Free Software
++# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
++# MA 02111-1307 USA
++#
++PLATFORM_CPPFLAGS += -march=armv7-a
+diff --git a/arch/arm/cpu/armv7/qsp/sys_info.c b/arch/arm/cpu/armv7/qsp/sys_info.c
+new file mode 100644
+index 0000000..284a718
+--- /dev/null
++++ b/arch/arm/cpu/armv7/qsp/sys_info.c
+@@ -0,0 +1,32 @@
++/*
++ * (C) Copyright 2010,2011
++ * NVIDIA Corporation <www.nvidia.com>
++ *
++ * See file CREDITS for list of people who contributed to this
++ * project.
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License as
++ * published by the Free Software Foundation; either version 2 of
++ * the License, or (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
++ * MA 02111-1307 USA
++ */
++#include <common.h>
++
++#ifdef CONFIG_DISPLAY_CPUINFO
++/* Print CPU information */
++int print_cpuinfo(void)
++{
++	puts("QSP ARM\n");
++	return 0;
++}
++#endif	/* CONFIG_DISPLAY_CPUINFO */
+diff --git a/board/windriver/qsp_arm/Makefile b/board/windriver/qsp_arm/Makefile
+new file mode 100644
+index 0000000..daafd6e
+--- /dev/null
++++ b/board/windriver/qsp_arm/Makefile
+@@ -0,0 +1,43 @@
++#
++# (C) Copyright 2000-2004
++# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
++#
++# See file CREDITS for list of people who contributed to this
++# project.
++#
++# This program is free software; you can redistribute it and/or
++# modify it under the terms of the GNU General Public License as
++# published by the Free Software Foundation; either version 2 of
++# the License, or (at your option) any later version.
++#
++# This program is distributed in the hope that it will be useful,
++# but WITHOUT ANY WARRANTY; without even the implied warranty of
++# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++# GNU General Public License for more details.
++#
++# You should have received a copy of the GNU General Public License
++# along with this program; if not, write to the Free Software
++# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
++# MA 02111-1307 USA
++#
++
++include $(TOPDIR)/config.mk
++
++LIB	= $(obj)lib$(BOARD).o
++
++COBJS	:= qsp_arm.o
++
++SRCS	:= $(COBJS:.o=.c)
++OBJS	:= $(addprefix $(obj),$(COBJS))
++
++$(LIB):	$(obj).depend $(OBJS)
++	$(call cmd_link_o_target, $(OBJS))
++
++#########################################################################
++
++# defines $(obj).depend target
++include $(SRCTREE)/rules.mk
++
++sinclude $(obj).depend
++
++#########################################################################
+diff --git a/board/windriver/qsp_arm/qsp_arm.c b/board/windriver/qsp_arm/qsp_arm.c
+new file mode 100644
+index 0000000..2ac54ce
+--- /dev/null
++++ b/board/windriver/qsp_arm/qsp_arm.c
+@@ -0,0 +1,170 @@
++/*
++ * (C) Copyright 2012
++ * Wind River AB
++ * Ivar Holmqvist <ivar.holmqvist@windriver.com>
++ *
++ * See file CREDITS for list of people who contributed to this
++ * project.
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License as
++ * published by the Free Software Foundation; either version 2 of
++ * the License, or (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
++ * MA 02111-1307 USA
++ */
++
++#include <asm/io.h>
++#include <common.h>
++
++DECLARE_GLOBAL_DATA_PTR;
++
++#if defined(CONFIG_SHOW_BOOT_PROGRESS)
++void show_boot_progress(int progress)
++{
++	printf("Boot reached stage %d\n", progress);
++}
++#endif
++
++int board_init(void)
++{
++        /* FIXME: ... */
++	gd->bd->bi_arch_number = MACH_TYPE_QSP_ARM;
++	gd->flags = 0;
++	gd->bd->bi_boot_params = LINUX_BOOT_PARAM_ADDR; /* FIXME: needed only using fdt... */
++
++	return 0;
++}
++
++int timer_init(void)
++{
++	return 0;
++}
++
++
++void reset_cpu(ulong addr)
++{
++        /* FIXME: ... */
++        /* Use the sysregs to cause reset */
++}
++
++/* We skip delay/timer support in u-boot, it will only slow things
++ * down in simics to do something fancy here. No devices need it and aborting
++ * auto-boot can be done with a script...
++ */
++void __udelay(ulong usec)
++{
++}
++
++ulong get_timer(ulong base)
++{
++        return 0;
++}
++
++ulong get_timer_masked(void)
++{
++	return 0;
++}
++
++unsigned long long get_ticks(void)
++{
++        return 0;
++}
++
++ulong get_tbclk (void)
++{
++	return (ulong)0;
++}
++
++#define QSP_SERIAL_BASE 0xe0010000
++#define QSP_SYSREG_BASE 0xe0001000
++
++/* Status register bits
++ */
++#define TX_READY (1<<0)
++#define RX_READY (1<<1)
++
++/* Control register bits
++ */
++#define TX_INT (1<<0)
++#define RX_INT (1<<1)
++
++#define ID_REG      0x00
++#define STATUS_REG  0x04
++#define CONTROL_REG 0x08
++#define TXDATA_REG  0x0c
++#define RXDATA_REG  0x10
++
++
++/* SYSREG registers */
++#define MEM_AVAIL_REG 0x20
++#define MEM_START_REG 0x24
++#define CPU_FREQ_REG  0x28
++
++int dram_init(void)
++{
++        if(readl(QSP_SYSREG_BASE + MEM_START_REG) != CONFIG_SYS_SDRAM_BASE) {
++                printf("### ERROR #### u-boot compiled for ram_base @ %08x, board reports %08x\n",
++                       CONFIG_SYS_SDRAM_BASE, readl(QSP_SYSREG_BASE + MEM_START_REG));
++                for(;;) {
++                }
++        }
++        /* Note, can't write gd->bd->bi_dram[0].size yet, this function lets the common code know
++         * where to place it. That is done later in dram_init_banksize.
++         */
++        gd->ram_size = readl(QSP_SYSREG_BASE + MEM_AVAIL_REG);
++        return 0;
++}
++
++void dram_init_banksize(void)
++{
++        gd->bd->bi_dram[0].start = readl(QSP_SYSREG_BASE + MEM_START_REG);
++        gd->bd->bi_dram[0].size =  readl(QSP_SYSREG_BASE + MEM_AVAIL_REG);
++	return;
++}
++
++int serial_init   (void)
++{
++        /*nop*/
++}
++
++void serial_setbrg (void)
++{
++        /*nop*/
++}
++
++void serial_putc(const char x)
++{
++        if (x == '\n')
++                writel('\r', QSP_SERIAL_BASE + TXDATA_REG);                
++        writel(x, QSP_SERIAL_BASE + TXDATA_REG);
++}
++
++void serial_puts   (const char *x)
++{
++        int i;
++        for (i = 0; x[i]; i++) {
++                serial_putc(x[i]);
++        }
++}
++
++int serial_getc(void)
++{
++        while(!serial_tstc())
++                ;
++        return readl(QSP_SERIAL_BASE + RXDATA_REG);
++}
++
++int serial_tstc(void)
++{
++        return readl(QSP_SERIAL_BASE + STATUS_REG) & RX_READY;
++}
++
+diff --git a/boards.cfg b/boards.cfg
+index 1e5b3e0..e040d6c 100644
+--- a/boards.cfg
++++ b/boards.cfg
+@@ -222,6 +222,7 @@ harmony                      arm         armv7       harmony             nvidia
+ seaboard                     arm         armv7       seaboard            nvidia         tegra2
+ ventana                      arm         armv7       ventana             nvidia         tegra2
+ u8500_href                   arm         armv7       u8500               st-ericsson    u8500
++qsp_arm                      arm         armv7       qsp_arm             windriver      qsp
+ actux1_4_16                  arm         ixp         actux1              -              -           actux1:FLASH2X2
+ actux1_4_32                  arm         ixp         actux1              -              -           actux1:FLASH2X2,RAM_32MB
+ actux1_8_16                  arm         ixp         actux1              -              -           actux1:FLASH1X8
+diff --git a/include/configs/qsp_arm.h b/include/configs/qsp_arm.h
+new file mode 100644
+index 0000000..51378c9
+--- /dev/null
++++ b/include/configs/qsp_arm.h
+@@ -0,0 +1,90 @@
++/*
++ * (C) Copyright 2010 Linaro
++ * Matt Waddel, <matt.waddel@linaro.org>
++ *
++ * Configuration for Versatile Express. Parts were derived from other ARM
++ *   configurations.
++ *
++ * See file CREDITS for list of people who contributed to this
++ * project.
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License as
++ * published by the Free Software Foundation; either version 2 of
++ * the License, or (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
++ * MA 02111-1307 USA
++ */
++
++#ifndef __CONFIG_H
++#define __CONFIG_H
++
++/* CHECKME do we need these? update in linux?*/
++#define MACH_TYPE_QSP_ARM 0xffffffff
++#define CONFIG_SYS_LOAD_ADDR		0x10008000	/* load address */
++#define LINUX_BOOT_PARAM_ADDR		0x10000100
++#define CONFIG_SYS_TEXT_BASE           0x000000
++
++#define CONFIG_SYS_HZ			1000
++#define CONFIG_SKIP_LOWLEVEL_INIT
++
++#define CONFIG_OF_LIBFDT		1
++/* FIXME: invented by qsp port, I doubt that it is needed, see arch/arm/lib/bootm.c 
++ *        for what it does.
++ */
++#define CONFIG_PASS_RELOCATED_FDT       1
++/* Size of malloc() pool */
++#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + 128 * 1024)
++
++
++/* TODO: BAUDRATE is irrelevant, but I guess we need a sane value... we could try with something larger...*/
++#define CONFIG_BAUDRATE			115200
++#define CONFIG_SYS_BAUDRATE_TABLE	{ 115200 }
++
++/* Miscellaneous configurable options */
++/* FIXME: needed? */
++
++#define CONFIG_BOOTDELAY		2
++
++/* Stack sizes are set up in start.S using the settings below */
++#define CONFIG_STACKSIZE		(128 * 1024)	/* regular stack */
++
++/* Physical Memory Map */
++#define CONFIG_NR_DRAM_BANKS		1
++#define PHYS_SDRAM_1			0x10000000
++
++/* additions for new relocation code */
++#define CONFIG_SYS_SDRAM_BASE		PHYS_SDRAM_1
++#define CONFIG_SYS_INIT_RAM_SIZE		0x8000
++#define CONFIG_SYS_GBL_DATA_OFFSET	(CONFIG_SYS_SDRAM_BASE + \
++					 CONFIG_SYS_INIT_RAM_SIZE - \
++					 GENERATED_GBL_DATA_SIZE)
++#define CONFIG_SYS_INIT_SP_ADDR		CONFIG_SYS_GBL_DATA_OFFSET
++
++/* Basic environment settings */
++#define CONFIG_BOOTCOMMAND		"use_simics_script_to_start;"
++
++#define CONFIG_SYS_NO_FLASH
++#define CONFIG_ENV_IS_NOWHERE		1
++#define CONFIG_ENV_SIZE			0x40000
++
++/* Monitor Command Prompt */
++#define CONFIG_SYS_CBSIZE		512	/* Console I/O Buffer Size */
++#define CONFIG_SYS_PROMPT		"qsp-arm# "
++#define CONFIG_SYS_PBSIZE		(CONFIG_SYS_CBSIZE + \
++					sizeof(CONFIG_SYS_PROMPT) + 16)
++#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE /* Boot args buffer */
++#define CONFIG_CMD_SOURCE
++#define CONFIG_SYS_LONGHELP
++#define CONFIG_CMDLINE_EDITING		1
++#define CONFIG_SYS_MAXARGS		16	/* max command args */
++
++#endif
+-- 
+1.7.9.5
+
diff -pNur buildroot.2014.08/board/windriver/qsp-ppc/uboot-2011.12-0002-qsp-ppc-Initial-support-for-qsp-ppc-board.patch buildroot/board/windriver/qsp-ppc/uboot-2011.12-0002-qsp-ppc-Initial-support-for-qsp-ppc-board.patch
--- buildroot.2014.08/board/windriver/qsp-ppc/uboot-2011.12-0002-qsp-ppc-Initial-support-for-qsp-ppc-board.patch	1970-01-01 07:00:00.000000000 +0700
+++ buildroot/board/windriver/qsp-ppc/uboot-2011.12-0002-qsp-ppc-Initial-support-for-qsp-ppc-board.patch	2014-12-09 13:19:53.701729700 +0800
@@ -0,0 +1,2972 @@
+From d68a9ec7a7339781528d8e4bfbc5d6e038973e9f Mon Sep 17 00:00:00 2001
+From: Ivar Holmqvist <ivarholmqvist@gmail.com>
+Date: Tue, 17 Jul 2012 19:33:39 +0200
+Subject: [PATCH] qsp-ppc: Initial support for qsp-ppc board.
+
+---
+ arch/powerpc/cpu/qsp/Makefile     |   59 +++
+ arch/powerpc/cpu/qsp/cache.S      |  379 ++++++++++++++
+ arch/powerpc/cpu/qsp/config.mk    |   27 +
+ arch/powerpc/cpu/qsp/cpu.c        |  141 ++++++
+ arch/powerpc/cpu/qsp/cpu_init.c   |  119 +++++
+ arch/powerpc/cpu/qsp/fdt.c        |   63 +++
+ arch/powerpc/cpu/qsp/interrupts.c |  132 +++++
+ arch/powerpc/cpu/qsp/mp.c         |  147 ++++++
+ arch/powerpc/cpu/qsp/speed.c      |   46 ++
+ arch/powerpc/cpu/qsp/start.S      | 1000 +++++++++++++++++++++++++++++++++++++
+ arch/powerpc/cpu/qsp/traps.c      |  234 +++++++++
+ arch/powerpc/cpu/qsp/u-boot.lds   |   93 ++++
+ board/windriver/qsp_ppc/Makefile  |   43 ++
+ board/windriver/qsp_ppc/qsp_ppc.c |  152 ++++++
+ boards.cfg                        |    1 +
+ include/configs/qsp_ppc.h         |  208 ++++++++
+ 16 files changed, 2844 insertions(+)
+
+diff --git a/arch/powerpc/cpu/qsp/Makefile b/arch/powerpc/cpu/qsp/Makefile
+new file mode 100644
+index 0000000..42bcc8f
+--- /dev/null
++++ b/arch/powerpc/cpu/qsp/Makefile
+@@ -0,0 +1,59 @@
++#
++# Copyright 2007 Freescale Semiconductor, Inc.
++# (C) Copyright 2002,2003 Motorola Inc.
++# Xianghua Xiao,X.Xiao@motorola.com
++#
++# (C) Copyright 2004 Freescale Semiconductor. (MC86xx Port)
++# Jeff Brown
++# See file CREDITS for list of people who contributed to this
++# project.
++#
++# This program is free software; you can redistribute it and/or
++# modify it under the terms of the GNU General Public License as
++# published by the Free Software Foundation; either version 2 of
++# the License, or (at your option) any later version.
++#
++# This program is distributed in the hope that it will be useful,
++# but WITHOUT ANY WARRANTY; without even the implied warranty of
++# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++# GNU General Public License for more details.
++#
++# You should have received a copy of the GNU General Public License
++# along with this program; if not, write to the Free Software
++# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
++# MA 02111-1307 USA
++#
++
++include $(TOPDIR)/config.mk
++
++LIB	= $(obj)lib$(CPU).o
++
++SSTART	= start.o
++CSTART	= traps.o
++
++SOBJS-y += cache.o
++
++COBJS-y	+= cpu.o
++COBJS-y	+= cpu_init.o
++COBJS-$(CONFIG_OF_LIBFDT) += fdt.o
++COBJS-y	+= interrupts.o
++COBJS-y	+= speed.o
++
++SRCS	:= $(START:.o=.S) $(SOBJS-y:.o=.S) $(COBJS-y:.o=.c)
++OBJS	:= $(addprefix $(obj),$(SOBJS-y) $(COBJS-y))
++START	:= $(addprefix $(obj),$(SSTART) $(CSTART))
++
++all:	$(obj).depend $(START) $(LIB)
++
++$(LIB):	$(OBJS)
++	echo "HELLO"
++	$(call cmd_link_o_target, $(OBJS))
++
++#########################################################################
++
++# defines $(obj).depend target
++include $(SRCTREE)/rules.mk
++
++sinclude $(obj).depend
++
++#########################################################################
+diff --git a/arch/powerpc/cpu/qsp/cache.S b/arch/powerpc/cpu/qsp/cache.S
+new file mode 100644
+index 0000000..bb146d5
+--- /dev/null
++++ b/arch/powerpc/cpu/qsp/cache.S
+@@ -0,0 +1,379 @@
++#include <config.h>
++//#include <qsp_ppc.h>
++#include <mpc86xx.h>
++#include <version.h>
++
++#include <ppc_asm.tmpl>
++#include <ppc_defs.h>
++
++#include <asm/cache.h>
++#include <asm/mmu.h>
++
++#ifndef CACHE_LINE_SIZE
++# define CACHE_LINE_SIZE L1_CACHE_BYTES
++#endif
++
++#if CACHE_LINE_SIZE == 128
++#define LG_CACHE_LINE_SIZE 7
++#elif CACHE_LINE_SIZE == 32
++#define LG_CACHE_LINE_SIZE 5
++#elif CACHE_LINE_SIZE == 16
++#define LG_CACHE_LINE_SIZE 4
++#elif CACHE_LINE_SIZE == 8
++#define LG_CACHE_LINE_SIZE 3
++#else
++# error "Invalid cache line size!"
++#endif
++
++/*
++ * Most of this code is taken from 74xx_7xx/cache.S
++ * and then cleaned up a bit
++ */
++
++/*
++ * Invalidate L1 instruction cache.
++ */
++_GLOBAL(invalidate_l1_instruction_cache)
++	/* use invalidate-all bit in HID0 */
++	mfspr	r3,HID0
++	ori	r3,r3,HID0_ICFI
++	mtspr	HID0,r3
++	isync
++	blr
++
++/*
++ * Invalidate L1 data cache.
++ */
++_GLOBAL(invalidate_l1_data_cache)
++	mfspr	r3,HID0
++	ori	r3,r3,HID0_DCFI
++	mtspr	HID0,r3
++	isync
++	blr
++
++/*
++ * Flush data cache.
++ */
++_GLOBAL(flush_dcache)
++	lis	r3,0
++	lis	r5,CACHE_LINE_SIZE
++flush:
++	cmp	0,1,r3,r5
++	bge	done
++	lwz	r5,0(r3)
++	lis	r5,CACHE_LINE_SIZE
++	addi	r3,r3,0x4
++	b	flush
++done:
++	blr
++/*
++ * Write any modified data cache blocks out to memory
++ * and invalidate the corresponding instruction cache blocks.
++ * This is a no-op on the 601.
++ *
++ * flush_icache_range(unsigned long start, unsigned long stop)
++ */
++_GLOBAL(flush_icache_range)
++	li	r5,CACHE_LINE_SIZE-1
++	andc	r3,r3,r5
++	subf	r4,r3,r4
++	add	r4,r4,r5
++	srwi.	r4,r4,LG_CACHE_LINE_SIZE
++	beqlr
++	mtctr	r4
++	mr	r6,r3
++1:	dcbst	0,r3
++	addi	r3,r3,CACHE_LINE_SIZE
++	bdnz	1b
++	sync				/* wait for dcbst's to get to ram */
++	mtctr	r4
++2:	icbi	0,r6
++	addi	r6,r6,CACHE_LINE_SIZE
++	bdnz	2b
++	sync				/* additional sync needed on g4 */
++	isync
++	blr
++/*
++ * Write any modified data cache blocks out to memory.
++ * Does not invalidate the corresponding cache lines (especially for
++ * any corresponding instruction cache).
++ *
++ * clean_dcache_range(unsigned long start, unsigned long stop)
++ */
++_GLOBAL(clean_dcache_range)
++	li	r5,CACHE_LINE_SIZE-1
++	andc	r3,r3,r5	/* align r3 down to cache line */
++	subf	r4,r3,r4	/* r4 = offset of stop from start of cache line */
++	add	r4,r4,r5	/* r4 += cache_line_size-1 */
++	srwi.	r4,r4,LG_CACHE_LINE_SIZE  /* r4 = number of cache lines to flush */
++	beqlr				  /* if r4 == 0 return */
++	mtctr	r4			  /* ctr = r4 */
++
++	sync
++1:	dcbst	0,r3
++	addi	r3,r3,CACHE_LINE_SIZE
++	bdnz	1b
++	sync				/* wait for dcbst's to get to ram */
++	blr
++
++/*
++ * Write any modified data cache blocks out to memory
++ * and invalidate the corresponding instruction cache blocks.
++ *
++ * flush_dcache_range(unsigned long start, unsigned long stop)
++ */
++_GLOBAL(flush_dcache_range)
++	li	r5,CACHE_LINE_SIZE-1
++	andc	r3,r3,r5
++	subf	r4,r3,r4
++	add	r4,r4,r5
++	srwi.	r4,r4,LG_CACHE_LINE_SIZE
++	beqlr
++	mtctr	r4
++
++	sync
++1:	dcbf	0,r3
++	addi	r3,r3,CACHE_LINE_SIZE
++	bdnz	1b
++	sync				/* wait for dcbf's to get to ram */
++	blr
++
++/*
++ * Like above, but invalidate the D-cache.  This is used by the 8xx
++ * to invalidate the cache so the PPC core doesn't get stale data
++ * from the CPM (no cache snooping here :-).
++ *
++ * invalidate_dcache_range(unsigned long start, unsigned long stop)
++ */
++_GLOBAL(invalidate_dcache_range)
++	li	r5,CACHE_LINE_SIZE-1
++	andc	r3,r3,r5
++	subf	r4,r3,r4
++	add	r4,r4,r5
++	srwi.	r4,r4,LG_CACHE_LINE_SIZE
++	beqlr
++	mtctr	r4
++
++	sync
++1:	dcbi	0,r3
++	addi	r3,r3,CACHE_LINE_SIZE
++	bdnz	1b
++	sync				/* wait for dcbi's to get to ram */
++	blr
++
++/*
++ * Flush a particular page from the data cache to RAM.
++ * Note: this is necessary because the instruction cache does *not*
++ * snoop from the data cache.
++ *
++ *	void __flush_page_to_ram(void *page)
++ */
++_GLOBAL(__flush_page_to_ram)
++	rlwinm	r3,r3,0,0,19		/* Get page base address */
++	li	r4,4096/CACHE_LINE_SIZE	/* Number of lines in a page */
++	mtctr	r4
++	mr	r6,r3
++0:	dcbst	0,r3			/* Write line to ram */
++	addi	r3,r3,CACHE_LINE_SIZE
++	bdnz	0b
++	sync
++	mtctr	r4
++1:	icbi	0,r6
++	addi	r6,r6,CACHE_LINE_SIZE
++	bdnz	1b
++	sync
++	isync
++	blr
++
++/*
++ * Flush a particular page from the instruction cache.
++ * Note: this is necessary because the instruction cache does *not*
++ * snoop from the data cache.
++ *
++ *	void __flush_icache_page(void *page)
++ */
++_GLOBAL(__flush_icache_page)
++	li	r4,4096/CACHE_LINE_SIZE	/* Number of lines in a page */
++	mtctr	r4
++1:	icbi	0,r3
++	addi	r3,r3,CACHE_LINE_SIZE
++	bdnz	1b
++	sync
++	isync
++	blr
++
++/*
++ * Clear a page using the dcbz instruction, which doesn't cause any
++ * memory traffic (except to write out any cache lines which get
++ * displaced).  This only works on cacheable memory.
++ */
++_GLOBAL(clear_page)
++	li	r0,4096/CACHE_LINE_SIZE
++	mtctr	r0
++1:	dcbz	0,r3
++	addi	r3,r3,CACHE_LINE_SIZE
++	bdnz	1b
++	blr
++
++/*
++ * Enable L1 Instruction cache
++ */
++_GLOBAL(icache_enable)
++	mfspr	r3, HID0
++	li	r5, HID0_ICFI|HID0_ILOCK
++	andc	r3, r3, r5
++	ori	r3, r3, HID0_ICE
++	ori	r5, r3, HID0_ICFI
++	mtspr	HID0, r5
++	mtspr	HID0, r3
++	isync
++	blr
++
++/*
++ * Disable L1 Instruction cache
++ */
++_GLOBAL(icache_disable)
++	mflr	r4
++	bl	invalidate_l1_instruction_cache		/* uses r3 */
++	sync
++	mtlr	r4
++	mfspr	r3, HID0
++	li	r5, 0
++	ori	r5, r5, HID0_ICE
++	andc	r3, r3, r5
++	mtspr	HID0, r3
++	isync
++	blr
++
++/*
++ * Is instruction cache enabled?
++ */
++_GLOBAL(icache_status)
++	mfspr	r3, HID0
++	andi.	r3, r3, HID0_ICE
++	blr
++
++
++_GLOBAL(l1dcache_enable)
++	mfspr	r3, HID0
++	li	r5, HID0_DCFI|HID0_DLOCK
++	andc	r3, r3, r5
++	mtspr	HID0, r3		/* no invalidate, unlock */
++	ori	r3, r3, HID0_DCE
++	ori	r5, r3, HID0_DCFI
++	mtspr	HID0, r5		/* enable + invalidate */
++	mtspr	HID0, r3		/* enable */
++	sync
++	blr
++
++/*
++ * Enable data cache(s) - L1 and optionally L2
++ * Calls l2cache_enable. LR saved in r5
++ */
++_GLOBAL(dcache_enable)
++	mfspr	r3, HID0
++	li	r5, HID0_DCFI|HID0_DLOCK
++	andc	r3, r3, r5
++	mtspr	HID0, r3		/* no invalidate, unlock */
++	ori	r3, r3, HID0_DCE
++	ori	r5, r3, HID0_DCFI
++	mtspr	HID0, r5		/* enable + invalidate */
++	mtspr	HID0, r3		/* enable */
++	sync
++#ifdef CONFIG_SYS_L2
++	mflr	r5
++	bl	l2cache_enable		/* uses r3 and r4 */
++	sync
++	mtlr	r5
++#endif
++	blr
++
++
++/*
++ * Disable data cache(s) - L1 and optionally L2
++ * Calls flush_dcache and l2cache_disable_no_flush.
++ * LR saved in r4
++ */
++_GLOBAL(dcache_disable)
++	mflr	r4			/* save link register */
++	bl	flush_dcache	/* uses r3 and r5 */
++	sync
++	mfspr	r3, HID0
++	li	r5, HID0_DCFI|HID0_DLOCK
++	andc	r3, r3, r5
++	mtspr	HID0, r3		/* no invalidate, unlock */
++	li	r5, HID0_DCE|HID0_DCFI
++	andc	r3, r3, r5		/* no enable, no invalidate */
++	mtspr	HID0, r3
++	sync
++#ifdef CONFIG_SYS_L2
++	bl	l2cache_disable_no_flush /* uses r3 */
++#endif
++	mtlr	r4			/* restore link register */
++	blr
++
++/*
++ * Is data cache enabled?
++ */
++_GLOBAL(dcache_status)
++	mfspr	r3, HID0
++	andi.	r3, r3, HID0_DCE
++	blr
++
++/*
++ * Invalidate L2 cache using L2I, assume L2 is enabled
++ */
++_GLOBAL(l2cache_invalidate)
++	mfspr	r3, l2cr
++	rlwinm.	r3, r3, 0, 0, 0
++	beq	1f
++
++	mfspr	r3, l2cr
++	rlwinm	r3, r3, 0, 1, 31
++
++#ifdef	CONFIG_ALTIVEC
++	dssall
++#endif
++	sync
++	mtspr	l2cr, r3
++	sync
++1:	mfspr	r3, l2cr
++	oris	r3, r3, L2CR_L2I@h
++	mtspr	l2cr, r3
++
++invl2:
++	mfspr	r3, l2cr
++	andis.	r3, r3, L2CR_L2I@h
++	bne	invl2
++	blr
++
++/*
++ * Enable L2 cache
++ * Calls l2cache_invalidate. LR is saved in r4
++ */
++_GLOBAL(l2cache_enable)
++	mflr	r4			/* save link register */
++	bl	l2cache_invalidate	/* uses r3 */
++	sync
++	lis	r3, L2_ENABLE@h
++	ori	r3, r3, L2_ENABLE@l
++	mtspr	l2cr, r3
++	isync
++	mtlr	r4			/* restore link register */
++	blr
++
++/*
++ * Disable L2 cache
++ * Calls flush_dcache. LR is saved in r4
++ */
++_GLOBAL(l2cache_disable)
++	mflr	r4			/* save link register */
++	bl	flush_dcache		/* uses r3 and r5 */
++	sync
++	mtlr	r4			/* restore link register */
++l2cache_disable_no_flush:		/* provide way to disable L2 w/o flushing */
++	lis	r3, L2_INIT@h
++	ori	r3, r3, L2_INIT@l
++	mtspr	l2cr, r3
++	isync
++	blr
+diff --git a/arch/powerpc/cpu/qsp/config.mk b/arch/powerpc/cpu/qsp/config.mk
+new file mode 100644
+index 0000000..92ff7bf
+--- /dev/null
++++ b/arch/powerpc/cpu/qsp/config.mk
+@@ -0,0 +1,27 @@
++#
++# (C) Copyright 2004 Freescale Semiconductor.
++# Jeff Brown
++#
++# See file CREDITS for list of people who contributed to this
++# project.
++#
++# This program is free software; you can redistribute it and/or
++# modify it under the terms of the GNU General Public License as
++# published by the Free Software Foundation; either version 2 of
++# the License, or (at your option) any later version.
++#
++# This program is distributed in the hope that it will be useful,
++# but WITHOUT ANY WARRANTY; without even the implied warranty of
++# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++# GNU General Public License for more details.
++#
++# You should have received a copy of the GNU General Public License
++# along with this program; if not, write to the Free Software
++# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
++# MA 02111-1307 USA
++#
++
++PLATFORM_RELFLAGS += -meabi
++
++PLATFORM_CPPFLAGS += -ffixed-r2 -mstring
++PLATFORM_CPPFLAGS += -maltivec -mabi=altivec -msoft-float
+diff --git a/arch/powerpc/cpu/qsp/cpu.c b/arch/powerpc/cpu/qsp/cpu.c
+new file mode 100644
+index 0000000..e275455
+--- /dev/null
++++ b/arch/powerpc/cpu/qsp/cpu.c
+@@ -0,0 +1,141 @@
++/*
++ * Copyright 2006,2009-2010 Freescale Semiconductor, Inc.
++ * Jeff Brown
++ * Srikanth Srinivasan (srikanth.srinivasan@freescale.com)
++ *
++ * See file CREDITS for list of people who contributed to this
++ * project.
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License as
++ * published by the Free Software Foundation; either version 2 of
++ * the License, or (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
++ * MA 02111-1307 USA
++ */
++
++#include <common.h>
++#include <watchdog.h>
++#include <command.h>
++#include <asm/cache.h>
++#include <asm/mmu.h>
++#include <asm/processor.h>
++
++DECLARE_GLOBAL_DATA_PTR;
++
++/*
++ * Default board reset function
++ */
++static void
++__board_reset(void)
++{
++	/* Do nothing */
++}
++void board_reset(void) __attribute__((weak, alias("__board_reset")));
++
++int cpu_numcores()
++{
++        return 1;
++}
++
++int
++checkcpu(void)
++{
++	sys_info_t sysinfo;
++	uint pvr, svr;
++	uint major, minor;
++	char buf1[32], buf2[32];
++	struct cpu_type *cpu;
++
++	svr = get_svr();
++	major = SVR_MAJ(svr);
++	minor = SVR_MIN(svr);
++
++	if (cpu_numcores() > 1) {
++#ifndef CONFIG_MP
++		puts("Unicore software on multiprocessor system!!\n"
++		     "To enable mutlticore build define CONFIG_MP\n");
++#endif
++	}
++
++	puts("Core:  ");
++	pvr = get_pvr();
++	major = PVR_E600_MAJ(pvr);
++	minor = PVR_E600_MIN(pvr);
++
++	printf("E600 Core ");
++	printf(", Version: %d.%d, (0x%08x)\n", major, minor, pvr);
++
++	get_sys_info(&sysinfo);
++
++	puts("Clock Configuration:\n");
++	printf("       CPU:%-4s MHz\n", strmhz(buf1, sysinfo.freqProcessor));
++	printf("       TIMEBASE:%-4s MHz\n", strmhz(buf1, sysinfo.freqTimebase));
++
++	return 0;
++}
++
++
++int do_reset(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
++{
++	/* Attempt board-specific reset */
++	board_reset();
++	while (1)
++		;
++
++	return 1;
++}
++
++
++/*
++ * Get timebase clock frequency
++ */
++unsigned long
++get_tbclk(void)
++{
++	sys_info_t sys_info;
++	get_sys_info(&sys_info);
++	return (sys_info.freqTimebase);
++}
++
++/*
++ * Set the DDR BATs to reflect the actual size of DDR.
++ *
++ * dram_size is the actual size of DDR, in bytes
++ *
++ * Note: we assume that CONFIG_MAX_MEM_MAPPED is 2G or smaller as we only
++ * are using a single BAT to cover DDR.
++ *
++ * If this is not true, (e.g. CONFIG_MAX_MEM_MAPPED is 2GB but HID0_XBSEN
++ * is not defined) then we might have a situation where U-Boot will attempt
++ * to relocated itself outside of the region mapped by DBAT0.
++ * This will cause a machine check.
++ *
++ * Currently we are limited to power of two sized DDR since we only use a
++ * single bat.  If a non-power of two size is used that is less than
++ * CONFIG_MAX_MEM_MAPPED u-boot will crash.
++ *
++ */
++void setup_ddr_bat(phys_addr_t dram_size)
++{
++	unsigned long batu, bl;
++
++	bl = TO_BATU_BL(min(dram_size, CONFIG_MAX_MEM_MAPPED));
++
++	if (BATU_SIZE(bl) != dram_size) {
++		u64 sz = (u64)dram_size - BATU_SIZE(bl);
++		print_size(sz, " left unmapped\n");
++	}
++
++	batu = bl | BATU_VS | BATU_VP;
++	write_bat(DBAT0, batu, CONFIG_SYS_DBAT0L);
++	write_bat(IBAT0, batu, CONFIG_SYS_IBAT0L);
++}
+diff --git a/arch/powerpc/cpu/qsp/cpu_init.c b/arch/powerpc/cpu/qsp/cpu_init.c
+new file mode 100644
+index 0000000..48f5556
+--- /dev/null
++++ b/arch/powerpc/cpu/qsp/cpu_init.c
+@@ -0,0 +1,119 @@
++/*
++ * Copyright 2004,2009-2011 Freescale Semiconductor, Inc.
++ * Jeff Brown
++ * Srikanth Srinivasan (srikanth.srinivasan@freescale.com)
++ *
++ * See file CREDITS for list of people who contributed to this
++ * project.
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License as
++ * published by the Free Software Foundation; either version 2 of
++ * the License, or (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
++ * MA 02111-1307 USA
++ */
++
++/*
++ * cpu_init.c - low level cpu init
++ */
++
++#include <config.h>
++#include <common.h>
++#include <mpc86xx.h>
++#include <asm/mmu.h>
++#include <asm/fsl_law.h>
++#include <asm/fsl_serdes.h>
++#include <asm/mp.h>
++
++extern void srio_init(void);
++
++DECLARE_GLOBAL_DATA_PTR;
++
++/*
++ * Breathe some life into the CPU...
++ *
++ * Set up the memory map
++ * initialize a bunch of registers
++ */
++
++void cpu_init_f(void)
++{
++	/* Pointer is writable since we allocated a register for it */
++	gd = (gd_t *) (CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_GBL_DATA_OFFSET);
++
++	/* Clear initial global data */
++	memset ((void *) gd, 0, sizeof (gd_t));
++
++#ifdef CONFIG_FSL_LAW
++//	init_laws();
++#endif
++
++	setup_bats();
++
++//	init_early_memctl_regs();
++
++#if defined(CONFIG_FSL_DMA)
++//	dma_init();
++#endif
++
++	/* enable the timebase bit in HID0 */
++	set_hid0(get_hid0() | 0x4000000);
++
++	/* enable EMCP, SYNCBE | ABE bits in HID1 */
++	set_hid1(get_hid1() | 0x80000C00);
++}
++
++/*
++ * initialize higher level parts of CPU like timers
++ */
++int cpu_init_r(void)
++{
++	/* needs to be in ram since code uses global static vars */
++//	fsl_serdes_init();
++
++#ifdef CONFIG_SYS_SRIO
++//	srio_init();
++#endif
++
++#if defined(CONFIG_MP)
++	setup_mp();
++#endif
++	return 0;
++}
++
++#ifdef CONFIG_ADDR_MAP
++/* Initialize address mapping array */
++void init_addr_map(void)
++{
++	int i;
++	ppc_bat_t bat = DBAT0;
++	phys_size_t size;
++	unsigned long upper, lower;
++
++	for (i = 0; i < CONFIG_SYS_NUM_ADDR_MAP; i++, bat++) {
++		if (read_bat(bat, &upper, &lower) != -1) {
++			if (!BATU_VALID(upper))
++				size = 0;
++			else
++				size = BATU_SIZE(upper);
++			addrmap_set_entry(BATU_VADDR(upper), BATL_PADDR(lower),
++					  size, i);
++		}
++#ifdef CONFIG_HIGH_BATS
++		/* High bats are not contiguous with low BAT numbers */
++		if (bat == DBAT3)
++			bat = DBAT4 - 1;
++#endif
++	}
++}
++
++#endif
+diff --git a/arch/powerpc/cpu/qsp/fdt.c b/arch/powerpc/cpu/qsp/fdt.c
+new file mode 100644
+index 0000000..63560e3
+--- /dev/null
++++ b/arch/powerpc/cpu/qsp/fdt.c
+@@ -0,0 +1,63 @@
++/*
++ * Copyright 2008, 2011 Freescale Semiconductor, Inc.
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License
++ * Version 2 as published by the Free Software Foundation.
++ */
++
++#include <common.h>
++#include <libfdt.h>
++#include <fdt_support.h>
++#include <asm/mp.h>
++
++DECLARE_GLOBAL_DATA_PTR;
++
++extern void ft_fixup_num_cores(void *blob);
++extern void ft_srio_setup(void *blob);
++
++void ft_cpu_setup(void *blob, bd_t *bd)
++{
++#ifdef CONFIG_MP
++	int off;
++	u32 bootpg = determine_mp_bootpg();
++#endif
++        sys_info_t sys_info;
++
++	get_sys_info(&sys_info);
++
++#if 0
++	do_fixup_by_prop_u32(blob, "device_type", "cpu", 4,
++			     "timebase-frequency", bd->bi_busfreq / 4, 1);
++	do_fixup_by_prop_u32(blob, "device_type", "cpu", 4,
++			     "bus-frequency", bd->bi_busfreq, 1);
++	do_fixup_by_prop_u32(blob, "device_type", "soc", 4,
++			     "bus-frequency", bd->bi_busfreq, 1);
++#endif
++
++	do_fixup_by_prop_u32(blob, "device_type", "cpu", 4,
++			     "clock-frequency", sys_info.freqProcessor, 1);
++	do_fixup_by_prop_u32(blob, "device_type", "cpu", 4,
++			     "timebase-frequency", sys_info.freqTimebase, 1);
++
++#if defined(CONFIG_MPC8641)
++	do_fixup_by_compat_u32(blob, "fsl,mpc8641-localbus",
++			       "bus-frequency", gd->lbc_clk, 1);
++#endif
++#if 0
++	do_fixup_by_compat_u32(blob, "fsl,elbc",
++			       "bus-frequency", gd->lbc_clk, 1);
++#endif
++
++	fdt_fixup_memory(blob, (u64)bd->bi_memstart, (u64)bd->bi_memsize);
++
++
++#ifdef CONFIG_MP
++	/* Reserve the boot page so OSes dont use it */
++	off = fdt_add_mem_rsv(blob, bootpg, (u64)4096);
++	if (off < 0)
++		printf("%s: %s\n", __FUNCTION__, fdt_strerror(off));
++
++	ft_fixup_num_cores(blob);
++#endif
++}
+diff --git a/arch/powerpc/cpu/qsp/interrupts.c b/arch/powerpc/cpu/qsp/interrupts.c
+new file mode 100644
+index 0000000..6895e26
+--- /dev/null
++++ b/arch/powerpc/cpu/qsp/interrupts.c
+@@ -0,0 +1,132 @@
++/*
++ * (C) Copyright 2000-2002
++ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
++ *
++ * (C) Copyright 2002 (440 port)
++ * Scott McNutt, Artesyn Communication Producs, smcnutt@artsyncp.com
++ *
++ * (C) Copyright 2003 Motorola Inc. (MPC85xx port)
++ * Xianghua Xiao (X.Xiao@motorola.com)
++ *
++ * (C) Copyright 2004, 2007 Freescale Semiconductor. (MPC86xx Port)
++ * Jeff Brown
++ * Srikanth Srinivasan (srikanth.srinivasan@freescale.com)
++ *
++ * See file CREDITS for list of people who contributed to this
++ * project.
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License as
++ * published by the Free Software Foundation; either version 2 of
++ * the License, or (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
++ * MA 02111-1307 USA
++ */
++
++#include <common.h>
++//#include <mpc86xx.h>
++#include <command.h>
++#include <asm/processor.h>
++#ifdef CONFIG_POST
++#include <post.h>
++#endif
++
++int interrupt_init_cpu(unsigned long *decrementer_count)
++{
++#if 0
++	volatile immap_t *immr = (immap_t *)CONFIG_SYS_IMMR;
++	volatile ccsr_pic_t *pic = &immr->im_pic;
++
++#ifdef CONFIG_POST
++	/*
++	 * The POST word is stored in the PIC's TFRR register which gets
++	 * cleared when the PIC is reset.  Save it off so we can restore it
++	 * later.
++	 */
++	ulong post_word = post_word_load();
++#endif
++
++	pic->gcr = MPC86xx_PICGCR_RST;
++	while (pic->gcr & MPC86xx_PICGCR_RST)
++		;
++	pic->gcr = MPC86xx_PICGCR_MODE;
++
++	*decrementer_count = get_tbclk() / CONFIG_SYS_HZ;
++	debug("interrupt init: tbclk() = %ld MHz, decrementer_count = %ld\n",
++	      (get_tbclk() / 1000000),
++	      *decrementer_count);
++
++#ifdef CONFIG_INTERRUPTS
++
++	pic->iivpr1 = 0x810001;	/* 50220 enable mcm interrupts */
++	debug("iivpr1@%p = %x\n", &pic->iivpr1, pic->iivpr1);
++
++	pic->iivpr2 = 0x810002;	/* 50240 enable ddr interrupts */
++	debug("iivpr2@%p = %x\n", &pic->iivpr2, pic->iivpr2);
++
++	pic->iivpr3 = 0x810003;	/* 50260 enable lbc interrupts */
++	debug("iivpr3@%p = %x\n", &pic->iivpr3, pic->iivpr3);
++
++#if defined(CONFIG_PCI1) || defined(CONFIG_PCIE1)
++	pic->iivpr8 = 0x810008;	/* enable pcie1 interrupts */
++	debug("iivpr8@%p = %x\n", &pic->iivpr8, pic->iivpr8);
++#endif
++#if defined(CONFIG_PCI2) || defined(CONFIG_PCIE2)
++	pic->iivpr9 = 0x810009;	/* enable pcie2 interrupts */
++	debug("iivpr9@%p = %x\n", &pic->iivpr9, pic->iivpr9);
++#endif
++
++	pic->ctpr = 0;	/* 40080 clear current task priority register */
++#endif
++
++#ifdef CONFIG_POST
++	post_word_store(post_word);
++#endif
++#endif
++	return 0;
++}
++
++/*
++ * timer_interrupt - gets called when the decrementer overflows,
++ * with interrupts disabled.
++ * Trivial implementation - no need to be really accurate.
++ */
++void timer_interrupt_cpu(struct pt_regs *regs)
++{
++	/* nothing to do here */
++}
++
++/*
++ * Install and free a interrupt handler. Not implemented yet.
++ */
++void irq_install_handler(int vec, interrupt_handler_t *handler, void *arg)
++{
++}
++
++void irq_free_handler(int vec)
++{
++}
++
++/*
++ * irqinfo - print information about PCI devices,not implemented.
++ */
++int do_irqinfo(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
++{
++	return 0;
++}
++
++/*
++ * Handle external interrupts
++ */
++void external_interrupt(struct pt_regs *regs)
++{
++	puts("external_interrupt (oops!)\n");
++}
+diff --git a/arch/powerpc/cpu/qsp/mp.c b/arch/powerpc/cpu/qsp/mp.c
+new file mode 100644
+index 0000000..4e97569
+--- /dev/null
++++ b/arch/powerpc/cpu/qsp/mp.c
+@@ -0,0 +1,147 @@
++/*
++ * Copyright 2008-2010 Freescale Semiconductor, Inc.
++ *
++ * See file CREDITS for list of people who contributed to this
++ * project.
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License as
++ * published by the Free Software Foundation; either version 2 of
++ * the License, or (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
++ * MA 02111-1307 USA
++ */
++
++#include <common.h>
++#include <asm/processor.h>
++#include <asm/mmu.h>
++#include <ioports.h>
++#include <lmb.h>
++#include <asm/io.h>
++#include <asm/mp.h>
++
++DECLARE_GLOBAL_DATA_PTR;
++
++int cpu_reset(int nr)
++{
++	/* dummy function so common/cmd_mp.c will build
++	 * should be implemented in the future, when cpu_release()
++	 * is supported.  Be aware there may be a similiar bug
++	 * as exists on MPC85xx w/its PIC having a timing window
++	 * associated to resetting the core */
++	return 1;
++}
++
++int cpu_status(int nr)
++{
++	/* dummy function so common/cmd_mp.c will build */
++	return 0;
++}
++
++int cpu_disable(int nr)
++{
++#if 0
++	volatile immap_t *immap = (immap_t *) CONFIG_SYS_CCSRBAR;
++	volatile ccsr_gur_t *gur = &immap->im_gur;
++
++	switch (nr) {
++	case 0:
++		setbits_be32(&gur->devdisr, MPC86xx_DEVDISR_CPU0);
++		break;
++	case 1:
++		setbits_be32(&gur->devdisr, MPC86xx_DEVDISR_CPU1);
++		break;
++	default:
++		printf("Invalid cpu number for disable %d\n", nr);
++		return 1;
++	}
++#endif
++	return 0;
++}
++
++int is_core_disabled(int nr) {
++#if 0
++	immap_t *immap = (immap_t *) CONFIG_SYS_CCSRBAR;
++	ccsr_gur_t *gur = &immap->im_gur;
++	u32 devdisr = in_be32(&gur->devdisr);
++
++	switch (nr) {
++	case 0:
++		return (devdisr & MPC86xx_DEVDISR_CPU0);
++	case 1:
++		return (devdisr & MPC86xx_DEVDISR_CPU1);
++	default:
++		printf("Invalid cpu number for disable %d\n", nr);
++	}
++#endif
++	return 0;
++}
++
++int cpu_release(int nr, int argc, char * const argv[])
++{
++	/* dummy function so common/cmd_mp.c will build
++	 * should be implemented in the future */
++	return 1;
++}
++
++u32 determine_mp_bootpg(void)
++{
++#if 0
++	/* if we have 4G or more of memory, put the boot page at 4Gb-1M */
++	if ((u64)gd->ram_size > 0xfffff000)
++		return (0xfff00000);
++#endif
++	return (gd->ram_size - (1024 * 1024));
++}
++
++void cpu_mp_lmb_reserve(struct lmb *lmb)
++{
++	u32 bootpg = determine_mp_bootpg();
++
++	/* tell u-boot we stole a page */
++	lmb_reserve(lmb, bootpg, 4096);
++}
++
++/*
++ * Copy the code for other cpus to execute into an
++ * aligned location accessible via BPTR
++ */
++void setup_mp(void)
++{
++#if 0
++	extern ulong __secondary_start_page;
++	ulong fixup = (ulong)&__secondary_start_page;
++	u32 bootpg = determine_mp_bootpg();
++	u32 bootpg_va;
++
++	if (bootpg >= CONFIG_SYS_MAX_DDR_BAT_SIZE) {
++		/* We're not covered by the DDR mapping, set up BAT  */
++		write_bat(DBAT7, CONFIG_SYS_SCRATCH_VA | BATU_BL_128K |
++			  BATU_VS | BATU_VP,
++			  bootpg | BATL_PP_RW | BATL_MEMCOHERENCE);
++		bootpg_va = CONFIG_SYS_SCRATCH_VA;
++	} else {
++		bootpg_va = bootpg;
++	}
++
++	memcpy((void *)bootpg_va, (void *)fixup, 4096);
++	flush_cache(bootpg_va, 4096);
++
++	/* remove the temporary BAT mapping */
++	if (bootpg >= CONFIG_SYS_MAX_DDR_BAT_SIZE)
++		write_bat(DBAT7, 0, 0);
++
++	/* If the physical location of bootpg is not at fff00000, set BPTR */
++	if (bootpg != 0xfff00000)
++		out_be32((uint *)(CONFIG_SYS_CCSRBAR + 0x20), 0x80000000 |
++			 (bootpg >> 12));
++#endif
++}
+diff --git a/arch/powerpc/cpu/qsp/speed.c b/arch/powerpc/cpu/qsp/speed.c
+new file mode 100644
+index 0000000..73bb018
+--- /dev/null
++++ b/arch/powerpc/cpu/qsp/speed.c
+@@ -0,0 +1,46 @@
++/*
++ * Copyright 2004 Freescale Semiconductor.
++ * Jeff Brown
++ * Srikanth Srinivasan (srikanth.srinivasan@freescale.com)
++ *
++ * (C) Copyright 2000-2002
++ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
++ *
++ * See file CREDITS for list of people who contributed to this
++ * project.
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License as
++ * published by the Free Software Foundation; either version 2 of
++ * the License, or (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
++ * MA 02111-1307 USA
++ */
++
++#include <common.h>
++#include <asm/processor.h>
++#include <asm/io.h>
++
++DECLARE_GLOBAL_DATA_PTR;
++
++void get_sys_info(sys_info_t *sysInfo)
++{
++        sysregs_get_freqs(sysInfo);
++}
++
++int get_clocks(void)
++{
++	sys_info_t sys_info;
++	get_sys_info(&sys_info);
++	gd->cpu_clk = sys_info.freqProcessor;
++	gd->bus_clk = sys_info.freqTimebase;
++        return 0;
++}
+diff --git a/arch/powerpc/cpu/qsp/start.S b/arch/powerpc/cpu/qsp/start.S
+new file mode 100644
+index 0000000..368667b
+--- /dev/null
++++ b/arch/powerpc/cpu/qsp/start.S
+@@ -0,0 +1,1000 @@
++/*
++ * Copyright 2004, 2007, 2011 Freescale Semiconductor.
++ * Srikanth Srinivasan <srikanth.srinivaan@freescale.com>
++ *
++ * See file CREDITS for list of people who contributed to this
++ * project.
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License as
++ * published by the Free Software Foundation; either version 2 of
++ * the License, or (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
++ * MA 02111-1307 USA
++ */
++
++/*  U-Boot - Startup Code for 86xx PowerPC based Embedded Boards
++ *
++ *
++ *  The processor starts at 0xfff00100 and the code is executed
++ *  from flash. The code is organized to be at an other address
++ *  in memory, but as long we don't jump around before relocating.
++ *  board_init lies at a quite high address and when the cpu has
++ *  jumped there, everything is ok.
++ */
++#include <asm-offsets.h>
++#include <config.h>
++#include <mpc86xx.h>
++#include <version.h>
++
++#include <ppc_asm.tmpl>
++#include <ppc_defs.h>
++
++#include <asm/cache.h>
++#include <asm/mmu.h>
++#include <asm/u-boot.h>
++
++/*
++ * Need MSR_DR | MSR_IR enabled to access I/O (printf) in exceptions
++ */
++
++/*
++ * Set up GOT: Global Offset Table
++ *
++ * Use r12 to access the GOT
++ */
++	START_GOT
++	GOT_ENTRY(_GOT2_TABLE_)
++	GOT_ENTRY(_FIXUP_TABLE_)
++
++	GOT_ENTRY(_start)
++	GOT_ENTRY(_start_of_vectors)
++	GOT_ENTRY(_end_of_vectors)
++	GOT_ENTRY(transfer_to_handler)
++
++	GOT_ENTRY(__init_end)
++	GOT_ENTRY(__bss_end__)
++	GOT_ENTRY(__bss_start)
++	END_GOT
++
++/*
++ * r3 - 1st arg to board_init(): IMMP pointer
++ * r4 - 2nd arg to board_init(): boot flag
++ */
++	.text
++	.long	0x27051956		/* U-Boot Magic Number */
++	.globl	version_string
++version_string:
++	.ascii U_BOOT_VERSION_STRING, "\0"
++
++	. = EXC_OFF_SYS_RESET
++	.globl	_start
++_start:
++	b	boot_cold
++
++	/* the boot code is located below the exception table */
++
++	.globl	_start_of_vectors
++_start_of_vectors:
++
++/* Machine check */
++	STD_EXCEPTION(0x200, MachineCheck, MachineCheckException)
++
++/* Data Storage exception. */
++	STD_EXCEPTION(0x300, DataStorage, UnknownException)
++
++/* Instruction Storage exception. */
++	STD_EXCEPTION(0x400, InstStorage, UnknownException)
++
++/* External Interrupt exception. */
++	STD_EXCEPTION(0x500, ExtInterrupt, external_interrupt)
++
++/* Alignment exception. */
++	. = 0x600
++Alignment:
++	EXCEPTION_PROLOG(SRR0, SRR1)
++	mfspr	r4,DAR
++	stw	r4,_DAR(r21)
++	mfspr	r5,DSISR
++	stw	r5,_DSISR(r21)
++	addi	r3,r1,STACK_FRAME_OVERHEAD
++	EXC_XFER_TEMPLATE(Alignment, AlignmentException, MSR_KERNEL, COPY_EE)
++
++/* Program check exception */
++	. = 0x700
++ProgramCheck:
++	EXCEPTION_PROLOG(SRR0, SRR1)
++	addi	r3,r1,STACK_FRAME_OVERHEAD
++	EXC_XFER_TEMPLATE(ProgramCheck, ProgramCheckException,
++		MSR_KERNEL, COPY_EE)
++
++	STD_EXCEPTION(0x800, FPUnavailable, UnknownException)
++
++	/* I guess we could implement decrementer, and may have
++	 * to someday for timekeeping.
++	 */
++	STD_EXCEPTION(0x900, Decrementer, timer_interrupt)
++	STD_EXCEPTION(0xa00, Trap_0a, UnknownException)
++	STD_EXCEPTION(0xb00, Trap_0b, UnknownException)
++	STD_EXCEPTION(0xc00, SystemCall, UnknownException)
++	STD_EXCEPTION(0xd00, SingleStep, UnknownException)
++	STD_EXCEPTION(0xe00, Trap_0e, UnknownException)
++	STD_EXCEPTION(0xf00, Trap_0f, UnknownException)
++	STD_EXCEPTION(0x1000, SoftEmu, SoftEmuException)
++	STD_EXCEPTION(0x1100, InstructionTLBMiss, UnknownException)
++	STD_EXCEPTION(0x1200, DataTLBMiss, UnknownException)
++	STD_EXCEPTION(0x1300, InstructionTLBError, UnknownException)
++	STD_EXCEPTION(0x1400, DataTLBError, UnknownException)
++	STD_EXCEPTION(0x1500, Reserved5, UnknownException)
++	STD_EXCEPTION(0x1600, Reserved6, UnknownException)
++	STD_EXCEPTION(0x1700, Reserved7, UnknownException)
++	STD_EXCEPTION(0x1800, Reserved8, UnknownException)
++	STD_EXCEPTION(0x1900, Reserved9, UnknownException)
++	STD_EXCEPTION(0x1a00, ReservedA, UnknownException)
++	STD_EXCEPTION(0x1b00, ReservedB, UnknownException)
++	STD_EXCEPTION(0x1c00, DataBreakpoint, UnknownException)
++	STD_EXCEPTION(0x1d00, InstructionBreakpoint, UnknownException)
++	STD_EXCEPTION(0x1e00, PeripheralBreakpoint, UnknownException)
++	STD_EXCEPTION(0x1f00, DevPortBreakpoint, UnknownException)
++
++	.globl	_end_of_vectors
++_end_of_vectors:
++
++	. = 0x2000
++
++boot_cold:
++	/*
++	 * NOTE: Only Cpu 0 will ever come here.  Other cores go to an
++	 * address specified by the BPTR
++	 */
++1:
++#ifdef CONFIG_SYS_RAMBOOT
++	/* disable everything */
++	li	r0, 0
++	mtspr	HID0, r0
++	sync
++	mtmsr	0
++#endif
++
++	/* Invalidate BATs */
++	bl	invalidate_bats
++	sync
++	/* Invalidate all of TLB before MMU turn on */
++	bl      clear_tlbs
++	sync
++
++#ifdef CONFIG_SYS_L2
++	/* init the L2 cache */
++	lis	r3, L2_INIT@h
++	ori	r3, r3, L2_INIT@l
++	mtspr	l2cr, r3
++	/* invalidate the L2 cache */
++	bl	l2cache_invalidate
++	sync
++#endif
++
++	/*
++	 * Calculate absolute address in FLASH and jump there
++	 *------------------------------------------------------*/
++	lis	r3, CONFIG_SYS_MONITOR_BASE_EARLY@h
++	ori	r3, r3, CONFIG_SYS_MONITOR_BASE_EARLY@l
++	addi	r3, r3, in_flash - _start + EXC_OFF_SYS_RESET
++	mtlr	r3
++	blr
++
++in_flash:
++	/* let the C-code set up the rest			*/
++	/*							*/
++	/* Be careful to keep code relocatable !		*/
++	/*------------------------------------------------------*/
++	/* perform low-level init */
++
++	/* enable extended addressing */
++	bl	enable_ext_addr
++
++	/* setup the bats */
++	bl	early_bats
++
++	/*
++	 * Cache must be enabled here for stack-in-cache trick.
++	 * This means we need to enable the BATS.
++	 * Cache should be turned on after BATs, since by default
++	 * everything is write-through.
++	 */
++
++	/* enable address translation */
++	mfmsr	r5
++	ori	r5, r5, (MSR_IR | MSR_DR)
++	lis	r3,addr_trans_enabled@h
++	ori	r3, r3, addr_trans_enabled@l
++	mtspr	SPRN_SRR0,r3
++	mtspr	SPRN_SRR1,r5
++	rfi
++
++addr_trans_enabled:
++	/* enable and invalidate the data cache */
++/*	bl	l1dcache_enable */
++	bl	dcache_enable
++	sync
++
++#if 1
++	bl	icache_enable
++#endif
++
++#ifdef CONFIG_SYS_INIT_RAM_LOCK
++	bl	lock_ram_in_cache
++	sync
++#endif
++
++#if (CONFIG_SYS_CCSRBAR_DEFAULT != CONFIG_SYS_CCSRBAR)
++//	bl      setup_ccsrbar
++#endif
++
++	/* set up the stack pointer in our newly created
++	 * cache-ram (r1) */
++	lis	r1, (CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_GBL_DATA_OFFSET)@h
++	ori	r1, r1, (CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_GBL_DATA_OFFSET)@l
++
++	li	r0, 0		/* Make room for stack frame header and */
++	stwu	r0, -4(r1)	/* clear final stack frame so that	*/
++	stwu	r0, -4(r1)	/* stack backtraces terminate cleanly	*/
++
++	GET_GOT			/* initialize GOT access	*/
++
++	/* run low-level CPU init code	   (from Flash) */
++	bl	cpu_init_f
++	sync
++
++#ifdef	RUN_DIAG
++
++	/* Load PX_AUX register address in r4 */
++	lis	r4, PIXIS_BASE@h
++	ori	r4, r4, 0x6
++	/* Load contents of PX_AUX in r3 bits 24 to 31*/
++	lbz	r3, 0(r4)
++
++	/* Mask and obtain the bit in r3 */
++	rlwinm. r3, r3, 0, 24, 24
++	/* If not zero, jump and continue with u-boot */
++	bne	diag_done
++
++	/* Load back contents of PX_AUX in r3 bits 24 to 31 */
++	lbz	r3, 0(r4)
++	/* Set the MSB of the register value */
++	ori	r3, r3, 0x80
++	/* Write value in r3 back to PX_AUX */
++	stb	r3, 0(r4)
++
++	/* Get the address to jump to in r3*/
++	lis	r3, CONFIG_SYS_DIAG_ADDR@h
++	ori	r3, r3, CONFIG_SYS_DIAG_ADDR@l
++
++	/* Load the LR with the branch address */
++	mtlr	r3
++
++	/* Branch to diagnostic */
++	blr
++
++diag_done:
++#endif
++
++/*	bl	l2cache_enable */
++
++	/* run 1st part of board init code (from Flash)	  */
++	bl	board_init_f
++	sync
++
++	/* NOTREACHED - board_init_f() does not return */
++
++	.globl	invalidate_bats
++invalidate_bats:
++
++	li	r0, 0
++	/* invalidate BATs */
++	mtspr	IBAT0U, r0
++	mtspr	IBAT1U, r0
++	mtspr	IBAT2U, r0
++	mtspr	IBAT3U, r0
++	mtspr	IBAT4U, r0
++	mtspr	IBAT5U, r0
++	mtspr	IBAT6U, r0
++	mtspr	IBAT7U, r0
++
++	isync
++	mtspr	DBAT0U, r0
++	mtspr	DBAT1U, r0
++	mtspr	DBAT2U, r0
++	mtspr	DBAT3U, r0
++	mtspr	DBAT4U, r0
++	mtspr	DBAT5U, r0
++	mtspr	DBAT6U, r0
++	mtspr	DBAT7U, r0
++
++	isync
++	sync
++	blr
++
++#define CONFIG_BAT_PAIR(n) \
++	lis	r4, CONFIG_SYS_IBAT##n##L@h; 		\
++	ori	r4, r4, CONFIG_SYS_IBAT##n##L@l; 	\
++	lis	r3, CONFIG_SYS_IBAT##n##U@h; 		\
++	ori	r3, r3, CONFIG_SYS_IBAT##n##U@l; 	\
++	mtspr	IBAT##n##L, r4; 			\
++	mtspr	IBAT##n##U, r3; 			\
++	lis	r4, CONFIG_SYS_DBAT##n##L@h; 		\
++	ori	r4, r4, CONFIG_SYS_DBAT##n##L@l; 	\
++	lis	r3, CONFIG_SYS_DBAT##n##U@h; 		\
++	ori	r3, r3, CONFIG_SYS_DBAT##n##U@l; 	\
++	mtspr	DBAT##n##L, r4;				\
++	mtspr	DBAT##n##U, r3;
++
++/*
++ * setup_bats:
++ *
++ * Set up the final BAT registers now that setup is done.
++ *
++ * Assumes that:
++ *	1) Address translation is enabled upon entry
++ *	2) The boot rom is still accessible via 1:1 translation
++ */
++	.globl setup_bats
++setup_bats:
++	mflr	r5
++	sync
++
++	/*
++	 * When we disable address translation, we will get 1:1 (VA==PA)
++	 * translation.  The only place we know for sure is safe for that is
++	 * the bootrom where we originally started out.  Pop back into there.
++	 */
++	lis	r4, CONFIG_SYS_MONITOR_BASE_EARLY@h
++	ori	r4, r4, CONFIG_SYS_MONITOR_BASE_EARLY@l
++	addi	r4, r4, trans_disabled - _start + EXC_OFF_SYS_RESET
++
++	/* disable address translation */
++	mfmsr	r3
++	rlwinm	r3, r3, 0, 28, 25
++	mtspr	SRR0, r4
++	mtspr	SRR1, r3
++	rfi
++
++trans_disabled:
++#if defined(CONFIG_SYS_DBAT0U) && defined(CONFIG_SYS_DBAT0L) \
++	&& defined(CONFIG_SYS_IBAT0U) && defined(CONFIG_SYS_IBAT0L)
++	CONFIG_BAT_PAIR(0)
++#endif
++	CONFIG_BAT_PAIR(1)
++	CONFIG_BAT_PAIR(2)
++	CONFIG_BAT_PAIR(3)
++	CONFIG_BAT_PAIR(4)
++	CONFIG_BAT_PAIR(5)
++	CONFIG_BAT_PAIR(6)
++	CONFIG_BAT_PAIR(7)
++
++	sync
++	isync
++
++	/* Turn translation back on and return */
++	mfmsr	r3
++	ori	r3, r3, (MSR_IR | MSR_DR)
++	mtspr	SPRN_SRR0,r5
++	mtspr	SPRN_SRR1,r3
++	rfi
++
++/*
++ * early_bats:
++ *
++ * Set up bats needed early on - this is usually the BAT for the
++ * stack-in-cache, the Flash, and CCSR space
++ */
++	.globl  early_bats
++early_bats:
++	/* IBAT 3 */
++	lis	r4, CONFIG_SYS_IBAT3L@h
++	ori     r4, r4, CONFIG_SYS_IBAT3L@l
++	lis	r3, CONFIG_SYS_IBAT3U@h
++	ori     r3, r3, CONFIG_SYS_IBAT3U@l
++	mtspr   IBAT3L, r4
++	mtspr   IBAT3U, r3
++	isync
++
++	/* DBAT 3 */
++	lis	r4, CONFIG_SYS_DBAT3L@h
++	ori     r4, r4, CONFIG_SYS_DBAT3L@l
++	lis	r3, CONFIG_SYS_DBAT3U@h
++	ori     r3, r3, CONFIG_SYS_DBAT3U@l
++	mtspr   DBAT3L, r4
++	mtspr   DBAT3U, r3
++	isync
++
++	/* DBAT 5 */
++	lis	r4, CONFIG_SYS_DBAT5L@h
++	ori     r4, r4, CONFIG_SYS_DBAT5L@l
++	lis	r3, CONFIG_SYS_DBAT5U@h
++	ori     r3, r3, CONFIG_SYS_DBAT5U@l
++	mtspr   DBAT5L, r4
++	mtspr   DBAT5U, r3
++	isync
++
++	/* IBAT 6 */
++	lis	r4, CONFIG_SYS_IBAT6L_EARLY@h
++	ori     r4, r4, CONFIG_SYS_IBAT6L_EARLY@l
++	lis	r3, CONFIG_SYS_IBAT6U_EARLY@h
++	ori     r3, r3, CONFIG_SYS_IBAT6U_EARLY@l
++	mtspr   IBAT6L, r4
++	mtspr   IBAT6U, r3
++	isync
++
++	/* DBAT 6 */
++	lis	r4, CONFIG_SYS_DBAT6L_EARLY@h
++	ori     r4, r4, CONFIG_SYS_DBAT6L_EARLY@l
++	lis	r3, CONFIG_SYS_DBAT6U_EARLY@h
++	ori     r3, r3, CONFIG_SYS_DBAT6U_EARLY@l
++	mtspr   DBAT6L, r4
++	mtspr   DBAT6U, r3
++	isync
++
++#if(CONFIG_SYS_CCSRBAR_DEFAULT != CONFIG_SYS_CCSRBAR)
++	/* IBAT 7 */
++	lis	r4, CONFIG_SYS_CCSR_DEFAULT_IBATL@h
++	ori     r4, r4, CONFIG_SYS_CCSR_DEFAULT_IBATL@l
++	lis	r3, CONFIG_SYS_CCSR_DEFAULT_IBATU@h
++	ori     r3, r3, CONFIG_SYS_CCSR_DEFAULT_IBATU@l
++	mtspr   IBAT7L, r4
++	mtspr   IBAT7U, r3
++	isync
++
++	/* DBAT 7 */
++	lis	r4, CONFIG_SYS_CCSR_DEFAULT_DBATL@h
++	ori     r4, r4, CONFIG_SYS_CCSR_DEFAULT_DBATL@l
++	lis	r3, CONFIG_SYS_CCSR_DEFAULT_DBATU@h
++	ori     r3, r3, CONFIG_SYS_CCSR_DEFAULT_DBATU@l
++	mtspr   DBAT7L, r4
++	mtspr   DBAT7U, r3
++	isync
++#endif
++	blr
++
++	.globl clear_tlbs
++clear_tlbs:
++	addis   r3, 0, 0x0000
++	addis   r5, 0, 0x4
++	isync
++tlblp:
++	tlbie   r3
++	sync
++	addi    r3, r3, 0x1000
++	cmp     0, 0, r3, r5
++	blt tlblp
++	blr
++
++	.globl disable_addr_trans
++disable_addr_trans:
++	/* disable address translation */
++	mflr	r4
++	mfmsr	r3
++	andi.	r0, r3, (MSR_IR | MSR_DR)
++	beqlr
++	andc	r3, r3, r0
++	mtspr	SRR0, r4
++	mtspr	SRR1, r3
++	rfi
++
++/*
++ * This code finishes saving the registers to the exception frame
++ * and jumps to the appropriate handler for the exception.
++ * Register r21 is pointer into trap frame, r1 has new stack pointer.
++ */
++	.globl	transfer_to_handler
++transfer_to_handler:
++	stw	r22,_NIP(r21)
++	lis	r22,MSR_POW@h
++	andc	r23,r23,r22
++	stw	r23,_MSR(r21)
++	SAVE_GPR(7, r21)
++	SAVE_4GPRS(8, r21)
++	SAVE_8GPRS(12, r21)
++	SAVE_8GPRS(24, r21)
++	mflr	r23
++	andi.	r24,r23,0x3f00		/* get vector offset */
++	stw	r24,TRAP(r21)
++	li	r22,0
++	stw	r22,RESULT(r21)
++	mtspr	SPRG2,r22		/* r1 is now kernel sp */
++	lwz	r24,0(r23)		/* virtual address of handler */
++	lwz	r23,4(r23)		/* where to go when done */
++	mtspr	SRR0,r24
++	mtspr	SRR1,r20
++	mtlr	r23
++	SYNC
++	rfi				/* jump to handler, enable MMU */
++
++int_return:
++	mfmsr	r28		/* Disable interrupts */
++	li	r4,0
++	ori	r4,r4,MSR_EE
++	andc	r28,r28,r4
++	SYNC			/* Some chip revs need this... */
++	mtmsr	r28
++	SYNC
++	lwz	r2,_CTR(r1)
++	lwz	r0,_LINK(r1)
++	mtctr	r2
++	mtlr	r0
++	lwz	r2,_XER(r1)
++	lwz	r0,_CCR(r1)
++	mtspr	XER,r2
++	mtcrf	0xFF,r0
++	REST_10GPRS(3, r1)
++	REST_10GPRS(13, r1)
++	REST_8GPRS(23, r1)
++	REST_GPR(31, r1)
++	lwz	r2,_NIP(r1)	/* Restore environment */
++	lwz	r0,_MSR(r1)
++	mtspr	SRR0,r2
++	mtspr	SRR1,r0
++	lwz	r0,GPR0(r1)
++	lwz	r2,GPR2(r1)
++	lwz	r1,GPR1(r1)
++	SYNC
++	rfi
++
++	.globl	dc_read
++dc_read:
++	blr
++
++	.globl get_pvr
++get_pvr:
++	mfspr	r3, PVR
++	blr
++
++	.globl get_svr
++get_svr:
++	mfspr	r3, SVR
++	blr
++
++
++/*
++ * Function:	in8
++ * Description:	Input 8 bits
++ */
++	.globl	in8
++in8:
++	lbz	r3,0x0000(r3)
++	blr
++
++/*
++ * Function:	out8
++ * Description:	Output 8 bits
++ */
++	.globl	out8
++out8:
++	stb	r4,0x0000(r3)
++	blr
++
++/*
++ * Function:	out16
++ * Description:	Output 16 bits
++ */
++	.globl	out16
++out16:
++	sth	r4,0x0000(r3)
++	blr
++
++/*
++ * Function:	out16r
++ * Description:	Byte reverse and output 16 bits
++ */
++	.globl	out16r
++out16r:
++	sthbrx	r4,r0,r3
++	blr
++
++/*
++ * Function:	out32
++ * Description:	Output 32 bits
++ */
++	.globl	out32
++out32:
++	stw	r4,0x0000(r3)
++	blr
++
++/*
++ * Function:	out32r
++ * Description:	Byte reverse and output 32 bits
++ */
++	.globl	out32r
++out32r:
++	stwbrx	r4,r0,r3
++	blr
++
++/*
++ * Function:	in16
++ * Description:	Input 16 bits
++ */
++	.globl	in16
++in16:
++	lhz	r3,0x0000(r3)
++	blr
++
++/*
++ * Function:	in16r
++ * Description:	Input 16 bits and byte reverse
++ */
++	.globl	in16r
++in16r:
++	lhbrx	r3,r0,r3
++	blr
++
++/*
++ * Function:	in32
++ * Description:	Input 32 bits
++ */
++	.globl	in32
++in32:
++	lwz	3,0x0000(3)
++	blr
++
++/*
++ * Function:	in32r
++ * Description:	Input 32 bits and byte reverse
++ */
++	.globl	in32r
++in32r:
++	lwbrx	r3,r0,r3
++	blr
++
++/*
++ * void relocate_code (addr_sp, gd, addr_moni)
++ *
++ * This "function" does not return, instead it continues in RAM
++ * after relocating the monitor code.
++ *
++ * r3 = dest
++ * r4 = src
++ * r5 = length in bytes
++ * r6 = cachelinesize
++ */
++	.globl	relocate_code
++relocate_code:
++
++	mr	r1,  r3		/* Set new stack pointer		*/
++	mr	r9,  r4		/* Save copy of Global Data pointer	*/
++	mr	r10, r5		/* Save copy of Destination Address	*/
++
++	GET_GOT
++	mr	r3,  r5				/* Destination Address	*/
++	lis	r4, CONFIG_SYS_MONITOR_BASE@h		/* Source      Address	*/
++	ori	r4, r4, CONFIG_SYS_MONITOR_BASE@l
++	lwz	r5, GOT(__init_end)
++	sub	r5, r5, r4
++	li	r6, CONFIG_SYS_CACHELINE_SIZE		/* Cache Line Size	*/
++
++	/*
++	 * Fix GOT pointer:
++	 *
++	 * New GOT-PTR = (old GOT-PTR - CONFIG_SYS_MONITOR_BASE) + Destination Address
++	 *
++	 * Offset:
++	 */
++	sub	r15, r10, r4
++
++	/* First our own GOT */
++	add	r12, r12, r15
++	/* then the one used by the C code */
++	add	r30, r30, r15
++
++	/*
++	 * Now relocate code
++	 */
++	cmplw	cr1,r3,r4
++	addi	r0,r5,3
++	srwi.	r0,r0,2
++	beq	cr1,4f		/* In place copy is not necessary	*/
++	beq	7f		/* Protect against 0 count		*/
++	mtctr	r0
++	bge	cr1,2f
++
++	la	r8,-4(r4)
++	la	r7,-4(r3)
++1:	lwzu	r0,4(r8)
++	stwu	r0,4(r7)
++	bdnz	1b
++	b	4f
++
++2:	slwi	r0,r0,2
++	add	r8,r4,r0
++	add	r7,r3,r0
++3:	lwzu	r0,-4(r8)
++	stwu	r0,-4(r7)
++	bdnz	3b
++/*
++ * Now flush the cache: note that we must start from a cache aligned
++ * address. Otherwise we might miss one cache line.
++ */
++4:	cmpwi	r6,0
++	add	r5,r3,r5
++	beq	7f		/* Always flush prefetch queue in any case */
++	subi	r0,r6,1
++	andc	r3,r3,r0
++	mr	r4,r3
++5:	dcbst	0,r4
++	add	r4,r4,r6
++	cmplw	r4,r5
++	blt	5b
++	sync			/* Wait for all dcbst to complete on bus */
++	mr	r4,r3
++6:	icbi	0,r4
++	add	r4,r4,r6
++	cmplw	r4,r5
++	blt	6b
++7:	sync			/* Wait for all icbi to complete on bus */
++	isync
++
++/*
++ * We are done. Do not return, instead branch to second part of board
++ * initialization, now running from RAM.
++ */
++	addi	r0, r10, in_ram - _start + EXC_OFF_SYS_RESET
++	mtlr	r0
++	blr
++
++in_ram:
++	/*
++	 * Relocation Function, r12 point to got2+0x8000
++	 *
++	 * Adjust got2 pointers, no need to check for 0, this code
++	 * already puts a few entries in the table.
++	 */
++	li	r0,__got2_entries@sectoff@l
++	la	r3,GOT(_GOT2_TABLE_)
++	lwz	r11,GOT(_GOT2_TABLE_)
++	mtctr	r0
++	sub	r11,r3,r11
++	addi	r3,r3,-4
++1:	lwzu	r0,4(r3)
++	cmpwi	r0,0
++	beq-	2f
++	add	r0,r0,r11
++	stw	r0,0(r3)
++2:	bdnz	1b
++
++	/*
++	 * Now adjust the fixups and the pointers to the fixups
++	 * in case we need to move ourselves again.
++	 */
++	li	r0,__fixup_entries@sectoff@l
++	lwz	r3,GOT(_FIXUP_TABLE_)
++	cmpwi	r0,0
++	mtctr	r0
++	addi	r3,r3,-4
++	beq	4f
++3:	lwzu	r4,4(r3)
++	lwzux	r0,r4,r11
++	cmpwi	r0,0
++	add	r0,r0,r11
++	stw	r4,0(r3)
++	beq-	5f
++	stw	r0,0(r4)
++5:	bdnz	3b
++4:
++/* clear_bss: */
++	/*
++	 * Now clear BSS segment
++	 */
++	lwz	r3,GOT(__bss_start)
++	lwz	r4,GOT(__bss_end__)
++
++	cmplw	0, r3, r4
++	beq	6f
++
++	li	r0, 0
++5:
++	stw	r0, 0(r3)
++	addi	r3, r3, 4
++	cmplw	0, r3, r4
++	bne	5b
++6:
++	mr	r3, r9		/* Init Date pointer		*/
++	mr	r4, r10		/* Destination Address		*/
++	bl	board_init_r
++
++	/* not reached - end relocate_code */
++/*-----------------------------------------------------------------------*/
++
++	/*
++	 * Copy exception vector code to low memory
++	 *
++	 * r3: dest_addr
++	 * r7: source address, r8: end address, r9: target address
++	 */
++	.globl	trap_init
++trap_init:
++	mflr	r4			/* save link register		*/
++	GET_GOT
++	lwz	r7, GOT(_start)
++	lwz	r8, GOT(_end_of_vectors)
++
++	li	r9, 0x100		/* reset vector always at 0x100 */
++
++	cmplw	0, r7, r8
++	bgelr				/* return if r7>=r8 - just in case */
++1:
++	lwz	r0, 0(r7)
++	stw	r0, 0(r9)
++	addi	r7, r7, 4
++	addi	r9, r9, 4
++	cmplw	0, r7, r8
++	bne	1b
++
++	/*
++	 * relocate `hdlr' and `int_return' entries
++	 */
++	li	r7, .L_MachineCheck - _start + EXC_OFF_SYS_RESET
++	li	r8, Alignment - _start + EXC_OFF_SYS_RESET
++2:
++	bl	trap_reloc
++	addi	r7, r7, 0x100		/* next exception vector	*/
++	cmplw	0, r7, r8
++	blt	2b
++
++	li	r7, .L_Alignment - _start + EXC_OFF_SYS_RESET
++	bl	trap_reloc
++
++	li	r7, .L_ProgramCheck - _start + EXC_OFF_SYS_RESET
++	bl	trap_reloc
++
++	li	r7, .L_FPUnavailable - _start + EXC_OFF_SYS_RESET
++	li	r8, SystemCall - _start + EXC_OFF_SYS_RESET
++3:
++	bl	trap_reloc
++	addi	r7, r7, 0x100		/* next exception vector	*/
++	cmplw	0, r7, r8
++	blt	3b
++
++	li	r7, .L_SingleStep - _start + EXC_OFF_SYS_RESET
++	li	r8, _end_of_vectors - _start + EXC_OFF_SYS_RESET
++4:
++	bl	trap_reloc
++	addi	r7, r7, 0x100		/* next exception vector	*/
++	cmplw	0, r7, r8
++	blt	4b
++
++	/* enable execptions from RAM vectors */
++	mfmsr	r7
++	li	r8,MSR_IP
++	andc	r7,r7,r8
++	ori	r7,r7,MSR_ME		/* Enable Machine Check */
++	mtmsr	r7
++
++	mtlr	r4			/* restore link register	*/
++	blr
++
++.globl enable_ext_addr
++enable_ext_addr:
++	mfspr	r0, HID0
++	lis	r0, (HID0_HIGH_BAT_EN | HID0_XBSEN | HID0_XAEN)@h
++	ori	r0, r0, (HID0_HIGH_BAT_EN | HID0_XBSEN | HID0_XAEN)@l
++	mtspr	HID0, r0
++	sync
++	isync
++	blr
++
++#if (CONFIG_SYS_CCSRBAR_DEFAULT != CONFIG_SYS_CCSRBAR)
++.globl setup_ccsrbar
++setup_ccsrbar:
++	/* Special sequence needed to update CCSRBAR itself */
++	lis	r4, CONFIG_SYS_CCSRBAR_DEFAULT@h
++	ori	r4, r4, CONFIG_SYS_CCSRBAR_DEFAULT@l
++
++	lis	r5, CONFIG_SYS_CCSRBAR_PHYS_LOW@h
++	ori	r5, r5, CONFIG_SYS_CCSRBAR_PHYS_LOW@l
++	srwi	r5,r5,12
++	li	r6, CONFIG_SYS_CCSRBAR_PHYS_HIGH@l
++	rlwimi	r5,r6,20,8,11
++	stw	r5, 0(r4) /* Store physical value of CCSR */
++	isync
++
++	lis	r5, CONFIG_SYS_TEXT_BASE@h
++	ori	r5,r5,CONFIG_SYS_TEXT_BASE@l
++	lwz	r5, 0(r5)
++	isync
++
++	/* Use VA of CCSR to do read */
++	lis	r3, CONFIG_SYS_CCSRBAR@h
++	lwz	r5, CONFIG_SYS_CCSRBAR@l(r3)
++	isync
++
++	blr
++#endif
++
++#ifdef CONFIG_SYS_INIT_RAM_LOCK
++	xx
++lock_ram_in_cache:
++	/* Allocate Initial RAM in data cache.
++	 */
++	lis	r3, (CONFIG_SYS_INIT_RAM_ADDR & ~31)@h
++	ori	r3, r3, (CONFIG_SYS_INIT_RAM_ADDR & ~31)@l
++	li	r4, ((CONFIG_SYS_INIT_RAM_SIZE & ~31) + \
++		     (CONFIG_SYS_INIT_RAM_ADDR & 31) + 31) / 32
++	mtctr	r4
++1:
++	dcbz	r0, r3
++	addi	r3, r3, 32
++	bdnz	1b
++#if 1
++/* Lock the data cache */
++	mfspr	r0, HID0
++	ori	r0, r0, 0x1000
++	sync
++	mtspr	HID0, r0
++	sync
++	blr
++#endif
++#if 0
++	/* Lock the first way of the data cache */
++	mfspr	r0, LDSTCR
++	ori	r0, r0, 0x0080
++#if defined(CONFIG_ALTIVEC)
++	dssall
++#endif
++	sync
++	mtspr	LDSTCR, r0
++	sync
++	isync
++	blr
++#endif
++
++.globl unlock_ram_in_cache
++unlock_ram_in_cache:
++	/* invalidate the INIT_RAM section */
++	lis	r3, (CONFIG_SYS_INIT_RAM_ADDR & ~31)@h
++	ori	r3, r3, (CONFIG_SYS_INIT_RAM_ADDR & ~31)@l
++	li	r4, ((CONFIG_SYS_INIT_RAM_SIZE & ~31) + \
++		     (CONFIG_SYS_INIT_RAM_ADDR & 31) + 31) / 32
++	mtctr	r4
++1:	icbi	r0, r3
++	addi	r3, r3, 32
++	bdnz	1b
++	sync			/* Wait for all icbi to complete on bus */
++	isync
++#if 1
++/* Unlock the data cache and invalidate it */
++	mfspr	r0, HID0
++	li	r3,0x1000
++	andc	r0,r0,r3
++	li	r3,0x0400
++	or	r0,r0,r3
++	sync
++	mtspr	HID0, r0
++	sync
++	blr
++#endif
++#if 0
++	/* Unlock the first way of the data cache */
++	mfspr	r0, LDSTCR
++	li	r3,0x0080
++	andc	r0,r0,r3
++#ifdef CONFIG_ALTIVEC
++	dssall
++#endif
++	sync
++	mtspr	LDSTCR, r0
++	sync
++	isync
++	li	r3,0x0400
++	or	r0,r0,r3
++	sync
++	mtspr	HID0, r0
++	sync
++	blr
++#endif
++#endif
+diff --git a/arch/powerpc/cpu/qsp/traps.c b/arch/powerpc/cpu/qsp/traps.c
+new file mode 100644
+index 0000000..166ff8c
+--- /dev/null
++++ b/arch/powerpc/cpu/qsp/traps.c
+@@ -0,0 +1,234 @@
++/*
++ * Copyright (C) 1995-1996  Gary Thomas (gdt@linuxppc.org)
++ *
++ * Modified by Cort Dougan (cort@cs.nmt.edu)
++ * and Paul Mackerras (paulus@cs.anu.edu.au)
++ *
++ * (C) Copyright 2000
++ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
++ *
++ * See file CREDITS for list of people who contributed to this
++ * project.
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License as
++ * published by the Free Software Foundation; either version 2 of
++ * the License, or (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
++ * MA 02111-1307 USA
++ */
++
++/*
++ * This file handles the architecture-dependent parts of hardware exceptions
++ */
++
++#include <common.h>
++#include <command.h>
++#include <kgdb.h>
++#include <asm/processor.h>
++
++DECLARE_GLOBAL_DATA_PTR;
++
++/* Returns 0 if exception not found and fixup otherwise.  */
++extern unsigned long search_exception_table(unsigned long);
++
++/*
++ * End of addressable memory.  This may be less than the actual
++ * amount of memory on the system if we're unable to keep all
++ * the memory mapped in.
++ */
++extern ulong get_effective_memsize(void);
++#define END_OF_MEM (gd->bd->bi_memstart + get_effective_memsize())
++
++/*
++ * Trap & Exception support
++ */
++
++void
++print_backtrace(unsigned long *sp)
++{
++	int cnt = 0;
++	unsigned long i;
++
++	printf("Call backtrace: ");
++	while (sp) {
++		if ((uint) sp > END_OF_MEM)
++			break;
++
++		i = sp[1];
++		if (cnt++ % 7 == 0)
++			printf("\n");
++		printf("%08lX ", i);
++		if (cnt > 32)
++			break;
++		sp = (unsigned long *)*sp;
++	}
++	printf("\n");
++}
++
++void
++show_regs(struct pt_regs *regs)
++{
++	int i;
++
++	printf("NIP: %08lX XER: %08lX LR: %08lX REGS:"
++	       " %p TRAP: %04lx DAR: %08lX\n",
++	       regs->nip, regs->xer, regs->link, regs, regs->trap, regs->dar);
++	printf("MSR: %08lx EE: %01x PR: %01x FP:"
++	       " %01x ME: %01x IR/DR: %01x%01x\n",
++	       regs->msr, regs->msr & MSR_EE ? 1 : 0,
++	       regs->msr & MSR_PR ? 1 : 0, regs->msr & MSR_FP ? 1 : 0,
++	       regs->msr & MSR_ME ? 1 : 0, regs->msr & MSR_IR ? 1 : 0,
++	       regs->msr & MSR_DR ? 1 : 0);
++
++	printf("\n");
++	for (i = 0; i < 32; i++) {
++		if ((i % 8) == 0) {
++			printf("GPR%02d: ", i);
++		}
++
++		printf("%08lX ", regs->gpr[i]);
++		if ((i % 8) == 7) {
++			printf("\n");
++		}
++	}
++}
++
++
++void
++_exception(int signr, struct pt_regs *regs)
++{
++	show_regs(regs);
++	print_backtrace((unsigned long *)regs->gpr[1]);
++	panic("Exception in kernel pc %lx signal %d", regs->nip, signr);
++}
++
++void
++MachineCheckException(struct pt_regs *regs)
++{
++	unsigned long fixup;
++
++	/* Probing PCI using config cycles cause this exception
++	 * when a device is not present.  Catch it and return to
++	 * the PCI exception handler.
++	 */
++	if ((fixup = search_exception_table(regs->nip)) != 0) {
++		regs->nip = fixup;
++		return;
++	}
++
++#if defined(CONFIG_CMD_KGDB)
++	if (debugger_exception_handler && (*debugger_exception_handler) (regs))
++		return;
++#endif
++
++	printf("Machine check in kernel mode.\n");
++	printf("Caused by (from msr): ");
++	printf("regs %p ", regs);
++	switch ( regs->msr & 0x001F0000) {
++	case (0x80000000>>11):
++                printf("FIXME\n");
++//		printf("MSS error. MSSSR0: %08x\n", mfspr(SPRN_MSSSR0));
++		break;
++	case (0x80000000>>12):
++		printf("Machine check signal - probably due to mm fault\n"
++		       "with mmu off\n");
++		break;
++	case (0x80000000 >> 13):
++		printf("Transfer error ack signal\n");
++		break;
++	case (0x80000000 >> 14):
++		printf("Data parity signal\n");
++		break;
++	case (0x80000000 >> 15):
++		printf("Address parity signal\n");
++		break;
++	default:
++		printf("Unknown values in msr\n");
++	}
++	show_regs(regs);
++	print_backtrace((unsigned long *)regs->gpr[1]);
++	panic("machine check");
++}
++
++void
++AlignmentException(struct pt_regs *regs)
++{
++#if defined(CONFIG_CMD_KGDB)
++	if (debugger_exception_handler && (*debugger_exception_handler) (regs))
++		return;
++#endif
++	show_regs(regs);
++	print_backtrace((unsigned long *)regs->gpr[1]);
++	panic("Alignment Exception");
++}
++
++void
++ProgramCheckException(struct pt_regs *regs)
++{
++	unsigned char *p = regs ? (unsigned char *)(regs->nip) : NULL;
++	int i, j;
++
++#if defined(CONFIG_CMD_KGDB)
++	if (debugger_exception_handler && (*debugger_exception_handler) (regs))
++		return;
++#endif
++	show_regs(regs);
++
++	p = (unsigned char *)((unsigned long)p & 0xFFFFFFE0);
++	p -= 32;
++	for (i = 0; i < 256; i += 16) {
++		printf("%08x: ", (unsigned int)p + i);
++		for (j = 0; j < 16; j++) {
++			printf("%02x ", p[i + j]);
++		}
++		printf("\n");
++	}
++
++	print_backtrace((unsigned long *)regs->gpr[1]);
++	panic("Program Check Exception");
++}
++
++void
++SoftEmuException(struct pt_regs *regs)
++{
++#if defined(CONFIG_CMD_KGDB)
++	if (debugger_exception_handler && (*debugger_exception_handler) (regs))
++		return;
++#endif
++	show_regs(regs);
++	print_backtrace((unsigned long *)regs->gpr[1]);
++	panic("Software Emulation Exception");
++}
++
++void
++UnknownException(struct pt_regs *regs)
++{
++#if defined(CONFIG_CMD_KGDB)
++	if (debugger_exception_handler && (*debugger_exception_handler) (regs))
++		return;
++#endif
++	printf("UnknownException regs@%lx\n", (ulong)regs);
++	printf("Bad trap at PC: %lx, SR: %lx, vector=%lx\n",
++	       regs->nip, regs->msr, regs->trap);
++	_exception(0, regs);
++}
++
++/*
++ * Probe an address by reading.
++ * If not present, return -1,
++ * otherwise return 0.
++ */
++int
++addr_probe(uint *addr)
++{
++	return 0;
++}
+diff --git a/arch/powerpc/cpu/qsp/u-boot.lds b/arch/powerpc/cpu/qsp/u-boot.lds
+new file mode 100644
+index 0000000..b579277
+--- /dev/null
++++ b/arch/powerpc/cpu/qsp/u-boot.lds
+@@ -0,0 +1,93 @@
++/*
++ * Copyright 2006, 2007 Freescale Semiconductor, Inc.
++ *
++ * See file CREDITS for list of people who contributed to this
++ * project.
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License as
++ * published by the Free Software Foundation; either version 2 of
++ * the License, or (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
++ * MA 02111-1307 USA
++ */
++
++OUTPUT_ARCH(powerpc)
++
++SECTIONS
++{
++
++  /* Read-only sections, merged into text segment: */
++  .text      :
++  {
++    arch/powerpc/cpu/qsp/start.o	(.text*)
++    arch/powerpc/cpu/qsp/traps.o	(.text*)
++    *(.text*)
++   }
++    _etext = .;
++    PROVIDE (etext = .);
++    .rodata    :
++   {
++    *(SORT_BY_ALIGNMENT(SORT_BY_NAME(.rodata*)))
++  }
++
++  /* Read-write section, merged into data segment: */
++  . = (. + 0x00FF) & 0xFFFFFF00;
++  _erotext = .;
++  PROVIDE (erotext = .);
++  .reloc   :
++  {
++    _GOT2_TABLE_ = .;
++    KEEP(*(.got2))
++    KEEP(*(.got))
++    PROVIDE(_GLOBAL_OFFSET_TABLE_ = . + 4);
++    _FIXUP_TABLE_ = .;
++    KEEP(*(.fixup))
++  }
++  __got2_entries = ((_GLOBAL_OFFSET_TABLE_ - _GOT2_TABLE_) >> 2) - 1;
++  __fixup_entries = (. - _FIXUP_TABLE_) >> 2;
++
++  .data    :
++  {
++    *(.data*)
++    *(.sdata*)
++  }
++  _edata  =  .;
++  PROVIDE (edata = .);
++
++  . = .;
++  __u_boot_cmd_start = .;
++  .u_boot_cmd : { *(.u_boot_cmd) }
++  __u_boot_cmd_end = .;
++
++  . = .;
++  __start___ex_table = .;
++  __ex_table : { *(__ex_table) }
++  __stop___ex_table = .;
++
++  . = ALIGN(256);
++  __init_begin = .;
++  .text.init : { *(.text.init) }
++  .data.init : { *(.data.init) }
++  . = ALIGN(256);
++  __init_end = .;
++
++  __bss_start = .;
++  .bss (NOLOAD)       :
++  {
++   *(.bss*)
++   *(.sbss*)
++   *(COMMON)
++   . = ALIGN(4);
++  }
++  __bss_end__ = . ;
++  PROVIDE (end = .);
++}
+diff --git a/board/windriver/qsp_ppc/Makefile b/board/windriver/qsp_ppc/Makefile
+new file mode 100644
+index 0000000..4d6f293
+--- /dev/null
++++ b/board/windriver/qsp_ppc/Makefile
+@@ -0,0 +1,43 @@
++#
++# (C) Copyright 2000-2004
++# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
++#
++# See file CREDITS for list of people who contributed to this
++# project.
++#
++# This program is free software; you can redistribute it and/or
++# modify it under the terms of the GNU General Public License as
++# published by the Free Software Foundation; either version 2 of
++# the License, or (at your option) any later version.
++#
++# This program is distributed in the hope that it will be useful,
++# but WITHOUT ANY WARRANTY; without even the implied warranty of
++# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++# GNU General Public License for more details.
++#
++# You should have received a copy of the GNU General Public License
++# along with this program; if not, write to the Free Software
++# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
++# MA 02111-1307 USA
++#
++
++include $(TOPDIR)/config.mk
++
++LIB	= $(obj)lib$(BOARD).o
++
++COBJS	:= qsp_ppc.o
++
++SRCS	:= $(COBJS:.o=.c)
++OBJS	:= $(addprefix $(obj),$(COBJS))
++
++$(LIB):	$(obj).depend $(OBJS)
++	$(call cmd_link_o_target, $(OBJS))
++
++#########################################################################
++
++# defines $(obj).depend target
++include $(SRCTREE)/rules.mk
++
++sinclude $(obj).depend
++
++#########################################################################
+diff --git a/board/windriver/qsp_ppc/qsp_ppc.c b/board/windriver/qsp_ppc/qsp_ppc.c
+new file mode 100644
+index 0000000..9a15225
+--- /dev/null
++++ b/board/windriver/qsp_ppc/qsp_ppc.c
+@@ -0,0 +1,152 @@
++/*
++ * (C) Copyright 2012
++ * Wind River AB
++ * Ivar Holmqvist <ivar.holmqvist@windriver.com>
++ *
++ * See file CREDITS for list of people who contributed to this
++ * project.
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License as
++ * published by the Free Software Foundation; either version 2 of
++ * the License, or (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
++ * MA 02111-1307 USA
++ */
++
++#include <common.h>
++#include <asm/processor.h>
++#include <asm/io.h>
++#include <libfdt.h>
++#include <fdt_support.h>
++
++#define QSP_SERIAL_BASE 0xe0010000
++#define QSP_SYSREG_BASE 0xe0001000
++
++/* Status register bits
++ */
++#define TX_READY (1<<0)
++#define RX_READY (1<<1)
++
++/* Control register bits
++ */
++#define TX_INT (1<<0)
++#define RX_INT (1<<1)
++
++#define ID_REG      0x00
++#define STATUS_REG  0x04
++#define CONTROL_REG 0x08
++#define TXDATA_REG  0x0c
++#define RXDATA_REG  0x10
++
++/* SYSREG registers */
++#define ID_REG            0x00
++#define CPU_ID_REG        0x10
++#define MEM_AVAIL_REG     0x20
++#define MEM_START_REG     0x24
++#define CPU_FREQ_REG      0x28
++#define TIMEBASE_FREQ_REG 0x2c
++
++
++int checkboard(void) 
++{
++        printf("QSP PPC board sysregs ID 0x%08x\n", readl(QSP_SYSREG_BASE + ID_REG));
++	return 0;
++}
++
++phys_size_t
++initdram(int board_type)
++{
++	phys_size_t dram_size = 0;
++        dram_size = readl(QSP_SYSREG_BASE + MEM_AVAIL_REG);
++	setup_ddr_bat(dram_size);        
++	return dram_size;
++}
++
++
++
++
++#if defined(CONFIG_OF_BOARD_SETUP)
++void
++ft_board_setup(void *blob, bd_t *bd)
++{
++	int off;
++	u64 *tmp;
++	u32 *addrcells;
++
++	ft_cpu_setup(blob, bd);
++}
++#endif
++
++void board_reset(void)
++{
++        printf("reset not supported\n");
++        /* FIXME:*/
++	while (1)
++		;
++}
++
++#if defined(CONFIG_SHOW_BOOT_PROGRESS)
++void show_boot_progress(int progress)
++{
++	printf("Boot reached stage %d\n", progress);
++}
++#endif
++
++int serial_init (void)
++{
++        /*nop*/
++}
++
++void serial_setbrg (void)
++{
++        /*nop*/
++}
++
++void serial_putc(const char x)
++{
++        if (x == '\n')
++                writel('\r', QSP_SERIAL_BASE + TXDATA_REG);                
++        writel(x, QSP_SERIAL_BASE + TXDATA_REG);
++}
++
++void serial_puts   (const char *x)
++{
++        int i;
++        for (i = 0; x[i]; i++) {
++                serial_putc(x[i]);
++        }
++}
++
++int serial_getc(void)
++{
++        while(!serial_tstc())
++                ;
++        return readl(QSP_SERIAL_BASE + RXDATA_REG);
++}
++
++int serial_tstc(void)
++{
++        return readl(QSP_SERIAL_BASE + STATUS_REG) & RX_READY;
++}
++
++
++
++int	saveenv	     (void)
++{
++        return 0;
++}
++
++void sysregs_get_freqs(sys_info_t *sysInfo)
++{
++        sysInfo->freqProcessor = readl(QSP_SYSREG_BASE + CPU_FREQ_REG);        
++        sysInfo->freqTimebase = readl(QSP_SYSREG_BASE + TIMEBASE_FREQ_REG);        
++}
+diff --git a/boards.cfg b/boards.cfg
+index e040d6c..8e5c31f 100644
+--- a/boards.cfg
++++ b/boards.cfg
+@@ -763,6 +763,7 @@ xpedite520x                  powerpc     mpc85xx     -                   xes
+ xpedite537x                  powerpc     mpc85xx     -                   xes
+ xpedite550x                  powerpc     mpc85xx     -                   xes
+ sbc8641d                     powerpc     mpc86xx
++qsp_ppc                      powerpc     qsp     qsp_ppc             windriver
+ MPC8610HPCD                  powerpc     mpc86xx     mpc8610hpcd         freescale
+ MPC8641HPCN                  powerpc     mpc86xx     mpc8641hpcn         freescale      -           MPC8641HPCN
+ MPC8641HPCN_36BIT            powerpc     mpc86xx     mpc8641hpcn         freescale      -           MPC8641HPCN:PHYS_64BIT
+diff --git a/include/configs/qsp_ppc.h b/include/configs/qsp_ppc.h
+new file mode 100644
+index 0000000..40d5eec
+--- /dev/null
++++ b/include/configs/qsp_ppc.h
+@@ -0,0 +1,208 @@
++#ifndef __QSP_PPC_H
++#define __QSP_PPC_H
++
++#define CONFIG_SYS_PHYS_ADDR_HIGH 0x00000000
++
++#define CONFIG_SYS_QSPREGS                 	0xe0000000	
++#define CONFIG_SYS_QSPREGS_PHYS_LOW	        0xe0000000	
++#define CONFIG_SYS_QSPREGS_PHYS_HIGH	        0x00000000	
++
++#define CONFIG_SYS_FLASH_BASE	0xd0000000     /* start of FLASH 256M */
++#define	CONFIG_SYS_TEXT_BASE	0xd0000000
++
++#define CONFIG_SYS_FLASH_BASE_PHYS_LOW	CONFIG_SYS_FLASH_BASE
++#define CONFIG_SYS_FLASH_BASE_PHYS \
++	PAIRED_PHYS_TO_PHYS(CONFIG_SYS_FLASH_BASE_PHYS_LOW, \
++			    CONFIG_SYS_PHYS_ADDR_HIGH)
++
++#define CONFIG_SYS_MONITOR_BASE		CONFIG_SYS_TEXT_BASE	/* start of monitor */
++#define CONFIG_SYS_MONITOR_BASE_EARLY   0xfff00000	/* early monitor loc */
++
++#define CONFIG_SYS_INIT_RAM_ADDR	0x00000000	/* Initial RAM address */
++
++#define CONFIG_SYS_INIT_RAM_SIZE	0x4000		/* Size of used area in RAM */
++#define CONFIG_SYS_GBL_DATA_OFFSET	(CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE)
++#define CONFIG_SYS_INIT_SP_OFFSET	CONFIG_SYS_GBL_DATA_OFFSET
++
++#define CONFIG_SYS_MONITOR_LEN		(256 * 1024)	/* Reserve 256 kB for Mon */
++#define CONFIG_SYS_MALLOC_LEN		(1024 * 1024)	 /* Reserved for malloc */
++
++
++#define CONFIG_SYS_NO_FLASH
++//#define CONFIG_MP		1	/* support multiple processors, not needed yet...  */
++#define CONFIG_LINUX_RESET_VEC	0x100	/* Reset vector used by Linux */
++#define CONFIG_ADDR_MAP		1	/* Use addr map */
++#define CONFIG_BAT_RW		1	/* Use common BAT rw code */
++#define CONFIG_HIGH_BATS	1	/* High BATs supported and enabled */
++
++/*
++ * BAT0		DDR
++ */
++#define CONFIG_SYS_DBAT0L	(BATL_PP_RW | BATL_MEMCOHERENCE)
++#define CONFIG_SYS_IBAT0L	(BATL_PP_RW | BATL_MEMCOHERENCE)
++
++
++
++/*
++ * BAT3		I/O
++ */
++#ifdef CONFIG_SYS_DBAT3L
++#error Redfine
++#endif
++#define CONFIG_SYS_DBAT3L	( CONFIG_SYS_QSPREGS_PHYS_LOW  \
++				 | BATL_PP_RW | BATL_CACHEINHIBIT \
++				 | BATL_GUARDEDSTORAGE)
++#define CONFIG_SYS_DBAT3U	( CONFIG_SYS_QSPREGS | BATU_BL_256M | BATU_VS \
++				 | BATU_VP)
++#define CONFIG_SYS_IBAT3L	( CONFIG_SYS_QSPREGS_PHYS_LOW \
++				 | BATL_PP_RW | BATL_MEMCOHERENCE)
++#define CONFIG_SYS_IBAT3U	CONFIG_SYS_DBAT3U
++
++
++/*
++ * BAT5		Init RAM for stack in the CPU DCache (no backing memory)
++ */
++#define CONFIG_SYS_DBAT5L	(CONFIG_SYS_INIT_RAM_ADDR | BATL_PP_RW | BATL_MEMCOHERENCE)
++#define CONFIG_SYS_DBAT5U	(CONFIG_SYS_INIT_RAM_ADDR | BATU_BL_128K | BATU_VS | BATU_VP)
++#define CONFIG_SYS_IBAT5L	CONFIG_SYS_DBAT5L
++#define CONFIG_SYS_IBAT5U	CONFIG_SYS_DBAT5U
++
++/*
++ * BAT6		FLASH
++ */
++#define CONFIG_SYS_DBAT6L	(CONFIG_SYS_FLASH_BASE_PHYS_LOW  \
++				 | BATL_PP_RW | BATL_CACHEINHIBIT \
++				 | BATL_GUARDEDSTORAGE)
++#define CONFIG_SYS_DBAT6U	(CONFIG_SYS_FLASH_BASE | BATU_BL_256M | BATU_VS \
++				 | BATU_VP)
++#define CONFIG_SYS_IBAT6L	(CONFIG_SYS_FLASH_BASE_PHYS_LOW \
++				 | BATL_PP_RW | BATL_MEMCOHERENCE)
++#define CONFIG_SYS_IBAT6U	CONFIG_SYS_DBAT6U
++
++/* Map the last 1M of flash where we're running from reset */
++#define CONFIG_SYS_DBAT6L_EARLY	(CONFIG_SYS_MONITOR_BASE_EARLY | BATL_PP_RW \
++				 | BATL_CACHEINHIBIT | BATL_GUARDEDSTORAGE)
++#define CONFIG_SYS_DBAT6U_EARLY	(CONFIG_SYS_TEXT_BASE | BATU_BL_1M | BATU_VS | BATU_VP)
++#define CONFIG_SYS_IBAT6L_EARLY	(CONFIG_SYS_MONITOR_BASE_EARLY | BATL_PP_RW \
++				 | BATL_MEMCOHERENCE)
++#define CONFIG_SYS_IBAT6U_EARLY	CONFIG_SYS_DBAT6U_EARLY
++
++/*
++ * BAT1,7,2,4		FREE - used later for tmp mappings
++ */
++#define CONFIG_SYS_DBAT1L 0x00000000
++#define CONFIG_SYS_DBAT1U 0x00000000
++#define CONFIG_SYS_IBAT1L 0x00000000
++#define CONFIG_SYS_IBAT1U 0x00000000
++
++#define CONFIG_SYS_DBAT2L 0x00000000
++#define CONFIG_SYS_DBAT2U 0x00000000
++#define CONFIG_SYS_IBAT2L 0x00000000
++#define CONFIG_SYS_IBAT2U 0x00000000
++
++#define CONFIG_SYS_DBAT4L 0x00000000
++#define CONFIG_SYS_DBAT4U 0x00000000
++#define CONFIG_SYS_IBAT4L 0x00000000
++#define CONFIG_SYS_IBAT4U 0x00000000
++
++#define CONFIG_SYS_DBAT7L 0x00000000
++#define CONFIG_SYS_DBAT7U 0x00000000
++#define CONFIG_SYS_IBAT7L 0x00000000
++#define CONFIG_SYS_IBAT7U 0x00000000
++
++#define CONFIG_ENV_IS_NOWHERE	1	/* Store ENV in memory only */
++#define CONFIG_ENV_ADDR		(CONFIG_SYS_MONITOR_BASE - 0x1000)
++#define CONFIG_ENV_SIZE		0x2000
++
++#define CONFIG_LOADS_ECHO	1	/* echo on for serial download */
++#define CONFIG_SYS_LOADS_BAUD_CHANGE	1	/* allow baudrate change */
++
++
++
++/*
++ * Command line configuration.
++ */
++#include <config_cmd_default.h>
++
++#if defined(CONFIG_SYS_RAMBOOT)
++    #undef CONFIG_CMD_SAVEENV
++#endif
++
++#if defined(CONFIG_PCI)
++    #define CONFIG_CMD_PCI
++    #define CONFIG_CMD_SCSI
++    #define CONFIG_CMD_EXT2
++    #define CONFIG_CMD_USB
++#endif
++
++
++//#undef CONFIG_WATCHDOG			/* watchdog disabled */
++
++/*
++ * Miscellaneous configurable options
++ */
++#define CONFIG_SYS_LONGHELP			/* undef to save memory	*/
++#define CONFIG_CMDLINE_EDITING		/* Command-line editing */
++#define CONFIG_SYS_LOAD_ADDR	0x2000000	/* default load address */
++#define CONFIG_SYS_PROMPT	"qsp-ppc# "		/* Monitor Command Prompt */
++
++#define CONFIG_OF_LIBFDT		1
++#define CONFIG_OF_BOARD_SETUP		1
++
++#if defined(CONFIG_CMD_KGDB)
++    #define CONFIG_SYS_CBSIZE	1024		/* Console I/O Buffer Size */
++#else
++    #define CONFIG_SYS_CBSIZE	256		/* Console I/O Buffer Size */
++#endif
++
++#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE+sizeof(CONFIG_SYS_PROMPT)+16) /* Print Buffer Size */
++#define CONFIG_SYS_MAXARGS	16		/* max number of command args */
++#define CONFIG_SYS_BARGSIZE	CONFIG_SYS_CBSIZE	/* Boot Argument Buffer Size */
++#define CONFIG_SYS_HZ		1000		/* decrementer freq: 1ms ticks */
++
++/*
++ * For booting Linux, the board info and command line data
++ * have to be in the first 8 MB of memory, since this is
++ * the maximum mapped by the Linux kernel during initialization.
++ */
++#define CONFIG_SYS_BOOTMAPSZ	(8 << 20)	/* Initial Memory map for Linux*/
++
++#if defined(CONFIG_CMD_KGDB)
++    #define CONFIG_KGDB_BAUDRATE	230400	/* speed to run kgdb serial port */
++    #define CONFIG_KGDB_SER_INDEX	2	/* which serial port to use */
++#endif
++/*
++ * Environment Configuration
++ */
++#define CONFIG_BOOTCOMMAND  "use_simics_script_instead"
++
++#define CONFIG_MAX_CPUS 128
++
++#ifndef __ASSEMBLY__
++typedef struct
++{
++        unsigned long freqProcessor;
++        unsigned long freqTimebase;
++} sys_info_t;
++#endif
++
++#define CONFIG_SYS_NUM_ADDR_MAP 8	/* Number of addr map slots = 8 dbats */
++#define CONFIG_BAUDRATE	115200
++#define CONFIG_SYS_BAUDRATE_TABLE	{ 115200 }
++#define CONFIG_SYS_DDR_SDRAM_BASE	0x00000000	/* DDR is system memory*/
++#define CONFIG_SYS_SDRAM_BASE		CONFIG_SYS_DDR_SDRAM_BASE
++#define CONFIG_SYS_MAX_DDR_BAT_SIZE	0x80000000	/* BAT mapping size */
++#define CONFIG_VERY_BIG_RAM
++
++#define CONFIG_SYS_MEMTEST_START	0x00200000	/* memtest region */
++#define CONFIG_SYS_MEMTEST_END		0x00400000
++
++#define CONFIG_SYS_SDRAM_SIZE           (256<<20)
++
++/* FIXME helpers for stolen cache.S
++ */
++#define CONFIG_SYS_L2
++#define L2_INIT		0
++#define L2_ENABLE	(L2CR_L2E)
++
++#endif	/* __CONFIG_H */
+-- 
+1.7.9.5
+
diff -pNur buildroot.2014.08/board/windriver/qsp-ppc/uboot-2011.12-0003-qsp-arm-Enable-ATAGS-for-older-kernels.patch buildroot/board/windriver/qsp-ppc/uboot-2011.12-0003-qsp-arm-Enable-ATAGS-for-older-kernels.patch
--- buildroot.2014.08/board/windriver/qsp-ppc/uboot-2011.12-0003-qsp-arm-Enable-ATAGS-for-older-kernels.patch	1970-01-01 07:00:00.000000000 +0700
+++ buildroot/board/windriver/qsp-ppc/uboot-2011.12-0003-qsp-arm-Enable-ATAGS-for-older-kernels.patch	2014-12-09 13:19:53.701729700 +0800
@@ -0,0 +1,28 @@
+From 3b11cb19fd79999c044c07c2c6960388cdc0003a Mon Sep 17 00:00:00 2001
+From: Ivar Holmqvist <ivarholmqvist@gmail.com>
+Date: Thu, 29 Nov 2012 15:47:17 +0100
+Subject: [PATCH] qsp-arm: Enable ATAGS for older kernels.
+
+---
+ include/configs/qsp_arm.h |    5 +++++
+ 1 file changed, 5 insertions(+)
+
+diff --git a/include/configs/qsp_arm.h b/include/configs/qsp_arm.h
+index 51378c9..bf73925 100644
+--- a/include/configs/qsp_arm.h
++++ b/include/configs/qsp_arm.h
+@@ -61,6 +61,11 @@
+ #define CONFIG_NR_DRAM_BANKS		1
+ #define PHYS_SDRAM_1			0x10000000
+ 
++#define CONFIG_CMDLINE_TAG
++#define CONFIG_SETUP_MEMORY_TAGS
++#define CONFIG_INITRD_TAG
++
++
+ /* additions for new relocation code */
+ #define CONFIG_SYS_SDRAM_BASE		PHYS_SDRAM_1
+ #define CONFIG_SYS_INIT_RAM_SIZE		0x8000
+-- 
+1.7.9.5
+
diff -pNur buildroot.2014.08/board/windriver/qsp-ppc/uboot-2011.12-0004-qsp-arm-Use-proper-machine-number-for-qsp-arm.patch buildroot/board/windriver/qsp-ppc/uboot-2011.12-0004-qsp-arm-Use-proper-machine-number-for-qsp-arm.patch
--- buildroot.2014.08/board/windriver/qsp-ppc/uboot-2011.12-0004-qsp-arm-Use-proper-machine-number-for-qsp-arm.patch	1970-01-01 07:00:00.000000000 +0700
+++ buildroot/board/windriver/qsp-ppc/uboot-2011.12-0004-qsp-arm-Use-proper-machine-number-for-qsp-arm.patch	2014-12-09 13:19:53.701729700 +0800
@@ -0,0 +1,26 @@
+From 264226fa25dc541c4eb68ccbd15352eef85ca171 Mon Sep 17 00:00:00 2001
+From: Ivar Holmqvist <ivarholmqvist@gmail.com>
+Date: Thu, 29 Nov 2012 15:47:59 +0100
+Subject: [PATCH] qsp-arm: Use proper machine number for qsp-arm.
+
+---
+ include/configs/qsp_arm.h |    3 +--
+ 1 file changed, 1 insertion(+), 2 deletions(-)
+
+diff --git a/include/configs/qsp_arm.h b/include/configs/qsp_arm.h
+index bf73925..e51745c 100644
+--- a/include/configs/qsp_arm.h
++++ b/include/configs/qsp_arm.h
+@@ -27,8 +27,7 @@
+ #ifndef __CONFIG_H
+ #define __CONFIG_H
+ 
+-/* CHECKME do we need these? update in linux?*/
+-#define MACH_TYPE_QSP_ARM 0xffffffff
++#define MACH_TYPE_QSP_ARM           4455
+ #define CONFIG_SYS_LOAD_ADDR		0x10008000	/* load address */
+ #define LINUX_BOOT_PARAM_ADDR		0x10000100
+ #define CONFIG_SYS_TEXT_BASE           0x000000
+-- 
+1.7.9.5
+
diff -pNur buildroot.2014.08/board/windriver/qsp-ppc/uboot-2011.12-0005-Backport-U-Boot-v2013.10-patches-to-support-loading-.patch buildroot/board/windriver/qsp-ppc/uboot-2011.12-0005-Backport-U-Boot-v2013.10-patches-to-support-loading-.patch
--- buildroot.2014.08/board/windriver/qsp-ppc/uboot-2011.12-0005-Backport-U-Boot-v2013.10-patches-to-support-loading-.patch	1970-01-01 07:00:00.000000000 +0700
+++ buildroot/board/windriver/qsp-ppc/uboot-2011.12-0005-Backport-U-Boot-v2013.10-patches-to-support-loading-.patch	2014-12-09 13:19:53.701729700 +0800
@@ -0,0 +1,302 @@
+From 98d69d3d6205473a0698cc166b3ac060bfacaad3 Mon Sep 17 00:00:00 2001
+From: Bin Meng <bin.meng@windriver.com>
+Date: Thu, 26 Dec 2013 12:27:52 +0800
+Subject: [PATCH] Backport U-Boot v2013.10 patches to support loading VxWorks
+ 7 kernel. Now Vx-7 kernel can be loaded by U-Boot via
+ command:
+
+=> bootm <kernel> <ramdisk> <dtb>
+
+Tested with PPC build (P2020RDB_config) and ARM build (qsp_arm_config).
+---
+ arch/arm/lib/bootm.c      |   23 +++++++++++++
+ arch/powerpc/lib/bootm.c  |   56 +++++++++++++++++++++++++++++++
+ common/cmd_bootm.c        |   82 ++++++++++++++++++++++++++++++++++++++++-----
+ include/common.h          |    4 +++
+ include/config_defaults.h |    1 +
+ include/vxworks.h         |    3 ++
+ 6 files changed, 160 insertions(+), 9 deletions(-)
+
+diff --git a/arch/arm/lib/bootm.c b/arch/arm/lib/bootm.c
+index afa0093..40fd064 100644
+--- a/arch/arm/lib/bootm.c
++++ b/arch/arm/lib/bootm.c
+@@ -344,3 +344,26 @@ static ulong get_sp(void)
+ 	asm("mov %0, sp" : "=r"(ret) : );
+ 	return ret;
+ }
++
++#if defined(CONFIG_BOOTM_VXWORKS)
++void boot_prep_vxworks(bootm_headers_t *images)
++{
++#if defined(CONFIG_OF_LIBFDT)
++       int off;
++
++       if (images->ft_addr) {
++               off = fdt_path_offset(images->ft_addr, "/memory");
++               if (off < 0) {
++                       if (fixup_memory_node(images->ft_addr))
++                               puts("## WARNING: fixup memory failed!\n");
++               }
++       }
++#endif
++       cleanup_before_linux();
++}
++void boot_jump_vxworks(bootm_headers_t *images)
++{
++       /* ARM VxWorks requires device tree physical address to be passed */
++       ((void (*)(void *))images->ep)(images->ft_addr);
++}
++#endif
+diff --git a/arch/powerpc/lib/bootm.c b/arch/powerpc/lib/bootm.c
+index efcfe84..ccb2a68 100644
+--- a/arch/powerpc/lib/bootm.c
++++ b/arch/powerpc/lib/bootm.c
+@@ -50,6 +50,7 @@ DECLARE_GLOBAL_DATA_PTR;
+ 
+ extern ulong get_effective_memsize(void);
+ static ulong get_sp (void);
++extern void ft_fixup_num_cores(void *blob);
+ static void set_clocks_in_mhz (bd_t *kbd);
+ 
+ #ifndef CONFIG_SYS_LINUX_LOWMEM_MAX_SIZE
+@@ -395,3 +396,58 @@ static void set_clocks_in_mhz (bd_t *kbd)
+ #endif /* CONFIG_MPC5xxx */
+ 	}
+ }
++
++#if defined(CONFIG_BOOTM_VXWORKS)
++void boot_prep_vxworks(bootm_headers_t *images)
++{
++#if defined(CONFIG_OF_LIBFDT)
++	int off;
++	u64 base, size;
++
++	if (!images->ft_addr)
++		return;
++
++	base = (u64)gd->bd->bi_memstart;
++	size = (u64)gd->bd->bi_memsize;
++
++	off = fdt_path_offset(images->ft_addr, "/memory");
++	if (off < 0)
++		fdt_fixup_memory(images->ft_addr, base, size);
++
++#if defined(CONFIG_MP)
++#if defined(CONFIG_MPC85xx)
++	ft_fixup_cpu(images->ft_addr, base + size);
++	ft_fixup_num_cores(images->ft_addr);
++#elif defined(CONFIG_MPC86xx)
++	off = fdt_add_mem_rsv(images->ft_addr,
++			determine_mp_bootpg(NULL), (u64)4096);
++	if (off < 0)
++		printf("## WARNING %s: %s\n", __func__, fdt_strerror(off));
++	ft_fixup_num_cores(images->ft_addr);
++#endif
++	flush_cache((unsigned long)images->ft_addr, images->ft_len);
++#endif
++#endif
++}
++
++void boot_jump_vxworks(bootm_headers_t *images)
++{
++	/* PowerPC VxWorks boot interface conforms to the ePAPR standard
++	 * general purpuse registers:
++	 *
++	 *	r3: Effective address of the device tree image
++	 *	r4: 0
++	 *	r5: 0
++	 *	r6: ePAPR magic value
++	 *	r7: shall be the size of the boot IMA in bytes
++	 *	r8: 0
++	 *	r9: 0
++	 *	TCR: WRC = 0, no watchdog timer reset will occur
++	 */
++	WATCHDOG_RESET();
++
++	((void (*)(void *, ulong, ulong, ulong,
++		ulong, ulong, ulong))images->ep)(images->ft_addr,
++		0, 0, EPAPR_MAGIC, getenv_bootm_mapsize(), 0, 0);
++}
++#endif
+diff --git a/common/cmd_bootm.c b/common/cmd_bootm.c
+index d5745b1..a148c59 100644
+--- a/common/cmd_bootm.c
++++ b/common/cmd_bootm.c
+@@ -38,6 +38,11 @@
+ #include <asm/byteorder.h>
+ #include <linux/compiler.h>
+ 
++#if defined(CONFIG_BOOTM_VXWORKS) && \
++	(defined(CONFIG_PPC) || defined(CONFIG_ARM))
++#include <vxworks.h>
++#endif
++
+ #if defined(CONFIG_CMD_USB)
+ #include <usb.h>
+ #endif
+@@ -123,8 +128,11 @@ static boot_os_fn do_bootm_rtems;
+ #if defined(CONFIG_BOOTM_OSE)
+ static boot_os_fn do_bootm_ose;
+ #endif
+-#if defined(CONFIG_CMD_ELF)
++#if defined(CONFIG_BOOTM_VXWORKS) && \
++	(defined(CONFIG_PPC) || defined(CONFIG_ARM))
+ static boot_os_fn do_bootm_vxworks;
++#endif
++#if defined(CONFIG_CMD_ELF)
+ static boot_os_fn do_bootm_qnxelf;
+ int do_bootvx(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[]);
+ int do_bootelf(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[]);
+@@ -149,8 +157,11 @@ static boot_os_fn *boot_os[] = {
+ #if defined(CONFIG_BOOTM_OSE)
+ 	[IH_OS_OSE] = do_bootm_ose,
+ #endif
+-#if defined(CONFIG_CMD_ELF)
++#if defined(CONFIG_BOOTM_VXWORKS) && \
++	(defined(CONFIG_PPC) || defined(CONFIG_ARM))
+ 	[IH_OS_VXWORKS] = do_bootm_vxworks,
++#endif
++#if defined(CONFIG_CMD_ELF)
+ 	[IH_OS_QNX] = do_bootm_qnxelf,
+ #endif
+ #ifdef CONFIG_INTEGRITY
+@@ -280,7 +291,8 @@ static int bootm_start(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[]
+ 	if (((images.os.type == IH_TYPE_KERNEL) ||
+ 	     (images.os.type == IH_TYPE_KERNEL_NOLOAD) ||
+ 	     (images.os.type == IH_TYPE_MULTI)) &&
+-	    (images.os.os == IH_OS_LINUX)) {
++	    (images.os.os == IH_OS_LINUX) ||
++	    (images.os.os == IH_OS_VXWORKS)) {
+ 		/* find ramdisk */
+ 		ret = boot_get_ramdisk(argc, argv, &images, IH_INITRD_ARCH,
+ 				&images.rd_start, &images.rd_end);
+@@ -1443,12 +1455,64 @@ static int do_bootm_ose(int flag, int argc, char * const argv[],
+ }
+ #endif /* CONFIG_BOOTM_OSE */
+ 
+-#if defined(CONFIG_CMD_ELF)
++#if defined(CONFIG_BOOTM_VXWORKS) && \
++	(defined(CONFIG_PPC) || defined(CONFIG_ARM))
++
++void do_bootvx_fdt(bootm_headers_t *images)
++{
++#if defined(CONFIG_OF_LIBFDT)
++	int ret;
++	char *bootline;
++	ulong of_size = images->ft_len;
++	char **of_flat_tree = &images->ft_addr;
++	struct lmb *lmb = &images->lmb;
++
++	if (*of_flat_tree) {
++		boot_fdt_add_mem_rsv_regions(lmb, *of_flat_tree);
++
++		ret = boot_relocate_fdt(lmb, of_flat_tree, &of_size);
++		if (ret)
++			return;
++
++		ret = fdt_add_subnode(*of_flat_tree, 0, "chosen");
++		if ((ret >= 0 || ret == -FDT_ERR_EXISTS)) {
++			bootline = getenv("bootargs");
++			if (bootline) {
++				ret = fdt_find_and_setprop(*of_flat_tree,
++						"/chosen", "bootargs",
++						bootline,
++						strlen(bootline) + 1, 1);
++				if (ret < 0) {
++					printf("## ERROR: %s : %s\n", __func__,
++					       fdt_strerror(ret));
++					return;
++				}
++			}
++		} else {
++			printf("## ERROR: %s : %s\n", __func__,
++			       fdt_strerror(ret));
++			return;
++		}
++	}
++#endif
++
++	boot_prep_vxworks(images);
++
++#if defined(CONFIG_OF_LIBFDT)
++	printf("## Starting vxWorks at 0x%08lx, device tree at 0x%08lx ...\n",
++	       (ulong)images->ep, (ulong)*of_flat_tree);
++#else
++	printf("## Starting vxWorks at 0x%08lx\n", (ulong)images->ep);
++#endif
++
++	boot_jump_vxworks(images);
++
++	puts("## vxWorks terminated\n");
++}
++
+ static int do_bootm_vxworks(int flag, int argc, char * const argv[],
+ 			     bootm_headers_t *images)
+ {
+-	char str[80];
+-
+ 	if ((flag != 0) && (flag != BOOTM_STATE_OS_GO))
+ 		return 1;
+ 
+@@ -1459,13 +1523,13 @@ static int do_bootm_vxworks(int flag, int argc, char * const argv[],
+ 	}
+ #endif
+ 
+-	sprintf(str, "%lx", images->ep); /* write entry-point into string */
+-	setenv("loadaddr", str);
+-	do_bootvx(NULL, 0, 0, NULL);
++	do_bootvx_fdt(images);
+ 
+ 	return 1;
+ }
++#endif
+ 
++#if defined(CONFIG_CMD_ELF)
+ static int do_bootm_qnxelf(int flag, int argc, char * const argv[],
+ 			    bootm_headers_t *images)
+ {
+diff --git a/include/common.h b/include/common.h
+index 5cfdd76..d490fd7 100644
+--- a/include/common.h
++++ b/include/common.h
+@@ -621,6 +621,10 @@ ulong get_ddr_freq(ulong);
+ #if defined(CONFIG_MPC85xx)
+ typedef MPC85xx_SYS_INFO sys_info_t;
+ void	get_sys_info  ( sys_info_t * );
++#  if defined(CONFIG_OF_LIBFDT)
++	void ft_fixup_cpu(void *, u64);
++	void ft_fixup_num_cores(void *);
++#  endif
+ #endif
+ #if defined(CONFIG_MPC86xx)
+ typedef MPC86xx_SYS_INFO sys_info_t;
+diff --git a/include/config_defaults.h b/include/config_defaults.h
+index d023c63..71191a4 100644
+--- a/include/config_defaults.h
++++ b/include/config_defaults.h
+@@ -13,6 +13,7 @@
+ #define CONFIG_BOOTM_LINUX 1
+ #define CONFIG_BOOTM_NETBSD 1
+ #define CONFIG_BOOTM_RTEMS 1
++#define CONFIG_BOOTM_VXWORKS 1
+ 
+ #define CONFIG_GZIP 1
+ #define CONFIG_ZLIB 1
+diff --git a/include/vxworks.h b/include/vxworks.h
+index 917a9ff..fce9504 100644
+--- a/include/vxworks.h
++++ b/include/vxworks.h
+@@ -25,6 +25,9 @@
+ #define _VXWORKS_H_
+ 
+ int do_bootvx(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[]);
++void boot_prep_vxworks(bootm_headers_t *images);
++void boot_jump_vxworks(bootm_headers_t *images);
++void do_bootvx_fdt(bootm_headers_t *images);
+ 
+ /*
+  * Use bootaddr to find the location in memory that VxWorks
+-- 
+1.7.9.5
+
diff -pNur buildroot.2014.08/board/windriver/qsp-ppc/uboot-2011.12-0006-common-fdt_support.c-avoid-unintended-return-from-fd.patch buildroot/board/windriver/qsp-ppc/uboot-2011.12-0006-common-fdt_support.c-avoid-unintended-return-from-fd.patch
--- buildroot.2014.08/board/windriver/qsp-ppc/uboot-2011.12-0006-common-fdt_support.c-avoid-unintended-return-from-fd.patch	1970-01-01 07:00:00.000000000 +0700
+++ buildroot/board/windriver/qsp-ppc/uboot-2011.12-0006-common-fdt_support.c-avoid-unintended-return-from-fd.patch	2014-12-09 13:19:53.701729700 +0800
@@ -0,0 +1,38 @@
+From 6430aff21033227f162e8075a785c4204559f21f Mon Sep 17 00:00:00 2001
+From: Miao Yan <miao.yan@windriver.com>
+Date: Thu, 28 Nov 2013 17:51:39 +0800
+Subject: [PATCH] common/fdt_support.c: avoid unintended return from
+ fdt_fixup_memory_banks()
+
+fdt_fixup_memory_banks() will add and update /memory node in
+device tree blob. In the case that /memory node doesn't exist,
+after adding a new one, this function returns error.
+
+The correct behavior should be continuing to update its properties.
+
+Signed-off-by: Miao Yan <miao.yan@windriver.com>
+---
+ common/fdt_support.c |    5 +++--
+ 1 file changed, 3 insertions(+), 2 deletions(-)
+
+diff --git a/common/fdt_support.c b/common/fdt_support.c
+index 593f16c..9d65470 100644
+--- a/common/fdt_support.c
++++ b/common/fdt_support.c
+@@ -407,10 +407,11 @@ int fdt_fixup_memory_banks(void *blob, u64 start[], u64 size[], int banks)
+ 	nodeoffset = fdt_path_offset(blob, "/memory");
+ 	if (nodeoffset < 0) {
+ 		nodeoffset = fdt_add_subnode(blob, 0, "memory");
+-		if (nodeoffset < 0)
++		if (nodeoffset < 0) {
+ 			printf("WARNING: could not create /memory: %s.\n",
+ 					fdt_strerror(nodeoffset));
+-		return nodeoffset;
++			return nodeoffset;
++		}
+ 	}
+ 	err = fdt_setprop(blob, nodeoffset, "device_type", "memory",
+ 			sizeof("memory"));
+-- 
+1.7.9.5
+
diff -pNur buildroot.2014.08/board/windriver/qsp-ppc/uboot-2011.12-0007-README.vxworks-add-a-document-describing-the-new-VxW.patch buildroot/board/windriver/qsp-ppc/uboot-2011.12-0007-README.vxworks-add-a-document-describing-the-new-VxW.patch
--- buildroot.2014.08/board/windriver/qsp-ppc/uboot-2011.12-0007-README.vxworks-add-a-document-describing-the-new-VxW.patch	1970-01-01 07:00:00.000000000 +0700
+++ buildroot/board/windriver/qsp-ppc/uboot-2011.12-0007-README.vxworks-add-a-document-describing-the-new-VxW.patch	2014-12-09 13:19:53.701729700 +0800
@@ -0,0 +1,39 @@
+From f967ef321c386498290ea98ccae2b9e2e6de91b5 Mon Sep 17 00:00:00 2001
+From: Miao Yan <miao.yan@windriver.com>
+Date: Thu, 28 Nov 2013 17:51:40 +0800
+Subject: [PATCH] README.vxworks: add a document describing the new VxWorks
+ boot interface
+
+Signed-off-by: Miao Yan <miao.yan@windriver.com>
+---
+ doc/README.vxworks |   19 +++++++++++++++++++
+ 1 file changed, 19 insertions(+)
+
+diff --git a/doc/README.vxworks b/doc/README.vxworks
+new file mode 100644
+index 0000000..4cb302e
+--- /dev/null
++++ b/doc/README.vxworks
+@@ -0,0 +1,19 @@
++From VxWorks 6.9+ (not include 6.9), VxWorks starts adopting device tree as its hardware
++decription mechansim (for PowerPC and ARM), thus requiring boot interface changes.
++This section will describe the new interface.
++
++For PowerPC, the calling convention of the new VxWorks entry point conforms to the ePAPR standard,
++which is shown below (see ePAPR for more details):
++
++    void (*kernel_entry)(fdt_addr,
++              0, 0, EPAPR_MAGIC, boot_IMA, 0, 0)
++
++For ARM, the calling convention is show below:
++
++    void (*kernel_entry)(void *fdt_addr)
++
++When booting new VxWorks kernel (uImage format), the parameters passed to bootm is like below:
++
++    bootm <kernel image address> - <device tree address>
++
++The do_bootvx command still works as it was for older VxWorks kernels.
+-- 
+1.7.9.5
+
diff -pNur buildroot.2014.08/board/windriver/qsp-ppc/uboot-2011.12-0008-qsp-arm-Add-reset-support.patch buildroot/board/windriver/qsp-ppc/uboot-2011.12-0008-qsp-arm-Add-reset-support.patch
--- buildroot.2014.08/board/windriver/qsp-ppc/uboot-2011.12-0008-qsp-arm-Add-reset-support.patch	1970-01-01 07:00:00.000000000 +0700
+++ buildroot/board/windriver/qsp-ppc/uboot-2011.12-0008-qsp-arm-Add-reset-support.patch	2014-12-09 13:19:53.701729700 +0800
@@ -0,0 +1,92 @@
+From a6c6eaa8b571a963c76f811d6e3a7011a3862dbe Mon Sep 17 00:00:00 2001
+From: "Gao, Lu" <Lu.Gao@windriver.com>
+Date: Sat, 11 Oct 2014 17:04:48 +0800
+Subject: [PATCH] qsp-arm: Add reset support.
+
+---
+ board/windriver/qsp_arm/qsp_arm.c |   55 +++++++++++++++++++------------------
+ 1 file changed, 28 insertions(+), 27 deletions(-)
+
+diff --git a/board/windriver/qsp_arm/qsp_arm.c b/board/windriver/qsp_arm/qsp_arm.c
+index 2ac54ce..44e2525 100644
+--- a/board/windriver/qsp_arm/qsp_arm.c
++++ b/board/windriver/qsp_arm/qsp_arm.c
+@@ -27,6 +27,32 @@
+ 
+ DECLARE_GLOBAL_DATA_PTR;
+ 
++#define QSP_SERIAL_BASE 0xe0010000
++#define QSP_SYSREG_BASE 0xe0001000
++
++/* Status register bits
++ */
++#define TX_READY (1<<0)
++#define RX_READY (1<<1)
++
++/* Control register bits
++ */
++#define TX_INT (1<<0)
++#define RX_INT (1<<1)
++
++#define ID_REG      0x00
++#define STATUS_REG  0x04
++#define CONTROL_REG 0x08
++#define TXDATA_REG  0x0c
++#define RXDATA_REG  0x10
++
++
++/* SYSREG registers */
++#define MEM_AVAIL_REG  0x20
++#define MEM_START_REG  0x24
++#define CPU_FREQ_REG   0x28
++#define SOFT_RESET_REG 0x30
++
+ #if defined(CONFIG_SHOW_BOOT_PROGRESS)
+ void show_boot_progress(int progress)
+ {
+@@ -52,8 +78,8 @@ int timer_init(void)
+ 
+ void reset_cpu(ulong addr)
+ {
+-        /* FIXME: ... */
+-        /* Use the sysregs to cause reset */
++        printf("do reset\n");
++        writel(1, QSP_SYSREG_BASE + SOFT_RESET_REG);
+ }
+ 
+ /* We skip delay/timer support in u-boot, it will only slow things
+@@ -84,31 +110,6 @@ ulong get_tbclk (void)
+ 	return (ulong)0;
+ }
+ 
+-#define QSP_SERIAL_BASE 0xe0010000
+-#define QSP_SYSREG_BASE 0xe0001000
+-
+-/* Status register bits
+- */
+-#define TX_READY (1<<0)
+-#define RX_READY (1<<1)
+-
+-/* Control register bits
+- */
+-#define TX_INT (1<<0)
+-#define RX_INT (1<<1)
+-
+-#define ID_REG      0x00
+-#define STATUS_REG  0x04
+-#define CONTROL_REG 0x08
+-#define TXDATA_REG  0x0c
+-#define RXDATA_REG  0x10
+-
+-
+-/* SYSREG registers */
+-#define MEM_AVAIL_REG 0x20
+-#define MEM_START_REG 0x24
+-#define CPU_FREQ_REG  0x28
+-
+ int dram_init(void)
+ {
+         if(readl(QSP_SYSREG_BASE + MEM_START_REG) != CONFIG_SYS_SDRAM_BASE) {
+-- 
+1.7.9.5
+
diff -pNur buildroot.2014.08/board/windriver/qsp-ppc/uboot-2011.12-0009-qsp-ppc-Add-reset-support.patch buildroot/board/windriver/qsp-ppc/uboot-2011.12-0009-qsp-ppc-Add-reset-support.patch
--- buildroot.2014.08/board/windriver/qsp-ppc/uboot-2011.12-0009-qsp-ppc-Add-reset-support.patch	1970-01-01 07:00:00.000000000 +0700
+++ buildroot/board/windriver/qsp-ppc/uboot-2011.12-0009-qsp-ppc-Add-reset-support.patch	2014-12-09 13:19:53.701729700 +0800
@@ -0,0 +1,38 @@
+From ce2f548baf732f4d80594178ef80655a4041ca73 Mon Sep 17 00:00:00 2001
+From: "Gao, Lu" <Lu.Gao@windriver.com>
+Date: Sat, 11 Oct 2014 17:05:06 +0800
+Subject: [PATCH] qsp-ppc: Add reset support.
+
+---
+ board/windriver/qsp_ppc/qsp_ppc.c |    8 +++-----
+ 1 file changed, 3 insertions(+), 5 deletions(-)
+
+diff --git a/board/windriver/qsp_ppc/qsp_ppc.c b/board/windriver/qsp_ppc/qsp_ppc.c
+index 9a15225..0d0ab73 100644
+--- a/board/windriver/qsp_ppc/qsp_ppc.c
++++ b/board/windriver/qsp_ppc/qsp_ppc.c
+@@ -54,7 +54,7 @@
+ #define MEM_START_REG     0x24
+ #define CPU_FREQ_REG      0x28
+ #define TIMEBASE_FREQ_REG 0x2c
+-
++#define SOFT_RESET_REG    0x30
+ 
+ int checkboard(void) 
+ {
+@@ -88,10 +88,8 @@ ft_board_setup(void *blob, bd_t *bd)
+ 
+ void board_reset(void)
+ {
+-        printf("reset not supported\n");
+-        /* FIXME:*/
+-	while (1)
+-		;
++        printf("do reset\n");
++        writel(1, QSP_SYSREG_BASE + SOFT_RESET_REG);
+ }
+ 
+ #if defined(CONFIG_SHOW_BOOT_PROGRESS)
+-- 
+1.7.9.5
+
diff -pNur buildroot.2014.08/board/windriver/qsp-ppc/uboot-2011.12-0010-qsp-ppc-enlarge-the-max-command-characters.patch buildroot/board/windriver/qsp-ppc/uboot-2011.12-0010-qsp-ppc-enlarge-the-max-command-characters.patch
--- buildroot.2014.08/board/windriver/qsp-ppc/uboot-2011.12-0010-qsp-ppc-enlarge-the-max-command-characters.patch	1970-01-01 07:00:00.000000000 +0700
+++ buildroot/board/windriver/qsp-ppc/uboot-2011.12-0010-qsp-ppc-enlarge-the-max-command-characters.patch	2014-12-09 13:19:53.701729700 +0800
@@ -0,0 +1,25 @@
+From 155a78c2a4897a8640238343940e259732b7ae03 Mon Sep 17 00:00:00 2001
+From: "Gao, Lu" <lu.gao@windriver.com>
+Date: Fri, 21 Nov 2014 09:14:31 +0800
+Subject: [PATCH] qsp-ppc: enlarge the max command characters
+
+---
+ include/configs/qsp_ppc.h |    2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/include/configs/qsp_ppc.h b/include/configs/qsp_ppc.h
+index 40d5eec..a80622a 100644
+--- a/include/configs/qsp_ppc.h
++++ b/include/configs/qsp_ppc.h
+@@ -152,7 +152,7 @@
+ #if defined(CONFIG_CMD_KGDB)
+     #define CONFIG_SYS_CBSIZE	1024		/* Console I/O Buffer Size */
+ #else
+-    #define CONFIG_SYS_CBSIZE	256		/* Console I/O Buffer Size */
++    #define CONFIG_SYS_CBSIZE	512		/* Console I/O Buffer Size */
+ #endif
+ 
+ #define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE+sizeof(CONFIG_SYS_PROMPT)+16) /* Print Buffer Size */
+-- 
+1.7.9.5
+
diff -pNur buildroot.2014.08/board/windriver/qsp-ppc/uboot-2011.12-0011-qsp-sysregs-changed-offset-of-sreset-to-0x48-avoidin.patch buildroot/board/windriver/qsp-ppc/uboot-2011.12-0011-qsp-sysregs-changed-offset-of-sreset-to-0x48-avoidin.patch
--- buildroot.2014.08/board/windriver/qsp-ppc/uboot-2011.12-0011-qsp-sysregs-changed-offset-of-sreset-to-0x48-avoidin.patch	1970-01-01 07:00:00.000000000 +0700
+++ buildroot/board/windriver/qsp-ppc/uboot-2011.12-0011-qsp-sysregs-changed-offset-of-sreset-to-0x48-avoidin.patch	2014-12-09 13:19:53.701729700 +0800
@@ -0,0 +1,40 @@
+From 46d8cb84f3e0cd198da8f848c854a6dd0dfbe320 Mon Sep 17 00:00:00 2001
+From: "Gao, Lu" <lu.gao@windriver.com>
+Date: Fri, 28 Nov 2014 12:52:12 +0800
+Subject: [PATCH] qsp-sysregs: changed offset of sreset to 0x48 avoiding
+ conflict with 4.8
+
+---
+ board/windriver/qsp_arm/qsp_arm.c |    2 +-
+ board/windriver/qsp_ppc/qsp_ppc.c |    2 +-
+ 2 files changed, 2 insertions(+), 2 deletions(-)
+
+diff --git a/board/windriver/qsp_arm/qsp_arm.c b/board/windriver/qsp_arm/qsp_arm.c
+index 44e2525..1ee61ef 100644
+--- a/board/windriver/qsp_arm/qsp_arm.c
++++ b/board/windriver/qsp_arm/qsp_arm.c
+@@ -51,7 +51,7 @@ DECLARE_GLOBAL_DATA_PTR;
+ #define MEM_AVAIL_REG  0x20
+ #define MEM_START_REG  0x24
+ #define CPU_FREQ_REG   0x28
+-#define SOFT_RESET_REG 0x30
++#define SOFT_RESET_REG 0x48
+ 
+ #if defined(CONFIG_SHOW_BOOT_PROGRESS)
+ void show_boot_progress(int progress)
+diff --git a/board/windriver/qsp_ppc/qsp_ppc.c b/board/windriver/qsp_ppc/qsp_ppc.c
+index 0d0ab73..461aa07 100644
+--- a/board/windriver/qsp_ppc/qsp_ppc.c
++++ b/board/windriver/qsp_ppc/qsp_ppc.c
+@@ -54,7 +54,7 @@
+ #define MEM_START_REG     0x24
+ #define CPU_FREQ_REG      0x28
+ #define TIMEBASE_FREQ_REG 0x2c
+-#define SOFT_RESET_REG    0x30
++#define SOFT_RESET_REG    0x48
+ 
+ int checkboard(void) 
+ {
+-- 
+1.7.9.5
+
diff -pNur buildroot.2014.08/board/windriver/qsp-ppc/uboot-2011.12-0012-qsp-ppc-handled-other-cpu-enabling-and-disabling-at-.patch buildroot/board/windriver/qsp-ppc/uboot-2011.12-0012-qsp-ppc-handled-other-cpu-enabling-and-disabling-at-.patch
--- buildroot.2014.08/board/windriver/qsp-ppc/uboot-2011.12-0012-qsp-ppc-handled-other-cpu-enabling-and-disabling-at-.patch	1970-01-01 07:00:00.000000000 +0700
+++ buildroot/board/windriver/qsp-ppc/uboot-2011.12-0012-qsp-ppc-handled-other-cpu-enabling-and-disabling-at-.patch	2014-12-09 13:19:53.701729700 +0800
@@ -0,0 +1,107 @@
+From 19c1af1a849301ad90f63c66cf38ff63b2e8844c Mon Sep 17 00:00:00 2001
+From: "Gao, Lu" <lu.gao@windriver.com>
+Date: Wed, 3 Dec 2014 10:34:54 +0800
+Subject: [PATCH] qsp-ppc: handled other cpu enabling and disabling at the
+ beginning
+
+---
+ arch/powerpc/cpu/qsp/start.S      |   24 ++++++++++++++++++++----
+ board/windriver/qsp_ppc/qsp_ppc.c |   10 ----------
+ include/configs/qsp_ppc.h         |   12 ++++++++++++
+ 3 files changed, 32 insertions(+), 14 deletions(-)
+
+diff --git a/arch/powerpc/cpu/qsp/start.S b/arch/powerpc/cpu/qsp/start.S
+index 368667b..fcb9360 100644
+--- a/arch/powerpc/cpu/qsp/start.S
++++ b/arch/powerpc/cpu/qsp/start.S
+@@ -78,8 +78,12 @@ version_string:
+ 	. = EXC_OFF_SYS_RESET
+ 	.globl	_start
+ _start:
+-	b	boot_cold
+-
++	lis	r14, QSP_SYSREG_BASE@h
++	ori	r14, r14, QSP_SYSREG_BASE@l
++	lwz	r15, CPU_ID_REG(r14)
++	cmpi	0, 0, r15, 0
++	beq	boot_cold
++	stw	r15, DISABLE_REG(r14)
+ 	/* the boot code is located below the exception table */
+ 
+ 	.globl	_start_of_vectors
+@@ -152,9 +156,21 @@ _end_of_vectors:
+ 
+ boot_cold:
+ 	/*
+-	 * NOTE: Only Cpu 0 will ever come here.  Other cores go to an
+-	 * address specified by the BPTR
++	 * NOTE: Only Cpu 0 will ever come here.  Other cores go
++	 * disabled.
+ 	 */
++        /* enable other cores to boot from 0xfff00100,
++           let them disable themselves at the beginning */
++	li	r16, BOOT_PC
++	lis	r17, 0xfff00100@h
++	ori	r17, r17, 0xfff00100@l
++	stwbrx	r17, r16, r14
++	li	r16, ENABLE_REG
++	li	r15, 1
++3:	stwbrx	r15, r16, r14
++	addi	r15, r15, 1
++	cmpi	0, 0, r15, CONFIG_MAX_CPUS
++	blt	3b
+ 1:
+ #ifdef CONFIG_SYS_RAMBOOT
+ 	/* disable everything */
+diff --git a/board/windriver/qsp_ppc/qsp_ppc.c b/board/windriver/qsp_ppc/qsp_ppc.c
+index 461aa07..ca3e525 100644
+--- a/board/windriver/qsp_ppc/qsp_ppc.c
++++ b/board/windriver/qsp_ppc/qsp_ppc.c
+@@ -29,7 +29,6 @@
+ #include <fdt_support.h>
+ 
+ #define QSP_SERIAL_BASE 0xe0010000
+-#define QSP_SYSREG_BASE 0xe0001000
+ 
+ /* Status register bits
+  */
+@@ -47,15 +46,6 @@
+ #define TXDATA_REG  0x0c
+ #define RXDATA_REG  0x10
+ 
+-/* SYSREG registers */
+-#define ID_REG            0x00
+-#define CPU_ID_REG        0x10
+-#define MEM_AVAIL_REG     0x20
+-#define MEM_START_REG     0x24
+-#define CPU_FREQ_REG      0x28
+-#define TIMEBASE_FREQ_REG 0x2c
+-#define SOFT_RESET_REG    0x48
+-
+ int checkboard(void) 
+ {
+         printf("QSP PPC board sysregs ID 0x%08x\n", readl(QSP_SYSREG_BASE + ID_REG));
+diff --git a/include/configs/qsp_ppc.h b/include/configs/qsp_ppc.h
+index a80622a..703318a 100644
+--- a/include/configs/qsp_ppc.h
++++ b/include/configs/qsp_ppc.h
+@@ -205,4 +205,16 @@ typedef struct
+ #define L2_INIT		0
+ #define L2_ENABLE	(L2CR_L2E)
+ 
++/* SYSREG registers */
++#define QSP_SYSREG_BASE   0xe0001000
++#define ENABLE_REG        0x04
++#define DISABLE_REG       0x08
++#define BOOT_PC           0x0c
++#define CPU_ID_REG        0x10
++#define MEM_AVAIL_REG     0x20
++#define MEM_START_REG     0x24
++#define CPU_FREQ_REG      0x28
++#define TIMEBASE_FREQ_REG 0x2c
++#define SOFT_RESET_REG    0x48
++
+ #endif	/* __CONFIG_H */
+-- 
+1.7.9.5
+
diff -pNur buildroot.2014.08/board/windriver/qsp-ppc/uboot-2011.12-0013-qsp-arm-handled-other-cpu-enabling-and-disabling-at-.patch buildroot/board/windriver/qsp-ppc/uboot-2011.12-0013-qsp-arm-handled-other-cpu-enabling-and-disabling-at-.patch
--- buildroot.2014.08/board/windriver/qsp-ppc/uboot-2011.12-0013-qsp-arm-handled-other-cpu-enabling-and-disabling-at-.patch	1970-01-01 07:00:00.000000000 +0700
+++ buildroot/board/windriver/qsp-ppc/uboot-2011.12-0013-qsp-arm-handled-other-cpu-enabling-and-disabling-at-.patch	2014-12-09 13:19:53.701729700 +0800
@@ -0,0 +1,91 @@
+From aa3ef3922230534f89637ee29b0b4d93bec894a6 Mon Sep 17 00:00:00 2001
+From: "Gao, Lu" <lu.gao@windriver.com>
+Date: Wed, 3 Dec 2014 13:38:18 +0800
+Subject: [PATCH] qsp-arm: handled other cpu enabling and disabling at the
+ beginning
+
+---
+ arch/arm/cpu/armv7/start.S        |   17 +++++++++++++++++
+ board/windriver/qsp_arm/qsp_arm.c |    8 --------
+ include/configs/qsp_arm.h         |   13 +++++++++++++
+ 3 files changed, 30 insertions(+), 8 deletions(-)
+
+diff --git a/arch/arm/cpu/armv7/start.S b/arch/arm/cpu/armv7/start.S
+index ef08a55..ffefe27 100644
+--- a/arch/arm/cpu/armv7/start.S
++++ b/arch/arm/cpu/armv7/start.S
+@@ -123,6 +123,23 @@ IRQ_STACK_START_IN:
+  */
+ 
+ reset:
++	ldr	r0, =(QSP_SYSREG_BASE)
++	ldr	r1, [r0, #CPU_ID_REG]
++	cmp	r1, #0
++	beq	start_boot
++	str	r1, [r0, #DISABLE_REG]
++        /* enable other cores to boot from 0xfff00100,
++           let them disable themselves at the beginning */
++start_boot:
++	ldr	r1, =_start
++	str	r1, [r0, #BOOT_PC]
++	mov     r1, #1
++enable_other_cpus:
++	str	r1, [r0, #ENABLE_REG]
++	add	r1, r1, #1
++	cmp	r1, #CONFIG_MAX_CPUS
++	blt	enable_other_cpus
++
+ 	bl	save_boot_params
+ 	/*
+ 	 * set the cpu to SVC32 mode
+diff --git a/board/windriver/qsp_arm/qsp_arm.c b/board/windriver/qsp_arm/qsp_arm.c
+index 1ee61ef..800e853 100644
+--- a/board/windriver/qsp_arm/qsp_arm.c
++++ b/board/windriver/qsp_arm/qsp_arm.c
+@@ -28,7 +28,6 @@
+ DECLARE_GLOBAL_DATA_PTR;
+ 
+ #define QSP_SERIAL_BASE 0xe0010000
+-#define QSP_SYSREG_BASE 0xe0001000
+ 
+ /* Status register bits
+  */
+@@ -46,13 +45,6 @@ DECLARE_GLOBAL_DATA_PTR;
+ #define TXDATA_REG  0x0c
+ #define RXDATA_REG  0x10
+ 
+-
+-/* SYSREG registers */
+-#define MEM_AVAIL_REG  0x20
+-#define MEM_START_REG  0x24
+-#define CPU_FREQ_REG   0x28
+-#define SOFT_RESET_REG 0x48
+-
+ #if defined(CONFIG_SHOW_BOOT_PROGRESS)
+ void show_boot_progress(int progress)
+ {
+diff --git a/include/configs/qsp_arm.h b/include/configs/qsp_arm.h
+index e51745c..6d3c89d 100644
+--- a/include/configs/qsp_arm.h
++++ b/include/configs/qsp_arm.h
+@@ -91,4 +91,17 @@
+ #define CONFIG_CMDLINE_EDITING		1
+ #define CONFIG_SYS_MAXARGS		16	/* max command args */
+ 
++#define CONFIG_MAX_CPUS 128
++
++/* SYSREG registers */
++#define QSP_SYSREG_BASE 0xe0001000
++#define ENABLE_REG      0x04
++#define DISABLE_REG     0x08
++#define BOOT_PC         0x0c
++#define CPU_ID_REG      0x10
++#define MEM_AVAIL_REG   0x20
++#define MEM_START_REG   0x24
++#define CPU_FREQ_REG    0x28
++#define SOFT_RESET_REG  0x48
++
+ #endif
+-- 
+1.7.9.5
+
diff -pNur buildroot.2014.08/configs/qsp_ppc_linux_defconfig buildroot/configs/qsp_ppc_linux_defconfig
--- buildroot.2014.08/configs/qsp_ppc_linux_defconfig	1970-01-01 07:00:00.000000000 +0700
+++ buildroot/configs/qsp_ppc_linux_defconfig	2014-12-09 13:19:53.697729700 +0800
@@ -0,0 +1,1510 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Buildroot 2014.08 Configuration
+#
+BR2_HAVE_DOT_CONFIG=y
+BR2_HOSTARCH_NEEDS_IA32_LIBS=y
+
+#
+# Target options
+#
+# BR2_arcle is not set
+# BR2_arceb is not set
+# BR2_arm is not set
+# BR2_armeb is not set
+# BR2_aarch64 is not set
+# BR2_bfin is not set
+# BR2_i386 is not set
+# BR2_microblazeel is not set
+# BR2_microblazebe is not set
+# BR2_mips is not set
+# BR2_mipsel is not set
+# BR2_mips64 is not set
+# BR2_mips64el is not set
+# BR2_nios2 is not set
+BR2_powerpc=y
+# BR2_powerpc64 is not set
+# BR2_powerpc64le is not set
+# BR2_sh is not set
+# BR2_sh64 is not set
+# BR2_sparc is not set
+# BR2_x86_64 is not set
+# BR2_xtensa is not set
+BR2_ARCH="powerpc"
+BR2_ENDIAN="BIG"
+BR2_ARCH_HAS_ATOMICS=y
+BR2_generic_powerpc=y
+# BR2_powerpc_401 is not set
+# BR2_powerpc_403 is not set
+# BR2_powerpc_405 is not set
+# BR2_powerpc_405fp is not set
+# BR2_powerpc_440 is not set
+# BR2_powerpc_440fp is not set
+# BR2_powerpc_464 is not set
+# BR2_powerpc_464fp is not set
+# BR2_powerpc_476 is not set
+# BR2_powerpc_476fp is not set
+# BR2_powerpc_505 is not set
+# BR2_powerpc_601 is not set
+# BR2_powerpc_602 is not set
+# BR2_powerpc_603 is not set
+# BR2_powerpc_603e is not set
+# BR2_powerpc_604 is not set
+# BR2_powerpc_604e is not set
+# BR2_powerpc_620 is not set
+# BR2_powerpc_630 is not set
+# BR2_powerpc_740 is not set
+# BR2_powerpc_7400 is not set
+# BR2_powerpc_7450 is not set
+# BR2_powerpc_750 is not set
+# BR2_powerpc_821 is not set
+# BR2_powerpc_823 is not set
+# BR2_powerpc_860 is not set
+# BR2_powerpc_970 is not set
+# BR2_powerpc_8540 is not set
+# BR2_powerpc_8548 is not set
+# BR2_powerpc_e300c2 is not set
+# BR2_powerpc_e300c3 is not set
+# BR2_powerpc_e500mc is not set
+# BR2_powerpc_power4 is not set
+# BR2_powerpc_power5 is not set
+# BR2_powerpc_power6 is not set
+# BR2_powerpc_power7 is not set
+# BR2_powerpc_power8 is not set
+BR2_powerpc_CLASSIC=y
+# BR2_POWERPC_SOFT_FLOAT is not set
+
+#
+# Build options
+#
+
+#
+# Commands
+#
+BR2_WGET="wget --passive-ftp -nd -t 3"
+BR2_SVN="svn"
+BR2_BZR="bzr"
+BR2_GIT="git"
+BR2_CVS="cvs"
+BR2_LOCALFILES="cp"
+BR2_SCP="scp"
+BR2_SSH="ssh"
+BR2_HG="hg"
+BR2_ZCAT="gzip -d -c"
+BR2_BZCAT="bzcat"
+BR2_XZCAT="xzcat"
+BR2_TAR_OPTIONS=""
+BR2_DEFCONFIG="$(CONFIG_DIR)/defconfig"
+BR2_DL_DIR="$(TOPDIR)/dl"
+BR2_HOST_DIR="$(BASE_DIR)/host"
+
+#
+# Mirrors and Download locations
+#
+BR2_PRIMARY_SITE=""
+BR2_BACKUP_SITE="http://sources.buildroot.net/"
+BR2_KERNEL_MIRROR="http://www.kernel.org/pub/"
+BR2_GNU_MIRROR="http://ftp.gnu.org/pub/gnu"
+BR2_DEBIAN_MIRROR="http://ftp.debian.org"
+BR2_LUAROCKS_MIRROR="http://rocks.moonscript.org"
+BR2_CPAN_MIRROR="http://cpan.metacpan.org"
+BR2_JLEVEL=12
+BR2_CCACHE=y
+BR2_CCACHE_DIR="$(HOME)/.buildroot-ccache"
+BR2_CCACHE_INITIAL_SETUP=""
+# BR2_DEPRECATED is not set
+# BR2_ENABLE_DEBUG is not set
+BR2_STRIP_strip=y
+# BR2_STRIP_none is not set
+BR2_STRIP_EXCLUDE_FILES=""
+BR2_STRIP_EXCLUDE_DIRS=""
+# BR2_OPTIMIZE_0 is not set
+# BR2_OPTIMIZE_1 is not set
+# BR2_OPTIMIZE_2 is not set
+# BR2_OPTIMIZE_3 is not set
+BR2_OPTIMIZE_S=y
+# BR2_ENABLE_SSP is not set
+# BR2_PREFER_STATIC_LIB is not set
+BR2_PACKAGE_OVERRIDE_FILE="$(TOPDIR)/local.mk"
+BR2_GLOBAL_PATCH_DIR=""
+
+#
+# Toolchain
+#
+BR2_TOOLCHAIN=y
+BR2_TOOLCHAIN_USES_GLIBC=y
+# BR2_TOOLCHAIN_BUILDROOT is not set
+BR2_TOOLCHAIN_EXTERNAL=y
+BR2_TOOLCHAIN_EXTERNAL_CODESOURCERY_POWERPC201103=y
+# BR2_TOOLCHAIN_EXTERNAL_CODESOURCERY_POWERPC201009 is not set
+# BR2_TOOLCHAIN_EXTERNAL_MUSL_CROSS is not set
+# BR2_TOOLCHAIN_EXTERNAL_CUSTOM is not set
+BR2_TOOLCHAIN_EXTERNAL_DOWNLOAD=y
+# BR2_TOOLCHAIN_EXTERNAL_PREINSTALLED is not set
+BR2_TOOLCHAIN_EXTERNAL_PREFIX="powerpc-linux-gnu"
+BR2_TOOLCHAIN_EXTERNAL_GLIBC=y
+# BR2_TOOLCHAIN_EXTERNAL_GDB_SERVER_COPY is not set
+# BR2_PACKAGE_HOST_GDB is not set
+BR2_LARGEFILE=y
+BR2_INET_IPV6=y
+BR2_TOOLCHAIN_HAS_NATIVE_RPC=y
+BR2_USE_WCHAR=y
+BR2_ENABLE_LOCALE=y
+BR2_INSTALL_LIBSTDCPP=y
+BR2_TOOLCHAIN_HAS_THREADS=y
+BR2_TOOLCHAIN_HAS_THREADS_DEBUG=y
+BR2_TOOLCHAIN_HAS_THREADS_NPTL=y
+BR2_TOOLCHAIN_HAS_SHADOW_PASSWORDS=y
+BR2_TOOLCHAIN_HAS_SSP=y
+# BR2_ENABLE_LOCALE_PURGE is not set
+BR2_GENERATE_LOCALE=""
+# BR2_TOOLCHAIN_GLIBC_GCONV_LIBS_COPY is not set
+BR2_USE_MMU=y
+BR2_TARGET_OPTIMIZATION="-pipe"
+BR2_TARGET_LDFLAGS=""
+# BR2_ECLIPSE_REGISTER is not set
+BR2_TOOLCHAIN_HEADERS_AT_LEAST="2.6"
+
+#
+# System configuration
+#
+BR2_TARGET_GENERIC_HOSTNAME="buildroot"
+BR2_TARGET_GENERIC_ISSUE="Welcome to Buildroot"
+# BR2_TARGET_GENERIC_PASSWD_DES is not set
+BR2_TARGET_GENERIC_PASSWD_MD5=y
+# BR2_TARGET_GENERIC_PASSWD_SHA256 is not set
+# BR2_TARGET_GENERIC_PASSWD_SHA512 is not set
+BR2_TARGET_GENERIC_PASSWD_METHOD="md5"
+BR2_INIT_BUSYBOX=y
+# BR2_INIT_SYSV is not set
+
+#
+# systemd needs an (e)glibc toolchain, headers >= 3.10
+#
+# BR2_INIT_NONE is not set
+# BR2_ROOTFS_DEVICE_CREATION_STATIC is not set
+BR2_ROOTFS_DEVICE_CREATION_DYNAMIC_DEVTMPFS=y
+# BR2_ROOTFS_DEVICE_CREATION_DYNAMIC_MDEV is not set
+# BR2_ROOTFS_DEVICE_CREATION_DYNAMIC_EUDEV is not set
+BR2_ROOTFS_DEVICE_TABLE="system/device_table.txt"
+BR2_ROOTFS_SKELETON_DEFAULT=y
+# BR2_ROOTFS_SKELETON_CUSTOM is not set
+BR2_TARGET_GENERIC_ROOT_PASSWD=""
+BR2_TARGET_GENERIC_GETTY=y
+
+#
+# getty options
+#
+BR2_TARGET_GENERIC_GETTY_PORT="ttyAM0"
+# BR2_TARGET_GENERIC_GETTY_BAUDRATE_KEEP is not set
+# BR2_TARGET_GENERIC_GETTY_BAUDRATE_9600 is not set
+# BR2_TARGET_GENERIC_GETTY_BAUDRATE_19200 is not set
+# BR2_TARGET_GENERIC_GETTY_BAUDRATE_38400 is not set
+# BR2_TARGET_GENERIC_GETTY_BAUDRATE_57600 is not set
+BR2_TARGET_GENERIC_GETTY_BAUDRATE_115200=y
+BR2_TARGET_GENERIC_GETTY_BAUDRATE="115200"
+BR2_TARGET_GENERIC_GETTY_TERM="vt100"
+BR2_TARGET_GENERIC_GETTY_OPTIONS=""
+BR2_TARGET_GENERIC_REMOUNT_ROOTFS_RW=y
+# BR2_TARGET_TZ_INFO is not set
+BR2_ROOTFS_USERS_TABLES=""
+BR2_ROOTFS_OVERLAY=""
+BR2_ROOTFS_POST_BUILD_SCRIPT="board/windriver/qsp_fs_post.sh"
+BR2_ROOTFS_POST_IMAGE_SCRIPT=""
+BR2_ROOTFS_POST_SCRIPT_ARGS=""
+
+#
+# Kernel
+#
+BR2_LINUX_KERNEL=y
+# BR2_LINUX_KERNEL_LATEST_VERSION is not set
+BR2_LINUX_KERNEL_CUSTOM_VERSION=y
+# BR2_LINUX_KERNEL_CUSTOM_TARBALL is not set
+# BR2_LINUX_KERNEL_CUSTOM_GIT is not set
+# BR2_LINUX_KERNEL_CUSTOM_HG is not set
+# BR2_LINUX_KERNEL_CUSTOM_LOCAL is not set
+BR2_LINUX_KERNEL_CUSTOM_VERSION_VALUE="3.4"
+BR2_LINUX_KERNEL_VERSION="3.4"
+BR2_LINUX_KERNEL_PATCH="board/windriver/qsp-ppc/"
+BR2_LINUX_KERNEL_USE_DEFCONFIG=y
+# BR2_LINUX_KERNEL_USE_CUSTOM_CONFIG is not set
+BR2_LINUX_KERNEL_DEFCONFIG="qsp"
+BR2_LINUX_KERNEL_UBOOT_IMAGE=y
+BR2_LINUX_KERNEL_UIMAGE=y
+# BR2_LINUX_KERNEL_ZIMAGE is not set
+# BR2_LINUX_KERNEL_CUIMAGE is not set
+# BR2_LINUX_KERNEL_VMLINUX is not set
+# BR2_LINUX_KERNEL_IMAGE_TARGET_CUSTOM is not set
+BR2_LINUX_KERNEL_DTS_SUPPORT=y
+BR2_LINUX_KERNEL_USE_INTREE_DTS=y
+# BR2_LINUX_KERNEL_USE_CUSTOM_DTS is not set
+BR2_LINUX_KERNEL_INTREE_DTS_NAME="qsp"
+# BR2_LINUX_KERNEL_INSTALL_TARGET is not set
+
+#
+# Linux Kernel Extensions
+#
+# BR2_LINUX_KERNEL_EXT_XENOMAI is not set
+# BR2_LINUX_KERNEL_EXT_RTAI is not set
+
+#
+# Target packages
+#
+BR2_PACKAGE_BUSYBOX=y
+BR2_PACKAGE_BUSYBOX_CONFIG="package/busybox/busybox.config"
+BR2_PACKAGE_BUSYBOX_SHOW_OTHERS=y
+# BR2_PACKAGE_BUSYBOX_WATCHDOG is not set
+
+#
+# Audio and video applications
+#
+# BR2_PACKAGE_ALSA_UTILS is not set
+# BR2_PACKAGE_AUMIX is not set
+# BR2_PACKAGE_BELLAGIO is not set
+# BR2_PACKAGE_ESPEAK is not set
+# BR2_PACKAGE_FAAD2 is not set
+# BR2_PACKAGE_FFMPEG is not set
+# BR2_PACKAGE_FLAC is not set
+# BR2_PACKAGE_FLITE is not set
+# BR2_PACKAGE_GSTREAMER is not set
+# BR2_PACKAGE_GSTREAMER1 is not set
+# BR2_PACKAGE_JACK2 is not set
+# BR2_PACKAGE_LAME is not set
+# BR2_PACKAGE_LIBVPX is not set
+# BR2_PACKAGE_MADPLAY is not set
+# BR2_PACKAGE_MPG123 is not set
+# BR2_PACKAGE_MPLAYER is not set
+# BR2_PACKAGE_MUSEPACK is not set
+# BR2_PACKAGE_NCMPC is not set
+# BR2_PACKAGE_OPUS_TOOLS is not set
+# BR2_PACKAGE_PULSEAUDIO is not set
+# BR2_PACKAGE_SOX is not set
+# BR2_PACKAGE_TSTOOLS is not set
+# BR2_PACKAGE_TWOLAME is not set
+# BR2_PACKAGE_VLC is not set
+# BR2_PACKAGE_VORBIS_TOOLS is not set
+# BR2_PACKAGE_WAVPACK is not set
+# BR2_PACKAGE_YAVTA is not set
+
+#
+# Compressors and decompressors
+#
+# BR2_PACKAGE_BZIP2 is not set
+# BR2_PACKAGE_GZIP is not set
+# BR2_PACKAGE_INFOZIP is not set
+# BR2_PACKAGE_LZ4 is not set
+# BR2_PACKAGE_LZIP is not set
+# BR2_PACKAGE_LZOP is not set
+# BR2_PACKAGE_XZ is not set
+
+#
+# Debugging, profiling and benchmark
+#
+# BR2_PACKAGE_BONNIE is not set
+# BR2_PACKAGE_CACHE_CALIBRATOR is not set
+# BR2_PACKAGE_DHRYSTONE is not set
+# BR2_PACKAGE_DMALLOC is not set
+# BR2_PACKAGE_DROPWATCH is not set
+# BR2_PACKAGE_DSTAT is not set
+# BR2_PACKAGE_DUMA is not set
+# BR2_PACKAGE_FIO is not set
+# BR2_PACKAGE_GDB is not set
+# BR2_PACKAGE_IOZONE is not set
+# BR2_PACKAGE_KEXEC is not set
+# BR2_PACKAGE_KEXEC_LITE is not set
+# BR2_PACKAGE_KTAP is not set
+# BR2_PACKAGE_LATENCYTOP is not set
+# BR2_PACKAGE_LMBENCH is not set
+# BR2_PACKAGE_LSOF is not set
+# BR2_PACKAGE_LTP_TESTSUITE is not set
+# BR2_PACKAGE_LTRACE is not set
+# BR2_PACKAGE_LTTNG_MODULES is not set
+# BR2_PACKAGE_LTTNG_TOOLS is not set
+# BR2_PACKAGE_MEMSTAT is not set
+# BR2_PACKAGE_NETPERF is not set
+# BR2_PACKAGE_OPROFILE is not set
+# BR2_PACKAGE_PAX_UTILS is not set
+# BR2_PACKAGE_PERF is not set
+# BR2_PACKAGE_PV is not set
+# BR2_PACKAGE_RAMSMP is not set
+# BR2_PACKAGE_RAMSPEED is not set
+# BR2_PACKAGE_RT_TESTS is not set
+# BR2_PACKAGE_STRACE is not set
+# BR2_PACKAGE_STRESS is not set
+# BR2_PACKAGE_SYSPROF is not set
+# BR2_PACKAGE_TINYMEMBENCH is not set
+# BR2_PACKAGE_TRACE_CMD is not set
+# BR2_PACKAGE_VALGRIND is not set
+# BR2_PACKAGE_WHETSTONE is not set
+
+#
+# Development tools
+#
+# BR2_PACKAGE_BINUTILS is not set
+# BR2_PACKAGE_BSDIFF is not set
+# BR2_PACKAGE_CVS is not set
+# BR2_PACKAGE_DIFFUTILS is not set
+# BR2_PACKAGE_FINDUTILS is not set
+# BR2_PACKAGE_FLEX is not set
+# BR2_PACKAGE_GAWK is not set
+# BR2_PACKAGE_GETTEXT is not set
+# BR2_PACKAGE_GIT is not set
+# BR2_PACKAGE_GPERF is not set
+# BR2_PACKAGE_GREP is not set
+# BR2_PACKAGE_JQ is not set
+# BR2_PACKAGE_LIBTOOL is not set
+# BR2_PACKAGE_MAKE is not set
+# BR2_PACKAGE_PATCH is not set
+# BR2_PACKAGE_PKGCONF is not set
+# BR2_PACKAGE_SED is not set
+# BR2_PACKAGE_SSTRIP is not set
+# BR2_PACKAGE_SUBVERSION is not set
+# BR2_PACKAGE_TAR is not set
+# BR2_PACKAGE_TREE is not set
+
+#
+# Filesystem and flash utilities
+#
+# BR2_PACKAGE_BTRFS_PROGS is not set
+# BR2_PACKAGE_CIFS_UTILS is not set
+# BR2_PACKAGE_CRAMFS is not set
+# BR2_PACKAGE_CURLFTPFS is not set
+# BR2_PACKAGE_DOSFSTOOLS is not set
+# BR2_PACKAGE_E2FSPROGS is not set
+# BR2_PACKAGE_E2TOOLS is not set
+# BR2_PACKAGE_ECRYPTFS_UTILS is not set
+# BR2_PACKAGE_EXFAT is not set
+# BR2_PACKAGE_EXFAT_UTILS is not set
+# BR2_PACKAGE_F2FS_TOOLS is not set
+# BR2_PACKAGE_FLASHBENCH is not set
+# BR2_PACKAGE_GENEXT2FS is not set
+# BR2_PACKAGE_GENROMFS is not set
+# BR2_PACKAGE_MAKEDEVS is not set
+
+#
+# mmc-utils needs a toolchain w/ largefile, headers >= 3.0
+#
+BR2_PACKAGE_MTD=y
+
+#
+# MTD tools selection
+#
+# BR2_PACKAGE_MTD_DOCFDISK is not set
+# BR2_PACKAGE_MTD_DOC_LOADBIOS is not set
+BR2_PACKAGE_MTD_FLASHCP=y
+BR2_PACKAGE_MTD_FLASH_ERASE=y
+# BR2_PACKAGE_MTD_FLASH_LOCK is not set
+# BR2_PACKAGE_MTD_FLASH_OTP_DUMP is not set
+# BR2_PACKAGE_MTD_FLASH_OTP_INFO is not set
+# BR2_PACKAGE_MTD_FLASH_OTP_LOCK is not set
+# BR2_PACKAGE_MTD_FLASH_OTP_WRITE is not set
+# BR2_PACKAGE_MTD_FLASH_UNLOCK is not set
+# BR2_PACKAGE_MTD_FTL_CHECK is not set
+# BR2_PACKAGE_MTD_FTL_FORMAT is not set
+# BR2_PACKAGE_MTD_JFFS2DUMP is not set
+BR2_PACKAGE_MTD_MKFSJFFS2=y
+# BR2_PACKAGE_MTD_MKFSUBIFS is not set
+BR2_PACKAGE_MTD_MTD_DEBUG=y
+# BR2_PACKAGE_MTD_NANDDUMP is not set
+# BR2_PACKAGE_MTD_NANDTEST is not set
+# BR2_PACKAGE_MTD_NANDWRITE is not set
+# BR2_PACKAGE_MTD_NFTLDUMP is not set
+# BR2_PACKAGE_MTD_NFTL_FORMAT is not set
+# BR2_PACKAGE_MTD_RECV_IMAGE is not set
+# BR2_PACKAGE_MTD_RFDDUMP is not set
+# BR2_PACKAGE_MTD_RFDFORMAT is not set
+# BR2_PACKAGE_MTD_SERVE_IMAGE is not set
+# BR2_PACKAGE_MTD_SUMTOOL is not set
+BR2_PACKAGE_MTD_MTDINFO=y
+# BR2_PACKAGE_MTD_UBIATTACH is not set
+# BR2_PACKAGE_MTD_UBICRC32 is not set
+# BR2_PACKAGE_MTD_UBIDETACH is not set
+BR2_PACKAGE_MTD_UBIFORMAT=y
+# BR2_PACKAGE_MTD_UBIMKVOL is not set
+# BR2_PACKAGE_MTD_UBINFO is not set
+# BR2_PACKAGE_MTD_UBINIZE is not set
+# BR2_PACKAGE_MTD_UBIRENAME is not set
+# BR2_PACKAGE_MTD_UBIRMVOL is not set
+# BR2_PACKAGE_MTD_UBIRSVOL is not set
+# BR2_PACKAGE_MTD_UBIUPDATEVOL is not set
+BR2_PACKAGE_MTD_UBIBLOCK=y
+# BR2_PACKAGE_MTOOLS is not set
+# BR2_PACKAGE_NFS_UTILS is not set
+# BR2_PACKAGE_NTFS_3G is not set
+# BR2_PACKAGE_SIMICSFS is not set
+# BR2_PACKAGE_SQUASHFS is not set
+# BR2_PACKAGE_SSHFS is not set
+# BR2_PACKAGE_UNIONFS is not set
+# BR2_PACKAGE_XFSPROGS is not set
+
+#
+# Games
+#
+# BR2_PACKAGE_GNUCHESS is not set
+# BR2_PACKAGE_LBREAKOUT2 is not set
+# BR2_PACKAGE_LTRIS is not set
+# BR2_PACKAGE_OPENTYRIAN is not set
+# BR2_PACKAGE_PRBOOM is not set
+
+#
+# Graphic libraries and applications (graphic/text)
+#
+
+#
+# Graphic applications
+#
+# BR2_PACKAGE_FSWEBCAM is not set
+# BR2_PACKAGE_GNUPLOT is not set
+# BR2_PACKAGE_JHEAD is not set
+# BR2_PACKAGE_RRDTOOL is not set
+
+#
+# Graphic libraries
+#
+# BR2_PACKAGE_CEGUI06 is not set
+# BR2_PACKAGE_DIRECTFB is not set
+# BR2_PACKAGE_FBDUMP is not set
+# BR2_PACKAGE_FBGRAB is not set
+# BR2_PACKAGE_FBSET is not set
+# BR2_PACKAGE_FB_TEST_APP is not set
+# BR2_PACKAGE_FBTERM is not set
+# BR2_PACKAGE_FBV is not set
+# BR2_PACKAGE_IMAGEMAGICK is not set
+# BR2_PACKAGE_LINUX_FUSION is not set
+
+#
+# mesa3d needs udev /dev management and a toolchain w/ C++, largefile, NPTL
+#
+# BR2_PACKAGE_OCRAD is not set
+# BR2_PACKAGE_PSPLASH is not set
+# BR2_PACKAGE_SDL is not set
+
+#
+# Other GUIs
+#
+# BR2_PACKAGE_EFL is not set
+# BR2_PACKAGE_QT is not set
+# BR2_PACKAGE_QT5 is not set
+
+#
+# weston needs udev and a toolchain w/ threads, headers >= 3.0
+#
+# BR2_PACKAGE_XORG7 is not set
+
+#
+# X applications
+#
+
+#
+# X libraries and helper libraries
+#
+# BR2_PACKAGE_DEJAVU is not set
+# BR2_PACKAGE_LIBERATION is not set
+# BR2_PACKAGE_XKEYBOARD_CONFIG is not set
+
+#
+# X window managers
+#
+
+#
+# Hardware handling
+#
+
+#
+# Firmware
+#
+# BR2_PACKAGE_B43_FIRMWARE is not set
+# BR2_PACKAGE_LINUX_FIRMWARE is not set
+# BR2_PACKAGE_UX500_FIRMWARE is not set
+# BR2_PACKAGE_ZD1211_FIRMWARE is not set
+# BR2_PACKAGE_AVRDUDE is not set
+# BR2_PACKAGE_CDRKIT is not set
+# BR2_PACKAGE_CRYPTSETUP is not set
+# BR2_PACKAGE_CWIID is not set
+# BR2_PACKAGE_DBUS is not set
+# BR2_PACKAGE_DEVMEM2 is not set
+# BR2_PACKAGE_DMRAID is not set
+
+#
+# dvb-apps utils needs a toolchain w/ largefile, threads, headers >= 3.3
+#
+# BR2_PACKAGE_DVBSNOOP is not set
+# BR2_PACKAGE_DTV_SCAN_TABLES is not set
+# BR2_PACKAGE_EEPROG is not set
+
+#
+# eudev needs eudev /dev management
+#
+# BR2_PACKAGE_EVEMU is not set
+# BR2_PACKAGE_EVTEST is not set
+# BR2_PACKAGE_FAN_CTRL is not set
+# BR2_PACKAGE_FCONFIG is not set
+# BR2_PACKAGE_FIS is not set
+# BR2_PACKAGE_FMTOOLS is not set
+# BR2_PACKAGE_FXLOAD is not set
+# BR2_PACKAGE_GADGETFS_TEST is not set
+# BR2_PACKAGE_GPM is not set
+# BR2_PACKAGE_GPSD is not set
+# BR2_PACKAGE_GPTFDISK is not set
+# BR2_PACKAGE_GVFS is not set
+# BR2_PACKAGE_HDPARM is not set
+# BR2_PACKAGE_HWDATA is not set
+# BR2_PACKAGE_I2C_TOOLS is not set
+# BR2_PACKAGE_INPUT_EVENT_DAEMON is not set
+# BR2_PACKAGE_INPUT_TOOLS is not set
+# BR2_PACKAGE_IOSTAT is not set
+# BR2_PACKAGE_IRDA_UTILS is not set
+# BR2_PACKAGE_KBD is not set
+# BR2_PACKAGE_LCDPROC is not set
+# BR2_PACKAGE_LM_SENSORS is not set
+# BR2_PACKAGE_LSHW is not set
+# BR2_PACKAGE_LSUIO is not set
+# BR2_PACKAGE_LVM2 is not set
+# BR2_PACKAGE_MDADM is not set
+# BR2_PACKAGE_MEDIA_CTL is not set
+# BR2_PACKAGE_MEMTESTER is not set
+# BR2_PACKAGE_MINICOM is not set
+# BR2_PACKAGE_NANOCOM is not set
+# BR2_PACKAGE_NEARD is not set
+# BR2_PACKAGE_OFONO is not set
+# BR2_PACKAGE_OPEN2300 is not set
+# BR2_PACKAGE_OPENOCD is not set
+# BR2_PACKAGE_PARTED is not set
+# BR2_PACKAGE_PCIUTILS is not set
+# BR2_PACKAGE_PICOCOM is not set
+# BR2_PACKAGE_RNG_TOOLS is not set
+# BR2_PACKAGE_SANE_BACKENDS is not set
+# BR2_PACKAGE_SDPARM is not set
+# BR2_PACKAGE_SETSERIAL is not set
+# BR2_PACKAGE_SG3_UTILS is not set
+# BR2_PACKAGE_SISPMCTL is not set
+# BR2_PACKAGE_SMARTMONTOOLS is not set
+# BR2_PACKAGE_SMSTOOLS3 is not set
+# BR2_PACKAGE_SNOWBALL_HDMISERVICE is not set
+# BR2_PACKAGE_SREDIRD is not set
+# BR2_PACKAGE_STATSERIAL is not set
+# BR2_PACKAGE_SYSSTAT is not set
+# BR2_PACKAGE_TI_UIM is not set
+# BR2_PACKAGE_TI_UTILS is not set
+# BR2_PACKAGE_UBOOT_TOOLS is not set
+
+#
+# udisks needs udev /dev management
+#
+# BR2_PACKAGE_USB_MODESWITCH is not set
+# BR2_PACKAGE_USB_MODESWITCH_DATA is not set
+
+#
+# usbmount requires udev to be enabled
+#
+# BR2_PACKAGE_USBUTILS is not set
+
+#
+# w_scan needs a toolchain w/ headers >= 3.0
+#
+# BR2_PACKAGE_WIPE is not set
+
+#
+# Interpreter languages and scripting
+#
+# BR2_PACKAGE_ENSCRIPT is not set
+# BR2_PACKAGE_ERLANG is not set
+# BR2_PACKAGE_HASERL is not set
+# BR2_PACKAGE_JAMVM is not set
+# BR2_PACKAGE_JIMTCL is not set
+# BR2_PACKAGE_LUA is not set
+# BR2_PACKAGE_LUAJIT is not set
+# BR2_PACKAGE_PERL is not set
+# BR2_PACKAGE_PHP is not set
+# BR2_PACKAGE_PYTHON is not set
+# BR2_PACKAGE_PYTHON3 is not set
+# BR2_PACKAGE_RUBY is not set
+# BR2_PACKAGE_TCL is not set
+
+#
+# Libraries
+#
+
+#
+# Audio/Sound
+#
+# BR2_PACKAGE_ALSA_LIB is not set
+# BR2_PACKAGE_AUDIOFILE is not set
+# BR2_PACKAGE_CELT051 is not set
+# BR2_PACKAGE_FDK_AAC is not set
+# BR2_PACKAGE_LIBAO is not set
+# BR2_PACKAGE_LIBCDAUDIO is not set
+# BR2_PACKAGE_LIBCDIO is not set
+# BR2_PACKAGE_LIBCUE is not set
+# BR2_PACKAGE_LIBCUEFILE is not set
+# BR2_PACKAGE_LIBID3TAG is not set
+# BR2_PACKAGE_LIBLO is not set
+# BR2_PACKAGE_LIBMAD is not set
+# BR2_PACKAGE_LIBMODPLUG is not set
+# BR2_PACKAGE_LIBMPD is not set
+# BR2_PACKAGE_LIBMPDCLIENT is not set
+# BR2_PACKAGE_LIBREPLAYGAIN is not set
+# BR2_PACKAGE_LIBSAMPLERATE is not set
+# BR2_PACKAGE_LIBSNDFILE is not set
+# BR2_PACKAGE_LIBSOXR is not set
+# BR2_PACKAGE_LIBVORBIS is not set
+# BR2_PACKAGE_OPENCORE_AMR is not set
+# BR2_PACKAGE_OPUS is not set
+# BR2_PACKAGE_PORTAUDIO is not set
+# BR2_PACKAGE_SPEEX is not set
+# BR2_PACKAGE_TAGLIB is not set
+# BR2_PACKAGE_TREMOR is not set
+# BR2_PACKAGE_VO_AACENC is not set
+
+#
+# Compression and decompression
+#
+# BR2_PACKAGE_LIBARCHIVE is not set
+BR2_PACKAGE_LZO=y
+# BR2_PACKAGE_SNAPPY is not set
+BR2_PACKAGE_ZLIB=y
+
+#
+# Crypto
+#
+# BR2_PACKAGE_BEECRYPT is not set
+# BR2_PACKAGE_CA_CERTIFICATES is not set
+# BR2_PACKAGE_CRYPTODEV is not set
+# BR2_PACKAGE_GNUTLS is not set
+# BR2_PACKAGE_LIBASSUAN is not set
+# BR2_PACKAGE_LIBGCRYPT is not set
+# BR2_PACKAGE_LIBGPG_ERROR is not set
+# BR2_PACKAGE_LIBGPGME is not set
+# BR2_PACKAGE_LIBKSBA is not set
+# BR2_PACKAGE_LIBMCRYPT is not set
+# BR2_PACKAGE_LIBMHASH is not set
+# BR2_PACKAGE_LIBNSS is not set
+# BR2_PACKAGE_LIBSECRET is not set
+# BR2_PACKAGE_LIBSHA1 is not set
+# BR2_PACKAGE_LIBSSH2 is not set
+# BR2_PACKAGE_NETTLE is not set
+# BR2_PACKAGE_OPENSSL is not set
+# BR2_PACKAGE_POLARSSL is not set
+
+#
+# Database
+#
+# BR2_PACKAGE_BERKELEYDB is not set
+# BR2_PACKAGE_GDBM is not set
+# BR2_PACKAGE_MYSQL is not set
+# BR2_PACKAGE_POSTGRESQL is not set
+# BR2_PACKAGE_REDIS is not set
+# BR2_PACKAGE_SQLCIPHER is not set
+# BR2_PACKAGE_SQLITE is not set
+
+#
+# Filesystem
+#
+# BR2_PACKAGE_GAMIN is not set
+# BR2_PACKAGE_LIBCONFIG is not set
+# BR2_PACKAGE_LIBCONFUSE is not set
+# BR2_PACKAGE_LIBFUSE is not set
+# BR2_PACKAGE_LIBLOCKFILE is not set
+# BR2_PACKAGE_LIBNFS is not set
+# BR2_PACKAGE_LIBSYSFS is not set
+# BR2_PACKAGE_LOCKDEV is not set
+
+#
+# Graphics
+#
+# BR2_PACKAGE_ATK is not set
+# BR2_PACKAGE_CAIRO is not set
+# BR2_PACKAGE_FONTCONFIG is not set
+# BR2_PACKAGE_FREETYPE is not set
+# BR2_PACKAGE_GD is not set
+# BR2_PACKAGE_GDK_PIXBUF is not set
+# BR2_PACKAGE_HARFBUZZ is not set
+# BR2_PACKAGE_IMLIB2 is not set
+# BR2_PACKAGE_JASPER is not set
+# BR2_PACKAGE_JPEG is not set
+# BR2_PACKAGE_LCMS2 is not set
+# BR2_PACKAGE_LIBART is not set
+# BR2_PACKAGE_LIBDMTX is not set
+# BR2_PACKAGE_LIBDRM is not set
+# BR2_PACKAGE_LIBEXIF is not set
+# BR2_PACKAGE_LIBGEOTIFF is not set
+
+#
+# libglew depends on X.org and needs an OpenGL backend
+#
+
+#
+# libglu needs an OpenGL backend
+#
+# BR2_PACKAGE_LIBPNG is not set
+# BR2_PACKAGE_LIBQRENCODE is not set
+# BR2_PACKAGE_LIBRAW is not set
+# BR2_PACKAGE_LIBRSVG is not set
+# BR2_PACKAGE_LIBSVG is not set
+# BR2_PACKAGE_LIBSVG_CAIRO is not set
+# BR2_PACKAGE_LIBSVGTINY is not set
+# BR2_PACKAGE_LIBUNGIF is not set
+# BR2_PACKAGE_LIBVA is not set
+# BR2_PACKAGE_OPENCV is not set
+# BR2_PACKAGE_PANGO is not set
+# BR2_PACKAGE_PIXMAN is not set
+# BR2_PACKAGE_POPPLER is not set
+# BR2_PACKAGE_TIFF is not set
+# BR2_PACKAGE_WAYLAND is not set
+# BR2_PACKAGE_WEBP is not set
+# BR2_PACKAGE_ZXING is not set
+
+#
+# Hardware handling
+#
+# BR2_PACKAGE_CCID is not set
+# BR2_PACKAGE_DTC is not set
+# BR2_PACKAGE_LCDAPI is not set
+# BR2_PACKAGE_LIBAIO is not set
+
+#
+# libatasmart requires udev to be enabled
+#
+# BR2_PACKAGE_LIBCEC is not set
+# BR2_PACKAGE_LIBFREEFARE is not set
+# BR2_PACKAGE_LIBFTDI is not set
+# BR2_PACKAGE_LIBHID is not set
+
+#
+# libinput needs udev /dev management
+#
+# BR2_PACKAGE_LIBIQRF is not set
+# BR2_PACKAGE_LIBLLCP is not set
+
+#
+# libmbim needs udev /dev management and a toolchain w/ wchar, threads
+#
+# BR2_PACKAGE_LIBNFC is not set
+# BR2_PACKAGE_LIBQMI is not set
+# BR2_PACKAGE_LIBRAW1394 is not set
+# BR2_PACKAGE_LIBRTLSDR is not set
+# BR2_PACKAGE_LIBSERIAL is not set
+# BR2_PACKAGE_LIBSOC is not set
+# BR2_PACKAGE_LIBUSB is not set
+# BR2_PACKAGE_LIBV4L is not set
+# BR2_PACKAGE_LIBXKBCOMMON is not set
+# BR2_PACKAGE_MTDEV is not set
+# BR2_PACKAGE_NEARDAL is not set
+# BR2_PACKAGE_PCSC_LITE is not set
+# BR2_PACKAGE_TSLIB is not set
+# BR2_PACKAGE_URG is not set
+
+#
+# Javascript
+#
+# BR2_PACKAGE_EXPLORERCANVAS is not set
+# BR2_PACKAGE_FLOT is not set
+# BR2_PACKAGE_JQUERY is not set
+# BR2_PACKAGE_JQUERY_KEYBOARD is not set
+# BR2_PACKAGE_JQUERY_MOBILE is not set
+# BR2_PACKAGE_JQUERY_SPARKLINE is not set
+# BR2_PACKAGE_JQUERY_UI is not set
+# BR2_PACKAGE_JQUERY_VALIDATION is not set
+# BR2_PACKAGE_JSMIN is not set
+# BR2_PACKAGE_JSON_JAVASCRIPT is not set
+
+#
+# JSON/XML
+#
+# BR2_PACKAGE_CJSON is not set
+# BR2_PACKAGE_EXPAT is not set
+# BR2_PACKAGE_EZXML is not set
+# BR2_PACKAGE_JANSSON is not set
+# BR2_PACKAGE_JSON_C is not set
+# BR2_PACKAGE_JSON_GLIB is not set
+# BR2_PACKAGE_LIBJSON is not set
+# BR2_PACKAGE_LIBROXML is not set
+# BR2_PACKAGE_LIBXML2 is not set
+# BR2_PACKAGE_LIBXMLPP is not set
+# BR2_PACKAGE_LIBXMLRPC is not set
+# BR2_PACKAGE_LIBXSLT is not set
+# BR2_PACKAGE_LIBYAML is not set
+# BR2_PACKAGE_MXML is not set
+# BR2_PACKAGE_RAPIDJSON is not set
+# BR2_PACKAGE_TINYXML is not set
+# BR2_PACKAGE_XERCES is not set
+# BR2_PACKAGE_YAJL is not set
+
+#
+# Logging
+#
+# BR2_PACKAGE_LIBLOG4C_LOCALTIME is not set
+# BR2_PACKAGE_LIBLOGGING is not set
+# BR2_PACKAGE_LOG4CPLUS is not set
+# BR2_PACKAGE_LOG4CXX is not set
+# BR2_PACKAGE_ZLOG is not set
+
+#
+# Multimedia
+#
+# BR2_PACKAGE_LIBASS is not set
+# BR2_PACKAGE_LIBBLURAY is not set
+# BR2_PACKAGE_LIBDVBSI is not set
+# BR2_PACKAGE_LIBDVDNAV is not set
+# BR2_PACKAGE_LIBDVDREAD is not set
+# BR2_PACKAGE_LIBEBML is not set
+# BR2_PACKAGE_LIBMATROSKA is not set
+# BR2_PACKAGE_LIBMMS is not set
+# BR2_PACKAGE_LIBMPEG2 is not set
+# BR2_PACKAGE_LIBOGG is not set
+# BR2_PACKAGE_LIBPLAYER is not set
+# BR2_PACKAGE_LIBTHEORA is not set
+# BR2_PACKAGE_LIVE555 is not set
+# BR2_PACKAGE_MEDIASTREAMER is not set
+
+#
+# Networking
+#
+# BR2_PACKAGE_AGENTPP is not set
+# BR2_PACKAGE_C_ARES is not set
+# BR2_PACKAGE_CPPZMQ is not set
+# BR2_PACKAGE_CZMQ is not set
+# BR2_PACKAGE_FILEMQ is not set
+# BR2_PACKAGE_FLICKCURL is not set
+# BR2_PACKAGE_GEOIP is not set
+# BR2_PACKAGE_GLIB_NETWORKING is not set
+# BR2_PACKAGE_LIBCGI is not set
+# BR2_PACKAGE_LIBCGICC is not set
+# BR2_PACKAGE_LIBCURL is not set
+# BR2_PACKAGE_LIBDNET is not set
+# BR2_PACKAGE_LIBEXOSIP2 is not set
+# BR2_PACKAGE_LIBFCGI is not set
+# BR2_PACKAGE_LIBGSASL is not set
+# BR2_PACKAGE_LIBIDN is not set
+# BR2_PACKAGE_LIBISCSI is not set
+# BR2_PACKAGE_LIBMBUS is not set
+# BR2_PACKAGE_LIBMEMCACHED is not set
+# BR2_PACKAGE_LIBMICROHTTPD is not set
+# BR2_PACKAGE_LIBMNL is not set
+# BR2_PACKAGE_LIBMODBUS is not set
+# BR2_PACKAGE_LIBNDP is not set
+# BR2_PACKAGE_LIBNETFILTER_ACCT is not set
+# BR2_PACKAGE_LIBNETFILTER_CONNTRACK is not set
+# BR2_PACKAGE_LIBNETFILTER_CTHELPER is not set
+# BR2_PACKAGE_LIBNETFILTER_CTTIMEOUT is not set
+# BR2_PACKAGE_LIBNETFILTER_LOG is not set
+# BR2_PACKAGE_LIBNETFILTER_QUEUE is not set
+# BR2_PACKAGE_LIBNFNETLINK is not set
+# BR2_PACKAGE_LIBNL is not set
+# BR2_PACKAGE_LIBOAUTH is not set
+# BR2_PACKAGE_LIBOPING is not set
+# BR2_PACKAGE_LIBOSIP2 is not set
+# BR2_PACKAGE_LIBPCAP is not set
+# BR2_PACKAGE_LIBRSYNC is not set
+# BR2_PACKAGE_LIBSOCKETCAN is not set
+# BR2_PACKAGE_LIBSHAIRPLAY is not set
+# BR2_PACKAGE_LIBSOUP is not set
+# BR2_PACKAGE_LIBSTROPHE is not set
+# BR2_PACKAGE_LIBTIRPC is not set
+# BR2_PACKAGE_LIBTORRENT is not set
+# BR2_PACKAGE_LIBUPNP is not set
+# BR2_PACKAGE_LIBVNCSERVER is not set
+# BR2_PACKAGE_LIBWEBSOCKETS is not set
+# BR2_PACKAGE_NEON is not set
+# BR2_PACKAGE_OMNIORB is not set
+# BR2_PACKAGE_OPENPGM is not set
+# BR2_PACKAGE_ORTP is not set
+# BR2_PACKAGE_QDECODER is not set
+# BR2_PACKAGE_RTMPDUMP is not set
+# BR2_PACKAGE_SLIRP is not set
+# BR2_PACKAGE_SNMPPP is not set
+# BR2_PACKAGE_THRIFT is not set
+# BR2_PACKAGE_USBREDIR is not set
+# BR2_PACKAGE_WVSTREAMS is not set
+# BR2_PACKAGE_ZEROMQ is not set
+# BR2_PACKAGE_ZYRE is not set
+
+#
+# Other
+#
+# BR2_PACKAGE_APR is not set
+# BR2_PACKAGE_APR_UTIL is not set
+# BR2_PACKAGE_ARGP_STANDALONE is not set
+# BR2_PACKAGE_ARMADILLO is not set
+# BR2_PACKAGE_BOOST is not set
+# BR2_PACKAGE_CLAPACK is not set
+# BR2_PACKAGE_CPPCMS is not set
+# BR2_PACKAGE_EIGEN is not set
+# BR2_PACKAGE_ELFUTILS is not set
+# BR2_PACKAGE_FFTW is not set
+# BR2_PACKAGE_FLANN is not set
+# BR2_PACKAGE_GLIBMM is not set
+# BR2_PACKAGE_GMP is not set
+# BR2_PACKAGE_GSL is not set
+# BR2_PACKAGE_GTEST is not set
+# BR2_PACKAGE_LIBARGTABLE2 is not set
+BR2_PACKAGE_LIBATOMIC_ARCH_SUPPORTS=y
+# BR2_PACKAGE_LIBATOMIC_OPS is not set
+# BR2_PACKAGE_LIBCAP is not set
+# BR2_PACKAGE_LIBCAP_NG is not set
+# BR2_PACKAGE_LIBCGROUP is not set
+# BR2_PACKAGE_LIBDAEMON is not set
+# BR2_PACKAGE_LIBEE is not set
+# BR2_PACKAGE_LIBELF is not set
+# BR2_PACKAGE_LIBEV is not set
+# BR2_PACKAGE_LIBEVDEV is not set
+# BR2_PACKAGE_LIBEVENT is not set
+# BR2_PACKAGE_LIBFFI is not set
+# BR2_PACKAGE_LIBGC is not set
+# BR2_PACKAGE_LIBGLIB2 is not set
+# BR2_PACKAGE_LIBICAL is not set
+BR2_PACKAGE_LIBNSPR_ARCH_SUPPORT=y
+# BR2_PACKAGE_LIBNSPR is not set
+# BR2_PACKAGE_LIBPFM4 is not set
+# BR2_PACKAGE_LIBPLIST is not set
+# BR2_PACKAGE_LIBPTHREAD_STUBS is not set
+# BR2_PACKAGE_LIBPTHSEM is not set
+# BR2_PACKAGE_LIBSIGC is not set
+# BR2_PACKAGE_LIBSIGSEGV is not set
+# BR2_PACKAGE_LIBTASN1 is not set
+# BR2_PACKAGE_LIBTPL is not set
+# BR2_PACKAGE_LIBUBOX is not set
+# BR2_PACKAGE_LIBUCI is not set
+# BR2_PACKAGE_LIBUNWIND is not set
+# BR2_PACKAGE_LIBURCU is not set
+# BR2_PACKAGE_LIBUV is not set
+# BR2_PACKAGE_LINUX_PAM is not set
+# BR2_PACKAGE_LTTNG_LIBUST is not set
+# BR2_PACKAGE_MPC is not set
+# BR2_PACKAGE_MPDECIMAL is not set
+# BR2_PACKAGE_MPFR is not set
+# BR2_PACKAGE_MSGPACK is not set
+# BR2_PACKAGE_MTDEV2TUIO is not set
+# BR2_PACKAGE_ORC is not set
+# BR2_PACKAGE_P11_KIT is not set
+# BR2_PACKAGE_POCO is not set
+# BR2_PACKAGE_PROTOBUF_C is not set
+# BR2_PACKAGE_QHULL is not set
+# BR2_PACKAGE_SCHIFRA is not set
+
+#
+# Security
+#
+# BR2_PACKAGE_LIBSEPOL is not set
+
+#
+# Text and terminal handling
+#
+# BR2_PACKAGE_ENCHANT is not set
+# BR2_PACKAGE_ICU is not set
+# BR2_PACKAGE_LIBEDIT is not set
+# BR2_PACKAGE_LIBENCA is not set
+# BR2_PACKAGE_LIBESTR is not set
+# BR2_PACKAGE_LIBFRIBIDI is not set
+# BR2_PACKAGE_LINENOISE is not set
+BR2_PACKAGE_NCURSES=y
+# BR2_PACKAGE_NCURSES_TARGET_PANEL is not set
+# BR2_PACKAGE_NCURSES_TARGET_FORM is not set
+# BR2_PACKAGE_NCURSES_TARGET_MENU is not set
+# BR2_PACKAGE_NCURSES_TARGET_PROGS is not set
+# BR2_PACKAGE_NEWT is not set
+# BR2_PACKAGE_PCRE is not set
+# BR2_PACKAGE_POPT is not set
+BR2_PACKAGE_READLINE=y
+# BR2_PACKAGE_SLANG is not set
+# BR2_PACKAGE_TCLAP is not set
+
+#
+# Miscellaneous
+#
+# BR2_PACKAGE_AESPIPE is not set
+# BR2_PACKAGE_BC is not set
+# BR2_PACKAGE_COLLECTD is not set
+# BR2_PACKAGE_EMPTY is not set
+# BR2_PACKAGE_GOOGLEFONTDIRECTORY is not set
+# BR2_PACKAGE_HAVEGED is not set
+# BR2_PACKAGE_MCRYPT is not set
+# BR2_PACKAGE_MOBILE_BROADBAND_PROVIDER_INFO is not set
+# BR2_PACKAGE_SHARED_MIME_INFO is not set
+# BR2_PACKAGE_SNOWBALL_INIT is not set
+# BR2_PACKAGE_SOUND_THEME_BOREALIS is not set
+# BR2_PACKAGE_SOUND_THEME_FREEDESKTOP is not set
+
+#
+# Mail
+#
+# BR2_PACKAGE_EXIM is not set
+# BR2_PACKAGE_FETCHMAIL is not set
+# BR2_PACKAGE_HEIRLOOM_MAILX is not set
+# BR2_PACKAGE_LIBESMTP is not set
+# BR2_PACKAGE_MSMTP is not set
+# BR2_PACKAGE_MUTT is not set
+
+#
+# Networking applications
+#
+# BR2_PACKAGE_AICCU is not set
+# BR2_PACKAGE_AIRCRACK_NG is not set
+# BR2_PACKAGE_ARGUS is not set
+# BR2_PACKAGE_ARPTABLES is not set
+# BR2_PACKAGE_ATFTP is not set
+# BR2_PACKAGE_AVAHI is not set
+# BR2_PACKAGE_AXEL is not set
+# BR2_PACKAGE_BANDWIDTHD is not set
+# BR2_PACKAGE_BCUSDK is not set
+# BR2_PACKAGE_BIND is not set
+# BR2_PACKAGE_BLUEZ_UTILS is not set
+
+#
+# bluez5-utils needs a toolchain w/ wchar, threads, IPv6, headers >= 3.4
+#
+# BR2_PACKAGE_BMON is not set
+# BR2_PACKAGE_BOA is not set
+# BR2_PACKAGE_BRIDGE_UTILS is not set
+# BR2_PACKAGE_BWM_NG is not set
+# BR2_PACKAGE_CAN_UTILS is not set
+# BR2_PACKAGE_CHRONY is not set
+# BR2_PACKAGE_CIVETWEB is not set
+# BR2_PACKAGE_CONNMAN is not set
+# BR2_PACKAGE_CONNTRACK_TOOLS is not set
+# BR2_PACKAGE_CRDA is not set
+# BR2_PACKAGE_CTORRENT is not set
+# BR2_PACKAGE_CUPS is not set
+# BR2_PACKAGE_DHCP is not set
+# BR2_PACKAGE_DHCPCD is not set
+# BR2_PACKAGE_DHCPDUMP is not set
+# BR2_PACKAGE_DNSMASQ is not set
+# BR2_PACKAGE_DROPBEAR is not set
+# BR2_PACKAGE_EBTABLES is not set
+# BR2_PACKAGE_ETHTOOL is not set
+# BR2_PACKAGE_FAIFA is not set
+# BR2_PACKAGE_FPING is not set
+# BR2_PACKAGE_GESFTPSERVER is not set
+# BR2_PACKAGE_HIAWATHA is not set
+# BR2_PACKAGE_HOSTAPD is not set
+# BR2_PACKAGE_HTTPING is not set
+# BR2_PACKAGE_IFPLUGD is not set
+# BR2_PACKAGE_IFTOP is not set
+# BR2_PACKAGE_IGH_ETHERCAT is not set
+# BR2_PACKAGE_IGMPPROXY is not set
+# BR2_PACKAGE_INADYN is not set
+BR2_PACKAGE_IPERF=y
+# BR2_PACKAGE_IPROUTE2 is not set
+# BR2_PACKAGE_IPSEC_TOOLS is not set
+# BR2_PACKAGE_IPSET is not set
+# BR2_PACKAGE_IPTABLES is not set
+# BR2_PACKAGE_IPTRAF_NG is not set
+# BR2_PACKAGE_IPUTILS is not set
+# BR2_PACKAGE_IW is not set
+# BR2_PACKAGE_KISMET is not set
+# BR2_PACKAGE_KNOCK is not set
+# BR2_PACKAGE_LFTP is not set
+# BR2_PACKAGE_LIGHTTPD is not set
+# BR2_PACKAGE_LINKNX is not set
+# BR2_PACKAGE_LINKS is not set
+# BR2_PACKAGE_LINPHONE is not set
+# BR2_PACKAGE_LINUX_ZIGBEE is not set
+# BR2_PACKAGE_LRZSZ is not set
+# BR2_PACKAGE_MACCHANGER is not set
+# BR2_PACKAGE_MEMCACHED is not set
+# BR2_PACKAGE_MII_DIAG is not set
+# BR2_PACKAGE_MINIDLNA is not set
+
+#
+# modemmanager needs udev /dev management and a toolchain w/ largefile, wchar, threads, IPv6
+#
+# BR2_PACKAGE_MONGOOSE is not set
+# BR2_PACKAGE_MONGREL2 is not set
+# BR2_PACKAGE_MROUTED is not set
+# BR2_PACKAGE_MTR is not set
+# BR2_PACKAGE_NBD is not set
+# BR2_PACKAGE_NCFTP is not set
+# BR2_PACKAGE_NDISC6 is not set
+# BR2_PACKAGE_NETATALK is not set
+# BR2_PACKAGE_NETCAT is not set
+# BR2_PACKAGE_NETPLUG is not set
+# BR2_PACKAGE_NETSNMP is not set
+# BR2_PACKAGE_NETSTAT_NAT is not set
+# BR2_PACKAGE_NET_TOOLS is not set
+
+#
+# NetworkManager needs udev /dev management and a toolchain w/ IPv6, largefile, wchar, threads, headers >= 3.7
+#
+# BR2_PACKAGE_NFACCT is not set
+
+#
+# nftables needs a toolchain w/ IPv6, largefile, threads, wchar, headers >= 3.4
+#
+# BR2_PACKAGE_NGIRCD is not set
+# BR2_PACKAGE_NGREP is not set
+# BR2_PACKAGE_NMAP is not set
+# BR2_PACKAGE_NOIP is not set
+# BR2_PACKAGE_NTP is not set
+# BR2_PACKAGE_NUTTCP is not set
+# BR2_PACKAGE_OLSR is not set
+# BR2_PACKAGE_OPENNTPD is not set
+# BR2_PACKAGE_OPENOBEX is not set
+# BR2_PACKAGE_OPENSSH is not set
+# BR2_PACKAGE_OPENSWAN is not set
+# BR2_PACKAGE_OPENVPN is not set
+# BR2_PACKAGE_P910ND is not set
+# BR2_PACKAGE_PORTMAP is not set
+# BR2_PACKAGE_PPPD is not set
+# BR2_PACKAGE_PPTP_LINUX is not set
+# BR2_PACKAGE_PROFTPD is not set
+# BR2_PACKAGE_PROXYCHAINS_NG is not set
+# BR2_PACKAGE_PTPD is not set
+# BR2_PACKAGE_PTPD2 is not set
+# BR2_PACKAGE_QUAGGA is not set
+# BR2_PACKAGE_RADVD is not set
+# BR2_PACKAGE_RPCBIND is not set
+# BR2_PACKAGE_RSH_REDONE is not set
+# BR2_PACKAGE_RSYNC is not set
+# BR2_PACKAGE_RTORRENT is not set
+# BR2_PACKAGE_RTPTOOLS is not set
+# BR2_PACKAGE_SAMBA is not set
+# BR2_PACKAGE_SAMBA4 is not set
+# BR2_PACKAGE_SCONESERVER is not set
+# BR2_PACKAGE_SER2NET is not set
+# BR2_PACKAGE_SMCROUTE is not set
+# BR2_PACKAGE_SOCAT is not set
+# BR2_PACKAGE_SOCKETCAND is not set
+# BR2_PACKAGE_SPAWN_FCGI is not set
+# BR2_PACKAGE_SPICE_PROTOCOL is not set
+# BR2_PACKAGE_SQUID is not set
+# BR2_PACKAGE_SSHPASS is not set
+# BR2_PACKAGE_STRONGSWAN is not set
+# BR2_PACKAGE_STUNNEL is not set
+# BR2_PACKAGE_TCPDUMP is not set
+# BR2_PACKAGE_TCPING is not set
+# BR2_PACKAGE_TCPREPLAY is not set
+# BR2_PACKAGE_TFTPD is not set
+# BR2_PACKAGE_THTTPD is not set
+# BR2_PACKAGE_TINYHTTPD is not set
+# BR2_PACKAGE_TN5250 is not set
+# BR2_PACKAGE_TRANSMISSION is not set
+
+#
+# tvheadend needs a toolchain w/ largefile, IPv6, NPTL, headers >= 3.2
+#
+# BR2_PACKAGE_UDPCAST is not set
+# BR2_PACKAGE_ULOGD is not set
+# BR2_PACKAGE_USHARE is not set
+# BR2_PACKAGE_USSP_PUSH is not set
+# BR2_PACKAGE_VDE2 is not set
+# BR2_PACKAGE_VPNC is not set
+# BR2_PACKAGE_VSFTPD is not set
+# BR2_PACKAGE_VTUN is not set
+# BR2_PACKAGE_WGET is not set
+# BR2_PACKAGE_WHOIS is not set
+# BR2_PACKAGE_WIRELESS_REGDB is not set
+# BR2_PACKAGE_WIRELESS_TOOLS is not set
+# BR2_PACKAGE_WIRESHARK is not set
+# BR2_PACKAGE_WPA_SUPPLICANT is not set
+# BR2_PACKAGE_WVDIAL is not set
+# BR2_PACKAGE_XINETD is not set
+# BR2_PACKAGE_XL2TP is not set
+# BR2_PACKAGE_ZNC is not set
+
+#
+# Package managers
+#
+# BR2_PACKAGE_IPKG is not set
+# BR2_PACKAGE_OPKG is not set
+# BR2_PACKAGE_RPM is not set
+
+#
+# Real-Time
+#
+# BR2_PACKAGE_XENOMAI is not set
+
+#
+# Shell and utilities
+#
+
+#
+# Shells
+#
+BR2_PACKAGE_BASH=y
+# BR2_PACKAGE_DASH is not set
+# BR2_PACKAGE_ZSH is not set
+
+#
+# Utilities
+#
+# BR2_PACKAGE_AT is not set
+# BR2_PACKAGE_CCRYPT is not set
+# BR2_PACKAGE_DIALOG is not set
+# BR2_PACKAGE_DTACH is not set
+# BR2_PACKAGE_FILE is not set
+# BR2_PACKAGE_GNUPG is not set
+# BR2_PACKAGE_GNUPG2 is not set
+# BR2_PACKAGE_INOTIFY_TOOLS is not set
+# BR2_PACKAGE_LOCKFILE_PROGS is not set
+# BR2_PACKAGE_LOGROTATE is not set
+# BR2_PACKAGE_LOGSURFER is not set
+# BR2_PACKAGE_PINENTRY is not set
+# BR2_PACKAGE_SCREEN is not set
+# BR2_PACKAGE_SUDO is not set
+# BR2_PACKAGE_TIME is not set
+# BR2_PACKAGE_TMUX is not set
+# BR2_PACKAGE_WHICH is not set
+# BR2_PACKAGE_XMLSTARLET is not set
+
+#
+# System tools
+#
+# BR2_PACKAGE_ACL is not set
+# BR2_PACKAGE_ATTR is not set
+# BR2_PACKAGE_BOOTUTILS is not set
+# BR2_PACKAGE_COREUTILS is not set
+# BR2_PACKAGE_CPULOAD is not set
+# BR2_PACKAGE_DCRON is not set
+# BR2_PACKAGE_FTOP is not set
+# BR2_PACKAGE_HTOP is not set
+# BR2_PACKAGE_IPRUTILS is not set
+# BR2_PACKAGE_KEYUTILS is not set
+# BR2_PACKAGE_KMOD is not set
+# BR2_PACKAGE_LXC is not set
+# BR2_PACKAGE_MONIT is not set
+# BR2_PACKAGE_NCDU is not set
+# BR2_PACKAGE_NUMACTL is not set
+# BR2_PACKAGE_NUT is not set
+# BR2_PACKAGE_POWERPC_UTILS is not set
+# BR2_PACKAGE_POLKIT is not set
+# BR2_PACKAGE_PROCPS_NG is not set
+# BR2_PACKAGE_PSMISC is not set
+# BR2_PACKAGE_PWGEN is not set
+# BR2_PACKAGE_QUOTA is not set
+# BR2_PACKAGE_RSYSLOG is not set
+
+#
+# smack needs a toolchain w/ dynamic library, threads, headers >= 3.0
+#
+
+#
+# supervisor needs the python interpreter
+#
+# BR2_PACKAGE_SYSKLOGD is not set
+BR2_PACKAGE_SYSTEMD_ARCH_SUPPORTS=y
+# BR2_PACKAGE_UTIL_LINUX is not set
+
+#
+# Text editors and viewers
+#
+# BR2_PACKAGE_ED is not set
+# BR2_PACKAGE_JOE is not set
+# BR2_PACKAGE_LESS is not set
+# BR2_PACKAGE_NANO is not set
+# BR2_PACKAGE_UEMACS is not set
+# BR2_PACKAGE_VIM is not set
+BR2_PACKAGE_SIMICS_AGENT=y
+
+#
+# Filesystem images
+#
+# BR2_TARGET_ROOTFS_CLOOP is not set
+# BR2_TARGET_ROOTFS_CPIO is not set
+# BR2_TARGET_ROOTFS_CRAMFS is not set
+BR2_TARGET_ROOTFS_EXT2=y
+BR2_TARGET_ROOTFS_EXT2_2=y
+BR2_TARGET_ROOTFS_EXT2_2r0=y
+# BR2_TARGET_ROOTFS_EXT2_2r1 is not set
+# BR2_TARGET_ROOTFS_EXT2_3 is not set
+# BR2_TARGET_ROOTFS_EXT2_4 is not set
+BR2_TARGET_ROOTFS_EXT2_GEN=2
+BR2_TARGET_ROOTFS_EXT2_REV=0
+BR2_TARGET_ROOTFS_EXT2_BLOCKS=0
+BR2_TARGET_ROOTFS_EXT2_INODES=0
+BR2_TARGET_ROOTFS_EXT2_RESBLKS=0
+BR2_TARGET_ROOTFS_EXT2_NONE=y
+# BR2_TARGET_ROOTFS_EXT2_GZIP is not set
+# BR2_TARGET_ROOTFS_EXT2_BZIP2 is not set
+# BR2_TARGET_ROOTFS_EXT2_LZMA is not set
+# BR2_TARGET_ROOTFS_EXT2_LZO is not set
+# BR2_TARGET_ROOTFS_EXT2_XZ is not set
+# BR2_TARGET_ROOTFS_INITRAMFS is not set
+# BR2_TARGET_ROOTFS_JFFS2 is not set
+# BR2_TARGET_ROOTFS_ROMFS is not set
+# BR2_TARGET_ROOTFS_SQUASHFS is not set
+BR2_TARGET_ROOTFS_TAR=y
+BR2_TARGET_ROOTFS_TAR_NONE=y
+# BR2_TARGET_ROOTFS_TAR_GZIP is not set
+# BR2_TARGET_ROOTFS_TAR_BZIP2 is not set
+# BR2_TARGET_ROOTFS_TAR_LZMA is not set
+# BR2_TARGET_ROOTFS_TAR_LZO is not set
+# BR2_TARGET_ROOTFS_TAR_XZ is not set
+BR2_TARGET_ROOTFS_TAR_OPTIONS=""
+# BR2_TARGET_ROOTFS_UBIFS is not set
+# BR2_TARGET_ROOTFS_YAFFS2 is not set
+
+#
+# Bootloaders
+#
+# BR2_TARGET_BAREBOX is not set
+BR2_TARGET_UBOOT=y
+BR2_TARGET_UBOOT_BOARDNAME="qsp_ppc"
+# BR2_TARGET_UBOOT_LATEST_VERSION is not set
+BR2_TARGET_UBOOT_CUSTOM_VERSION=y
+# BR2_TARGET_UBOOT_CUSTOM_TARBALL is not set
+# BR2_TARGET_UBOOT_CUSTOM_GIT is not set
+# BR2_TARGET_UBOOT_CUSTOM_HG is not set
+BR2_TARGET_UBOOT_CUSTOM_VERSION_VALUE="2011.12"
+BR2_TARGET_UBOOT_VERSION="2011.12"
+BR2_TARGET_UBOOT_CUSTOM_PATCH_DIR="board/windriver/qsp-ppc"
+# BR2_TARGET_UBOOT_FORMAT_AIS is not set
+BR2_TARGET_UBOOT_FORMAT_BIN=y
+# BR2_TARGET_UBOOT_FORMAT_IMG is not set
+# BR2_TARGET_UBOOT_FORMAT_IMX is not set
+# BR2_TARGET_UBOOT_FORMAT_NAND_BIN is not set
+# BR2_TARGET_UBOOT_FORMAT_ELF is not set
+# BR2_TARGET_UBOOT_FORMAT_CUSTOM is not set
+# BR2_TARGET_UBOOT_SPL is not set
+# BR2_TARGET_UBOOT_ENVIMAGE is not set
+
+#
+# Host utilities
+#
+# BR2_PACKAGE_HOST_DFU_UTIL is not set
+# BR2_PACKAGE_HOST_DOSFSTOOLS is not set
+BR2_PACKAGE_HOST_E2FSPROGS=y
+# BR2_PACKAGE_HOST_E2TOOLS is not set
+BR2_PACKAGE_HOST_GENEXT2FS=y
+# BR2_PACKAGE_HOST_GENIMAGE is not set
+# BR2_PACKAGE_HOST_GENPART is not set
+# BR2_PACKAGE_HOST_LPC3250LOADER is not set
+# BR2_PACKAGE_HOST_MTD is not set
+# BR2_PACKAGE_HOST_MTOOLS is not set
+# BR2_PACKAGE_HOST_OPENOCD is not set
+# BR2_PACKAGE_HOST_PARTED is not set
+# BR2_PACKAGE_HOST_PATCHELF is not set
+# BR2_PACKAGE_HOST_PWGEN is not set
+# BR2_PACKAGE_HOST_SAM_BA is not set
+# BR2_PACKAGE_HOST_SQUASHFS is not set
+# BR2_PACKAGE_HOST_UBOOT_TOOLS is not set
+# BR2_PACKAGE_HOST_UTIL_LINUX is not set
+
+#
+# Legacy config options
+#
+
+#
+# Legacy options removed in 2014.08
+#
+# BR2_KERNEL_HEADERS_3_8 is not set
+# BR2_PACKAGE_GETTEXT_TOOLS is not set
+# BR2_PACKAGE_PROCPS is not set
+# BR2_BINUTILS_VERSION_2_20_1 is not set
+# BR2_BINUTILS_VERSION_2_21 is not set
+# BR2_BINUTILS_VERSION_2_23_1 is not set
+# BR2_UCLIBC_VERSION_0_9_32 is not set
+# BR2_GCC_VERSION_4_3_X is not set
+# BR2_GCC_VERSION_4_6_X is not set
+# BR2_GDB_VERSION_7_4 is not set
+# BR2_GDB_VERSION_7_5 is not set
+# BR2_BUSYBOX_VERSION_1_19_X is not set
+# BR2_BUSYBOX_VERSION_1_20_X is not set
+# BR2_BUSYBOX_VERSION_1_21_X is not set
+# BR2_PACKAGE_LIBV4L_DECODE_TM6000 is not set
+# BR2_PACKAGE_LIBV4L_IR_KEYTABLE is not set
+# BR2_PACKAGE_LIBV4L_V4L2_COMPLIANCE is not set
+# BR2_PACKAGE_LIBV4L_V4L2_CTL is not set
+# BR2_PACKAGE_LIBV4L_V4L2_DBG is not set
+
+#
+# Legacy options removed in 2014.05
+#
+# BR2_PACKAGE_EVTEST_CAPTURE is not set
+# BR2_KERNEL_HEADERS_3_6 is not set
+# BR2_KERNEL_HEADERS_3_7 is not set
+# BR2_PACKAGE_VALA is not set
+BR2_PACKAGE_TZDATA_ZONELIST=""
+# BR2_PACKAGE_LUA_INTERPRETER_EDITING_NONE is not set
+# BR2_PACKAGE_LUA_INTERPRETER_READLINE is not set
+# BR2_PACKAGE_LUA_INTERPRETER_LINENOISE is not set
+# BR2_PACKAGE_DVB_APPS_UTILS is not set
+# BR2_KERNEL_HEADERS_SNAP is not set
+# BR2_ROOTFS_DEVICE_CREATION_DYNAMIC_UDEV is not set
+# BR2_PACKAGE_UDEV is not set
+# BR2_PACKAGE_UDEV_RULES_GEN is not set
+# BR2_PACKAGE_UDEV_ALL_EXTRAS is not set
+
+#
+# Legacy options removed in 2014.02
+#
+# BR2_sh2 is not set
+# BR2_sh3 is not set
+# BR2_sh3eb is not set
+# BR2_KERNEL_HEADERS_3_1 is not set
+# BR2_KERNEL_HEADERS_3_3 is not set
+# BR2_KERNEL_HEADERS_3_5 is not set
+# BR2_GDB_VERSION_7_2 is not set
+# BR2_GDB_VERSION_7_3 is not set
+# BR2_PACKAGE_CCACHE is not set
+# BR2_HAVE_DOCUMENTATION is not set
+# BR2_PACKAGE_AUTOMAKE is not set
+# BR2_PACKAGE_AUTOCONF is not set
+# BR2_PACKAGE_XSTROKE is not set
+# BR2_PACKAGE_LZMA is not set
+# BR2_PACKAGE_TTCP is not set
+# BR2_PACKAGE_LIBNFC_LLCP is not set
+# BR2_PACKAGE_MYSQL_CLIENT is not set
+# BR2_PACKAGE_SQUASHFS3 is not set
+# BR2_TARGET_ROOTFS_SQUASHFS3 is not set
+# BR2_PACKAGE_NETKITBASE is not set
+# BR2_PACKAGE_NETKITTELNET is not set
+# BR2_PACKAGE_LUASQL is not set
+# BR2_PACKAGE_LUACJSON is not set
+
+#
+# Legacy options removed in 2013.11
+#
+# BR2_PACKAGE_LVM2_DMSETUP_ONLY is not set
+# BR2_PACKAGE_QT_JAVASCRIPTCORE is not set
+# BR2_PACKAGE_MODULE_INIT_TOOLS is not set
+BR2_TARGET_UBOOT_CUSTOM_GIT_REPO_URL=""
+BR2_TARGET_UBOOT_CUSTOM_GIT_VERSION=""
+BR2_LINUX_KERNEL_CUSTOM_GIT_REPO_URL=""
+BR2_LINUX_KERNEL_CUSTOM_GIT_VERSION=""
+
+#
+# Legacy options removed in 2013.08
+#
+# BR2_ARM_OABI is not set
+# BR2_PACKAGE_DOSFSTOOLS_DOSFSCK is not set
+# BR2_PACKAGE_DOSFSTOOLS_DOSFSLABEL is not set
+# BR2_PACKAGE_DOSFSTOOLS_MKDOSFS is not set
+# BR2_ELF2FLT is not set
+# BR2_VFP_FLOAT is not set
+# BR2_PACKAGE_GCC_TARGET is not set
+# BR2_HAVE_DEVFILES is not set
+
+#
+# Legacy options removed in 2013.05
+#
+# BR2_PACKAGE_LINUX_FIRMWARE_RTL_8192 is not set
+# BR2_PACKAGE_LINUX_FIRMWARE_RTL_8712 is not set
+
+#
+# Legacy options removed in 2013.02
+#
+# BR2_sa110 is not set
+# BR2_sa1100 is not set
+# BR2_PACKAGE_GDISK is not set
+# BR2_PACKAGE_GDISK_GDISK is not set
+# BR2_PACKAGE_GDISK_SGDISK is not set
+# BR2_PACKAGE_GDB_HOST is not set
+# BR2_PACKAGE_DIRECTB_DITHER_RGB16 is not set
+# BR2_PACKAGE_DIRECTB_TESTS is not set
+
+#
+# Legacy options removed in 2012.11
+#
+# BR2_PACKAGE_CUSTOMIZE is not set
+# BR2_PACKAGE_XSERVER_xorg is not set
+# BR2_PACKAGE_XSERVER_tinyx is not set
+# BR2_PACKAGE_PTHREAD_STUBS is not set
+
+#
+# Legacy options removed in 2012.08
+#
+# BR2_PACKAGE_GETTEXT_STATIC is not set
+# BR2_PACKAGE_LIBINTL is not set
+# BR2_PACKAGE_INPUT_TOOLS_EVTEST is not set
+# BR2_BFIN_FDPIC is not set
+# BR2_BFIN_FLAT is not set
diff -pNur buildroot.2014.08/package/Config.in buildroot/package/Config.in
--- buildroot.2014.08/package/Config.in	2014-09-01 19:20:56.000000000 +0800
+++ buildroot/package/Config.in	2014-12-09 13:19:53.713729700 +0800
@@ -1204,4 +1204,7 @@ if BR2_PACKAGE_BUSYBOX_SHOW_OTHERS
 endif
 endmenu
 
+
+	source "package/simics-agent/Config.in"
+
 endmenu
diff -pNur buildroot.2014.08/package/simics-agent/Config.in buildroot/package/simics-agent/Config.in
--- buildroot.2014.08/package/simics-agent/Config.in	1970-01-01 07:00:00.000000000 +0700
+++ buildroot/package/simics-agent/Config.in	2014-12-09 13:19:53.701729700 +0800
@@ -0,0 +1,6 @@
+config BR2_PACKAGE_SIMICS_AGENT
+	bool "Simics Agent"
+	help
+	  Simics Agent. See Simics Hindsight User's Guide for more details.
+
+	  http://www.windriver.com/
diff -pNur buildroot.2014.08/package/simics-agent/simics-agent.mk buildroot/package/simics-agent/simics-agent.mk
--- buildroot.2014.08/package/simics-agent/simics-agent.mk	1970-01-01 07:00:00.000000000 +0700
+++ buildroot/package/simics-agent/simics-agent.mk	2014-12-09 13:19:53.701729700 +0800
@@ -0,0 +1,20 @@
+################################################################################
+#
+# simics-agent
+#
+################################################################################
+
+SIMICS_AGENT_VERSION = buildroot
+SIMICS_AGENT_SITE = $(TOPDIR)/package/simics-agent/src
+SIMICS_AGENT_SITE_METHOD = local
+SIMICS_AGENT_LICENSE = WR
+
+define SIMICS_AGENT_BUILD_CMDS
+	$(MAKE) $(TARGET_CONFIGURE_OPTS) -C $(@D) all
+endef
+
+define SIMICS_AGENT_INSTALL_TARGET_CMDS
+	$(INSTALL) -D -m 0755 $(@D)/simics-agent $(TARGET_DIR)/usr/bin/simics-agent
+endef
+
+$(eval $(generic-package))
